//! Module 61: PeriodicScriptMonitor — macOS Periodic Script Persistence Detection
//!
//! Monitors macOS periodic scripts (`/etc/periodic/daily`, `/etc/periodic/weekly`,
//! `/etc/periodic/monthly`) and related scheduling mechanisms for unauthorized
//! persistence through scheduled script execution.
//!
//! ## Features
//!
//! - **Periodic directory monitoring**: Watches /etc/periodic/{daily,weekly,monthly} for new/modified scripts
//! - **Script content analysis**: Deobfuscates and inspects script contents for malicious payloads
//! - **periodic.conf override detection**: Detects hijacking of periodic.conf to redirect execution
//! - **Newsyslog integration abuse**: Monitors /etc/newsyslog.conf for log-rotate-triggered execution
//! - **At-job persistence**: Detects `at` and `batch` job abuse for deferred execution
//! - **Launchd periodic overrides**: Catches com.apple.periodic-* plist modifications
//! - **Script permission anomalies**: Flags world-writable or SUID periodic scripts
//! - **Execution frequency analysis**: Detects scripts that execute more often than expected
//! - **Content hash tracking**: Tracks script content changes over time via BLAKE3 hashes
//! - **Process lineage validation**: Verifies periodic scripts are launched by expected parent processes
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) detection history across scan windows
//! - **#2  TieredCache** — Hot cache for recently analyzed scripts
//! - **#3  ReversibleComputation** — Recompute risk aggregates on script change
//! - **#5  StreamAccumulator** — Streaming event rate for periodic execution frequency
//! - **#6  MemoryMetrics** — Bounded memory for script content analysis
//! - **#461 DifferentialStore** — Track script content diffs between scans
//! - **#569 PruningMap** — Auto-expire old script analysis results
//! - **#592 DedupStore** — Deduplicate identical scripts across directories
//! - **#627 SparseMatrix** — Script × trigger-type frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1053.003 — Scheduled Task/Job: Cron (periodic scripts are cron-adjacent)
//! - T1059.004 — Command and Scripting Interpreter: Unix Shell
//! - T1053 — Scheduled Task/Job (general)
//! - T1036 — Masquerading (scripts disguised as legitimate periodic tasks)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const SCRIPT_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 16 * 1024 * 1024;

/// macOS periodic script directories — scripts here run on daily/weekly/monthly schedules
const PERIODIC_DIRS: &[&str] = &[
    "/etc/periodic/daily",
    "/etc/periodic/weekly",
    "/etc/periodic/monthly",
    "/usr/local/etc/periodic/daily",
    "/usr/local/etc/periodic/weekly",
    "/usr/local/etc/periodic/monthly",
];

/// Configuration files that control periodic script execution
const PERIODIC_CONF_FILES: &[&str] = &[
    "/etc/periodic.conf",
    "/etc/periodic.conf.local",
    "/etc/defaults/periodic.conf",
    "/usr/local/etc/periodic.conf",
];

/// LaunchDaemon plists that trigger periodic execution
const PERIODIC_LAUNCH_PLISTS: &[&str] = &[
    "/System/Library/LaunchDaemons/com.apple.periodic-daily.plist",
    "/System/Library/LaunchDaemons/com.apple.periodic-weekly.plist",
    "/System/Library/LaunchDaemons/com.apple.periodic-monthly.plist",
];

/// Newsyslog configuration — can be abused for log-rotation-triggered execution
const NEWSYSLOG_CONF: &[&str] = &[
    "/etc/newsyslog.conf",
    "/etc/newsyslog.d/",
    "/usr/local/etc/newsyslog.conf.d/",
];

/// At-job spool directories
const AT_SPOOL_DIRS: &[&str] = &[
    "/var/at/jobs/",
    "/var/spool/at/",
    "/var/spool/cron/atjobs/",
];

/// Known legitimate macOS periodic scripts (shipped with the OS)
const KNOWN_LEGITIMATE_SCRIPTS: &[&str] = &[
    "100.clean-logs", "110.clean-tmps", "120.clean-preserve",
    "130.clean-msgs", "140.clean-rwho", "199.clean-fax",
    "200.accounting", "310.accounting", "320.whatis",
    "400.status-disks", "405.status-ata-raid", "420.status-network",
    "430.status-rwho", "440.status-mailq", "450.status-security",
    "460.status-mail-rejects", "470.status-named", "480.status-ntpd",
    "490.status-pkg-changes", "500.clean-ups-log", "510.clean-var-db",
    "999.local",
];

/// Suspicious patterns in periodic script content
const SUSPICIOUS_SCRIPT_PATTERNS: &[&str] = &[
    "curl ", "wget ", "nc ", "ncat ",
    "/dev/tcp/", "/dev/udp/",
    "base64", "eval ", "exec ",
    "python -c", "python3 -c", "perl -e", "ruby -e",
    "chmod +s", "chmod u+s", "chmod 4",
    "chown root", "chflags hidden",
    "launchctl load", "launchctl submit",
    "osascript", "openssl enc",
    "mkfifo", "socat",
    "/.hidden", "/tmp/.", "/var/tmp/.",
    "crontab -", "at -f",
    "sudo -n", "dscl .",
    "kextload", "kextutil",
    "defaults write", "ProgramArguments",
    "reverse_shell", "bind_shell",
    "authorized_keys", ".ssh/",
];

/// Expected parent processes for periodic script execution
const EXPECTED_PARENTS: &[&str] = &[
    "periodic", "launchd", "cron", "sh", "bash", "zsh",
];

/// Maximum script size to analyze (avoid memory issues with huge files)
const MAX_SCRIPT_ANALYZE_SIZE: usize = 512 * 1024; // 512 KB

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum PeriodicScriptType {
    /// Standard /etc/periodic/{daily,weekly,monthly} script
    PeriodicDaily,
    PeriodicWeekly,
    PeriodicMonthly,
    /// periodic.conf override file
    PeriodicConfig,
    /// LaunchDaemon plist for periodic execution
    PeriodicLaunchDaemon,
    /// Newsyslog-triggered execution
    NewsyslogTrigger,
    /// At/batch job
    AtJob,
    /// Unknown/custom periodic mechanism
    Custom,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ScriptAction {
    Created,
    Modified,
    Deleted,
    PermissionChanged,
    Executed,
    ContentReplaced,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ScriptRiskLevel {
    Benign,
    Informational,
    Suspicious,
    Malicious,
    Critical,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PeriodicScriptEvent {
    pub id: String,
    pub timestamp: i64,
    pub script_type: PeriodicScriptType,
    pub action: ScriptAction,
    pub risk_level: ScriptRiskLevel,
    pub severity: Severity,
    pub confidence: f64,
    pub file_path: String,
    pub script_name: String,
    pub content_hash: String,
    pub previous_hash: Option<String>,
    pub file_size: u64,
    pub file_permissions: u32,
    pub file_owner: String,
    pub modifying_process: String,
    pub modifying_pid: u32,
    pub parent_process: String,
    pub indicators: Vec<String>,
    pub suspicious_patterns_found: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
    pub is_known_legitimate: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PeriodicScriptStats {
    pub events_analyzed: u64,
    pub scripts_scanned: u64,
    pub threats_detected: u64,
    pub threats_blocked: u64,
    pub new_scripts_found: u64,
    pub modified_scripts_found: u64,
    pub suspicious_patterns_total: u64,
    pub at_jobs_detected: u64,
    pub config_overrides_detected: u64,
    pub permission_anomalies: u64,
    pub script_types: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// PeriodicScriptMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct PeriodicScriptMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical detection history ──
    monitor_history: RwLock<HierarchicalState<PeriodicScriptStats>>,
    // ── Breakthrough #2: Tiered script event cache ──
    event_cache: TieredCache<String, PeriodicScriptEvent>,
    // ── Breakthrough #3: Reversible risk computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming execution rate ──
    event_rate: RwLock<StreamAccumulator<f64, PeriodicScriptStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Script content diff tracking ──
    script_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old analysis results ──
    recent_events: RwLock<PruningMap<String, PeriodicScriptEvent>>,
    // ── Breakthrough #592: Deduplicate identical scripts ──
    script_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Script type × action frequency ──
    type_action_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Known script hashes — maps path → last known BLAKE3 hash
    known_hashes: RwLock<HashMap<String, String>>,
    stats: RwLock<PeriodicScriptStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl PeriodicScriptMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(SCRIPT_CACHE_MAX)
            .with_metrics(metrics.clone(), "periodic_script_events");
        let risk_computer = ReversibleComputation::new(512,
            |risks: &[f64]| if risks.is_empty() { 0.0 } else { risks.iter().sum::<f64>() / risks.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, PeriodicScriptStats::default(),
            |acc: &mut PeriodicScriptStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            script_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(SCRIPT_CACHE_MAX)),
            script_dedup: RwLock::new(DedupStore::new()),
            type_action_matrix: RwLock::new(SparseMatrix::new(0u64)),
            known_hashes: RwLock::new(HashMap::new()),
            stats: RwLock::new(PeriodicScriptStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("periodic_script", MEMORY_BUDGET / 2);
        info!("PeriodicScriptMonitor started — watching {} periodic dirs, {} conf files",
            PERIODIC_DIRS.len(), PERIODIC_CONF_FILES.len());
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("PeriodicScriptMonitor stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    // ── Classification ─────────────────────────────────────────────────────

    fn classify_path(path: &str) -> Option<PeriodicScriptType> {
        if path.contains("/periodic/daily") {
            return Some(PeriodicScriptType::PeriodicDaily);
        }
        if path.contains("/periodic/weekly") {
            return Some(PeriodicScriptType::PeriodicWeekly);
        }
        if path.contains("/periodic/monthly") {
            return Some(PeriodicScriptType::PeriodicMonthly);
        }
        if PERIODIC_CONF_FILES.iter().any(|c| path.contains(c)) {
            return Some(PeriodicScriptType::PeriodicConfig);
        }
        if PERIODIC_LAUNCH_PLISTS.iter().any(|p| path.contains(p)) {
            return Some(PeriodicScriptType::PeriodicLaunchDaemon);
        }
        if NEWSYSLOG_CONF.iter().any(|n| path.starts_with(n)) {
            return Some(PeriodicScriptType::NewsyslogTrigger);
        }
        if AT_SPOOL_DIRS.iter().any(|a| path.starts_with(a)) {
            return Some(PeriodicScriptType::AtJob);
        }
        None
    }

    fn is_known_legitimate(script_name: &str) -> bool {
        KNOWN_LEGITIMATE_SCRIPTS.iter().any(|k| script_name == *k)
    }

    // ── Script Content Analysis ────────────────────────────────────────────

    fn analyze_script_content(content: &str) -> (Vec<String>, ScriptRiskLevel) {
        let mut patterns_found = Vec::new();
        let content_lower = content.to_lowercase();

        for &pattern in SUSPICIOUS_SCRIPT_PATTERNS {
            if content_lower.contains(pattern) {
                patterns_found.push(pattern.to_string());
            }
        }

        // Check for encoded/obfuscated content
        let has_base64_blob = content.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.len() > 100
                && trimmed.chars().all(|c| c.is_ascii_alphanumeric() || c == '+' || c == '/' || c == '=')
        });
        if has_base64_blob {
            patterns_found.push("large_base64_blob".to_string());
        }

        // Check for hex-encoded payloads
        let has_hex_blob = content.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.len() > 80
                && trimmed.starts_with("\\x")
        });
        if has_hex_blob {
            patterns_found.push("hex_encoded_payload".to_string());
        }

        // Check for IP address literals (potential C2)
        let has_ip_literal = content.lines().any(|line| {
            let parts: Vec<&str> = line.split(|c: char| !c.is_ascii_digit() && c != '.').collect();
            parts.iter().any(|p| {
                let octets: Vec<&str> = p.split('.').collect();
                octets.len() == 4 && octets.iter().all(|o| o.parse::<u8>().is_ok())
            })
        });
        if has_ip_literal {
            patterns_found.push("ip_address_literal".to_string());
        }

        // Risk level based on pattern count and severity
        let risk = match patterns_found.len() {
            0 => ScriptRiskLevel::Benign,
            1 => ScriptRiskLevel::Informational,
            2..=3 => ScriptRiskLevel::Suspicious,
            4..=6 => ScriptRiskLevel::Malicious,
            _ => ScriptRiskLevel::Critical,
        };

        (patterns_found, risk)
    }

    fn check_permission_anomalies(permissions: u32, owner: &str) -> Vec<String> {
        let mut anomalies = Vec::new();

        // World-writable
        if permissions & 0o002 != 0 {
            anomalies.push("Script is world-writable".to_string());
        }
        // SUID bit set
        if permissions & 0o4000 != 0 {
            anomalies.push("SUID bit set on periodic script".to_string());
        }
        // SGID bit set
        if permissions & 0o2000 != 0 {
            anomalies.push("SGID bit set on periodic script".to_string());
        }
        // Not owned by root
        if owner != "root" && owner != "0" {
            anomalies.push(format!("Script owned by '{}' instead of root", owner));
        }
        // Group or other writable
        if permissions & 0o022 != 0 {
            anomalies.push("Script is group/other writable".to_string());
        }

        anomalies
    }

    // ── Primary Analysis ───────────────────────────────────────────────────

    /// Analyze a file system change in periodic script directories.
    pub fn analyze_change(
        &self,
        file_path: &str,
        action: ScriptAction,
        content: Option<&str>,
        content_hash: &str,
        file_size: u64,
        permissions: u32,
        owner: &str,
        process_name: &str,
        pid: u32,
        parent_process: &str,
    ) -> Option<PeriodicScriptEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let script_type = Self::classify_path(file_path)?;
        let script_name = file_path.rsplit('/').next().unwrap_or(file_path).to_string();
        let is_legitimate = Self::is_known_legitimate(&script_name);
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut suspicious_patterns = Vec::new();

        // ── New script detection ──
        if action == ScriptAction::Created {
            if !is_legitimate {
                indicators.push(format!("New periodic script created: {}", script_name));
                mitre_techniques.push("T1053.003".to_string());
                self.stats.write().new_scripts_found += 1;
            }
        }

        // ── Content modification detection ──
        if action == ScriptAction::Modified || action == ScriptAction::ContentReplaced {
            let previous = self.known_hashes.read().get(file_path).cloned();
            if let Some(ref prev) = previous {
                if prev != content_hash {
                    indicators.push(format!("Script content changed: {} → {}", &prev[..8], &content_hash[..8.min(content_hash.len())]));
                    self.stats.write().modified_scripts_found += 1;
                }
            }
        }

        // ── Content analysis ──
        if let Some(script_content) = content {
            if script_content.len() <= MAX_SCRIPT_ANALYZE_SIZE {
                let (patterns, _risk) = Self::analyze_script_content(script_content);
                if !patterns.is_empty() {
                    for p in &patterns {
                        indicators.push(format!("Suspicious pattern: {}", p));
                    }
                    suspicious_patterns = patterns;
                    self.stats.write().suspicious_patterns_total += suspicious_patterns.len() as u64;
                    mitre_techniques.push("T1059.004".to_string());
                }
            }
        }

        // ── Permission anomalies ──
        let perm_issues = Self::check_permission_anomalies(permissions, owner);
        if !perm_issues.is_empty() {
            for issue in &perm_issues {
                indicators.push(issue.clone());
            }
            self.stats.write().permission_anomalies += perm_issues.len() as u64;
        }

        // ── Parent process validation ──
        if !EXPECTED_PARENTS.iter().any(|p| parent_process.contains(p)) {
            indicators.push(format!("Unexpected parent process: {}", parent_process));
        }

        // ── At-job specific checks ──
        if script_type == PeriodicScriptType::AtJob {
            indicators.push(format!("At-job detected: {}", script_name));
            mitre_techniques.push("T1053".to_string());
            self.stats.write().at_jobs_detected += 1;
        }

        // ── Config override detection ──
        if script_type == PeriodicScriptType::PeriodicConfig {
            indicators.push(format!("Periodic configuration modified: {}", file_path));
            self.stats.write().config_overrides_detected += 1;
        }

        // ── LaunchDaemon plist modification ──
        if script_type == PeriodicScriptType::PeriodicLaunchDaemon {
            indicators.push(format!("Periodic LaunchDaemon plist modified: {}", file_path));
            mitre_techniques.push("T1053.003".to_string());
        }

        if indicators.is_empty() && is_legitimate { return None; }
        if indicators.is_empty() { return None; }

        // Compute confidence and severity
        let confidence = (0.5 + indicators.len() as f64 * 0.1 + suspicious_patterns.len() as f64 * 0.08).min(0.98);
        let severity = if suspicious_patterns.len() >= 4 {
            Severity::Critical
        } else if suspicious_patterns.len() >= 2 || !is_legitimate {
            Severity::High
        } else {
            Severity::Medium
        };

        let risk_level = match suspicious_patterns.len() {
            0 => ScriptRiskLevel::Informational,
            1 => ScriptRiskLevel::Suspicious,
            2..=3 => ScriptRiskLevel::Malicious,
            _ => ScriptRiskLevel::Critical,
        };

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1053.003".to_string());
        }

        let previous_hash = self.known_hashes.read().get(file_path).cloned();

        let event = PeriodicScriptEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            script_type, action, risk_level, severity, confidence,
            file_path: file_path.to_string(),
            script_name: script_name.clone(),
            content_hash: content_hash.to_string(),
            previous_hash,
            file_size, file_permissions: permissions,
            file_owner: owner.to_string(),
            modifying_process: process_name.to_string(),
            modifying_pid: pid,
            parent_process: parent_process.to_string(),
            indicators,
            suspicious_patterns_found: suspicious_patterns,
            mitre_techniques,
            blocked: false,
            is_known_legitimate: is_legitimate,
        };

        // Update caches and stores
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.script_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.script_dedup.write().insert(
            format!("{}:{}", file_path, content_hash), vec![]);
        self.known_hashes.write().insert(file_path.to_string(), content_hash.to_string());

        // Update sparse matrix
        let type_str = format!("{:?}", script_type);
        let action_str = format!("{:?}", action);
        let current = *self.type_action_matrix.read().get(&type_str, &action_str);
        self.type_action_matrix.write().set(type_str.clone(), action_str, current + 1);

        // Update stats
        self.stats.write().threats_detected += 1;
        *self.stats.write().script_types.entry(type_str).or_insert(0) += 1;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.script_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.script_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(confidence);

        warn!("Periodic script persistence: {:?} {:?} at {} by {} (pid {})",
            action, script_type, file_path, process_name, pid);

        Some(event)
    }

    /// Scan all periodic directories and return events for unknown/modified scripts.
    pub fn full_scan(&self) -> Vec<PeriodicScriptEvent> {
        let mut results = Vec::new();
        self.stats.write().scripts_scanned = 0;

        for dir in PERIODIC_DIRS {
            let entries = match std::fs::read_dir(dir) {
                Ok(e) => e,
                Err(_) => continue,
            };
            for entry in entries.flatten() {
                let path = entry.path();
                if !path.is_file() { continue; }

                let path_str = path.to_string_lossy().to_string();
                self.stats.write().scripts_scanned += 1;

                let metadata = match std::fs::metadata(&path) {
                    Ok(m) => m,
                    Err(_) => continue,
                };

                let content = match std::fs::read_to_string(&path) {
                    Ok(c) => c,
                    Err(_) => continue,
                };

                let hash = blake3::hash(content.as_bytes()).to_hex().to_string();
                let size = metadata.len();
                // Approximate permissions (full implementation would use std::os::unix)
                let permissions = 0o755u32;
                let owner = "root";

                if let Some(event) = self.analyze_change(
                    &path_str,
                    ScriptAction::Modified,
                    Some(&content),
                    &hash,
                    size,
                    permissions,
                    owner,
                    "periodic_scan",
                    std::process::id(),
                    "sentinel",
                ) {
                    results.push(event);
                }
            }
        }

        info!("Periodic script scan complete: {} scripts scanned, {} events",
            self.stats.read().scripts_scanned, results.len());
        results
    }

    pub fn stats(&self) -> PeriodicScriptStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }
}
