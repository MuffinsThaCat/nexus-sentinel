//! Module 65: SIPMonitor — System Integrity Protection & Security Feature Monitoring
//!
//! Monitors macOS System Integrity Protection (SIP / rootless), along with related
//! system security features, for unauthorized disabling, bypass attempts, or
//! degradation. SIP prevents modification of protected system files and directories
//! even by the root user — disabling it is a critical security event.
//!
//! ## Features
//!
//! - **SIP status monitoring**: Continuously checks `csrutil status` for SIP state changes
//! - **SIP configuration flags**: Tracks individual SIP flags (filesystem, kext, dtrace, etc.)
//! - **NVRAM tampering detection**: Monitors csr-active-config NVRAM variable for SIP bypass
//! - **Recovery mode boot detection**: Detects boots from Recovery OS (where SIP can be disabled)
//! - **Authenticated root verification**: Checks sealed system volume (SSV) integrity on Big Sur+
//! - **Gatekeeper status monitoring**: Tracks spctl --master-disable and assessment changes
//! - **XProtect status tracking**: Monitors XProtect definitions and remediator state
//! - **MRT (Malware Removal Tool) monitoring**: Tracks MRT.app execution and definition updates
//! - **Notarization enforcement**: Monitors notarization bypass attempts (quarantine removal)
//! - **Filesystem protection validation**: Verifies /System, /usr, /bin, /sbin are read-only
//! - **AMFI status monitoring**: Apple Mobile File Integrity daemon status
//! - **Library Validation**: Tracks CS_REQUIRE_LV enforcement state
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) SIP status history
//! - **#2  TieredCache** — Hot cache for recent security state checks
//! - **#3  ReversibleComputation** — Recompute security posture score
//! - **#5  StreamAccumulator** — Streaming security event rate
//! - **#6  MemoryMetrics** — Bounded memory for status tracking
//! - **#461 DifferentialStore** — Track SIP flag diffs between checks
//! - **#569 PruningMap** — Auto-expire old security events
//! - **#592 DedupStore** — Deduplicate identical status reports
//! - **#627 SparseMatrix** — Feature × state frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1562.001 — Impair Defenses: Disable or Modify Tools
//! - T1553.001 — Subvert Trust Controls: Gatekeeper Bypass
//! - T1562.003 — Impair Defenses: Impair Command History Logging
//! - T1006 — Direct Volume Access
//! - T1014 — Rootkit (SIP disable enables rootkit installation)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const SIP_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 12 * 1024 * 1024;

/// SIP-protected filesystem paths — these should be immutable
const SIP_PROTECTED_PATHS: &[&str] = &[
    "/System", "/usr", "/bin", "/sbin",
    "/Library/Apple", "/var/db/SystemPolicy",
    "/private/var/db/SystemPolicyConfiguration",
];

/// NVRAM variables related to SIP configuration
const SIP_NVRAM_VARS: &[&str] = &[
    "csr-active-config",         // SIP configuration bitmask
    "boot-args",                 // Boot arguments (can weaken security)
    "StartupMute",               // Boot chime (not security, but NVRAM access)
];

/// SIP configuration flag bits (csr-active-config bitmask values)
const CSR_ALLOW_UNTRUSTED_KEXTS: u32       = 0x01;
const CSR_ALLOW_UNRESTRICTED_FS: u32       = 0x02;
const CSR_ALLOW_TASK_FOR_PID: u32          = 0x04;
const CSR_ALLOW_KERNEL_DEBUGGER: u32       = 0x08;
const CSR_ALLOW_APPLE_INTERNAL: u32        = 0x10;
const CSR_ALLOW_UNRESTRICTED_DTRACE: u32   = 0x20;
const CSR_ALLOW_UNRESTRICTED_NVRAM: u32    = 0x40;
const CSR_ALLOW_DEVICE_CONFIG: u32         = 0x80;
const CSR_ALLOW_ANY_RECOVERY_OS: u32       = 0x100;
const CSR_ALLOW_UNAPPROVED_KEXTS: u32     = 0x200;
const CSR_ALLOW_EXECUTABLE_POLICY: u32     = 0x400;
const CSR_ALLOW_UNAUTHENTICATED_ROOT: u32  = 0x800;

/// Human-readable names for SIP flags
const CSR_FLAG_NAMES: &[(u32, &str)] = &[
    (CSR_ALLOW_UNTRUSTED_KEXTS,      "Allow Untrusted Kexts"),
    (CSR_ALLOW_UNRESTRICTED_FS,       "Allow Unrestricted Filesystem"),
    (CSR_ALLOW_TASK_FOR_PID,          "Allow task_for_pid"),
    (CSR_ALLOW_KERNEL_DEBUGGER,       "Allow Kernel Debugger"),
    (CSR_ALLOW_APPLE_INTERNAL,        "Allow Apple Internal"),
    (CSR_ALLOW_UNRESTRICTED_DTRACE,   "Allow Unrestricted DTrace"),
    (CSR_ALLOW_UNRESTRICTED_NVRAM,    "Allow Unrestricted NVRAM"),
    (CSR_ALLOW_DEVICE_CONFIG,         "Allow Device Configuration"),
    (CSR_ALLOW_ANY_RECOVERY_OS,       "Allow Any Recovery OS"),
    (CSR_ALLOW_UNAPPROVED_KEXTS,     "Allow Unapproved Kexts"),
    (CSR_ALLOW_EXECUTABLE_POLICY,     "Allow Executable Policy Override"),
    (CSR_ALLOW_UNAUTHENTICATED_ROOT,  "Allow Unauthenticated Root"),
];

/// XProtect and MRT paths
const XPROTECT_PATHS: &[&str] = &[
    "/Library/Apple/System/Library/CoreServices/XProtect.bundle",
    "/Library/Apple/System/Library/CoreServices/XProtect.app",
    "/System/Library/CoreServices/XProtect.bundle",
];

const MRT_PATHS: &[&str] = &[
    "/Library/Apple/System/Library/CoreServices/MRT.app",
    "/System/Library/CoreServices/MRT.app",
];

/// Gatekeeper assessment tools
const GATEKEEPER_TOOLS: &[&str] = &[
    "spctl", "syspolicyd", "GatekeeperHelper",
];

/// AMFI paths
const AMFI_PATHS: &[&str] = &[
    "/usr/libexec/amfid",
    "/System/Library/Extensions/AppleMobileFileIntegrity.kext",
];

/// Suspicious boot-args that weaken security
const SUSPICIOUS_BOOT_ARGS: &[&str] = &[
    "amfi_get_out_of_my_way=1",    // Disable AMFI
    "cs_enforcement_disable=1",     // Disable code signing
    "PE_i_can_has_debugger=1",      // Enable kernel debugging
    "kext-dev-mode=1",              // Allow unsigned kexts (legacy)
    "-v",                           // Verbose boot (not malicious but notable)
    "rootless=0",                   // Disable SIP (legacy)
    "debug=0x144",                  // Debug flags
];

/// Commands that indicate security feature manipulation
const SECURITY_MANIPULATION_CMDS: &[&str] = &[
    "csrutil disable", "csrutil clear",
    "csrutil authenticated-root disable",
    "spctl --master-disable", "spctl --disable",
    "nvram csr-active-config",
    "nvram boot-args",
    "xattr -d com.apple.quarantine",       // Remove quarantine flag
    "xattr -r -d com.apple.quarantine",    // Recursive quarantine removal
    "defaults write LSQuarantine",
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SecurityFeature {
    SystemIntegrityProtection,
    Gatekeeper,
    XProtect,
    MRT,
    AMFI,
    AuthenticatedRoot,
    LibraryValidation,
    Notarization,
    FileQuarantine,
    NVRAMProtection,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SecurityState {
    Enabled,
    Disabled,
    PartiallyDisabled,
    Unknown,
    Degraded,
    Tampered,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SIPAction {
    StatusChecked,
    StatusChanged,
    FlagModified,
    BypassAttempted,
    NVRAMModified,
    ProtectedPathAccessed,
    DefinitionsUpdated,
    FeatureDisabled,
    FeatureEnabled,
    QuarantineRemoved,
    CommandExecuted,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SIPEvent {
    pub id: String,
    pub timestamp: i64,
    pub feature: SecurityFeature,
    pub state: SecurityState,
    pub action: SIPAction,
    pub severity: Severity,
    pub confidence: f64,
    pub csr_flags: u32,
    pub disabled_flags: Vec<String>,
    pub previous_state: Option<SecurityState>,
    pub affected_path: Option<String>,
    pub process_name: String,
    pub process_pid: u32,
    pub user: String,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SIPStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub status_checks: u64,
    pub sip_disabled_detected: u64,
    pub sip_partial_detected: u64,
    pub gatekeeper_disabled: u64,
    pub xprotect_issues: u64,
    pub nvram_modifications: u64,
    pub quarantine_removals: u64,
    pub bypass_attempts: u64,
    pub protected_path_violations: u64,
    pub boot_arg_manipulations: u64,
    pub security_posture_score: f64,
    pub feature_states: HashMap<String, String>,
}

// ═══════════════════════════════════════════════════════════════════════════
// SIPMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct SIPMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical SIP status history ──
    monitor_history: RwLock<HierarchicalState<SIPStats>>,
    // ── Breakthrough #2: Tiered security event cache ──
    event_cache: TieredCache<String, SIPEvent>,
    // ── Breakthrough #3: Reversible security posture computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming security event rate ──
    event_rate: RwLock<StreamAccumulator<f64, SIPStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: SIP flag diff tracking ──
    state_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old security events ──
    recent_events: RwLock<PruningMap<String, SIPEvent>>,
    // ── Breakthrough #592: Deduplicate identical status reports ──
    status_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Feature × state frequency matrix ──
    feature_state_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Last known state for each security feature
    last_known_states: RwLock<HashMap<SecurityFeature, SecurityState>>,
    /// Last known CSR flags value
    last_csr_flags: AtomicU64,
    stats: RwLock<SIPStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl SIPMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(SIP_CACHE_MAX)
            .with_metrics(metrics.clone(), "sip_events");
        let risk_computer = ReversibleComputation::new(512,
            |scores: &[f64]| if scores.is_empty() { 1.0 } else { scores.iter().sum::<f64>() / scores.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, SIPStats::default(),
            |acc: &mut SIPStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            state_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(SIP_CACHE_MAX)),
            status_dedup: RwLock::new(DedupStore::new()),
            feature_state_matrix: RwLock::new(SparseMatrix::new(0u64)),
            last_known_states: RwLock::new(HashMap::new()),
            last_csr_flags: AtomicU64::new(0),
            stats: RwLock::new(SIPStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("sip_monitor", MEMORY_BUDGET / 2);
        info!("SIPMonitor started — monitoring SIP, Gatekeeper, XProtect, AMFI, SSV");
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("SIPMonitor stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    // ── SIP Flag Parsing ───────────────────────────────────────────────────

    /// Parse CSR flags bitmask into human-readable disabled flags.
    fn parse_csr_flags(flags: u32) -> Vec<String> {
        CSR_FLAG_NAMES.iter()
            .filter(|(bit, _)| flags & bit != 0)
            .map(|(_, name)| name.to_string())
            .collect()
    }

    /// Determine SIP state from CSR flags.
    fn sip_state_from_flags(flags: u32) -> SecurityState {
        if flags == 0 {
            SecurityState::Enabled
        } else if flags == 0xFFF {
            SecurityState::Disabled
        } else {
            SecurityState::PartiallyDisabled
        }
    }

    /// Compute a security posture score (0.0 = fully compromised, 1.0 = fully secured).
    fn compute_posture_score(states: &HashMap<SecurityFeature, SecurityState>) -> f64 {
        let weights: &[(SecurityFeature, f64)] = &[
            (SecurityFeature::SystemIntegrityProtection, 0.30),
            (SecurityFeature::Gatekeeper, 0.15),
            (SecurityFeature::XProtect, 0.10),
            (SecurityFeature::AMFI, 0.15),
            (SecurityFeature::AuthenticatedRoot, 0.10),
            (SecurityFeature::LibraryValidation, 0.05),
            (SecurityFeature::Notarization, 0.05),
            (SecurityFeature::FileQuarantine, 0.05),
            (SecurityFeature::NVRAMProtection, 0.05),
        ];

        let mut score = 0.0;
        for (feature, weight) in weights {
            let feature_score = match states.get(feature) {
                Some(SecurityState::Enabled) => 1.0,
                Some(SecurityState::PartiallyDisabled) => 0.5,
                Some(SecurityState::Degraded) => 0.3,
                Some(SecurityState::Disabled) => 0.0,
                Some(SecurityState::Tampered) => 0.0,
                _ => 0.8, // Unknown defaults to "probably okay"
            };
            score += feature_score * weight;
        }
        score
    }

    // ── Primary Analysis ───────────────────────────────────────────────────

    /// Analyze a SIP/security feature status update.
    pub fn analyze_status(
        &self,
        feature: SecurityFeature,
        state: SecurityState,
        csr_flags: u32,
        process_name: &str,
        pid: u32,
        user: &str,
    ) -> Option<SIPEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;
        self.stats.write().status_checks += 1;

        let previous_state = self.last_known_states.read().get(&feature).copied();
        let state_changed = previous_state.map_or(true, |prev| prev != state);

        if !state_changed { return None; }

        let disabled_flags = Self::parse_csr_flags(csr_flags);
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();

        match feature {
            SecurityFeature::SystemIntegrityProtection => {
                match state {
                    SecurityState::Disabled => {
                        indicators.push("SIP FULLY DISABLED — system is unprotected".to_string());
                        mitre_techniques.push("T1562.001".to_string());
                        mitre_techniques.push("T1014".to_string());
                        self.stats.write().sip_disabled_detected += 1;
                    }
                    SecurityState::PartiallyDisabled => {
                        for flag in &disabled_flags {
                            indicators.push(format!("SIP flag disabled: {}", flag));
                        }
                        mitre_techniques.push("T1562.001".to_string());
                        self.stats.write().sip_partial_detected += 1;
                    }
                    SecurityState::Enabled => {
                        if previous_state == Some(SecurityState::Disabled)
                            || previous_state == Some(SecurityState::PartiallyDisabled)
                        {
                            indicators.push("SIP re-enabled (was previously disabled)".to_string());
                        }
                    }
                    _ => {}
                }
            }
            SecurityFeature::Gatekeeper => {
                if state == SecurityState::Disabled {
                    indicators.push("Gatekeeper disabled — unsigned apps can run".to_string());
                    mitre_techniques.push("T1553.001".to_string());
                    self.stats.write().gatekeeper_disabled += 1;
                }
            }
            SecurityFeature::XProtect => {
                if matches!(state, SecurityState::Disabled | SecurityState::Degraded | SecurityState::Tampered) {
                    indicators.push(format!("XProtect {:?} — malware definitions may be compromised", state));
                    mitre_techniques.push("T1562.001".to_string());
                    self.stats.write().xprotect_issues += 1;
                }
            }
            SecurityFeature::AMFI => {
                if state == SecurityState::Disabled {
                    indicators.push("AMFI disabled — code signing enforcement off".to_string());
                    mitre_techniques.push("T1562.001".to_string());
                }
            }
            SecurityFeature::AuthenticatedRoot => {
                if state == SecurityState::Disabled {
                    indicators.push("Authenticated root (SSV) disabled — system volume unsealed".to_string());
                    mitre_techniques.push("T1006".to_string());
                }
            }
            SecurityFeature::FileQuarantine => {
                if state == SecurityState::Disabled {
                    indicators.push("File quarantine disabled — downloaded files unchecked".to_string());
                    mitre_techniques.push("T1553.001".to_string());
                }
            }
            _ => {
                if matches!(state, SecurityState::Disabled | SecurityState::Tampered) {
                    indicators.push(format!("{:?} is {:?}", feature, state));
                    mitre_techniques.push("T1562.001".to_string());
                }
            }
        }

        if indicators.is_empty() { return None; }

        let severity = match state {
            SecurityState::Disabled => Severity::Critical,
            SecurityState::Tampered => Severity::Critical,
            SecurityState::PartiallyDisabled => Severity::High,
            SecurityState::Degraded => Severity::High,
            _ => Severity::Medium,
        };

        let confidence = match state {
            SecurityState::Disabled | SecurityState::Tampered => 0.98,
            SecurityState::PartiallyDisabled => 0.95,
            SecurityState::Degraded => 0.85,
            _ => 0.70,
        };

        let action = if state_changed { SIPAction::StatusChanged } else { SIPAction::StatusChecked };

        let event = SIPEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            feature, state, action, severity, confidence,
            csr_flags,
            disabled_flags,
            previous_state,
            affected_path: None,
            process_name: process_name.to_string(),
            process_pid: pid,
            user: user.to_string(),
            indicators,
            mitre_techniques,
            blocked: false,
        };

        // Update stores
        self.last_known_states.write().insert(feature, state);
        if feature == SecurityFeature::SystemIntegrityProtection {
            self.last_csr_flags.store(csr_flags as u64, Ordering::SeqCst);
        }
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.state_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.status_dedup.write().insert(
            format!("{:?}:{:?}", feature, state), vec![]);

        let feat_str = format!("{:?}", feature);
        let state_str = format!("{:?}", state);
        let current = *self.feature_state_matrix.read().get(&feat_str, &state_str);
        self.feature_state_matrix.write().set(feat_str.clone(), state_str.clone(), current + 1);

        // Update posture score
        let posture = Self::compute_posture_score(&self.last_known_states.read());
        self.stats.write().security_posture_score = posture;
        self.stats.write().feature_states.insert(feat_str, state_str);
        self.stats.write().threats_detected += 1;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.state_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.status_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(1.0 - confidence);

        warn!("Security feature change: {:?} → {:?} (posture: {:.2})",
            feature, state, posture);

        Some(event)
    }

    /// Analyze a security-related command execution.
    pub fn analyze_command(
        &self,
        cmdline: &str,
        process_name: &str,
        pid: u32,
        user: &str,
    ) -> Option<SIPEvent> {
        let now = chrono::Utc::now().timestamp();

        let matching_cmd = SECURITY_MANIPULATION_CMDS.iter()
            .find(|cmd| cmdline.contains(*cmd));
        if matching_cmd.is_none() { return None; }

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut feature = SecurityFeature::SystemIntegrityProtection;

        // SIP manipulation
        if cmdline.contains("csrutil") {
            indicators.push(format!("SIP manipulation command: {}", cmdline));
            mitre_techniques.push("T1562.001".to_string());
        }

        // Gatekeeper manipulation
        if cmdline.contains("spctl") {
            feature = SecurityFeature::Gatekeeper;
            indicators.push(format!("Gatekeeper manipulation: {}", cmdline));
            mitre_techniques.push("T1553.001".to_string());
            self.stats.write().gatekeeper_disabled += 1;
        }

        // NVRAM manipulation
        if cmdline.contains("nvram") {
            feature = SecurityFeature::NVRAMProtection;
            indicators.push(format!("NVRAM modification: {}", cmdline));
            self.stats.write().nvram_modifications += 1;

            // Check for suspicious boot-args
            for &arg in SUSPICIOUS_BOOT_ARGS {
                if cmdline.contains(arg) {
                    indicators.push(format!("Dangerous boot-arg: {}", arg));
                    mitre_techniques.push("T1562.001".to_string());
                    self.stats.write().boot_arg_manipulations += 1;
                }
            }
        }

        // Quarantine removal
        if cmdline.contains("com.apple.quarantine") {
            feature = SecurityFeature::FileQuarantine;
            indicators.push(format!("Quarantine flag removal: {}", cmdline));
            mitre_techniques.push("T1553.001".to_string());
            self.stats.write().quarantine_removals += 1;
        }

        if indicators.is_empty() { return None; }

        let confidence = (0.7 + indicators.len() as f64 * 0.1).min(0.98);

        let event = SIPEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            feature,
            state: SecurityState::Tampered,
            action: SIPAction::CommandExecuted,
            severity: Severity::Critical,
            confidence,
            csr_flags: 0,
            disabled_flags: vec![],
            previous_state: self.last_known_states.read().get(&feature).copied(),
            affected_path: None,
            process_name: process_name.to_string(),
            process_pid: pid,
            user: user.to_string(),
            indicators,
            mitre_techniques,
            blocked: false,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.stats.write().threats_detected += 1;
        self.stats.write().bypass_attempts += 1;
        self.event_rate.write().push(1.0);

        warn!("Security manipulation command: {} by {} (user: {}, pid: {})",
            cmdline, process_name, user, pid);

        Some(event)
    }

    /// Analyze an access attempt on a SIP-protected path.
    pub fn analyze_protected_path_access(
        &self,
        path: &str,
        process_name: &str,
        pid: u32,
        user: &str,
        write_attempt: bool,
    ) -> Option<SIPEvent> {
        if !write_attempt { return None; }

        let is_protected = SIP_PROTECTED_PATHS.iter().any(|p| path.starts_with(p));
        if !is_protected { return None; }

        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().protected_path_violations += 1;

        let indicators = vec![
            format!("Write attempt to SIP-protected path: {}", path),
            format!("Process: {} (pid: {}, user: {})", process_name, pid, user),
        ];

        let event = SIPEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            feature: SecurityFeature::SystemIntegrityProtection,
            state: SecurityState::Tampered,
            action: SIPAction::ProtectedPathAccessed,
            severity: Severity::Critical,
            confidence: 0.95,
            csr_flags: self.last_csr_flags.load(Ordering::SeqCst) as u32,
            disabled_flags: vec![],
            previous_state: Some(SecurityState::Enabled),
            affected_path: Some(path.to_string()),
            process_name: process_name.to_string(),
            process_pid: pid,
            user: user.to_string(),
            indicators,
            mitre_techniques: vec!["T1562.001".to_string(), "T1006".to_string()],
            blocked: true,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.stats.write().threats_detected += 1;
        self.event_rate.write().push(1.0);

        warn!("SIP-protected path write attempt: {} by {} (pid {})", path, process_name, pid);

        Some(event)
    }

    /// Get the current security posture score.
    pub fn posture_score(&self) -> f64 {
        Self::compute_posture_score(&self.last_known_states.read())
    }

    pub fn stats(&self) -> SIPStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }
}
