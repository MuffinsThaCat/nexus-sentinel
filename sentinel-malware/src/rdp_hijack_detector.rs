//! Module 119: RDPHijackDetector — RDP Session Hijacking & Abuse Detection
//!
//! Detects Remote Desktop Protocol abuse including session hijacking, RDP
//! tunneling, BlueKeep-style exploits, and credential theft via RDP. While
//! macOS doesn't natively serve RDP, it can be an RDP client target and
//! mixed-OS enterprise networks are common attack surfaces.
//!
//! ## Detection Capabilities
//!
//! - **Session hijacking**: tscon.exe session takeover without credentials,
//!   disconnected session reconnection abuse
//! - **RDP tunneling**: RDP over SSH, RDP over HTTP/HTTPS (rdp2tcp, SharpRDP),
//!   Chisel/ligolo tunneled RDP
//! - **Credential theft**: NLA bypass, RDP credential harvesting, RDCMan
//!   credential file theft, .rdp file credential extraction
//! - **BlueKeep/DejaBlue**: CVE-2019-0708, CVE-2019-1181/1182 exploit detection
//! - **Lateral movement via RDP**: Unusual RDP connections between internal hosts,
//!   RDP from non-admin accounts, rapid multi-host RDP sessions
//! - **Shadowing**: RDP session shadowing for surveillance
//! - **Clipboard hijacking**: RDP clipboard data exfiltration
//! - **Drive redirection abuse**: RDP drive mapping for file access/exfiltration
//! - **RDP brute force**: Rapid failed RDP authentication attempts
//! - **Restricted Admin abuse**: Pass-the-hash via RDP Restricted Admin mode
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const BRUTE_FORCE_THRESHOLD: u32 = 15;
const BRUTE_FORCE_WINDOW_SECS: u64 = 120;
const MULTI_HOST_THRESHOLD: u32 = 5;
const MULTI_HOST_WINDOW_SECS: u64 = 300;

// ── RDP Attack Signatures ────────────────────────────────────────────────────

const RDP_HIJACK_INDICATORS: &[(&str, &str, f64)] = &[
    ("tscon", "Session hijacking via tscon.exe", 0.95),
    ("query session", "Session enumeration for hijacking", 0.6),
    ("query user", "User session enumeration", 0.5),
    ("mstsc /v:", "RDP client connection (programmatic)", 0.4),
    ("mstsc /shadow:", "RDP session shadowing", 0.85),
    ("mstsc /control", "RDP shadow with control", 0.9),
    ("tsdiscon", "Session disconnect (pre-hijack)", 0.7),
    ("logoff", "Forced logoff (session takeover)", 0.5),
    ("Restricted Admin", "RDP Restricted Admin (PtH vector)", 0.8),
    ("/restrictedAdmin", "Restricted Admin mode flag", 0.85),
    ("enablerestrictedadmin", "Enable Restricted Admin registry", 0.9),
    ("DisableRestrictedAdmin", "Restricted Admin registry key", 0.85),
];

const RDP_TUNNEL_TOOLS: &[(&str, &str, &str, f64)] = &[
    ("SharpRDP", "SharpRDP — .NET RDP lateral movement", "T1021.001", 0.9),
    ("rdp2tcp", "RDP tunnel over TCP channel", "T1572", 0.85),
    ("xfreerdp", "FreeRDP client (scripted lateral movement)", "T1021.001", 0.5),
    ("rdesktop", "rdesktop client (Linux/macOS RDP)", "T1021.001", 0.4),
    ("Chisel", "Chisel tunneled RDP", "T1572", 0.85),
    ("ligolo", "Ligolo reverse tunnel for RDP", "T1572", 0.85),
    ("ngrok", "Ngrok-tunneled RDP exposure", "T1572", 0.8),
    ("socat", "Socat RDP port forwarding", "T1572", 0.6),
    ("ncrack", "Ncrack RDP brute forcer", "T1110", 0.9),
    ("hydra", "Hydra RDP brute forcer", "T1110", 0.9),
    ("crowbar", "Crowbar RDP brute forcer", "T1110", 0.9),
];

const RDP_CVE_SIGS: &[(&str, &str, &str, f64)] = &[
    ("CVE-2019-0708", "BlueKeep — RDP RCE pre-auth", "T1210", 0.95),
    ("CVE-2019-1181", "DejaBlue — RDP RCE", "T1210", 0.95),
    ("CVE-2019-1182", "DejaBlue variant", "T1210", 0.95),
    ("CVE-2019-0887", "RDP clipboard RCE", "T1210", 0.9),
    ("CVE-2020-0609", "RDP Gateway RCE", "T1210", 0.9),
    ("CVE-2020-0610", "RDP Gateway RCE variant", "T1210", 0.9),
    ("CVE-2021-34535", "RDP Client RCE", "T1210", 0.88),
    ("CVE-2023-24905", "RDP Client RCE (ASLR bypass)", "T1210", 0.88),
];

const RDP_LATERAL_INDICATORS: &[(&str, &str, f64)] = &[
    ("clipboard", "RDP clipboard redirection (data theft)", 0.5),
    ("drive", "RDP drive redirection (file access)", 0.6),
    ("printer", "RDP printer redirection", 0.3),
    ("smartcard", "RDP smartcard redirection", 0.4),
    ("audio", "RDP audio redirection", 0.2),
    ("USB", "RDP USB redirection", 0.5),
    ("RemoteApp", "RDP RemoteApp (selective app publishing)", 0.4),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum RDPThreatType {
    SessionHijack,
    SessionShadow,
    BruteForce,
    TunneledRDP,
    RestrictedAdminPTH,
    NLABypass,
    CredentialTheft,
    BlueKeepExploit,
    DejaBlueExploit,
    ClipboardHijack,
    DriveRedirectionAbuse,
    MultiHostLateral,
    NonStandardPort,
    UnauthorizedAccess,
    RDPFileAbuse,
    DisconnectedSessionAbuse,
    ToolDetection,
    CVEExploit,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RDPThreatFinding {
    pub threat_type: RDPThreatType,
    pub source_ip: String,
    pub dest_ip: String,
    pub dest_port: u16,
    pub confidence: f64,
    pub description: String,
    pub username: Option<String>,
    pub session_id: Option<u32>,
    pub tool_name: Option<String>,
    pub cve_id: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RDPSession {
    pub session_id: String,
    pub source_ip: String,
    pub dest_ip: String,
    pub dest_port: u16,
    pub username: String,
    pub domain: String,
    pub auth_method: String,
    pub nla_enabled: bool,
    pub encryption_level: String,
    pub redirections: Vec<String>,
    pub start_time: u64,
    pub is_shadowed: bool,
    pub is_restricted_admin: bool,
    pub auth_attempts: u32,
    pub failed_attempts: u32,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub command_line: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RDPAnalysisResult {
    pub is_malicious: bool,
    pub sessions_analyzed: u32,
    pub findings: Vec<RDPThreatFinding>,
    pub hijack_attempts: Vec<String>,
    pub lateral_chains: Vec<Vec<String>>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct RDPScanStats {
    pub total_sessions: u64,
    pub hijack_detections: u64,
    pub brute_force_detections: u64,
    pub tunnel_detections: u64,
    pub lateral_detections: u64,
    pub exploit_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RDPDetectorConfig {
    pub enabled: bool,
    pub detect_hijacking: bool,
    pub detect_tunneling: bool,
    pub detect_brute_force: bool,
    pub detect_lateral: bool,
    pub brute_force_threshold: u32,
    pub multi_host_threshold: u32,
    pub standard_rdp_ports: Vec<u16>,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for RDPDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            detect_hijacking: true,
            detect_tunneling: true,
            detect_brute_force: true,
            detect_lateral: true,
            brute_force_threshold: BRUTE_FORCE_THRESHOLD,
            multi_host_threshold: MULTI_HOST_THRESHOLD,
            standard_rdp_ports: vec![3389],
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RDPSigEntry {
    pub pattern: String,
    pub description: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct RDPHijackDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<RDPScanStats>>,
    result_cache: TieredCache<String, RDPAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    session_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, RDPScanStats>>,
    metrics: MemoryMetrics,
    session_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, RDPAnalysisResult>>,
    sig_db: PagedMemory<RDPSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<RDPDetectorConfig>,
    stats: RwLock<RDPScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_analyses: AtomicU64,
    rdp_graph: RwLock<HashMap<String, HashSet<String>>>,
    user_session_map: RwLock<HashMap<String, Vec<(String, u64)>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl RDPHijackDetector {
    pub fn new() -> Self {
        let cfg = RDPDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            session_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, RDPScanStats::default(),
                |acc: &mut RDPScanStats, vals: &[f64]| { acc.total_sessions += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            session_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(RDPScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_analyses: AtomicU64::new(0),
            rdp_graph: RwLock::new(HashMap::new()),
            user_session_map: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_session(&self, session: &RDPSession) -> Option<RDPAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_analyses.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", session.source_ip, session.dest_ip, session.session_id);

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut hijack_attempts = Vec::new();

        // Check hijacking indicators
        if cfg.detect_hijacking {
            if let Some(ref cmd) = session.command_line {
                let cmd_lower = cmd.to_lowercase();
                for &(indicator, desc, conf) in RDP_HIJACK_INDICATORS {
                    if cmd_lower.contains(&indicator.to_lowercase()) {
                        let tt = if indicator.contains("shadow") { RDPThreatType::SessionShadow }
                            else if indicator.contains("Restricted") || indicator.contains("restricted") {
                                RDPThreatType::RestrictedAdminPTH
                            } else { RDPThreatType::SessionHijack };
                        findings.push(RDPThreatFinding {
                            threat_type: tt,
                            source_ip: session.source_ip.clone(),
                            dest_ip: session.dest_ip.clone(),
                            dest_port: session.dest_port,
                            confidence: conf,
                            description: desc.to_string(),
                            username: Some(session.username.clone()),
                            session_id: None,
                            tool_name: None,
                            cve_id: None,
                            mitre_id: "T1563.002".into(),
                            timestamp: session.start_time,
                        });
                        mitre_ids.insert("T1563.002".into());
                        hijack_attempts.push(format!("{}: {}", indicator, desc));
                    }
                }
            }

            if session.is_shadowed {
                findings.push(RDPThreatFinding {
                    threat_type: RDPThreatType::SessionShadow,
                    source_ip: session.source_ip.clone(),
                    dest_ip: session.dest_ip.clone(),
                    dest_port: session.dest_port,
                    confidence: 0.8,
                    description: "Active RDP session shadowing detected".into(),
                    username: Some(session.username.clone()),
                    session_id: None, tool_name: None, cve_id: None,
                    mitre_id: "T1563.002".into(),
                    timestamp: session.start_time,
                });
                mitre_ids.insert("T1563.002".into());
            }

            if session.is_restricted_admin {
                findings.push(RDPThreatFinding {
                    threat_type: RDPThreatType::RestrictedAdminPTH,
                    source_ip: session.source_ip.clone(),
                    dest_ip: session.dest_ip.clone(),
                    dest_port: session.dest_port,
                    confidence: 0.85,
                    description: "RDP Restricted Admin mode — pass-the-hash vector".into(),
                    username: Some(session.username.clone()),
                    session_id: None, tool_name: None, cve_id: None,
                    mitre_id: "T1550.002".into(),
                    timestamp: session.start_time,
                });
                mitre_ids.insert("T1550.002".into());
            }
        }

        // Check brute force
        if cfg.detect_brute_force && session.failed_attempts >= cfg.brute_force_threshold {
            findings.push(RDPThreatFinding {
                threat_type: RDPThreatType::BruteForce,
                source_ip: session.source_ip.clone(),
                dest_ip: session.dest_ip.clone(),
                dest_port: session.dest_port,
                confidence: 0.85,
                description: format!("{} failed RDP auth attempts from {}",
                    session.failed_attempts, session.source_ip),
                username: Some(session.username.clone()),
                session_id: None, tool_name: None, cve_id: None,
                mitre_id: "T1110".into(),
                timestamp: session.start_time,
            });
            mitre_ids.insert("T1110".into());
        }

        // Check NLA bypass
        if !session.nla_enabled {
            findings.push(RDPThreatFinding {
                threat_type: RDPThreatType::NLABypass,
                source_ip: session.source_ip.clone(),
                dest_ip: session.dest_ip.clone(),
                dest_port: session.dest_port,
                confidence: 0.6,
                description: "RDP without NLA — pre-auth attack surface exposed".into(),
                username: Some(session.username.clone()),
                session_id: None, tool_name: None, cve_id: None,
                mitre_id: "T1021.001".into(),
                timestamp: session.start_time,
            });
            mitre_ids.insert("T1021.001".into());
        }

        // Check tunnel tools
        if cfg.detect_tunneling {
            if let Some(ref cmd) = session.command_line {
                let cmd_lower = cmd.to_lowercase();
                for &(tool, desc, mitre, conf) in RDP_TUNNEL_TOOLS {
                    if cmd_lower.contains(&tool.to_lowercase()) {
                        let tt = if tool.contains("crack") || tool.contains("hydra") || tool.contains("crowbar") {
                            RDPThreatType::BruteForce
                        } else {
                            RDPThreatType::TunneledRDP
                        };
                        findings.push(RDPThreatFinding {
                            threat_type: tt,
                            source_ip: session.source_ip.clone(),
                            dest_ip: session.dest_ip.clone(),
                            dest_port: session.dest_port,
                            confidence: conf,
                            description: desc.to_string(),
                            username: Some(session.username.clone()),
                            session_id: None,
                            tool_name: Some(tool.into()),
                            cve_id: None,
                            mitre_id: mitre.into(),
                            timestamp: session.start_time,
                        });
                        mitre_ids.insert(mitre.into());
                    }
                }
            }
        }

        // Check redirections
        for redir in &session.redirections {
            for &(indicator, desc, conf) in RDP_LATERAL_INDICATORS {
                if redir.to_lowercase().contains(&indicator.to_lowercase()) {
                    let tt = if indicator == "clipboard" { RDPThreatType::ClipboardHijack }
                        else if indicator == "drive" { RDPThreatType::DriveRedirectionAbuse }
                        else { RDPThreatType::UnauthorizedAccess };
                    if conf >= cfg.min_confidence {
                        findings.push(RDPThreatFinding {
                            threat_type: tt,
                            source_ip: session.source_ip.clone(),
                            dest_ip: session.dest_ip.clone(),
                            dest_port: session.dest_port,
                            confidence: conf,
                            description: format!("RDP {}: {}", redir, desc),
                            username: Some(session.username.clone()),
                            session_id: None, tool_name: None, cve_id: None,
                            mitre_id: "T1021.001".into(),
                            timestamp: session.start_time,
                        });
                        mitre_ids.insert("T1021.001".into());
                    }
                }
            }
        }

        // Non-standard port
        if !cfg.standard_rdp_ports.contains(&session.dest_port) {
            findings.push(RDPThreatFinding {
                threat_type: RDPThreatType::NonStandardPort,
                source_ip: session.source_ip.clone(),
                dest_ip: session.dest_ip.clone(),
                dest_port: session.dest_port,
                confidence: 0.5,
                description: format!("RDP on non-standard port {}", session.dest_port),
                username: Some(session.username.clone()),
                session_id: None, tool_name: None, cve_id: None,
                mitre_id: "T1571".into(),
                timestamp: session.start_time,
            });
            mitre_ids.insert("T1571".into());
        }

        // Track RDP lateral movement graph
        if cfg.detect_lateral {
            self.rdp_graph.write()
                .entry(session.source_ip.clone())
                .or_default()
                .insert(session.dest_ip.clone());

            // Track multi-host access per user
            self.user_session_map.write()
                .entry(session.username.clone())
                .or_default()
                .push((session.dest_ip.clone(), session.start_time));

            let user_hosts = self.user_session_map.read()
                .get(&session.username)
                .map(|v| {
                    let unique: HashSet<&String> = v.iter().map(|(ip, _)| ip).collect();
                    unique.len() as u32
                })
                .unwrap_or(0);

            if user_hosts >= cfg.multi_host_threshold {
                findings.push(RDPThreatFinding {
                    threat_type: RDPThreatType::MultiHostLateral,
                    source_ip: session.source_ip.clone(),
                    dest_ip: session.dest_ip.clone(),
                    dest_port: session.dest_port,
                    confidence: 0.8,
                    description: format!("User {} connected to {} hosts via RDP",
                        session.username, user_hosts),
                    username: Some(session.username.clone()),
                    session_id: None, tool_name: None, cve_id: None,
                    mitre_id: "T1021.001".into(),
                    timestamp: session.start_time,
                });
                mitre_ids.insert("T1021.001".into());
            }
        }

        let lateral_chains = self.find_lateral_chains(&session.source_ip, 5);

        self.session_diffs.write().record_insert(
            cache_key.clone(),
            format!("src={},dst={}:{},user={},nla={}",
                session.source_ip, session.dest_ip, session.dest_port,
                session.username, session.nla_enabled),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = RDPAnalysisResult {
            is_malicious,
            sessions_analyzed: 1,
            findings,
            hijack_attempts,
            lateral_chains,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_sessions += 1;
            if is_malicious {
                for f in &result.findings {
                    match f.threat_type {
                        RDPThreatType::SessionHijack | RDPThreatType::SessionShadow => stats.hijack_detections += 1,
                        RDPThreatType::BruteForce => stats.brute_force_detections += 1,
                        RDPThreatType::TunneledRDP => stats.tunnel_detections += 1,
                        RDPThreatType::MultiHostLateral => stats.lateral_detections += 1,
                        RDPThreatType::BlueKeepExploit | RDPThreatType::DejaBlueExploit | RDPThreatType::CVEExploit => stats.exploit_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = stats.total_sessions as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "rdp_hijack_detector".into(),
                title: format!("RDP abuse: {} → {}:{}", session.source_ip, session.dest_ip, session.dest_port),
                details: format!("Risk: {:.1}%, {} findings, user: {}\\{}",
                    risk_score * 100.0, result.findings.len(), session.domain, session.username),
                path: None,
                process_name: session.process_name.clone(),
                process_pid: session.process_pid,
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Enable NLA for all RDP connections".into(),
                    "Restrict RDP access with firewall rules".into(),
                    "Disable RDP drive and clipboard redirection where not needed".into(),
                    "Implement RDP session time limits".into(),
                    "Deploy RDP Gateway for external access".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn find_lateral_chains(&self, start: &str, max_depth: usize) -> Vec<Vec<String>> {
        let graph = self.rdp_graph.read();
        let mut chains = Vec::new();
        let mut visited = HashSet::new();
        let mut stack = vec![(start.to_string(), vec![start.to_string()])];
        while let Some((node, path)) = stack.pop() {
            if path.len() > max_depth { continue; }
            if path.len() >= 3 { chains.push(path.clone()); }
            visited.insert(node.clone());
            if let Some(neighbors) = graph.get(&node) {
                for next in neighbors {
                    if !visited.contains(next) {
                        let mut np = path.clone();
                        np.push(next.clone());
                        stack.push((next.clone(), np));
                    }
                }
            }
        }
        chains
    }

    fn calculate_risk_score(&self, findings: &[RDPThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                RDPThreatType::SessionHijack => 1.5,
                RDPThreatType::BlueKeepExploit | RDPThreatType::DejaBlueExploit => 1.5,
                RDPThreatType::RestrictedAdminPTH => 1.4,
                RDPThreatType::SessionShadow => 1.3,
                RDPThreatType::TunneledRDP => 1.3,
                RDPThreatType::MultiHostLateral => 1.2,
                RDPThreatType::BruteForce => 1.1,
                RDPThreatType::DriveRedirectionAbuse => 1.0,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> RDPScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
