//! Module 98: PhishingUrlDetector — Phishing URL & Domain Detection
//!
//! World-class detection engine for phishing URLs, typosquatting domains, homoglyph
//! attacks, URL shortener abuse, credential harvesting pages, and brand impersonation.
//! Uses Levenshtein distance, IDN homoglyph analysis, URL structural analysis, and
//! known phishing feed correlation.
//!
//! ## Features
//!
//! - **Typosquatting detection**: Identifies domains within edit distance of known
//!   legitimate brands (gooogle.com, microsft.com, arnazon.com)
//! - **Homoglyph/IDN attack detection**: Detects Punycode domains using visually
//!   similar characters (а vs a, о vs o, і vs i — Cyrillic/Latin)
//! - **URL structural analysis**: Flags URLs with IP addresses, excessive subdomains,
//!   @ symbols, hexadecimal encoding, and suspicious path patterns
//! - **Brand impersonation**: Detects URLs containing brand names in subdomains
//!   or paths (login-microsoft.evil.com, paypal.com.attacker.com)
//! - **URL shortener tracking**: Identifies shortened URLs (bit.ly, t.co, goo.gl)
//!   used to hide phishing destinations
//! - **Credential harvesting indicators**: Detects login forms, password fields,
//!   and authentication UI elements at suspicious URLs
//! - **Certificate analysis**: Flags newly registered domains, free SSL certificates,
//!   and certificate mismatch with claimed brand
//! - **Known phishing feed**: Database of known phishing URLs and domains from
//!   PhishTank, OpenPhish, and community feeds
//! - **Redirect chain analysis**: Follows and analyzes HTTP redirect chains for
//!   cloaking and evasion techniques
//! - **QR code phishing (quishing)**: Detects malicious URLs embedded in QR codes
//! - **Data URI detection**: Identifies data: URIs used for inline phishing pages
//! - **Domain age analysis**: Flags domains registered within the last 30 days
//!   combined with high-value brand keywords
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) URL scan history
//! - **#2  TieredCache** — Hot cache for recent URL analyses
//! - **#3  ReversibleComputation** — Recompute URL risk scores
//! - **#5  StreamAccumulator** — Streaming scan rate
//! - **#6  MemoryMetrics** — Bounded memory for URL data
//! - **#461 DifferentialStore** — Track domain registration diffs
//! - **#569 PruningMap** — Auto-expire old URL events
//! - **#592 DedupStore** — Deduplicate identical URL scans
//! - **#627 SparseMatrix** — Domain × technique frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1566.002 — Phishing: Spearphishing Link
//! - T1598.003 — Phishing for Information: Spearphishing Link
//! - T1204.001 — User Execution: Malicious Link
//! - T1071.001 — Application Layer Protocol: Web Protocols

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const URL_CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 32 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 2_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────
/// Maximum edit distance for typosquatting detection
const MAX_EDIT_DISTANCE: usize = 2;
/// Domain age threshold (days) for new domain flagging
const NEW_DOMAIN_THRESHOLD_DAYS: u32 = 30;
/// Excessive subdomain threshold
const EXCESSIVE_SUBDOMAIN_THRESHOLD: u32 = 3;
/// Maximum URL length before suspicion
const SUSPICIOUS_URL_LENGTH: usize = 256;
const PUNYCODE_RISK: f64 = 0.75;
const REDIRECT_CHAIN_RISK: f64 = 0.60;
const CERT_MISMATCH_RISK: f64 = 0.70;

/// Protected brand domains for typosquatting detection: (domain, brand, category)
const PROTECTED_BRANDS: &[(&str, &str, &str)] = &[
    ("google.com",          "Google",       "Tech"),
    ("microsoft.com",       "Microsoft",    "Tech"),
    ("apple.com",           "Apple",        "Tech"),
    ("amazon.com",          "Amazon",       "Retail"),
    ("facebook.com",        "Facebook",     "Social"),
    ("instagram.com",       "Instagram",    "Social"),
    ("twitter.com",         "Twitter",      "Social"),
    ("linkedin.com",        "LinkedIn",     "Social"),
    ("paypal.com",          "PayPal",       "Finance"),
    ("chase.com",           "Chase",        "Finance"),
    ("bankofamerica.com",   "BofA",         "Finance"),
    ("wellsfargo.com",      "Wells Fargo",  "Finance"),
    ("citibank.com",        "Citibank",     "Finance"),
    ("netflix.com",         "Netflix",      "Entertainment"),
    ("spotify.com",         "Spotify",      "Entertainment"),
    ("dropbox.com",         "Dropbox",      "Cloud"),
    ("github.com",          "GitHub",       "Dev"),
    ("gitlab.com",          "GitLab",       "Dev"),
    ("slack.com",           "Slack",        "Business"),
    ("zoom.us",             "Zoom",         "Business"),
    ("coinbase.com",        "Coinbase",     "Crypto"),
    ("binance.com",         "Binance",      "Crypto"),
    ("kraken.com",          "Kraken",       "Crypto"),
    ("metamask.io",         "MetaMask",     "Crypto"),
    ("icloud.com",          "iCloud",       "Cloud"),
    ("outlook.com",         "Outlook",      "Email"),
    ("yahoo.com",           "Yahoo",        "Email"),
    ("proton.me",           "Proton",       "Email"),
    ("usps.com",            "USPS",         "Shipping"),
    ("fedex.com",           "FedEx",        "Shipping"),
    ("dhl.com",             "DHL",          "Shipping"),
    ("ups.com",             "UPS",          "Shipping"),
    ("adobe.com",           "Adobe",        "Software"),
    ("salesforce.com",      "Salesforce",   "Business"),
    ("docusign.com",        "DocuSign",     "Business"),
];

/// Homoglyph character mappings (visual lookalikes): (unicode, ascii_equiv, script)
const HOMOGLYPHS: &[(char, char, &str)] = &[
    ('а', 'a', "Cyrillic"),
    ('е', 'e', "Cyrillic"),
    ('о', 'o', "Cyrillic"),
    ('р', 'p', "Cyrillic"),
    ('с', 'c', "Cyrillic"),
    ('у', 'y', "Cyrillic"),
    ('і', 'i', "Cyrillic"),
    ('ν', 'v', "Greek"),
    ('ο', 'o', "Greek"),
    ('α', 'a', "Greek"),
    ('τ', 't', "Greek"),
    ('ɡ', 'g', "Latin Extended"),
    ('ɩ', 'i', "Latin Extended"),
    ('ℓ', 'l', "Letterlike"),
    ('ⅰ', 'i', "Roman Numeral"),
    ('０', '0', "Fullwidth"),
    ('１', '1', "Fullwidth"),
];

/// URL shortener domains
const URL_SHORTENERS: &[(&str, &str)] = &[
    ("bit.ly",         "Bitly"),
    ("t.co",           "Twitter"),
    ("goo.gl",         "Google"),
    ("tinyurl.com",    "TinyURL"),
    ("ow.ly",          "Hootsuite"),
    ("is.gd",          "is.gd"),
    ("buff.ly",        "Buffer"),
    ("rebrand.ly",     "Rebrandly"),
    ("short.io",       "Short.io"),
    ("cutt.ly",        "Cuttly"),
    ("rb.gy",          "Rebrandly"),
    ("t.ly",           "T.LY"),
    ("shorturl.at",    "ShortURL"),
    ("tiny.cc",        "Tiny.cc"),
    ("lnkd.in",       "LinkedIn"),
];

/// Suspicious/// Punycode / IDN homograph attack patterns
const PUNYCODE_INDICATORS: &[(&str, f64, &str)] = &[
    ("xn--",              0.75, "Punycode domain — internationalized domain name"),
    ("%00",               0.80, "Null byte in URL — potential injection"),
    ("%2e",               0.65, "URL-encoded dot — obfuscation"),
    ("%2f",               0.65, "URL-encoded slash — path obfuscation"),
    ("%40",               0.70, "URL-encoded @ — credential prefix trick"),
    ("%23",               0.50, "URL-encoded hash — fragment obfuscation"),
    ("\\u00",             0.70, "Unicode escape sequence"),
];

/// Redirect chain / open redirect indicators
const REDIRECT_INDICATORS: &[(&str, f64, &str)] = &[
    ("redirect=",          0.55, "Redirect parameter in URL"),
    ("url=",               0.50, "URL parameter — potential open redirect"),
    ("next=",              0.45, "Next parameter — post-auth redirect"),
    ("return=",            0.45, "Return URL parameter"),
    ("redir=",             0.55, "Redir parameter"),
    ("goto=",              0.50, "Goto parameter"),
    ("dest=",              0.50, "Destination parameter"),
    ("continue=",          0.45, "Continue URL parameter"),
    ("target=",            0.50, "Target URL parameter"),
    ("ReturnUrl=",         0.55, "ASP.NET return URL"),
];

/// Certificate-related phishing indicators
const CERT_INDICATORS: &[(&str, f64, &str)] = &[
    ("let's encrypt",      0.30, "Let's Encrypt cert (common, low risk alone)"),
    ("self-signed",        0.65, "Self-signed certificate"),
    ("expired",            0.50, "Expired certificate"),
    ("mismatch",           0.70, "Certificate domain mismatch"),
    ("untrusted",          0.65, "Untrusted certificate authority"),
];

/// Known phishing kit indicators in URL paths
const PHISHING_KIT_PATHS: &[(&str, f64, &str)] = &[
    ("/wp-content/",       0.45, "WordPress content directory (common abuse vector)"),
    ("/wp-includes/",      0.50, "WordPress includes — unusual for user-facing"),
    ("/wp-admin/",         0.40, "WordPress admin path"),
    ("/cgi-bin/",          0.50, "CGI-BIN directory"),
    ("/tmp/",              0.60, "Temp directory in URL path"),
    ("/.well-known/",      0.35, "Well-known directory (context-dependent)"),
    ("/phish",             0.90, "Literal phish in path"),
    ("/scam",              0.90, "Literal scam in path"),
    ("/login/verify",      0.65, "Login verification path"),
    ("/account/confirm",   0.60, "Account confirmation path"),
    ("/secure/update",     0.65, "Secure update path"),
    ("/banking/",          0.55, "Banking path"),
    ("/paypal/",           0.70, "PayPal path on non-PayPal domain"),
    ("/microsoft/",        0.60, "Microsoft path on non-Microsoft domain"),
    ("/apple/",            0.60, "Apple path on non-Apple domain"),
];

/// URL structural patterns
const URL_STRUCTURAL_PATTERNS: &[(&str, f64, &str)] = &[
    ("@",                  0.80, "@ symbol — credential-like URL structure"),
    ("//login",            0.65, "Login keyword in path"),
    ("//signin",           0.65, "Signin keyword in path"),
    ("//verify",           0.60, "Verify keyword in path"),
    ("//update",           0.55, "Update keyword in path"),
    ("//secure",           0.50, "Secure keyword in path (ironic)"),
    ("//account",          0.55, "Account keyword in path"),
    ("/wp-content/",       0.40, "WordPress content (common phishing host)"),
    ("/wp-admin/",         0.45, "WordPress admin (compromised site)"),
    (".php?",              0.35, "PHP with parameters"),
    ("data:",              0.85, "Data URI — inline content"),
    ("%2F%2F",             0.70, "Double-encoded slashes"),
    ("javascript:",        0.90, "JavaScript URI scheme"),
    ("-login",             0.60, "Login in subdomain"),
    ("-secure",            0.55, "Secure in subdomain"),
    ("-verify",            0.60, "Verify in subdomain"),
    (".tk",                0.55, "Tokelau TLD (free, abused)"),
    (".ml",                0.55, "Mali TLD (free, abused)"),
    (".ga",                0.55, "Gabon TLD (free, abused)"),
    (".cf",                0.55, "Central African Republic TLD (free, abused)"),
    (".gq",                0.55, "Equatorial Guinea TLD (free, abused)"),
    (".xyz",               0.40, "XYZ TLD (cheap, often abused)"),
    (".top",               0.40, "TOP TLD (cheap, often abused)"),
    (".buzz",              0.45, "BUZZ TLD (cheap, often abused)"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum PhishingTechnique {
    Typosquatting, Homoglyph, BrandImpersonation, URLShortener,
    SuspiciousStructure, IPAddress, DataURI, ExcessiveSubdomains,
    NewDomain, CredentialHarvesting, CertificateMismatch,
    RedirectChain, QRCodePhishing, FreeHosting,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PhishingScanResult {
    pub id: String,
    pub timestamp: i64,
    pub url: String,
    pub domain: String,
    pub severity: Severity,
    pub confidence: f64,
    pub techniques: Vec<PhishingTechnique>,
    pub impersonated_brand: Option<String>,
    pub edit_distance: Option<usize>,
    pub homoglyph_chars: Vec<String>,
    pub url_shortener: Option<String>,
    pub subdomain_count: u32,
    pub has_ip_address: bool,
    pub structural_flags: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PhishingStats {
    pub urls_scanned: u64,
    pub threats_detected: u64,
    pub typosquatting_detected: u64,
    pub homoglyph_detected: u64,
    pub brand_impersonation: u64,
    pub shortener_detected: u64,
    pub structural_flags: u64,
    pub ip_address_urls: u64,
    pub new_domains: u64,
    pub excessive_length_urls: u64,
    pub redirect_chains: u64,
    pub blocked_urls: u64,
    pub safe_urls: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PhishingConfig {
    pub block_typosquatting: bool,
    pub block_homoglyphs: bool,
    pub block_ip_urls: bool,
    pub scan_shorteners: bool,
    pub max_edit_distance: usize,
    pub block_on_high: bool,
}

impl PhishingConfig {
    pub fn default_config() -> Self {
        Self {
            block_typosquatting: true,
            block_homoglyphs: true,
            block_ip_urls: true,
            scan_shorteners: true,
            max_edit_distance: MAX_EDIT_DISTANCE,
            block_on_high: true,
        }
    }
}

pub struct PhishingUrlDetector {
    // Breakthrough #1: HierarchicalState — O(log n) scan history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<PhishingStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, PhishingScanResult>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, PhishingStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — domain pattern diffs
    domain_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, PhishingScanResult>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — domain × technique matrix
    domain_technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<PhishingConfig>,
    stats: RwLock<PhishingStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl PhishingUrlDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(URL_CACHE_MAX)
            .with_metrics(metrics.clone(), "phishing_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, PhishingStats::default(),
            |acc: &mut PhishingStats, rates: &[f64]| {
                for &r in rates { acc.urls_scanned += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            domain_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(URL_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            domain_technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(PhishingConfig::default_config()),
            stats: RwLock::new(PhishingStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("phishing_url", MEMORY_BUDGET / 2);
        info!("PhishingUrlDetector started — {} brands, {} homoglyphs, {} shorteners, {} structural patterns",
            PROTECTED_BRANDS.len(), HOMOGLYPHS.len(),
            URL_SHORTENERS.len(), URL_STRUCTURAL_PATTERNS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("PhishingUrlDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn levenshtein(a: &str, b: &str) -> usize {
        let (la, lb) = (a.len(), b.len());
        if la == 0 { return lb; }
        if lb == 0 { return la; }
        let mut prev: Vec<usize> = (0..=lb).collect();
        let mut curr = vec![0usize; lb + 1];
        for (i, ca) in a.chars().enumerate() {
            curr[0] = i + 1;
            for (j, cb) in b.chars().enumerate() {
                let cost = if ca == cb { 0 } else { 1 };
                curr[j + 1] = (prev[j] + cost).min(curr[j] + 1).min(prev[j + 1] + 1);
            }
            std::mem::swap(&mut prev, &mut curr);
        }
        prev[lb]
    }

    fn extract_domain(url: &str) -> String {
        let without_scheme = url.split("://").last().unwrap_or(url);
        let without_path = without_scheme.split('/').next().unwrap_or(without_scheme);
        let without_port = without_path.split(':').next().unwrap_or(without_path);
        let without_auth = without_port.split('@').last().unwrap_or(without_port);
        without_auth.to_lowercase()
    }

    fn count_subdomains(domain: &str) -> u32 {
        let parts: Vec<&str> = domain.split('.').collect();
        if parts.len() <= 2 { 0 } else { (parts.len() - 2) as u32 }
    }

    fn is_ip_address(domain: &str) -> bool {
        domain.chars().all(|c| c.is_ascii_digit() || c == '.')
            && domain.split('.').count() == 4
    }

    /// Scan a URL for phishing indicators.
    pub fn scan_url(&self, url: &str) -> PhishingScanResult {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().urls_scanned += 1;

        let domain = Self::extract_domain(url);
        let url_lower = url.to_lowercase();
        let subdomain_count = Self::count_subdomains(&domain);
        let has_ip = Self::is_ip_address(&domain);

        let mut techniques = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut homoglyph_chars = Vec::new();
        let mut impersonated_brand: Option<String> = None;
        let mut edit_dist: Option<usize> = None;
        let mut shortener: Option<String> = None;
        let mut structural_flags = Vec::new();
        let mut max_risk: f64 = 0.0;

        // ── 1. Typosquatting detection ──
        for &(brand_domain, brand_name, _category) in PROTECTED_BRANDS {
            if domain == brand_domain { break; } // exact match = safe
            let dist = Self::levenshtein(&domain, brand_domain);
            if dist > 0 && dist <= MAX_EDIT_DISTANCE {
                impersonated_brand = Some(brand_name.to_string());
                edit_dist = Some(dist);
                indicators.push(format!("Typosquatting: '{}' is {} edit(s) from '{}'",
                    domain, dist, brand_domain));
                techniques.push(PhishingTechnique::Typosquatting);
                self.stats.write().typosquatting_detected += 1;
                mitre_techniques.push("T1566.002".to_string());
                max_risk = max_risk.max(0.90);
                break;
            }
            // Brand in subdomain/path check
            if domain.contains(brand_domain.split('.').next().unwrap_or("")) && domain != brand_domain {
                impersonated_brand = Some(brand_name.to_string());
                indicators.push(format!("Brand impersonation: '{}' contains '{}'", domain, brand_name));
                techniques.push(PhishingTechnique::BrandImpersonation);
                self.stats.write().brand_impersonation += 1;
                max_risk = max_risk.max(0.80);
                break;
            }
        }

        // ── 2. Homoglyph detection ──
        for ch in domain.chars() {
            for &(homoglyph, _ascii, script) in HOMOGLYPHS {
                if ch == homoglyph {
                    homoglyph_chars.push(format!("'{}' ({}) looks like '{}'", ch, script, _ascii));
                    techniques.push(PhishingTechnique::Homoglyph);
                    max_risk = max_risk.max(0.95);
                }
            }
        }
        if !homoglyph_chars.is_empty() {
            indicators.push(format!("{} homoglyph characters in domain", homoglyph_chars.len()));
            self.stats.write().homoglyph_detected += 1;
        }

        // ── 3. URL shortener ──
        for &(short_domain, name) in URL_SHORTENERS {
            if domain == short_domain || domain.ends_with(&format!(".{}", short_domain)) {
                shortener = Some(name.to_string());
                indicators.push(format!("URL shortener: {} ({})", short_domain, name));
                techniques.push(PhishingTechnique::URLShortener);
                self.stats.write().shortener_detected += 1;
                max_risk = max_risk.max(0.50);
                break;
            }
        }

        // ── 4. IP address URL ──
        if has_ip {
            indicators.push(format!("IP address URL: {}", domain));
            techniques.push(PhishingTechnique::IPAddress);
            self.stats.write().ip_address_urls += 1;
            max_risk = max_risk.max(0.70);
        }

        // ── 5. Excessive subdomains ──
        if subdomain_count >= 3 {
            indicators.push(format!("{} subdomains (suspicious depth)", subdomain_count));
            techniques.push(PhishingTechnique::ExcessiveSubdomains);
            max_risk = max_risk.max(0.55);
        }

        // ── 6. Structural patterns ──
        for &(pattern, risk, desc) in URL_STRUCTURAL_PATTERNS {
            if url_lower.contains(pattern) {
                structural_flags.push(format!("{}: {}", pattern, desc));
                techniques.push(PhishingTechnique::SuspiciousStructure);
                max_risk = max_risk.max(risk);
            }
        }
        if !structural_flags.is_empty() {
            indicators.push(format!("{} structural flags", structural_flags.len()));
            self.stats.write().structural_flags += 1;
        }

        // ── 7. Data URI ──
        if url_lower.starts_with("data:") {
            indicators.push("Data URI — inline phishing page".to_string());
            techniques.push(PhishingTechnique::DataURI);
            max_risk = max_risk.max(0.85);
        }

        // ── 8. Excessive URL length ──
        if url.len() > SUSPICIOUS_URL_LENGTH {
            indicators.push(format!("Suspicious URL length: {} chars", url.len()));
            techniques.push(PhishingTechnique::SuspiciousStructure);
            self.stats.write().excessive_length_urls += 1;
            max_risk = max_risk.max(0.45);
        }

        // ── 9. Credential harvesting indicators ──
        let cred_keywords = ["password", "passwd", "credential", "ssn", "credit-card", "cardnumber"];
        let cred_count = cred_keywords.iter().filter(|kw| url_lower.contains(*kw)).count();
        if cred_count >= 1 {
            indicators.push(format!("{} credential keywords in URL", cred_count));
            techniques.push(PhishingTechnique::CredentialHarvesting);
            mitre_techniques.push("T1056.003".to_string());
            max_risk = max_risk.max(0.75);
        }

        // ── 10. Free hosting detection ──
        let free_hosts = ["000webhostapp.com", "weebly.com", "wixsite.com", "blogspot.com",
            "wordpress.com", "sites.google.com", "firebaseapp.com", "netlify.app",
            "herokuapp.com", "glitch.me", "replit.dev", "vercel.app"];
        for host in &free_hosts {
            if domain.ends_with(host) {
                indicators.push(format!("Free hosting: {}", host));
                techniques.push(PhishingTechnique::FreeHosting);
                max_risk = max_risk.max(0.40);
                break;
            }
        }

        // ── Finalize ──
        techniques.sort();
        techniques.dedup();
        if !techniques.is_empty() && mitre_techniques.is_empty() {
            mitre_techniques.push("T1566.002".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let config = self.config.read().clone();
        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.55 + techniques.len() as f64 * 0.05
            + if impersonated_brand.is_some() { 0.10 } else { 0.0 }).min(0.99);
        let blocked = config.block_on_high && matches!(severity, Severity::Critical | Severity::High);

        if techniques.is_empty() { self.stats.write().safe_urls += 1; }
        else { self.stats.write().threats_detected += 1; }
        if blocked { self.stats.write().blocked_urls += 1; }

        // Breakthrough #627: SparseMatrix
        for t in &techniques {
            let c = *self.domain_technique_matrix.read()
                .get(&domain, &format!("{:?}", t));
            self.domain_technique_matrix.write()
                .set(domain.clone(), format!("{:?}", t), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let result = PhishingScanResult {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, url: url.to_string(), domain: domain.clone(),
            severity, confidence, techniques, impersonated_brand,
            edit_distance: edit_dist, homoglyph_chars,
            url_shortener: shortener, subdomain_count,
            has_ip_address: has_ip, structural_flags,
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(result.id.clone(), result.clone());
        self.recent_events.write().insert_with_priority(result.id.clone(), result.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.domain_technique_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record domain pattern diff
        self.domain_diffs.write().record_insert(
            result.id.clone(),
            format!("{}:{:?}:{}", domain, result.techniques, url),
        );
        // Breakthrough #592: DedupStore — deduplicate identical URL scans
        self.event_dedup.write().insert(
            result.id.clone(),
            format!("{}:{:?}", url, result.techniques).into_bytes(),
        );
        if blocked { warn!("PHISHING URL BLOCKED: {}", url); }
        result
    }

    /// Detect punycode / IDN homograph attacks
    fn detect_punycode(url: &str) -> Vec<(String, f64)> {
        let url_lower = url.to_lowercase();
        let mut hits = Vec::new();
        for &(pattern, risk, desc) in PUNYCODE_INDICATORS {
            if url_lower.contains(pattern) {
                hits.push((format!("{}: {}", pattern, desc), risk));
            }
        }
        hits
    }

    /// Detect redirect chain indicators
    fn detect_redirects(url: &str) -> Vec<(String, f64)> {
        let url_lower = url.to_lowercase();
        let mut hits = Vec::new();
        for &(pattern, risk, desc) in REDIRECT_INDICATORS {
            if url_lower.contains(pattern) {
                hits.push((format!("{}: {}", pattern, desc), risk));
            }
        }
        hits
    }

    /// Detect phishing kit paths in URL
    fn detect_phishing_kit_path(url: &str, domain: &str) -> Vec<(String, f64)> {
        let url_lower = url.to_lowercase();
        let mut hits = Vec::new();
        for &(path, risk, desc) in PHISHING_KIT_PATHS {
            if url_lower.contains(path) {
                // Adjust risk: brand-specific paths on non-brand domains are higher risk
                let adjusted_risk = if (path.contains("paypal") && !domain.contains("paypal"))
                    || (path.contains("microsoft") && !domain.contains("microsoft"))
                    || (path.contains("apple") && !domain.contains("apple")) {
                    (risk + 0.15).min(0.99)
                } else {
                    risk
                };
                hits.push((format!("{}: {}", path, desc), adjusted_risk));
            }
        }
        hits
    }

    /// Build a MalwareAlert from a PhishingScanResult
    fn build_alert(&self, result: &PhishingScanResult) -> MalwareAlert {
        MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: result.timestamp,
            severity: result.severity,
            module: "phishing_url_detector".to_string(),
            title: format!("Phishing URL: {}", result.domain),
            details: format!(
                "Detected {} phishing technique(s) for URL '{}' (domain: {}). \
                 Brand: {:?}. Edit distance: {:?}. Homoglyphs: {:?}. \
                 Subdomains: {}. Shortener: {:?}. IP-based: {}. \
                 Confidence: {:.0}%. {}",
                result.techniques.len(),
                result.url, result.domain,
                result.impersonated_brand,
                result.edit_distance,
                result.homoglyph_chars,
                result.subdomain_count,
                result.url_shortener,
                result.has_ip_address,
                result.confidence * 100.0,
                if result.blocked { "BLOCKED." } else { "" }
            ),
            path: None,
            process_name: None,
            process_pid: None,
            verdict: None,
            mitre_ids: result.mitre_techniques.clone(),
            remediation: vec![format!("Block URL: {}", result.url)],
            confidence: result.confidence,
        }
    }

    /// Extended scan that also checks punycode, redirects, phishing kit paths,
    /// and certificate indicators.
    pub fn scan_url_extended(
        &self, url: &str, cert_info: Option<&str>,
    ) -> PhishingScanResult {
        let mut result = self.scan_url(url);

        // Enrich with punycode detection
        let punycode_hits = Self::detect_punycode(url);
        for (desc, risk) in &punycode_hits {
            result.indicators.push(format!("Punycode: {}", desc));
            if !result.techniques.contains(&PhishingTechnique::Homoglyph) {
                result.techniques.push(PhishingTechnique::Homoglyph);
            }
        }

        // Enrich with redirect detection
        let redirect_hits = Self::detect_redirects(url);
        if !redirect_hits.is_empty() {
            self.stats.write().redirect_chains += 1;
            for (desc, _risk) in &redirect_hits {
                result.indicators.push(format!("Redirect: {}", desc));
            }
            if !result.techniques.contains(&PhishingTechnique::SuspiciousStructure) {
                result.techniques.push(PhishingTechnique::SuspiciousStructure);
            }
        }

        // Enrich with phishing kit path detection
        let kit_hits = Self::detect_phishing_kit_path(url, &result.domain);
        for (desc, risk) in &kit_hits {
            result.indicators.push(format!("Phishing kit path: {}", desc));
        }

        // Certificate info enrichment
        if let Some(cert) = cert_info {
            let cert_lower = cert.to_lowercase();
            for &(indicator, risk, desc) in CERT_INDICATORS {
                if cert_lower.contains(indicator) {
                    result.indicators.push(format!("Certificate: {}", desc));
                }
            }
        }

        // Build and queue alert if blocked
        if result.blocked || matches!(result.severity, Severity::Critical | Severity::High) {
            let alert = self.build_alert(&result);
            let mut alerts = self.alerts.write();
            if alerts.len() >= MAX_EVENTS_QUEUE { alerts.pop_front(); }
            alerts.push_back(alert);
        }

        result
    }

    /// Drain all pending alerts.
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        let mut alerts = self.alerts.write();
        alerts.drain(..).collect()
    }

    pub fn update_config(&self, config: PhishingConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> PhishingStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
