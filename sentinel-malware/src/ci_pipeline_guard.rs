//! Module 140: CIPipelineGuard — CI/CD Pipeline Security & Poisoning Detection
//!
//! Detects attacks targeting CI/CD pipelines including GitHub Actions abuse,
//! workflow injection, secret exfiltration, runner compromise, and build
//! artifact tampering on macOS-based CI runners.
//!
//! ## Detection Capabilities
//!
//! - **Workflow injection**: PR-based workflow_run exploitation, expression
//!   injection in github.event contexts, untrusted input in run: steps
//! - **Secret exfiltration**: Secrets printed to logs, exfiltrated via HTTP,
//!   encoded in artifacts, leaked via error messages
//! - **Runner compromise**: Self-hosted runner persistence, runner token theft,
//!   runner environment poisoning, tool cache manipulation
//! - **Artifact poisoning**: Build artifact replacement, cache poisoning,
//!   dependency cache manipulation
//! - **Action supply chain**: Typosquatted actions, pinned-to-branch actions
//!   (mutable), compromised third-party actions
//! - **Build reproducibility**: Non-deterministic builds, phantom dependencies
//! - **macOS runner specifics**: Keychain access on CI, provisioning profile
//!   theft, certificate extraction, Xcode version manipulation
//!
//! ## MITRE ATT&CK: T1195.002, T1059.004, T1552.001, T1553.002
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const WORKFLOW_INJECTION_PATTERNS: &[(&str, &str, f64)] = &[
    ("${{ github.event.issue.title }}", "Expression injection via issue title", 0.85),
    ("${{ github.event.issue.body }}", "Expression injection via issue body", 0.85),
    ("${{ github.event.pull_request.title }}", "Expression injection via PR title", 0.85),
    ("${{ github.event.pull_request.body }}", "Expression injection via PR body", 0.85),
    ("${{ github.event.comment.body }}", "Expression injection via comment", 0.85),
    ("${{ github.event.review.body }}", "Expression injection via review", 0.8),
    ("${{ github.event.head_commit.message }}", "Injection via commit message", 0.75),
    ("${{ github.event.head_commit.author.name }}", "Injection via author name", 0.8),
    ("${{ github.head_ref }}", "Injection via branch name", 0.7),
    ("workflow_run", "workflow_run trigger (cross-workflow execution)", 0.4),
    ("pull_request_target", "pull_request_target (runs in base repo context)", 0.6),
    ("issue_comment.*created", "Issue comment trigger (potential injection)", 0.4),
];

const SECRET_EXFIL_PATTERNS: &[(&str, &str, f64)] = &[
    ("echo.*${{ secrets.", "Secret printed to stdout/logs", 0.9),
    ("curl.*${{ secrets.", "Secret sent via HTTP", 0.95),
    ("wget.*${{ secrets.", "Secret downloaded/exfiltrated", 0.95),
    ("base64.*${{ secrets.", "Secret base64 encoded", 0.85),
    ("env.*SECRET", "Secret in environment variable (log risk)", 0.5),
    (">>.*$GITHUB_ENV.*secret", "Secret written to GITHUB_ENV", 0.8),
    (">>.*$GITHUB_OUTPUT.*secret", "Secret in step output", 0.7),
    ("::set-output.*secret", "Secret in set-output (deprecated)", 0.8),
    ("::add-mask", "Dynamic masking (may indicate secret handling)", 0.3),
    ("ACTIONS_RUNTIME_TOKEN", "Runner runtime token access", 0.7),
    ("ACTIONS_ID_TOKEN_REQUEST", "OIDC token request", 0.5),
    ("GITHUB_TOKEN", "GITHUB_TOKEN usage (verify scope)", 0.3),
];

const RUNNER_COMPROMISE_PATTERNS: &[(&str, &str, f64)] = &[
    ("LaunchAgents", "Persistence on macOS CI runner", 0.9),
    ("launchctl load", "LaunchAgent loading on runner", 0.85),
    ("crontab", "Cron job on CI runner", 0.8),
    (".bashrc", "Shell profile modification on runner", 0.7),
    (".zshrc", "Zsh profile modification on runner", 0.7),
    ("/etc/hosts", "Hosts file modification on runner", 0.7),
    ("~/.ssh/authorized_keys", "SSH key injection on runner", 0.85),
    ("security find-generic-password", "Keychain access on CI runner", 0.9),
    ("security dump-keychain", "Keychain dump on CI runner", 0.95),
    ("security unlock-keychain", "Keychain unlock on CI runner", 0.7),
    ("security import", "Certificate import on runner", 0.4),
    ("profiles install", "MDM profile install on runner", 0.8),
    ("xcode-select", "Xcode version switching", 0.3),
    ("RUNNER_TEMP", "Runner temp directory access", 0.2),
    ("_work/_temp", "Runner work temp access", 0.3),
    ("nc -l", "Netcat listener on runner", 0.9),
    ("/dev/tcp/", "Bash TCP on runner (reverse shell)", 0.95),
    ("nohup", "Background process on runner", 0.6),
];

const ACTION_SUPPLY_CHAIN_PATTERNS: &[(&str, &str, f64)] = &[
    ("uses: .*@master", "Action pinned to master (mutable)", 0.6),
    ("uses: .*@main", "Action pinned to main (mutable)", 0.6),
    ("uses: .*@latest", "Action pinned to latest (mutable)", 0.7),
    ("uses: .*@v[0-9]$", "Action pinned to major version only", 0.4),
    ("uses: docker://", "Docker action (supply chain risk)", 0.4),
    ("uses: ./", "Local action (verify source)", 0.2),
];

const MACOS_CI_THEFT_PATTERNS: &[(&str, &str, f64)] = &[
    ("MATCH_PASSWORD", "Fastlane match password access", 0.7),
    ("FASTLANE_PASSWORD", "Fastlane password variable", 0.7),
    ("APPLE_ID", "Apple ID credential", 0.5),
    ("APP_STORE_CONNECT_API_KEY", "App Store Connect API key", 0.7),
    ("PROVISIONING_PROFILE", "Provisioning profile data", 0.5),
    ("CERTIFICATE_PASSWORD", "Certificate password", 0.7),
    ("P12_PASSWORD", "P12 certificate password", 0.7),
    ("KEYCHAIN_PASSWORD", "CI keychain password", 0.6),
    ("codesign.*export", "Code signing certificate export", 0.7),
    ("security export -t identities", "Identity export from CI keychain", 0.85),
    ("mobileprovision", "Provisioning profile file access", 0.4),
    (".p12", "P12 certificate file access", 0.4),
    (".cer", "Certificate file access", 0.3),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum CIThreatType {
    WorkflowInjection,
    ExpressionInjection,
    SecretExfiltration,
    SecretLogLeak,
    RunnerPersistence,
    RunnerCompromise,
    KeychainTheftOnCI,
    CertificateTheft,
    ActionSupplyChain,
    MutableActionPin,
    ArtifactPoisoning,
    CachePoisoning,
    ProvisioningProfileTheft,
    TokenTheft,
    ReverseShellOnRunner,
    BuildReproducibility,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CIThreatFinding {
    pub threat_type: CIThreatType,
    pub confidence: f64,
    pub description: String,
    pub workflow_file: Option<String>,
    pub step_name: Option<String>,
    pub action_ref: Option<String>,
    pub secret_name: Option<String>,
    pub mitre_id: String,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CIPipelineEvent {
    pub event_type: String,
    pub workflow_file: Option<String>,
    pub workflow_content: Option<String>,
    pub step_name: Option<String>,
    pub run_command: Option<String>,
    pub action_ref: Option<String>,
    pub file_path: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub is_self_hosted_runner: bool,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CIAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<CIThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct CIScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub injection_detections: u64,
    pub secret_detections: u64,
    pub runner_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CISigEntry { pub pattern: String, pub description: String, pub severity: f64 }

pub struct CIPipelineGuard {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<CIScanStats>>,
    result_cache: TieredCache<String, CIAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, CIScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, CIAnalysisResult>>,
    sig_db: PagedMemory<CISigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<CIScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl CIPipelineGuard {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, CIScanStats::default(),
                |acc: &mut CIScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(CIScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &CIPipelineEvent) -> Option<CIAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("ci:{}:{}", event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        let analysis_text = format!("{} {} {}",
            event.workflow_content.as_deref().unwrap_or(""),
            event.run_command.as_deref().unwrap_or(""),
            event.action_ref.as_deref().unwrap_or(""));
        let text_lower = analysis_text.to_lowercase();

        // ── 1. Workflow injection ───────────────────────────────────────
        for &(pattern, desc, conf) in WORKFLOW_INJECTION_PATTERNS {
            if text_lower.contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("${{") { CIThreatType::ExpressionInjection }
                    else { CIThreatType::WorkflowInjection };
                findings.push(CIThreatFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    workflow_file: event.workflow_file.clone(), step_name: event.step_name.clone(),
                    action_ref: event.action_ref.clone(), secret_name: None,
                    mitre_id: "T1195.002".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1195.002".into());
            }
        }

        // ── 2. Secret exfiltration ──────────────────────────────────────
        for &(pattern, desc, conf) in SECRET_EXFIL_PATTERNS {
            if text_lower.contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("curl") || pattern.contains("wget") { CIThreatType::SecretExfiltration }
                    else if pattern.contains("echo") { CIThreatType::SecretLogLeak }
                    else if pattern.contains("TOKEN") { CIThreatType::TokenTheft }
                    else { CIThreatType::SecretExfiltration };
                findings.push(CIThreatFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    workflow_file: event.workflow_file.clone(), step_name: event.step_name.clone(),
                    action_ref: None, secret_name: None,
                    mitre_id: "T1552.001".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1552.001".into());
            }
        }

        // ── 3. Runner compromise ────────────────────────────────────────
        if let Some(ref cmd) = event.run_command {
            let cmd_lower = cmd.to_lowercase();
            for &(pattern, desc, conf) in RUNNER_COMPROMISE_PATTERNS {
                if cmd_lower.contains(&pattern.to_lowercase()) {
                    let adjusted = if event.is_self_hosted_runner { (conf + 0.1).min(0.99) } else { conf };
                    let tt = if pattern.contains("LaunchAgents") || pattern.contains("launchctl") || pattern.contains("crontab") {
                        CIThreatType::RunnerPersistence
                    } else if pattern.contains("keychain") || pattern.contains("security") {
                        CIThreatType::KeychainTheftOnCI
                    } else if pattern.contains("/dev/tcp") || pattern.contains("nc -l") {
                        CIThreatType::ReverseShellOnRunner
                    } else { CIThreatType::RunnerCompromise };
                    findings.push(CIThreatFinding {
                        threat_type: tt, confidence: adjusted, description: desc.to_string(),
                        workflow_file: event.workflow_file.clone(), step_name: event.step_name.clone(),
                        action_ref: None, secret_name: None,
                        mitre_id: "T1059.004".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1059.004".into());
                }
            }

            // macOS CI-specific theft
            for &(pattern, desc, conf) in MACOS_CI_THEFT_PATTERNS {
                if cmd_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("codesign") || pattern.contains("security export") || pattern.contains("p12") || pattern.contains("cer") {
                        CIThreatType::CertificateTheft
                    } else if pattern.contains("mobileprovision") || pattern.contains("PROVISIONING") {
                        CIThreatType::ProvisioningProfileTheft
                    } else { CIThreatType::KeychainTheftOnCI };
                    findings.push(CIThreatFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        workflow_file: event.workflow_file.clone(), step_name: event.step_name.clone(),
                        action_ref: None, secret_name: None,
                        mitre_id: "T1553.002".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1553.002".into());
                }
            }
        }

        // ── 4. Action supply chain ──────────────────────────────────────
        if let Some(ref action) = event.action_ref {
            for &(pattern, desc, conf) in ACTION_SUPPLY_CHAIN_PATTERNS {
                let check = pattern.replace(".*", "");
                if action.to_lowercase().contains(&check.to_lowercase()) {
                    findings.push(CIThreatFinding {
                        threat_type: if pattern.contains("master") || pattern.contains("main") || pattern.contains("latest") {
                            CIThreatType::MutableActionPin
                        } else { CIThreatType::ActionSupplyChain },
                        confidence: conf, description: format!("{}: {}", desc, action),
                        workflow_file: event.workflow_file.clone(), step_name: event.step_name.clone(),
                        action_ref: Some(action.clone()), secret_name: None,
                        mitre_id: "T1195.002".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1195.002".into());
                }
            }
        }

        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},wf={:?},findings={}", event.event_type, event.workflow_file, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = CIAnalysisResult {
            is_malicious, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_malicious { s.malicious_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "ci_pipeline_guard".into(),
                title: format!("CI/CD threat: {:?}", event.workflow_file),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Pin actions to full SHA hashes".into(),
                    "Never use untrusted input in run: steps".into(),
                    "Use CODEOWNERS for .github/workflows/".into(),
                    "Rotate all secrets if exfiltration detected".into(),
                    "Use ephemeral runners, not persistent self-hosted".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[CIThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                CIThreatType::SecretExfiltration => 1.6,
                CIThreatType::ReverseShellOnRunner => 1.5,
                CIThreatType::KeychainTheftOnCI => 1.5,
                CIThreatType::RunnerPersistence => 1.4,
                CIThreatType::ExpressionInjection => 1.3,
                CIThreatType::CertificateTheft => 1.3,
                CIThreatType::TokenTheft => 1.2,
                CIThreatType::RunnerCompromise => 1.2,
                CIThreatType::MutableActionPin => 0.8,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> CIScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
