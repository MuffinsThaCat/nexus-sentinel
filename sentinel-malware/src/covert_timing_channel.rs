//! Module 122: CovertTimingChannel — Network Timing-Based Covert Channel Detection
//!
//! Detects covert channels that encode data in packet inter-arrival times,
//! TCP sequence numbers, IP TTL fields, and other protocol timing/header
//! manipulations. These channels are extremely stealthy and bypass content
//! inspection entirely.
//!
//! ## Detection Capabilities
//!
//! - **Inter-packet timing**: Data encoded in delays between packets
//!   (JitterBug, Cloak, TimeRelay patterns)
//! - **TCP sequence number encoding**: Data hidden in ISN/sequence deltas
//! - **IP TTL manipulation**: Data encoded in TTL field values
//! - **TCP timestamp manipulation**: Data in TCP timestamp options
//! - **Packet size modulation**: Binary data encoded in packet lengths
//! - **Protocol field abuse**: Unused/reserved header bits carrying data
//! - **HTTP header timing**: Data in request timing patterns
//! - **TLS record timing**: Encrypted channel timing anomalies
//! - **Statistical detection**: Kolmogorov-Smirnov, chi-squared, entropy
//!   tests on timing distributions
//! - **Known tool detection**: Covert_TCP, Ncovert, SteganRTP, TimingChannel
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const MIN_PACKETS_FOR_ANALYSIS: usize = 50;
const TIMING_REGULARITY_THRESHOLD: f64 = 0.15;
const BIMODAL_SEPARATION_THRESHOLD: f64 = 2.0;
const TTL_DEVIATION_THRESHOLD: u8 = 3;
const SEQ_ANOMALY_THRESHOLD: f64 = 0.3;

const TIMING_CHANNEL_TOOLS: &[(&str, &str, f64)] = &[
    ("covert_tcp", "Covert_TCP — TCP header data hiding", 0.95),
    ("ncovert", "Ncovert — network covert channel", 0.9),
    ("steganrtp", "SteganRTP — RTP timing channel", 0.9),
    ("timingchannel", "TimingChannel — IPD-based channel", 0.9),
    ("jitterbug", "JitterBug — keyboard timing channel", 0.85),
    ("cloak", "Cloak — timing-based covert channel", 0.85),
    ("covertutils", "CovertUtils — Python covert channel lib", 0.9),
    ("ptunnel", "Protocol tunnel via timing", 0.8),
    ("tunna", "Tunna — HTTP timing tunnel", 0.85),
    ("regeorg", "ReGeorg — HTTP tunnel timing", 0.8),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TimingThreatType {
    InterPacketTimingChannel,
    BimodalTimingDistribution,
    SequenceNumberEncoding,
    TTLManipulation,
    TimestampManipulation,
    PacketSizeModulation,
    ReservedBitAbuse,
    HTTPTimingChannel,
    TLSTimingAnomaly,
    StatisticalAnomaly,
    ToolSignature,
    RegularIntervalBeacon,
    QuantizedTiming,
    EntropyAnomaly,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimingThreatFinding {
    pub threat_type: TimingThreatType,
    pub source_ip: String,
    pub dest_ip: String,
    pub protocol: String,
    pub confidence: f64,
    pub description: String,
    pub statistical_evidence: String,
    pub estimated_bandwidth_bps: f64,
    pub tool_name: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NetworkPacketInfo {
    pub source_ip: String,
    pub dest_ip: String,
    pub source_port: u16,
    pub dest_port: u16,
    pub protocol: String,
    pub size: usize,
    pub ttl: u8,
    pub tcp_seq: Option<u32>,
    pub tcp_timestamp: Option<u32>,
    pub flags: u8,
    pub arrival_time_us: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimingAnalysisResult {
    pub is_covert: bool,
    pub packets_analyzed: u32,
    pub findings: Vec<TimingThreatFinding>,
    pub detected_channels: Vec<(String, String)>,
    pub estimated_bandwidth_bps: f64,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TimingScanStats {
    pub total_packets: u64,
    pub flows_analyzed: u64,
    pub timing_detections: u64,
    pub header_detections: u64,
    pub tool_detections: u64,
    pub estimated_covert_bps: f64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimingDetectorConfig {
    pub enabled: bool,
    pub min_packets: usize,
    pub timing_regularity_threshold: f64,
    pub bimodal_threshold: f64,
    pub ttl_deviation_threshold: u8,
    pub detect_timing: bool,
    pub detect_header: bool,
    pub detect_statistical: bool,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for TimingDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            min_packets: MIN_PACKETS_FOR_ANALYSIS,
            timing_regularity_threshold: TIMING_REGULARITY_THRESHOLD,
            bimodal_threshold: BIMODAL_SEPARATION_THRESHOLD,
            ttl_deviation_threshold: TTL_DEVIATION_THRESHOLD,
            detect_timing: true,
            detect_header: true,
            detect_statistical: true,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimingToolSig {
    pub name: String,
    pub pattern: String,
    pub severity: f64,
}

#[derive(Debug, Clone, Default)]
struct FlowTimingData {
    arrival_times: Vec<u64>,
    packet_sizes: Vec<usize>,
    ttl_values: Vec<u8>,
    seq_numbers: Vec<u32>,
    tcp_timestamps: Vec<u32>,
    first_seen: u64,
    last_seen: u64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct CovertTimingChannelDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<TimingScanStats>>,
    result_cache: TieredCache<String, TimingAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    flow_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, TimingScanStats>>,
    metrics: MemoryMetrics,
    flow_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, TimingAnalysisResult>>,
    tool_sig_db: PagedMemory<TimingToolSig>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<TimingDetectorConfig>,
    stats: RwLock<TimingScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_packets: AtomicU64,
    flow_data: RwLock<HashMap<String, FlowTimingData>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl CovertTimingChannelDetector {
    pub fn new() -> Self {
        let cfg = TimingDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            flow_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, TimingScanStats::default(),
                |acc: &mut TimingScanStats, vals: &[f64]| { acc.total_packets += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            flow_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            tool_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(TimingScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_packets: AtomicU64::new(0),
            flow_data: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn ingest_packet(&self, pkt: &NetworkPacketInfo) {
        if !self.running.load(Ordering::SeqCst) { return; }
        self.total_packets.fetch_add(1, Ordering::Relaxed);

        let flow_key = format!("{}:{}→{}:{}", pkt.source_ip, pkt.source_port, pkt.dest_ip, pkt.dest_port);
        let mut flows = self.flow_data.write();
        let flow = flows.entry(flow_key).or_default();
        flow.arrival_times.push(pkt.arrival_time_us);
        flow.packet_sizes.push(pkt.size);
        flow.ttl_values.push(pkt.ttl);
        if let Some(seq) = pkt.tcp_seq { flow.seq_numbers.push(seq); }
        if let Some(ts) = pkt.tcp_timestamp { flow.tcp_timestamps.push(ts); }
        if flow.first_seen == 0 { flow.first_seen = pkt.arrival_time_us; }
        flow.last_seen = pkt.arrival_time_us;

        // Bounded storage
        if flow.arrival_times.len() > 2000 {
            flow.arrival_times.drain(..1000);
            flow.packet_sizes.drain(..1000);
            flow.ttl_values.drain(..1000);
            if flow.seq_numbers.len() > 1000 { flow.seq_numbers.drain(..500); }
            if flow.tcp_timestamps.len() > 1000 { flow.tcp_timestamps.drain(..500); }
        }
    }

    pub fn analyze_flow(&self, source_ip: &str, source_port: u16, dest_ip: &str, dest_port: u16) -> Option<TimingAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();

        let flow_key = format!("{}:{}→{}:{}", source_ip, source_port, dest_ip, dest_port);

        let flow_snapshot = {
            let flows = self.flow_data.read();
            flows.get(&flow_key).cloned()
        };
        let flow = flow_snapshot?;
        if flow.arrival_times.len() < cfg.min_packets { return None; }

        self.scan_history.write().checkpoint(self.stats.read().clone());

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut est_bw = 0.0f64;

        // Inter-packet delay analysis
        if cfg.detect_timing {
            let ipds: Vec<f64> = flow.arrival_times.windows(2)
                .map(|w| (w[1] as f64 - w[0] as f64))
                .collect();

            if !ipds.is_empty() {
                let mean = ipds.iter().sum::<f64>() / ipds.len() as f64;
                let variance = ipds.iter().map(|&d| (d - mean).powi(2)).sum::<f64>() / ipds.len() as f64;
                let std_dev = variance.sqrt();
                let cv = if mean > 0.0 { std_dev / mean } else { 1.0 };

                // Check for quantized timing (data encoded in discrete delay levels)
                let unique_delays = Self::count_clusters(&ipds, mean * 0.05);
                if unique_delays >= 2 && unique_delays <= 8 && cv < 0.5 {
                    findings.push(TimingThreatFinding {
                        threat_type: TimingThreatType::QuantizedTiming,
                        source_ip: source_ip.into(), dest_ip: dest_ip.into(),
                        protocol: "TCP".into(),
                        confidence: (0.6 + (1.0 - cv) * 0.3).min(0.9),
                        description: format!("{} discrete timing levels (CV={:.3})", unique_delays, cv),
                        statistical_evidence: format!("mean={:.1}us, std={:.1}us, clusters={}", mean, std_dev, unique_delays),
                        estimated_bandwidth_bps: unique_delays as f64 * ipds.len() as f64 / ((flow.last_seen - flow.first_seen) as f64 / 1_000_000.0),
                        tool_name: None, mitre_id: "T1001.003".into(), timestamp: flow.last_seen,
                    });
                    mitre_ids.insert("T1001.003".into());
                }

                // Check for bimodal distribution (binary encoding: short delay = 0, long = 1)
                if let Some((low_mean, high_mean, separation)) = Self::detect_bimodal(&ipds) {
                    if separation > cfg.bimodal_threshold {
                        est_bw = ipds.len() as f64 / ((flow.last_seen - flow.first_seen) as f64 / 1_000_000.0);
                        findings.push(TimingThreatFinding {
                            threat_type: TimingThreatType::BimodalTimingDistribution,
                            source_ip: source_ip.into(), dest_ip: dest_ip.into(),
                            protocol: "TCP".into(),
                            confidence: (0.6 + (separation - cfg.bimodal_threshold) * 0.1).min(0.95),
                            description: format!("Bimodal IPD: low={:.0}us, high={:.0}us (sep={:.2}σ)", low_mean, high_mean, separation),
                            statistical_evidence: format!("separation={:.2}σ, n={}", separation, ipds.len()),
                            estimated_bandwidth_bps: est_bw,
                            tool_name: None, mitre_id: "T1001.003".into(), timestamp: flow.last_seen,
                        });
                        mitre_ids.insert("T1001.003".into());
                    }
                }

                // Regular beacon detection
                if cv < cfg.timing_regularity_threshold && ipds.len() > 20 {
                    findings.push(TimingThreatFinding {
                        threat_type: TimingThreatType::RegularIntervalBeacon,
                        source_ip: source_ip.into(), dest_ip: dest_ip.into(),
                        protocol: "TCP".into(),
                        confidence: (0.5 + (cfg.timing_regularity_threshold - cv) * 2.0).min(0.9),
                        description: format!("Regular interval: {:.1}us ± {:.1}us (CV={:.4})", mean, std_dev, cv),
                        statistical_evidence: format!("CV={:.4}, n={}", cv, ipds.len()),
                        estimated_bandwidth_bps: 0.0,
                        tool_name: None, mitre_id: "T1071".into(), timestamp: flow.last_seen,
                    });
                    mitre_ids.insert("T1071".into());
                }
            }
        }

        // Header manipulation checks
        if cfg.detect_header {
            // TTL analysis
            if flow.ttl_values.len() >= cfg.min_packets {
                let ttl_mode = Self::mode(&flow.ttl_values);
                let deviations = flow.ttl_values.iter()
                    .filter(|&&t| (t as i16 - ttl_mode as i16).unsigned_abs() as u8 > cfg.ttl_deviation_threshold)
                    .count();
                let dev_ratio = deviations as f64 / flow.ttl_values.len() as f64;
                if dev_ratio > 0.1 && dev_ratio < 0.6 {
                    findings.push(TimingThreatFinding {
                        threat_type: TimingThreatType::TTLManipulation,
                        source_ip: source_ip.into(), dest_ip: dest_ip.into(),
                        protocol: "IP".into(),
                        confidence: (0.5 + dev_ratio * 0.5).min(0.85),
                        description: format!("{:.1}% TTL deviations from mode {} (threshold: ±{})",
                            dev_ratio * 100.0, ttl_mode, cfg.ttl_deviation_threshold),
                        statistical_evidence: format!("mode={}, deviations={}/{}", ttl_mode, deviations, flow.ttl_values.len()),
                        estimated_bandwidth_bps: deviations as f64 * 3.0 / ((flow.last_seen - flow.first_seen) as f64 / 1_000_000.0),
                        tool_name: None, mitre_id: "T1001.003".into(), timestamp: flow.last_seen,
                    });
                    mitre_ids.insert("T1001.003".into());
                }
            }

            // Packet size modulation
            if flow.packet_sizes.len() >= cfg.min_packets {
                let unique_sizes: HashSet<usize> = flow.packet_sizes.iter().cloned().collect();
                if unique_sizes.len() >= 2 && unique_sizes.len() <= 16 {
                    let size_entropy = Self::discrete_entropy(&flow.packet_sizes);
                    if size_entropy > 0.5 && size_entropy < 3.5 {
                        findings.push(TimingThreatFinding {
                            threat_type: TimingThreatType::PacketSizeModulation,
                            source_ip: source_ip.into(), dest_ip: dest_ip.into(),
                            protocol: "TCP".into(),
                            confidence: (0.4 + size_entropy * 0.1).min(0.8),
                            description: format!("{} distinct sizes, entropy={:.2} bits", unique_sizes.len(), size_entropy),
                            statistical_evidence: format!("sizes={:?}, H={:.2}", unique_sizes, size_entropy),
                            estimated_bandwidth_bps: (size_entropy * flow.packet_sizes.len() as f64) / ((flow.last_seen - flow.first_seen) as f64 / 1_000_000.0),
                            tool_name: None, mitre_id: "T1001.003".into(), timestamp: flow.last_seen,
                        });
                        mitre_ids.insert("T1001.003".into());
                    }
                }
            }

            // TCP sequence number analysis
            if flow.seq_numbers.len() >= cfg.min_packets {
                let seq_deltas: Vec<f64> = flow.seq_numbers.windows(2)
                    .map(|w| (w[1] as f64 - w[0] as f64).abs())
                    .collect();
                if !seq_deltas.is_empty() {
                    let mean_delta = seq_deltas.iter().sum::<f64>() / seq_deltas.len() as f64;
                    let entropy = Self::continuous_entropy(&seq_deltas);
                    // Unusually structured sequence deltas may indicate encoding
                    if entropy < 2.0 && mean_delta > 0.0 {
                        findings.push(TimingThreatFinding {
                            threat_type: TimingThreatType::SequenceNumberEncoding,
                            source_ip: source_ip.into(), dest_ip: dest_ip.into(),
                            protocol: "TCP".into(),
                            confidence: (0.4 + (2.0 - entropy) * 0.2).min(0.8),
                            description: format!("Structured TCP seq deltas (H={:.2}, mean={:.0})", entropy, mean_delta),
                            statistical_evidence: format!("entropy={:.2}, mean_delta={:.0}, n={}", entropy, mean_delta, seq_deltas.len()),
                            estimated_bandwidth_bps: 0.0,
                            tool_name: None, mitre_id: "T1001.003".into(), timestamp: flow.last_seen,
                        });
                        mitre_ids.insert("T1001.003".into());
                    }
                }
            }
        }

        self.flow_diffs.write().record_insert(
            flow_key.clone(),
            format!("pkts={},dur={}us", flow.arrival_times.len(), flow.last_seen - flow.first_seen),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_covert = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let detected_channels = if is_covert {
            vec![(source_ip.to_string(), dest_ip.to_string())]
        } else { Vec::new() };

        let result = TimingAnalysisResult {
            is_covert,
            packets_analyzed: flow.arrival_times.len() as u32,
            findings,
            detected_channels,
            estimated_bandwidth_bps: est_bw,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(flow_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(flow_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &flow_key);
                m.set(k, flow_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(flow_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.flows_analyzed += 1;
            if is_covert { stats.timing_detections += 1; }
            let n = stats.flows_analyzed as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_covert {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "covert_timing_channel".into(),
                title: format!("Covert timing channel: {} → {}", source_ip, dest_ip),
                details: format!("Risk: {:.1}%, {} findings, ~{:.1} bps bandwidth",
                    risk_score * 100.0, result.findings.len(), est_bw),
                path: None,
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Add random jitter to outbound traffic".into(),
                    "Normalize packet timing at egress".into(),
                    "Monitor flow statistical properties".into(),
                    "Implement traffic shaping".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn count_clusters(values: &[f64], tolerance: f64) -> usize {
        if values.is_empty() { return 0; }
        let mut sorted: Vec<f64> = values.to_vec();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        let mut clusters = 1usize;
        let mut last_center = sorted[0];
        for &v in &sorted[1..] {
            if (v - last_center).abs() > tolerance {
                clusters += 1;
                last_center = v;
            }
        }
        clusters
    }

    fn detect_bimodal(values: &[f64]) -> Option<(f64, f64, f64)> {
        if values.len() < 20 { return None; }
        let mean = values.iter().sum::<f64>() / values.len() as f64;
        let low: Vec<f64> = values.iter().filter(|&&v| v < mean).cloned().collect();
        let high: Vec<f64> = values.iter().filter(|&&v| v >= mean).cloned().collect();
        if low.len() < 5 || high.len() < 5 { return None; }
        let low_mean = low.iter().sum::<f64>() / low.len() as f64;
        let high_mean = high.iter().sum::<f64>() / high.len() as f64;
        let overall_std = (values.iter().map(|v| (v - mean).powi(2)).sum::<f64>() / values.len() as f64).sqrt();
        if overall_std > 0.0 {
            Some((low_mean, high_mean, (high_mean - low_mean) / overall_std))
        } else { None }
    }

    fn mode(values: &[u8]) -> u8 {
        let mut freq = [0u32; 256];
        for &v in values { freq[v as usize] += 1; }
        freq.iter().enumerate().max_by_key(|(_, &c)| c).map(|(i, _)| i as u8).unwrap_or(0)
    }

    fn discrete_entropy(values: &[usize]) -> f64 {
        if values.is_empty() { return 0.0; }
        let mut freq: HashMap<usize, u32> = HashMap::new();
        for &v in values { *freq.entry(v).or_insert(0) += 1; }
        let len = values.len() as f64;
        freq.values().map(|&c| {
            let p = c as f64 / len;
            -p * p.log2()
        }).sum()
    }

    fn continuous_entropy(values: &[f64]) -> f64 {
        if values.is_empty() { return 0.0; }
        // Discretize into 16 bins
        let min = values.iter().cloned().fold(f64::INFINITY, f64::min);
        let max = values.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
        if (max - min).abs() < 1e-10 { return 0.0; }
        let bins = 16usize;
        let bin_width = (max - min) / bins as f64;
        let mut counts = vec![0u32; bins];
        for &v in values {
            let bin = ((v - min) / bin_width).floor() as usize;
            counts[bin.min(bins - 1)] += 1;
        }
        let len = values.len() as f64;
        counts.iter().filter(|&&c| c > 0).map(|&c| {
            let p = c as f64 / len;
            -p * p.log2()
        }).sum()
    }

    fn calculate_risk_score(&self, findings: &[TimingThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                TimingThreatType::ToolSignature => 1.5,
                TimingThreatType::BimodalTimingDistribution => 1.4,
                TimingThreatType::SequenceNumberEncoding => 1.3,
                TimingThreatType::QuantizedTiming => 1.3,
                TimingThreatType::TTLManipulation => 1.2,
                TimingThreatType::PacketSizeModulation => 1.1,
                TimingThreatType::RegularIntervalBeacon => 1.0,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> TimingScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
