//! Module 131: LoginPersistenceAuditor — macOS Persistence Mechanism Detection
//!
//! Comprehensive detection of all known macOS persistence mechanisms. This
//! module monitors, audits, and alerts on unauthorized persistence installations
//! across every vector available on macOS — from LaunchAgents to kernel extensions.
//!
//! ## Detection Capabilities
//!
//! ### Launch Services Persistence
//! - **LaunchAgents** (user & system): ~/Library/LaunchAgents, /Library/LaunchAgents
//! - **LaunchDaemons** (system): /Library/LaunchDaemons
//! - **Login Items**: SMLoginItemSetEnabled, LSSharedFileListInsertItemURL,
//!   BackgroundTaskManagementAgent (BTM), ServiceManagement framework
//! - **Login/Logout Hooks**: defaults write loginwindow LoginHook/LogoutHook
//!
//! ### Scheduled Tasks
//! - **Cron jobs**: /var/at/tabs/, crontab -l, /etc/crontab
//! - **At jobs**: atq, at scheduling
//! - **Periodic tasks**: /etc/periodic/daily|weekly|monthly
//! - **Calendar alarms**: EventKit-based persistence
//!
//! ### Application-Level Persistence
//! - **Folder Actions**: ~/Library/Workflows/Applications/Folder Actions/
//! - **Automator workflows**: .workflow bundles in launch paths
//! - **Spotlight importers**: mdimporter bundles
//! - **Quick Look generators**: qlgenerator bundles
//! - **Authorization plugins**: /Library/Security/SecurityAgentPlugins/
//! - **Directory Services plugins**: /Library/DirectoryServices/PlugIns/
//! - **Input methods**: ~/Library/Input Methods/
//! - **Screen savers**: ~/Library/Screen Savers/ (code execution vector)
//!
//! ### System-Level Persistence
//! - **Kernel extensions** (KEXTs): /Library/Extensions/, /System/Library/Extensions/
//! - **System extensions**: SystemExtensions framework
//! - **Network extensions**: NEProvider, content filters
//! - **Endpoint Security clients**: ES framework system extensions
//! - **Configuration profiles**: MDM profiles with persistence payloads
//! - **rc.common / rc.local**: Legacy boot scripts
//! - **emond rules**: /etc/emond.d/ event monitor persistence
//! - **XPC services**: /Library/PrivilegedHelperTools/
//!
//! ### Shell & Environment Persistence
//! - **Shell profiles**: .bashrc, .zshrc, .bash_profile, .zprofile, .profile
//! - **Environment variables**: ~/.MacOSX/environment.plist, launchctl setenv
//! - **SSH authorized_keys**: ~/.ssh/authorized_keys modifications
//! - **Sudoers**: /etc/sudoers, /etc/sudoers.d/ modifications
//!
//! ### Browser & App Persistence
//! - **Browser extensions**: Safari, Chrome, Firefox extension installations
//! - **Dock persistence**: com.apple.dock.plist manipulation
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1543.001 — Launch Agent
//! - T1543.004 — Launch Daemon
//! - T1547.001 — Registry Run Keys / Startup Folder
//! - T1547.006 — Kernel Modules and Extensions
//! - T1547.009 — Shortcut Modification
//! - T1547.015 — Login Items
//! - T1053.003 — Cron
//! - T1546.015 — Folder Actions
//! - T1037.002 — Login Hook
//! - T1037.005 — Startup Items
//! - T1176 — Browser Extensions
//! - T1556.003 — Pluggable Authentication Modules
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

// ── Persistence Locations ────────────────────────────────────────────────────

const LAUNCH_AGENT_DIRS: &[(&str, &str, f64)] = &[
    ("~/Library/LaunchAgents/", "User LaunchAgent", 0.6),
    ("/Library/LaunchAgents/", "System LaunchAgent", 0.7),
    ("/System/Library/LaunchAgents/", "Apple LaunchAgent (SIP protected)", 0.9),
];

const LAUNCH_DAEMON_DIRS: &[(&str, &str, f64)] = &[
    ("/Library/LaunchDaemons/", "System LaunchDaemon (root)", 0.7),
    ("/System/Library/LaunchDaemons/", "Apple LaunchDaemon (SIP protected)", 0.9),
];

const SHELL_PROFILE_PATHS: &[(&str, &str, f64)] = &[
    ("~/.bashrc", "Bash RC", 0.5),
    ("~/.bash_profile", "Bash profile", 0.5),
    ("~/.zshrc", "Zsh RC", 0.5),
    ("~/.zprofile", "Zsh profile", 0.5),
    ("~/.profile", "Shell profile", 0.5),
    ("~/.zshenv", "Zsh environment (runs for ALL zsh)", 0.6),
    ("/etc/zshrc", "System Zsh RC (all users)", 0.8),
    ("/etc/profile", "System shell profile (all users)", 0.8),
    ("/etc/bashrc", "System Bash RC (all users)", 0.75),
    ("/etc/paths", "System PATH file", 0.7),
    ("/etc/paths.d/", "System PATH directory", 0.7),
];

const CRON_PATHS: &[(&str, &str, f64)] = &[
    ("/var/at/tabs/", "User crontab directory", 0.7),
    ("/etc/crontab", "System crontab", 0.8),
    ("/usr/lib/cron/tabs/", "Legacy crontab location", 0.7),
];

const PERIODIC_DIRS: &[(&str, &str, f64)] = &[
    ("/etc/periodic/daily/", "Daily periodic task", 0.7),
    ("/etc/periodic/weekly/", "Weekly periodic task", 0.7),
    ("/etc/periodic/monthly/", "Monthly periodic task", 0.7),
];

const SYSTEM_PERSISTENCE_PATHS: &[(&str, &str, &str, f64)] = &[
    ("/Library/Extensions/", "Kernel extension (KEXT)", "T1547.006", 0.8),
    ("/System/Library/Extensions/", "System KEXT (SIP)", "T1547.006", 0.95),
    ("/Library/Security/SecurityAgentPlugins/", "Authorization plugin", "T1556.003", 0.85),
    ("/Library/DirectoryServices/PlugIns/", "Directory Services plugin", "T1556", 0.8),
    ("/Library/PrivilegedHelperTools/", "Privileged helper tool (XPC)", "T1543", 0.6),
    ("/etc/emond.d/rules/", "Emond rule (event monitor)", "T1546", 0.85),
    ("/etc/rc.common", "RC common boot script (legacy)", "T1037.005", 0.8),
    ("/etc/rc.local", "RC local boot script (legacy)", "T1037.005", 0.8),
    ("~/Library/Input Methods/", "Input method bundle", "T1546", 0.7),
    ("~/Library/Screen Savers/", "Screen saver bundle (code exec)", "T1546", 0.65),
    ("~/Library/Spotlight/", "Spotlight importer plugin", "T1546", 0.6),
    ("~/Library/QuickLook/", "Quick Look generator plugin", "T1546", 0.6),
    ("/Library/StartupItems/", "Startup item (legacy)", "T1037.005", 0.8),
    ("~/Library/Workflows/Applications/Folder Actions/", "Folder Action workflow", "T1546.015", 0.75),
    ("/Library/ScriptingAdditions/", "Scripting addition (osax)", "T1546", 0.8),
    ("~/.ssh/authorized_keys", "SSH authorized keys", "T1098.004", 0.65),
    ("/etc/sudoers.d/", "Sudoers modification", "T1548.003", 0.85),
    ("~/.MacOSX/environment.plist", "Environment variables plist", "T1574.007", 0.6),
];

// ── Suspicious Plist Keys ────────────────────────────────────────────────────

const SUSPICIOUS_PLIST_PROPERTIES: &[(&str, &str, f64)] = &[
    ("RunAtLoad", "Runs at system/user load (persistence)", 0.4),
    ("KeepAlive", "Restarts if killed (resilient persistence)", 0.5),
    ("StartOnMount", "Runs on volume mount (trigger-based)", 0.6),
    ("WatchPaths", "Watches file paths (trigger-based)", 0.5),
    ("StartCalendarInterval", "Calendar-based scheduling", 0.4),
    ("QueueDirectories", "Queue directory watcher", 0.5),
    ("StartInterval", "Interval-based execution", 0.4),
    ("LimitLoadToSessionType", "Session type restriction", 0.3),
    ("MachServices", "Mach service registration", 0.3),
    ("Sockets", "Socket listener (network service)", 0.5),
    ("AssociatedBundleIdentifiers", "Associated bundle IDs", 0.3),
    ("ProcessType", "Process type specification", 0.2),
];

// ── Command-Line Persistence Techniques ──────────────────────────────────────

const PERSISTENCE_COMMANDS: &[(&str, &str, &str, f64)] = &[
    ("launchctl load", "Load LaunchAgent/Daemon", "T1543.001", 0.7),
    ("launchctl bootstrap", "Bootstrap launch service", "T1543.001", 0.7),
    ("launchctl enable", "Enable launch service", "T1543.001", 0.6),
    ("launchctl submit", "Submit launch job", "T1543.001", 0.7),
    ("defaults write loginwindow LoginHook", "Install login hook", "T1037.002", 0.9),
    ("defaults write loginwindow LogoutHook", "Install logout hook", "T1037.002", 0.85),
    ("defaults write loginwindow AutoLaunchedApplicationDictionary", "Auto-launch app", "T1547.015", 0.8),
    ("osascript.*login item", "AppleScript login item", "T1547.015", 0.7),
    ("osascript.*make new login item", "Create login item via AS", "T1547.015", 0.8),
    ("crontab -", "Install cron job", "T1053.003", 0.7),
    ("crontab -l", "List cron jobs (recon before install)", "T1053.003", 0.3),
    ("at ", "Schedule at job", "T1053.003", 0.6),
    ("kextload", "Load kernel extension", "T1547.006", 0.85),
    ("kmutil load", "Load kernel module", "T1547.006", 0.85),
    ("systemextensionsctl install", "Install system extension", "T1547.006", 0.5),
    ("profiles install", "Install configuration profile", "T1176", 0.6),
    ("profiles -I", "Install profile via flag", "T1176", 0.65),
    ("ditto.*LaunchAgents", "Copy to LaunchAgents dir", "T1543.001", 0.8),
    ("cp.*LaunchAgents", "Copy to LaunchAgents dir", "T1543.001", 0.8),
    ("mv.*LaunchAgents", "Move to LaunchAgents dir", "T1543.001", 0.8),
    ("ditto.*LaunchDaemons", "Copy to LaunchDaemons dir", "T1543.004", 0.85),
    ("cp.*LaunchDaemons", "Copy to LaunchDaemons dir", "T1543.004", 0.85),
    ("chmod +x.*LaunchAgents", "Make LaunchAgent executable", "T1543.001", 0.7),
    ("plutil.*LaunchAgents", "Modify LaunchAgent plist", "T1543.001", 0.6),
    ("PlistBuddy.*LaunchAgents", "PlistBuddy LaunchAgent edit", "T1543.001", 0.65),
    ("PlistBuddy.*RunAtLoad", "Set RunAtLoad property", "T1543.001", 0.75),
    ("sqlite3.*backgrounditems.btm", "BTM database manipulation", "T1547.015", 0.85),
    ("sfltool add-item", "Add login item via sfltool", "T1547.015", 0.75),
    ("lsregister", "LaunchServices database manipulation", "T1547.015", 0.5),
];

// ── Known Malware Persistence Identifiers ────────────────────────────────────

const MALWARE_PERSISTENCE_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("com.apple.SafariHelper", "Fake Safari helper (adware)", "Adload", 0.9),
    ("com.apple.systemmond", "Fake system monitor (backdoor)", "Generic Backdoor", 0.9),
    ("com.google.keystone", "Real Google updater (but commonly spoofed)", "Potential Spoof", 0.3),
    ("com.adobe.fpsaud", "Adobe Flash updater (discontinued — malware)", "Shlayer", 0.95),
    ("com.apple.preferences.timezone", "Fake timezone pref (backdoor)", "Generic Backdoor", 0.85),
    ("com.startup.plist", "Generic startup plist (suspicious)", "Generic Malware", 0.7),
    ("com.UserAgent.System", "Fake UserAgent (cryptominer)", "OSAMiner", 0.9),
    ("com.apple.loginwindow.plist", "Login window manipulation", "Generic Backdoor", 0.85),
    (".local.service", "Hidden local service (dot prefix)", "Generic Malware", 0.7),
    ("com.system.update", "Fake system update service", "Generic Backdoor", 0.75),
];

// ── Trusted Apple Persistence Prefixes ───────────────────────────────────────

const TRUSTED_PREFIXES: &[&str] = &[
    "com.apple.",
    "com.microsoft.",
    "com.google.Chrome",
    "com.google.keystone",
    "com.adobe.ARMDC",
    "com.docker.",
    "com.jetbrains.",
    "com.visualstudio.",
    "org.mozilla.",
    "com.1password.",
    "com.dropbox.",
    "us.zoom.",
    "com.slack.",
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum PersistenceType {
    LaunchAgent,
    LaunchDaemon,
    LoginItem,
    LoginHook,
    LogoutHook,
    CronJob,
    AtJob,
    PeriodicTask,
    KernelExtension,
    SystemExtension,
    AuthorizationPlugin,
    DirectoryServicesPlugin,
    FolderAction,
    ShellProfile,
    EnvironmentVariable,
    EmonDRule,
    RCScript,
    StartupItem,
    InputMethod,
    ScreenSaver,
    SpotlightImporter,
    QuickLookGenerator,
    ScriptingAddition,
    PrivilegedHelper,
    SSHAuthorizedKey,
    SudoersModification,
    BrowserExtension,
    ConfigurationProfile,
    BTMDatabaseManipulation,
    AutomatorWorkflow,
    CalendarAlarm,
    KnownMalwarePersistence,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistenceFinding {
    pub persistence_type: PersistenceType,
    pub confidence: f64,
    pub description: String,
    pub file_path: String,
    pub label: Option<String>,
    pub program: Option<String>,
    pub program_arguments: Option<Vec<String>>,
    pub is_signed: Option<bool>,
    pub signing_authority: Option<String>,
    pub malware_family: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub plist_properties: HashMap<String, String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistenceEvent {
    pub event_type: String,           // "create", "modify", "delete", "load", "exec"
    pub file_path: String,
    pub process_name: String,
    pub process_pid: u32,
    pub command_line: Option<String>,
    pub plist_label: Option<String>,
    pub plist_program: Option<String>,
    pub plist_arguments: Option<Vec<String>>,
    pub plist_properties: HashMap<String, String>,
    pub is_signed: Option<bool>,
    pub signing_authority: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistenceAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<PersistenceFinding>,
    pub persistence_types: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PersistenceScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub launch_agent_detections: u64,
    pub launch_daemon_detections: u64,
    pub login_item_detections: u64,
    pub shell_profile_detections: u64,
    pub cron_detections: u64,
    pub kext_detections: u64,
    pub known_malware_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistenceSigEntry { pub label: String, pub family: String, pub severity: f64 }

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct LoginPersistenceAuditor {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<PersistenceScanStats>>,
    result_cache: TieredCache<String, PersistenceAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, PersistenceScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, PersistenceAnalysisResult>>,
    sig_db: PagedMemory<PersistenceSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<PersistenceScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    known_persistence: RwLock<HashMap<String, PersistenceFinding>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl LoginPersistenceAuditor {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, PersistenceScanStats::default(),
                |acc: &mut PersistenceScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(PersistenceScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            known_persistence: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &PersistenceEvent) -> Option<PersistenceAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.file_path, event.process_pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut persistence_types = HashSet::new();

        let path_lower = event.file_path.to_lowercase();
        let is_trusted_label = event.plist_label.as_ref()
            .map(|l| TRUSTED_PREFIXES.iter().any(|p| l.starts_with(p)))
            .unwrap_or(false);

        // ── 1. LaunchAgent detection ────────────────────────────────────
        for &(dir, desc, base_conf) in LAUNCH_AGENT_DIRS {
            if path_lower.contains(&dir.to_lowercase().replace("~/", "")) {
                let conf = if is_trusted_label { (base_conf * 0.3).max(0.1) } else { base_conf };
                if event.event_type == "create" || event.event_type == "modify" {
                    findings.push(self.build_finding(
                        PersistenceType::LaunchAgent, conf,
                        format!("{} {}: {}", desc, event.event_type, event.file_path),
                        event, "T1543.001",
                    ));
                    mitre_ids.insert("T1543.001".into());
                    persistence_types.insert("LaunchAgent".to_string());
                }
            }
        }

        // ── 2. LaunchDaemon detection ───────────────────────────────────
        for &(dir, desc, base_conf) in LAUNCH_DAEMON_DIRS {
            if path_lower.contains(&dir.to_lowercase()) {
                let conf = if is_trusted_label { (base_conf * 0.3).max(0.1) } else { base_conf };
                if event.event_type == "create" || event.event_type == "modify" {
                    findings.push(self.build_finding(
                        PersistenceType::LaunchDaemon, conf,
                        format!("{} {}: {}", desc, event.event_type, event.file_path),
                        event, "T1543.004",
                    ));
                    mitre_ids.insert("T1543.004".into());
                    persistence_types.insert("LaunchDaemon".to_string());
                }
            }
        }

        // ── 3. Shell profile detection ──────────────────────────────────
        for &(path, desc, base_conf) in SHELL_PROFILE_PATHS {
            let check_path = path.to_lowercase().replace("~/", "");
            if path_lower.contains(&check_path) {
                if event.event_type == "modify" || event.event_type == "create" {
                    findings.push(self.build_finding(
                        PersistenceType::ShellProfile, base_conf,
                        format!("{} modified by {}", desc, event.process_name),
                        event, "T1546.004",
                    ));
                    mitre_ids.insert("T1546.004".into());
                    persistence_types.insert("ShellProfile".to_string());
                }
            }
        }

        // ── 4. Cron job detection ───────────────────────────────────────
        for &(path, desc, base_conf) in CRON_PATHS {
            if path_lower.contains(&path.to_lowercase()) {
                findings.push(self.build_finding(
                    PersistenceType::CronJob, base_conf,
                    format!("{} {}: {}", desc, event.event_type, event.file_path),
                    event, "T1053.003",
                ));
                mitre_ids.insert("T1053.003".into());
                persistence_types.insert("CronJob".to_string());
            }
        }

        // ── 5. Periodic task detection ──────────────────────────────────
        for &(dir, desc, base_conf) in PERIODIC_DIRS {
            if path_lower.contains(&dir.to_lowercase()) {
                findings.push(self.build_finding(
                    PersistenceType::PeriodicTask, base_conf,
                    format!("{} {}: {}", desc, event.event_type, event.file_path),
                    event, "T1053.003",
                ));
                mitre_ids.insert("T1053.003".into());
                persistence_types.insert("PeriodicTask".to_string());
            }
        }

        // ── 6. System-level persistence detection ───────────────────────
        for &(path, desc, mitre, base_conf) in SYSTEM_PERSISTENCE_PATHS {
            let check_path = path.to_lowercase().replace("~/", "");
            if path_lower.contains(&check_path) {
                let pt = if path.contains("Extensions") && path.contains("Library") {
                    PersistenceType::KernelExtension
                } else if path.contains("SecurityAgentPlugins") {
                    PersistenceType::AuthorizationPlugin
                } else if path.contains("DirectoryServices") {
                    PersistenceType::DirectoryServicesPlugin
                } else if path.contains("emond") {
                    PersistenceType::EmonDRule
                } else if path.contains("rc.") {
                    PersistenceType::RCScript
                } else if path.contains("StartupItems") {
                    PersistenceType::StartupItem
                } else if path.contains("Input Methods") {
                    PersistenceType::InputMethod
                } else if path.contains("Screen Savers") {
                    PersistenceType::ScreenSaver
                } else if path.contains("Spotlight") {
                    PersistenceType::SpotlightImporter
                } else if path.contains("QuickLook") {
                    PersistenceType::QuickLookGenerator
                } else if path.contains("Folder Actions") {
                    PersistenceType::FolderAction
                } else if path.contains("ScriptingAdditions") {
                    PersistenceType::ScriptingAddition
                } else if path.contains("PrivilegedHelperTools") {
                    PersistenceType::PrivilegedHelper
                } else if path.contains("authorized_keys") {
                    PersistenceType::SSHAuthorizedKey
                } else if path.contains("sudoers") {
                    PersistenceType::SudoersModification
                } else if path.contains("environment.plist") {
                    PersistenceType::EnvironmentVariable
                } else {
                    PersistenceType::LaunchAgent // fallback
                };

                if event.event_type == "create" || event.event_type == "modify" {
                    findings.push(self.build_finding(
                        pt, base_conf, format!("{}: {}", desc, event.file_path),
                        event, mitre,
                    ));
                    mitre_ids.insert(mitre.into());
                    persistence_types.insert(format!("{:?}", pt));
                }
            }
        }

        // ── 7. Command-line persistence detection ───────────────────────
        if let Some(ref cmd) = event.command_line {
            let cmd_lower = cmd.to_lowercase();
            for &(pattern, desc, mitre, conf) in PERSISTENCE_COMMANDS {
                if cmd_lower.contains(&pattern.to_lowercase()) {
                    let pt = if pattern.contains("launchctl") || pattern.contains("LaunchAgents") {
                        PersistenceType::LaunchAgent
                    } else if pattern.contains("LaunchDaemons") {
                        PersistenceType::LaunchDaemon
                    } else if pattern.contains("LoginHook") {
                        PersistenceType::LoginHook
                    } else if pattern.contains("LogoutHook") {
                        PersistenceType::LogoutHook
                    } else if pattern.contains("login item") || pattern.contains("btm") || pattern.contains("sfltool") {
                        PersistenceType::LoginItem
                    } else if pattern.contains("cron") || pattern.contains("at ") {
                        PersistenceType::CronJob
                    } else if pattern.contains("kext") || pattern.contains("kmutil") {
                        PersistenceType::KernelExtension
                    } else if pattern.contains("systemextension") {
                        PersistenceType::SystemExtension
                    } else if pattern.contains("profiles") {
                        PersistenceType::ConfigurationProfile
                    } else if pattern.contains("PlistBuddy") || pattern.contains("plutil") {
                        PersistenceType::LaunchAgent
                    } else {
                        PersistenceType::LaunchAgent
                    };

                    findings.push(self.build_finding(pt, conf, desc.to_string(), event, mitre));
                    mitre_ids.insert(mitre.into());
                    persistence_types.insert(format!("{:?}", pt));
                }
            }
        }

        // ── 8. Suspicious plist property analysis ───────────────────────
        if !event.plist_properties.is_empty() && !is_trusted_label {
            for (key, value) in &event.plist_properties {
                for &(prop, desc, conf) in SUSPICIOUS_PLIST_PROPERTIES {
                    if key.contains(prop) {
                        // KeepAlive + RunAtLoad = highly resilient persistence
                        let boost = if prop == "KeepAlive" && event.plist_properties.contains_key("RunAtLoad") {
                            0.2
                        } else { 0.0 };

                        findings.push(PersistenceFinding {
                            persistence_type: PersistenceType::LaunchAgent,
                            confidence: (conf + boost).min(0.9),
                            description: format!("{}: {}={}", desc, key, value),
                            file_path: event.file_path.clone(),
                            label: event.plist_label.clone(),
                            program: event.plist_program.clone(),
                            program_arguments: event.plist_arguments.clone(),
                            is_signed: event.is_signed,
                            signing_authority: event.signing_authority.clone(),
                            malware_family: None,
                            mitre_id: "T1543.001".into(),
                            process_name: Some(event.process_name.clone()),
                            process_pid: Some(event.process_pid),
                            plist_properties: event.plist_properties.clone(),
                            timestamp: event.timestamp,
                        });
                    }
                }
            }
        }

        // ── 9. Known malware persistence label matching ─────────────────
        if let Some(ref label) = event.plist_label {
            for &(indicator, desc, family, conf) in MALWARE_PERSISTENCE_INDICATORS {
                if label.to_lowercase().contains(&indicator.to_lowercase()) {
                    findings.push(PersistenceFinding {
                        persistence_type: PersistenceType::KnownMalwarePersistence,
                        confidence: conf,
                        description: format!("{}: label={}", desc, label),
                        file_path: event.file_path.clone(),
                        label: Some(label.clone()),
                        program: event.plist_program.clone(),
                        program_arguments: event.plist_arguments.clone(),
                        is_signed: event.is_signed,
                        signing_authority: event.signing_authority.clone(),
                        malware_family: Some(family.to_string()),
                        mitre_id: "T1543.001".into(),
                        process_name: Some(event.process_name.clone()),
                        process_pid: Some(event.process_pid),
                        plist_properties: event.plist_properties.clone(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1543.001".into());
                    persistence_types.insert("KnownMalware".to_string());
                }
            }
        }

        // ── 10. Unsigned persistence binary ─────────────────────────────
        if let Some(false) = event.is_signed {
            if !findings.is_empty() {
                for f in findings.iter_mut() {
                    f.confidence = (f.confidence + 0.1).min(0.99);
                }
            }
        }

        // ── Store in known persistence registry ─────────────────────────
        if !findings.is_empty() {
            let mut known = self.known_persistence.write();
            if let Some(top) = findings.first() {
                known.insert(event.file_path.clone(), top.clone());
            }
        }

        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("path={},type={},label={:?}", event.file_path, event.event_type, event.plist_label));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let types_vec: Vec<String> = persistence_types.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = PersistenceAnalysisResult {
            is_malicious, events_analyzed: 1, findings, persistence_types: types_vec,
            risk_score, severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.persistence_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_malicious {
                s.malicious_detections += 1;
                for f in &result.findings {
                    match f.persistence_type {
                        PersistenceType::LaunchAgent => s.launch_agent_detections += 1,
                        PersistenceType::LaunchDaemon => s.launch_daemon_detections += 1,
                        PersistenceType::LoginItem | PersistenceType::LoginHook => s.login_item_detections += 1,
                        PersistenceType::ShellProfile => s.shell_profile_detections += 1,
                        PersistenceType::CronJob | PersistenceType::PeriodicTask => s.cron_detections += 1,
                        PersistenceType::KernelExtension | PersistenceType::SystemExtension => s.kext_detections += 1,
                        PersistenceType::KnownMalwarePersistence => s.known_malware_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            let label_str = event.plist_label.as_deref().unwrap_or("unknown");
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "login_persistence_auditor".into(),
                title: format!("Persistence: {} ({})", label_str, result.persistence_types.join(", ")),
                details: format!("Risk: {:.1}%, {} findings, path: {}, by: {} (pid {})",
                    risk_score * 100.0, result.findings.len(), event.file_path,
                    event.process_name, event.process_pid),
                path: Some(event.file_path.clone()),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid), verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    format!("Remove persistence item: {}", event.file_path),
                    "Run: launchctl list | grep <label> to verify".into(),
                    "Check program binary code signature".into(),
                    "Review all LaunchAgents: ls ~/Library/LaunchAgents/".into(),
                    "Review all LaunchDaemons: ls /Library/LaunchDaemons/".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn build_finding(&self, pt: PersistenceType, confidence: f64, description: String,
        event: &PersistenceEvent, mitre: &str) -> PersistenceFinding
    {
        PersistenceFinding {
            persistence_type: pt, confidence, description,
            file_path: event.file_path.clone(),
            label: event.plist_label.clone(),
            program: event.plist_program.clone(),
            program_arguments: event.plist_arguments.clone(),
            is_signed: event.is_signed,
            signing_authority: event.signing_authority.clone(),
            malware_family: None,
            mitre_id: mitre.into(),
            process_name: Some(event.process_name.clone()),
            process_pid: Some(event.process_pid),
            plist_properties: event.plist_properties.clone(),
            timestamp: event.timestamp,
        }
    }

    fn calculate_risk_score(&self, findings: &[PersistenceFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.persistence_type {
                PersistenceType::KnownMalwarePersistence => 1.6,
                PersistenceType::KernelExtension => 1.5,
                PersistenceType::AuthorizationPlugin => 1.5,
                PersistenceType::SudoersModification => 1.4,
                PersistenceType::LaunchDaemon => 1.3,
                PersistenceType::LoginHook => 1.3,
                PersistenceType::EmonDRule => 1.3,
                PersistenceType::RCScript | PersistenceType::StartupItem => 1.2,
                PersistenceType::LaunchAgent => 1.1,
                PersistenceType::CronJob => 1.1,
                PersistenceType::ShellProfile => 1.0,
                PersistenceType::LoginItem => 1.0,
                PersistenceType::SSHAuthorizedKey => 1.2,
                PersistenceType::ScriptingAddition => 1.3,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn known_persistence_count(&self) -> usize { self.known_persistence.read().len() }
    pub fn stats(&self) -> PersistenceScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
