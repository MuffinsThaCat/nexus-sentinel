//! Module 124: TransparencyConsentBypass — TCC Framework Bypass Detection
//!
//! Detects attempts to bypass macOS Transparency, Consent, and Control (TCC)
//! framework which protects access to camera, microphone, screen recording,
//! contacts, calendars, full disk access, and other sensitive resources.
//!
//! ## Detection Capabilities
//!
//! - **TCC database manipulation**: Direct SQLite modification of TCC.db
//!   to grant permissions without user consent
//! - **FDA injection**: Full Disk Access abuse to read/modify TCC.db
//! - **Synthetic events**: CGEvent/IOHIDPost to fake user consent clicks
//! - **Accessibility abuse**: AX API to programmatically click Allow dialogs
//! - **Bundle ID spoofing**: Impersonating trusted apps to inherit TCC grants
//! - **MDM profile abuse**: Configuration profiles granting TCC permissions
//! - **AppleScript/osascript exploitation**: System Events scripting to bypass
//! - **Endpoint Security bypass**: Circumventing ES client notifications
//! - **SIP-protected TCC paths**: Attempts to access /Library/Application Support/com.apple.TCC/
//! - **Known CVE exploitation**: CVE-2020-9934, CVE-2021-30713, CVE-2023-32364,
//!   CVE-2023-38571 and related TCC bypass chains
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const TCC_DB_PATHS: &[&str] = &[
    "/Library/Application Support/com.apple.TCC/TCC.db",
    "~/Library/Application Support/com.apple.TCC/TCC.db",
];

const TCC_SERVICES: &[(&str, &str)] = &[
    ("kTCCServiceCamera", "Camera access"),
    ("kTCCServiceMicrophone", "Microphone access"),
    ("kTCCServiceScreenCapture", "Screen recording"),
    ("kTCCServiceAccessibility", "Accessibility"),
    ("kTCCServiceSystemPolicyAllFiles", "Full Disk Access"),
    ("kTCCServiceSystemPolicySysAdminFiles", "Admin file access"),
    ("kTCCServiceAddressBook", "Contacts access"),
    ("kTCCServiceCalendar", "Calendar access"),
    ("kTCCServiceReminders", "Reminders access"),
    ("kTCCServicePhotos", "Photos access"),
    ("kTCCServiceMediaLibrary", "Media Library access"),
    ("kTCCServiceAppleEvents", "Apple Events / Automation"),
    ("kTCCServiceListenEvent", "Input Monitoring"),
    ("kTCCServicePostEvent", "Synthetic Input"),
    ("kTCCServiceLocation", "Location Services"),
    ("kTCCServiceBluetoothAlways", "Bluetooth access"),
];

const TCC_BYPASS_TECHNIQUES: &[(&str, &str, &str, f64)] = &[
    ("sqlite3 TCC.db", "Direct TCC database modification", "T1548", 0.95),
    ("INSERT INTO access", "TCC permission insertion via SQL", "T1548", 0.95),
    ("UPDATE access SET allowed", "TCC permission update via SQL", "T1548", 0.95),
    ("tccutil reset", "TCC permission reset utility", "T1548", 0.7),
    ("tccutil", "TCC utility usage", "T1548", 0.5),
    ("csrutil disable", "SIP disable (pre-TCC bypass)", "T1553.006", 0.9),
    ("CGEventPost", "Synthetic event injection", "T1548", 0.7),
    ("AXUIElementPerformAction", "Accessibility API click simulation", "T1548", 0.8),
    ("IOHIDPostEvent", "HID synthetic input event", "T1548", 0.75),
    ("com.apple.TCC", "TCC framework reference", "T1548", 0.3),
    ("kMDItemDisplayName", "Spotlight metadata (bundle ID spoof)", "T1036.005", 0.5),
    ("osascript.*System Events", "AppleScript System Events abuse", "T1059.002", 0.65),
    ("osascript.*click", "AppleScript click automation", "T1059.002", 0.7),
    ("profiles install", "MDM profile installation", "T1176", 0.6),
    ("profiles -I", "MDM profile install command", "T1176", 0.65),
    ("codesign --force --sign", "Code signing override (bundle spoof)", "T1036.005", 0.6),
    ("xattr -d com.apple.quarantine", "Quarantine flag removal", "T1553.001", 0.6),
    ("open -a", "App launch (potential TCC inheritor)", "T1204.002", 0.3),
    ("NSAppleScript", "NSAppleScript execution (TCC bypass vector)", "T1059.002", 0.5),
    ("JXA", "JavaScript for Automation (TCC bypass)", "T1059.007", 0.5),
];

const TCC_BYPASS_CVES: &[(&str, &str, &str, f64)] = &[
    ("CVE-2020-9934", "TCC bypass via environment variable", "T1548", 0.95),
    ("CVE-2020-27937", "TCC bypass via symlink", "T1548", 0.95),
    ("CVE-2021-30713", "TCC bypass (XCSSET malware)", "T1548", 0.95),
    ("CVE-2021-30920", "TCC bypass via mounted DMG", "T1548", 0.95),
    ("CVE-2022-22616", "TCC bypass via Gatekeeper", "T1548", 0.95),
    ("CVE-2023-32364", "TCC bypass via file provider", "T1548", 0.95),
    ("CVE-2023-38571", "TCC bypass via process injection", "T1548", 0.95),
    ("CVE-2023-40424", "TCC bypass via Safari", "T1548", 0.95),
    ("CVE-2024-44133", "TCC bypass (HM Surf)", "T1548", 0.95),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TCCBypassType {
    DirectDBModification,
    SQLInjection,
    SyntheticEventInjection,
    AccessibilityAPIAbuse,
    BundleIDSpoofing,
    MDMProfileAbuse,
    AppleScriptBypass,
    JXABypass,
    SymlinkBypass,
    EnvironmentVariableBypass,
    MountedDMGBypass,
    ProcessInjectionBypass,
    SIPDisable,
    QuarantineFlagRemoval,
    CodeSignOverride,
    KnownCVEExploit,
    TCCResetAbuse,
    EndpointSecurityBypass,
    FDAAbuse,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCBypassFinding {
    pub bypass_type: TCCBypassType,
    pub tcc_service: Option<String>,
    pub confidence: f64,
    pub description: String,
    pub command_line: Option<String>,
    pub target_bundle_id: Option<String>,
    pub cve_id: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCEvent {
    pub event_type: String,
    pub process_name: String,
    pub process_pid: u32,
    pub bundle_id: Option<String>,
    pub command_line: Option<String>,
    pub file_path: Option<String>,
    pub tcc_service: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCAnalysisResult {
    pub is_bypass: bool,
    pub events_analyzed: u32,
    pub findings: Vec<TCCBypassFinding>,
    pub bypassed_services: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TCCScanStats {
    pub total_events: u64,
    pub bypass_detections: u64,
    pub db_modification_detections: u64,
    pub synthetic_event_detections: u64,
    pub cve_exploit_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCDetectorConfig {
    pub enabled: bool,
    pub monitor_tcc_db: bool,
    pub detect_synthetic_events: bool,
    pub detect_accessibility_abuse: bool,
    pub detect_cve_exploits: bool,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for TCCDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            monitor_tcc_db: true,
            detect_synthetic_events: true,
            detect_accessibility_abuse: true,
            detect_cve_exploits: true,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCSigEntry {
    pub pattern: String,
    pub bypass_type: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct TransparencyConsentBypassDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<TCCScanStats>>,
    result_cache: TieredCache<String, TCCAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, TCCScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, TCCAnalysisResult>>,
    sig_db: PagedMemory<TCCSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<TCCDetectorConfig>,
    stats: RwLock<TCCScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    tcc_db_hashes: RwLock<HashMap<String, String>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl TransparencyConsentBypassDetector {
    pub fn new() -> Self {
        let cfg = TCCDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, TCCScanStats::default(),
                |acc: &mut TCCScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(TCCScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            tcc_db_hashes: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &TCCEvent) -> Option<TCCAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.process_name, event.process_pid, event.timestamp);

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut bypassed_services = Vec::new();

        let event_text = format!("{} {} {}",
            event.command_line.as_deref().unwrap_or(""),
            event.file_path.as_deref().unwrap_or(""),
            event.event_type);

        // Check TCC bypass techniques
        for &(pattern, desc, mitre, conf) in TCC_BYPASS_TECHNIQUES {
            if event_text.to_lowercase().contains(&pattern.to_lowercase()) {
                let bt = if pattern.contains("sqlite3") || pattern.contains("INSERT") || pattern.contains("UPDATE") {
                    TCCBypassType::DirectDBModification
                } else if pattern.contains("CGEvent") || pattern.contains("IOHIDPost") {
                    TCCBypassType::SyntheticEventInjection
                } else if pattern.contains("AXUIElement") {
                    TCCBypassType::AccessibilityAPIAbuse
                } else if pattern.contains("osascript") {
                    TCCBypassType::AppleScriptBypass
                } else if pattern.contains("profiles") {
                    TCCBypassType::MDMProfileAbuse
                } else if pattern.contains("csrutil") {
                    TCCBypassType::SIPDisable
                } else if pattern.contains("codesign") {
                    TCCBypassType::CodeSignOverride
                } else if pattern.contains("xattr") {
                    TCCBypassType::QuarantineFlagRemoval
                } else if pattern.contains("tccutil reset") {
                    TCCBypassType::TCCResetAbuse
                } else {
                    TCCBypassType::DirectDBModification
                };

                findings.push(TCCBypassFinding {
                    bypass_type: bt,
                    tcc_service: event.tcc_service.clone(),
                    confidence: conf,
                    description: desc.to_string(),
                    command_line: event.command_line.clone(),
                    target_bundle_id: event.bundle_id.clone(),
                    cve_id: None,
                    mitre_id: mitre.into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    file_path: event.file_path.clone(),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                if let Some(ref svc) = event.tcc_service {
                    bypassed_services.push(svc.clone());
                }
            }
        }

        // Check file path access to TCC database
        if cfg.monitor_tcc_db {
            if let Some(ref path) = event.file_path {
                for tcc_path in TCC_DB_PATHS {
                    if path.contains(tcc_path) || path.contains("TCC.db") {
                        let is_write = event.event_type.contains("write") || event.event_type.contains("modify")
                            || event.event_type.contains("create") || event.event_type.contains("rename");
                        if is_write {
                            findings.push(TCCBypassFinding {
                                bypass_type: TCCBypassType::DirectDBModification,
                                tcc_service: None,
                                confidence: 0.95,
                                description: format!("TCC database write: {} by {}", path, event.process_name),
                                command_line: event.command_line.clone(),
                                target_bundle_id: event.bundle_id.clone(),
                                cve_id: None,
                                mitre_id: "T1548".into(),
                                process_name: Some(event.process_name.clone()),
                                process_pid: Some(event.process_pid),
                                file_path: Some(path.clone()),
                                timestamp: event.timestamp,
                            });
                            mitre_ids.insert("T1548".into());
                        }
                    }
                }
            }
        }

        // Check for known CVE patterns
        if cfg.detect_cve_exploits {
            for &(cve, desc, mitre, conf) in TCC_BYPASS_CVES {
                if event_text.contains(cve) {
                    findings.push(TCCBypassFinding {
                        bypass_type: TCCBypassType::KnownCVEExploit,
                        tcc_service: event.tcc_service.clone(),
                        confidence: conf,
                        description: format!("{}: {}", cve, desc),
                        command_line: event.command_line.clone(),
                        target_bundle_id: event.bundle_id.clone(),
                        cve_id: Some(cve.to_string()),
                        mitre_id: mitre.into(),
                        process_name: Some(event.process_name.clone()),
                        process_pid: Some(event.process_pid),
                        file_path: event.file_path.clone(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                }
            }
        }

        self.event_diffs.write().record_insert(
            cache_key.clone(),
            format!("proc={},type={}", event.process_name, event.event_type),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_bypass = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = TCCAnalysisResult {
            is_bypass,
            events_analyzed: 1,
            findings,
            bypassed_services,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.bypass_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_events += 1;
            if is_bypass { stats.bypass_detections += 1; }
            let n = stats.total_events as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_bypass {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "transparency_consent_bypass".into(),
                title: format!("TCC bypass: {} (pid {})", event.process_name, event.process_pid),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: event.file_path.clone(),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid),
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Verify SIP is enabled (csrutil status)".into(),
                    "Audit TCC database permissions".into(),
                    "Review MDM profiles for unauthorized TCC grants".into(),
                    "Monitor Accessibility API usage".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[TCCBypassFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.bypass_type {
                TCCBypassType::DirectDBModification => 1.5,
                TCCBypassType::KnownCVEExploit => 1.5,
                TCCBypassType::SIPDisable => 1.4,
                TCCBypassType::SyntheticEventInjection => 1.3,
                TCCBypassType::ProcessInjectionBypass => 1.3,
                TCCBypassType::AccessibilityAPIAbuse => 1.2,
                TCCBypassType::MDMProfileAbuse => 1.1,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> TCCScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
