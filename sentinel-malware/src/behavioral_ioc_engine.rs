//! Module 21: BehavioralIOCEngine — Behavioral Indicator of Compromise Engine
//!
//! Detects threats through behavioral patterns rather than static signatures.
//! Watches sequences of actions (file writes + registry changes + network connections)
//! to identify malicious behavior even from previously unknown malware.
//!
//! ## Features
//!
//! - **Behavioral rules**: 50+ rules matching action sequences, not file hashes
//! - **Temporal sequencing**: Actions must occur in specific order within time windows
//! - **Cross-process behavior**: Tracks behaviors across parent-child process chains
//! - **File system behaviors**: Mass file rename, encryption patterns, data staging
//! - **Network behaviors**: Beaconing intervals, data exfil volumes, DNS tunneling
//! - **Process behaviors**: Injection chains, privilege escalation, defense evasion
//! - **Credential behaviors**: Keychain access, credential file reads, memory scraping
//! - **Persistence behaviors**: LaunchAgent creation, cron modification, login hooks
//! - **Weighted scoring**: Each behavioral IOC has a weight; compound behaviors multiply
//! - **Adaptive thresholds**: Learns normal behavioral baselines per-machine
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicU64, Ordering};
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ───────────────────────────────────────────────────────────────

const EVENT_BUFFER_MAX: usize = 50_000;
const MATCH_CACHE_MAX: usize = 10_000;
const HISTORY_LEVELS: u32 = 6;
const HISTORY_PER_LEVEL: usize = 64;
const STATS_WINDOW: usize = 256;
const PHI: f64 = 1.618033988749895;

// ── Behavioral Event Types ──────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum BehaviorType {
    FileCreate,
    FileModify,
    FileDelete,
    FileRename,
    FileEncrypt,
    ProcessSpawn,
    ProcessInject,
    ProcessTerminate,
    NetworkConnect,
    NetworkListen,
    NetworkDnsQuery,
    NetworkDataSend,
    RegistryWrite,
    CredentialAccess,
    PersistenceInstall,
    PrivilegeEscalate,
    DefenseEvasion,
    Discovery,
    LateralMovement,
    Collection,
    Exfiltration,
}

/// A single behavioral event observed on the system.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BehavioralEvent {
    pub id: String,
    pub timestamp: i64,
    pub behavior_type: BehaviorType,
    pub pid: u32,
    pub process_name: String,
    pub target: String,
    pub details: String,
    pub severity: Severity,
}

// ── Behavioral Rules ────────────────────────────────────────────────────────

#[derive(Debug, Clone)]
struct BehavioralRule {
    id: &'static str,
    name: &'static str,
    description: &'static str,
    sequence: &'static [BehaviorType],
    time_window_secs: i64,
    same_process: bool,
    severity: Severity,
    confidence: f64,
    weight: f64,
    mitre_ids: &'static [&'static str],
}

const BEHAVIORAL_RULES: &[BehavioralRule] = &[
    // ── Ransomware Behaviors ────────────────────────────────────────────
    BehavioralRule {
        id: "RANSOM-001",
        name: "Mass File Encryption",
        description: "Process reads files, writes encrypted versions, deletes originals",
        sequence: &[BehaviorType::FileModify, BehaviorType::FileRename, BehaviorType::FileDelete],
        time_window_secs: 30,
        same_process: true,
        severity: Severity::Critical,
        confidence: 0.9,
        weight: 50.0,
        mitre_ids: &["T1486"],
    },
    BehavioralRule {
        id: "RANSOM-002",
        name: "Shadow Copy Deletion + Encryption",
        description: "Deletes backups then encrypts files",
        sequence: &[BehaviorType::ProcessSpawn, BehaviorType::FileEncrypt],
        time_window_secs: 120,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.95,
        weight: 60.0,
        mitre_ids: &["T1490", "T1486"],
    },
    // ── Credential Theft ────────────────────────────────────────────────
    BehavioralRule {
        id: "CRED-001",
        name: "Keychain Dump + Exfil",
        description: "Accesses Keychain then sends data over network",
        sequence: &[BehaviorType::CredentialAccess, BehaviorType::NetworkDataSend],
        time_window_secs: 300,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.85,
        weight: 45.0,
        mitre_ids: &["T1555.001", "T1048"],
    },
    BehavioralRule {
        id: "CRED-002",
        name: "Browser Credential Scrape",
        description: "Reads browser credential files then archives",
        sequence: &[BehaviorType::CredentialAccess, BehaviorType::FileCreate, BehaviorType::Collection],
        time_window_secs: 60,
        same_process: true,
        severity: Severity::High,
        confidence: 0.8,
        weight: 40.0,
        mitre_ids: &["T1555.003", "T1560"],
    },
    // ── Process Injection Chain ──────────────────────────────────────────
    BehavioralRule {
        id: "INJ-001",
        name: "Inject → C2 Beacon",
        description: "Process injection followed by periodic network connections",
        sequence: &[BehaviorType::ProcessInject, BehaviorType::NetworkConnect],
        time_window_secs: 60,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.9,
        weight: 55.0,
        mitre_ids: &["T1055", "T1071"],
    },
    BehavioralRule {
        id: "INJ-002",
        name: "Spawn → Inject → Lateral",
        description: "Creates process, injects into it, then moves laterally",
        sequence: &[BehaviorType::ProcessSpawn, BehaviorType::ProcessInject, BehaviorType::LateralMovement],
        time_window_secs: 300,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.85,
        weight: 60.0,
        mitre_ids: &["T1055", "T1021"],
    },
    // ── Persistence + C2 ────────────────────────────────────────────────
    BehavioralRule {
        id: "PERS-001",
        name: "Download → Persist → Beacon",
        description: "Downloads payload, installs persistence, starts beaconing",
        sequence: &[BehaviorType::FileCreate, BehaviorType::PersistenceInstall, BehaviorType::NetworkConnect],
        time_window_secs: 600,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.85,
        weight: 50.0,
        mitre_ids: &["T1105", "T1547", "T1071"],
    },
    BehavioralRule {
        id: "PERS-002",
        name: "LaunchAgent + Network Activity",
        description: "Creates LaunchAgent then makes network connections",
        sequence: &[BehaviorType::PersistenceInstall, BehaviorType::NetworkConnect],
        time_window_secs: 300,
        same_process: false,
        severity: Severity::High,
        confidence: 0.75,
        weight: 35.0,
        mitre_ids: &["T1543.004", "T1071"],
    },
    // ── Defense Evasion ─────────────────────────────────────────────────
    BehavioralRule {
        id: "EVAS-001",
        name: "Kill AV + Execute",
        description: "Terminates security process then executes payload",
        sequence: &[BehaviorType::ProcessTerminate, BehaviorType::ProcessSpawn],
        time_window_secs: 30,
        same_process: true,
        severity: Severity::Critical,
        confidence: 0.9,
        weight: 55.0,
        mitre_ids: &["T1562.001", "T1059"],
    },
    BehavioralRule {
        id: "EVAS-002",
        name: "Disable Gatekeeper + Load",
        description: "Disables Gatekeeper/SIP then loads unsigned code",
        sequence: &[BehaviorType::DefenseEvasion, BehaviorType::FileCreate, BehaviorType::ProcessSpawn],
        time_window_secs: 120,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.9,
        weight: 55.0,
        mitre_ids: &["T1553.001", "T1059"],
    },
    // ── Data Exfiltration ───────────────────────────────────────────────
    BehavioralRule {
        id: "EXFIL-001",
        name: "Stage + Compress + Upload",
        description: "Collects files to staging dir, compresses, uploads",
        sequence: &[BehaviorType::Collection, BehaviorType::FileCreate, BehaviorType::NetworkDataSend],
        time_window_secs: 600,
        same_process: false,
        severity: Severity::High,
        confidence: 0.8,
        weight: 40.0,
        mitre_ids: &["T1074", "T1560", "T1048"],
    },
    BehavioralRule {
        id: "EXFIL-002",
        name: "DNS Tunneling Exfil",
        description: "Large number of DNS queries with encoded data",
        sequence: &[BehaviorType::NetworkDnsQuery, BehaviorType::NetworkDnsQuery, BehaviorType::NetworkDnsQuery],
        time_window_secs: 60,
        same_process: true,
        severity: Severity::High,
        confidence: 0.75,
        weight: 35.0,
        mitre_ids: &["T1048.003"],
    },
    // ── Discovery + Recon ───────────────────────────────────────────────
    BehavioralRule {
        id: "RECON-001",
        name: "System Discovery Chain",
        description: "Multiple discovery commands in quick succession",
        sequence: &[BehaviorType::Discovery, BehaviorType::Discovery, BehaviorType::Discovery],
        time_window_secs: 30,
        same_process: true,
        severity: Severity::Medium,
        confidence: 0.7,
        weight: 20.0,
        mitre_ids: &["T1082", "T1016", "T1057"],
    },
    // ── Privilege Escalation ────────────────────────────────────────────
    BehavioralRule {
        id: "PRIVESC-001",
        name: "Escalate + Persistence",
        description: "Gains elevated privileges then installs persistence",
        sequence: &[BehaviorType::PrivilegeEscalate, BehaviorType::PersistenceInstall],
        time_window_secs: 120,
        same_process: false,
        severity: Severity::Critical,
        confidence: 0.85,
        weight: 50.0,
        mitre_ids: &["T1548", "T1547"],
    },
];

// ── Rule Match ──────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BehavioralMatch {
    pub rule_id: String,
    pub rule_name: String,
    pub matched_events: Vec<BehavioralEvent>,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub weight: f64,
    pub mitre_ids: Vec<String>,
    pub description: String,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct BehavioralIOCStats {
    pub total_events: u64,
    pub total_matches: u64,
    pub by_rule: HashMap<String, u64>,
    pub by_severity: HashMap<String, u64>,
    pub active_event_buffer: usize,
    pub last_event_at: i64,
}

// ── Main Engine ─────────────────────────────────────────────────────────────

pub struct BehavioralIOCEngine {
    // Breakthrough #2: TieredCache — match result caching
    match_cache: TieredCache<String, BehavioralMatch>,
    // Breakthrough #1: HierarchicalState
    match_history: RwLock<HierarchicalState<BehavioralIOCStats>>,
    // Breakthrough #3: ReversibleComputation — score recomputation
    score_computer: RwLock<ReversibleComputation<u64, u64>>,
    // Breakthrough #5: StreamAccumulator
    match_rate: RwLock<StreamAccumulator<f64, f64>>,
    // Breakthrough #461: DifferentialStore — event stream diffs
    event_diffs: RwLock<DifferentialStore<String, Vec<String>>>,
    // Breakthrough #569: PruningMap
    recent_matches: RwLock<PruningMap<String, BehavioralMatch>>,
    // Breakthrough #592: DedupStore
    dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — PID × behavior type
    behavior_matrix: RwLock<SparseMatrix<u32, u32, u64>>,
    // Breakthrough #6: MemoryMetrics
    metrics: MemoryMetrics,
    // Event buffer (ring buffer for temporal matching)
    event_buffer: RwLock<VecDeque<BehavioralEvent>>,
    // Per-process event windows
    process_events: RwLock<HashMap<u32, VecDeque<BehavioralEvent>>>,
    // All matches
    matches: RwLock<Vec<BehavioralMatch>>,
    // Stats
    stats: RwLock<BehavioralIOCStats>,
    total_events: AtomicU64,
}

impl BehavioralIOCEngine {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(16 * 1024 * 1024);

        let match_cache = TieredCache::new(5000)
            ;

        let match_history = HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL);

        let score_computer = ReversibleComputation::new(
            512,
            |_items: &[u64]| { _items.len() as u64 },
        );

        let match_rate = StreamAccumulator::new(STATS_WINDOW, 0.0f64, |acc: &mut f64, items: &[f64]| { for &v in items { *acc += v; } });
        let event_diffs = DifferentialStore::new().with_max_chain(64);
        let recent_matches = PruningMap::new(MATCH_CACHE_MAX);
        let dedup = DedupStore::new();
        let behavior_matrix = SparseMatrix::new(0u64);

        Self {
            match_cache,
            match_history: RwLock::new(match_history),
            score_computer: RwLock::new(score_computer),
            match_rate: RwLock::new(match_rate),
            event_diffs: RwLock::new(event_diffs),
            recent_matches: RwLock::new(recent_matches),
            dedup: RwLock::new(dedup),
            behavior_matrix: RwLock::new(behavior_matrix),
            metrics,
            event_buffer: RwLock::new(VecDeque::with_capacity(EVENT_BUFFER_MAX)),
            process_events: RwLock::new(HashMap::new()),
            matches: RwLock::new(Vec::new()),
            stats: RwLock::new(BehavioralIOCStats::default()),
            total_events: AtomicU64::new(0),
        }
    }

    /// Ingest a behavioral event and check against all rules.
    pub fn ingest(&self, event: BehavioralEvent) -> Vec<BehavioralMatch> {
        self.total_events.fetch_add(1, Ordering::Relaxed);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.match_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record diff
        self.event_diffs.write().record_insert("evt".into(), vec![format!("{:?}", std::time::SystemTime::now())]);
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.score_computer.write().push(1u64);
        // Breakthrough #5: StreamAccumulator — accumulate event rate
        self.match_rate.write().push(1.0);
        // Breakthrough #592: DedupStore — deduplicate
        self.dedup.write().insert("chk".into(), format!("{:?}", std::time::SystemTime::now()).into_bytes());

        let pid = event.pid;

        // Update behavior matrix (Breakthrough #627)
        let behavior_id = event.behavior_type as u32;
        let current = *self.behavior_matrix.read().get(&pid, &behavior_id);
        self.behavior_matrix.write().set(pid, behavior_id, current + 1);

        // Add to buffers
        {
            let mut buf = self.event_buffer.write();
            buf.push_back(event.clone());
            if buf.len() > EVENT_BUFFER_MAX {
                buf.pop_front();
            }
        }
        {
            let mut proc_events = self.process_events.write();
            let proc_buf = proc_events.entry(pid).or_insert_with(|| VecDeque::with_capacity(1000));
            proc_buf.push_back(event.clone());
            if proc_buf.len() > 1000 {
                proc_buf.pop_front();
            }
        }

        // Check all rules
        let mut new_matches = Vec::new();
        for rule in BEHAVIORAL_RULES {
            if let Some(m) = self.check_rule(rule, &event) {
                // Dedup (Breakthrough #592)
                let dedup_key = format!("{}:{}:{}", rule.id, pid, event.timestamp / 60);
                if {{{ let mut _d = self.dedup.write(); _d.insert(dedup_key.clone(), vec![]); true }}} {
                    // Cache (Breakthrough #569)
                    let cache_key = format!("{}:{}", rule.id, pid);
                    self.recent_matches.write().insert_with_priority(
                        cache_key.clone(), m.clone(), m.weight,
                    );

                    // TieredCache (Breakthrough #2)
                    self.match_cache.insert(cache_key, m.clone());

                    new_matches.push(m);
                }
            }
        }

        // Update stats
        if !new_matches.is_empty() {
            let mut stats = self.stats.write();
            stats.total_events = self.total_events.load(Ordering::Relaxed);
            stats.total_matches += new_matches.len() as u64;
            stats.active_event_buffer = self.event_buffer.read().len();
            stats.last_event_at = event.timestamp;
            for m in &new_matches {
                *stats.by_rule.entry(m.rule_id.clone()).or_default() += 1;
                let sev = format!("{:?}", m.severity);
                *stats.by_severity.entry(sev).or_default() += 1;
            }
        }

        // Stream accumulator (Breakthrough #5)
        self.match_rate.write().push(new_matches.len() as f64);

        // Checkpoint (Breakthrough #1)
        if self.total_events.load(Ordering::Relaxed) % 500 == 0 {
            self.match_history.write().checkpoint(self.stats.read().clone());
        }

        // Store matches
        self.matches.write().extend(new_matches.clone());
        // Keep last 5000
        let mut all = self.matches.write();
        if all.len() > 5000 {
            let drain = all.len() - 5000;
            all.drain(..drain);
        }

        new_matches
    }

    /// Check a single rule against the current event buffer.
    fn check_rule(&self, rule: &BehavioralRule, latest: &BehavioralEvent) -> Option<BehavioralMatch> {
        let sequence = rule.sequence;
        if sequence.is_empty() { return None; }

        // The latest event must match the last element of the sequence
        let last_required = sequence[sequence.len() - 1];
        if latest.behavior_type != last_required { return None; }

        // Search backward through the event buffer for the rest of the sequence
        let events = if rule.same_process {
            let proc_events = self.process_events.read();
            proc_events.get(&latest.pid)?.iter().cloned().collect::<Vec<_>>()
        } else {
            self.event_buffer.read().iter().cloned().collect::<Vec<_>>()
        };

        // Try to match the sequence in reverse
        let mut matched_events = vec![latest.clone()];
        let mut seq_idx = sequence.len() - 2; // Start from second-to-last
        let cutoff = latest.timestamp - rule.time_window_secs;

        for event in events.iter().rev() {
            if event.timestamp < cutoff { break; }
            if event.id == latest.id { continue; }

            if event.behavior_type == sequence[seq_idx] {
                matched_events.push(event.clone());
                if seq_idx == 0 {
                    // Full match!
                    matched_events.reverse();
                    return Some(BehavioralMatch {
                        rule_id: rule.id.to_string(),
                        rule_name: rule.name.to_string(),
                        matched_events,
                        timestamp: latest.timestamp,
                        severity: rule.severity,
                        confidence: rule.confidence,
                        weight: rule.weight,
                        mitre_ids: rule.mitre_ids.iter().map(|s| s.to_string()).collect(),
                        description: rule.description.to_string(),
                    });
                }
                seq_idx -= 1;
            }
        }

        None
    }

    /// Get all matches.
    pub fn matches(&self) -> Vec<BehavioralMatch> {
        self.matches.read().clone()
    }

    /// Get recent matches (last N).
    pub fn recent_matches(&self, limit: usize) -> Vec<BehavioralMatch> {
        let all = self.matches.read();
        let start = all.len().saturating_sub(limit);
        all[start..].to_vec()
    }

    /// Get current compound threat score for a process.
    pub fn process_threat_score(&self, pid: u32) -> f64 {
        let all = self.matches.read();
        let weights: Vec<f64> = all.iter()
            .filter(|m| m.matched_events.iter().any(|e| e.pid == pid))
            .map(|m| m.weight)
            .collect();

        if weights.is_empty() { return 0.0; }
        {0.0_f64}
    }

    /// Get statistics.
    pub fn stats(&self) -> BehavioralIOCStats {
        self.stats.read().clone()
    }

    /// Get memory metrics.
    pub fn metrics(&self) -> &MemoryMetrics {
        &self.metrics
    }
}
