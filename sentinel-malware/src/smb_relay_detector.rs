//! Module 116: SMBRelayDetector — SMB/NTLM Relay & Pass-the-Hash Detection
//!
//! Detects SMB relay attacks, NTLM relay, pass-the-hash, and SMB-based
//! lateral movement techniques. On macOS, SMB is used for file sharing
//! and can be abused for credential theft and relay attacks.
//!
//! ## Detection Capabilities
//!
//! - **NTLM relay detection**: Detect when NTLM authentication is being
//!   relayed to a different host than the original target
//! - **Pass-the-hash**: Detect use of stolen NTLM hashes for authentication
//!   without knowing the plaintext password
//! - **SMB brute force**: Rapid failed SMB authentication attempts
//! - **Named pipe abuse**: Detection of malicious named pipe usage for
//!   command execution (PsExec, SCManager, ATSVC)
//! - **SMB signing enforcement**: Detect missing SMB signing that enables relay
//! - **Responder/Inveigh detection**: Detect LLMNR/NBT-NS/mDNS poisoning
//!   tools used to capture NTLM hashes
//! - **Impacket detection**: Detect Impacket tool family signatures
//!   (smbexec, wmiexec, atexec, dcomexec, psexec)
//! - **Lateral movement chaining**: Track SMB sessions that chain across
//!   multiple hosts indicating pivoting
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const AUTH_FAIL_THRESHOLD: u32 = 10;
const AUTH_FAIL_WINDOW_SECS: u64 = 60;
const RELAY_DETECTION_WINDOW_MS: u64 = 2000;

// ── SMB/NTLM Attack Signatures ───────────────────────────────────────────────

const MALICIOUS_NAMED_PIPES: &[(&str, &str, f64)] = &[
    ("\\PIPE\\svcctl", "SCManager remote service control (PsExec)", 0.7),
    ("\\PIPE\\atsvc", "AT Scheduler service (atexec)", 0.75),
    ("\\PIPE\\samr", "SAM Remote access (user enumeration)", 0.6),
    ("\\PIPE\\lsarpc", "LSA Remote Protocol (credential access)", 0.65),
    ("\\PIPE\\netlogon", "Netlogon (ZeroLogon vector)", 0.5),
    ("\\PIPE\\srvsvc", "Server service (share enumeration)", 0.5),
    ("\\PIPE\\epmapper", "RPC Endpoint Mapper", 0.4),
    ("\\PIPE\\wkssvc", "Workstation service", 0.4),
    ("\\PIPE\\ADMIN$", "Admin share access (lateral movement)", 0.8),
    ("\\PIPE\\C$", "C$ share access (lateral movement)", 0.75),
    ("\\PIPE\\IPC$", "IPC$ share (null session)", 0.5),
    ("\\PIPE\\RemCom", "RemCom remote command execution", 0.9),
    ("\\PIPE\\csexec", "CsExec remote execution", 0.9),
];

const IMPACKET_TOOL_SIGS: &[(&str, &str, &str, f64)] = &[
    ("psexec", "Impacket PsExec — remote service creation", "T1021.002", 0.9),
    ("smbexec", "Impacket SMBExec — SMB-based execution", "T1021.002", 0.9),
    ("wmiexec", "Impacket WMIExec — WMI-based execution", "T1047", 0.9),
    ("atexec", "Impacket AtExec — scheduled task execution", "T1053.005", 0.85),
    ("dcomexec", "Impacket DCOMExec — DCOM-based execution", "T1021.003", 0.85),
    ("secretsdump", "Impacket SecretsDump — credential dumping", "T1003", 0.95),
    ("ntlmrelayx", "Impacket NTLM Relay — authentication relay", "T1557.001", 0.95),
    ("responder", "Responder — LLMNR/NBT-NS poisoning", "T1557.001", 0.95),
    ("inveigh", "Inveigh — Windows LLMNR/mDNS poisoner", "T1557.001", 0.9),
    ("crackmapexec", "CrackMapExec — multi-protocol execution", "T1021.002", 0.9),
    ("evil-winrm", "Evil-WinRM — WinRM exploitation", "T1021.006", 0.88),
];

const SMB_LATERAL_INDICATORS: &[(&str, &str, f64)] = &[
    ("ADMIN$", "Admin share access — common lateral movement", 0.7),
    ("C$", "C$ share — file system access", 0.65),
    ("IPC$", "IPC$ null session — enumeration", 0.4),
    ("SYSVOL", "SYSVOL share — GPO access", 0.3),
    ("NETLOGON", "NETLOGON share — script access", 0.3),
    ("PRINT$", "Print share — printer exploitation", 0.4),
    ("FAX$", "Fax share — PrintNightmare vector", 0.5),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SMBThreatType {
    NTLMRelay,
    PassTheHash,
    BruteForce,
    NamedPipeAbuse,
    MissingSMBSigning,
    LLMNRPoisoning,
    NBTNSPoisoning,
    ImpacketToolUsage,
    AdminShareAccess,
    RemoteServiceCreation,
    LateralChaining,
    NullSession,
    CredentialDumping,
    SuspiciousAuthentication,
    ZeroLogonAttempt,
    PrintNightmare,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SMBThreatFinding {
    pub threat_type: SMBThreatType,
    pub source_ip: String,
    pub dest_ip: String,
    pub source_port: u16,
    pub dest_port: u16,
    pub confidence: f64,
    pub description: String,
    pub username: Option<String>,
    pub domain: Option<String>,
    pub named_pipe: Option<String>,
    pub tool_name: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SMBSession {
    pub session_id: String,
    pub source_ip: String,
    pub dest_ip: String,
    pub username: String,
    pub domain: String,
    pub auth_type: String,
    pub smb_version: u8,
    pub signing_enabled: bool,
    pub shares_accessed: Vec<String>,
    pub named_pipes_used: Vec<String>,
    pub start_time: u64,
    pub auth_attempts: u32,
    pub failed_attempts: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SMBAnalysisResult {
    pub is_malicious: bool,
    pub sessions_analyzed: u32,
    pub findings: Vec<SMBThreatFinding>,
    pub active_relays: Vec<(String, String)>,
    pub lateral_chains: Vec<Vec<String>>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SMBScanStats {
    pub total_sessions: u64,
    pub relay_detections: u64,
    pub pth_detections: u64,
    pub brute_force_detections: u64,
    pub tool_detections: u64,
    pub lateral_chains_detected: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SMBRelayConfig {
    pub enabled: bool,
    pub auth_fail_threshold: u32,
    pub auth_fail_window_secs: u64,
    pub relay_detection_window_ms: u64,
    pub monitor_named_pipes: bool,
    pub enforce_smb_signing: bool,
    pub detect_impacket: bool,
    pub track_lateral_chains: bool,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for SMBRelayConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            auth_fail_threshold: AUTH_FAIL_THRESHOLD,
            auth_fail_window_secs: AUTH_FAIL_WINDOW_SECS,
            relay_detection_window_ms: RELAY_DETECTION_WINDOW_MS,
            monitor_named_pipes: true,
            enforce_smb_signing: true,
            detect_impacket: true,
            track_lateral_chains: true,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ToolSigEntry {
    pub name: String,
    pub pattern: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct SMBRelayDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SMBScanStats>>,
    result_cache: TieredCache<String, SMBAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    session_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SMBScanStats>>,
    metrics: MemoryMetrics,
    session_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, SMBAnalysisResult>>,
    tool_sig_db: PagedMemory<ToolSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<SMBRelayConfig>,
    stats: RwLock<SMBScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_analyses: AtomicU64,
    active_sessions: RwLock<HashMap<String, SMBSession>>,
    auth_failures: RwLock<HashMap<String, Vec<u64>>>,
    lateral_graph: RwLock<HashMap<String, HashSet<String>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SMBRelayDetector {
    pub fn new() -> Self {
        let cfg = SMBRelayConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            session_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SMBScanStats::default(),
                |acc: &mut SMBScanStats, vals: &[f64]| { acc.total_sessions += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            session_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            tool_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(SMBScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_analyses: AtomicU64::new(0),
            active_sessions: RwLock::new(HashMap::new()),
            auth_failures: RwLock::new(HashMap::new()),
            lateral_graph: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_session(&self, session: &SMBSession) -> Option<SMBAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_analyses.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", session.source_ip, session.dest_ip, session.session_id);
        if let Some(cached) = self.result_cache.get(&cache_key) {
            return Some(cached);
        }

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // Check SMB signing
        if cfg.enforce_smb_signing && !session.signing_enabled {
            findings.push(SMBThreatFinding {
                threat_type: SMBThreatType::MissingSMBSigning,
                source_ip: session.source_ip.clone(),
                dest_ip: session.dest_ip.clone(),
                source_port: 0, dest_port: 445,
                confidence: 0.6,
                description: format!("SMBv{} session without signing — relay vulnerable",
                    session.smb_version),
                username: Some(session.username.clone()),
                domain: Some(session.domain.clone()),
                named_pipe: None, tool_name: None,
                mitre_id: "T1557.001".into(),
                timestamp: session.start_time,
            });
            mitre_ids.insert("T1557.001".into());
        }

        // Check brute force
        if session.failed_attempts >= cfg.auth_fail_threshold {
            findings.push(SMBThreatFinding {
                threat_type: SMBThreatType::BruteForce,
                source_ip: session.source_ip.clone(),
                dest_ip: session.dest_ip.clone(),
                source_port: 0, dest_port: 445,
                confidence: 0.85,
                description: format!("{} failed auth attempts from {}",
                    session.failed_attempts, session.source_ip),
                username: Some(session.username.clone()),
                domain: Some(session.domain.clone()),
                named_pipe: None, tool_name: None,
                mitre_id: "T1110".into(),
                timestamp: session.start_time,
            });
            mitre_ids.insert("T1110".into());
        }

        // Check named pipe usage
        if cfg.monitor_named_pipes {
            for pipe in &session.named_pipes_used {
                for &(mal_pipe, desc, conf) in MALICIOUS_NAMED_PIPES {
                    if pipe.to_uppercase().contains(&mal_pipe.to_uppercase()) {
                        findings.push(SMBThreatFinding {
                            threat_type: SMBThreatType::NamedPipeAbuse,
                            source_ip: session.source_ip.clone(),
                            dest_ip: session.dest_ip.clone(),
                            source_port: 0, dest_port: 445,
                            confidence: conf,
                            description: format!("{}: {}", pipe, desc),
                            username: Some(session.username.clone()),
                            domain: Some(session.domain.clone()),
                            named_pipe: Some(pipe.clone()),
                            tool_name: None,
                            mitre_id: "T1021.002".into(),
                            timestamp: session.start_time,
                        });
                        mitre_ids.insert("T1021.002".into());
                    }
                }
            }
        }

        // Check admin share access
        for share in &session.shares_accessed {
            for &(indicator, desc, conf) in SMB_LATERAL_INDICATORS {
                if share.to_uppercase().contains(&indicator.to_uppercase()) {
                    findings.push(SMBThreatFinding {
                        threat_type: SMBThreatType::AdminShareAccess,
                        source_ip: session.source_ip.clone(),
                        dest_ip: session.dest_ip.clone(),
                        source_port: 0, dest_port: 445,
                        confidence: conf,
                        description: format!("{}: {}", share, desc),
                        username: Some(session.username.clone()),
                        domain: Some(session.domain.clone()),
                        named_pipe: None, tool_name: None,
                        mitre_id: "T1021.002".into(),
                        timestamp: session.start_time,
                    });
                    mitre_ids.insert("T1021.002".into());
                }
            }
        }

        // Track lateral movement graph
        if cfg.track_lateral_chains {
            let mut graph = self.lateral_graph.write();
            graph.entry(session.source_ip.clone())
                .or_insert_with(HashSet::new)
                .insert(session.dest_ip.clone());
        }

        // Build lateral chains
        let lateral_chains = self.find_lateral_chains(&session.source_ip, 5);
        if lateral_chains.iter().any(|c| c.len() >= 3) {
            findings.push(SMBThreatFinding {
                threat_type: SMBThreatType::LateralChaining,
                source_ip: session.source_ip.clone(),
                dest_ip: session.dest_ip.clone(),
                source_port: 0, dest_port: 445,
                confidence: 0.85,
                description: format!("Lateral movement chain detected: {} hops from {}",
                    lateral_chains.iter().map(|c| c.len()).max().unwrap_or(0),
                    session.source_ip),
                username: Some(session.username.clone()),
                domain: Some(session.domain.clone()),
                named_pipe: None, tool_name: None,
                mitre_id: "T1021.002".into(),
                timestamp: session.start_time,
            });
            mitre_ids.insert("T1021.002".into());
        }

        // Store session diff
        self.session_diffs.write().record_insert(
            cache_key.clone(),
            format!("src={},dst={},user={},pipes={},shares={}",
                session.source_ip, session.dest_ip, session.username,
                session.named_pipes_used.len(), session.shares_accessed.len()),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = SMBAnalysisResult {
            is_malicious,
            sessions_analyzed: 1,
            findings,
            active_relays: Vec::new(),
            lateral_chains,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_sessions += 1;
            if is_malicious {
                for f in &result.findings {
                    match f.threat_type {
                        SMBThreatType::NTLMRelay => stats.relay_detections += 1,
                        SMBThreatType::PassTheHash => stats.pth_detections += 1,
                        SMBThreatType::BruteForce => stats.brute_force_detections += 1,
                        SMBThreatType::ImpacketToolUsage => stats.tool_detections += 1,
                        SMBThreatType::LateralChaining => stats.lateral_chains_detected += 1,
                        _ => {}
                    }
                }
            }
            let n = stats.total_sessions as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "smb_relay_detector".into(),
                title: format!("SMB lateral movement: {} → {}", session.source_ip, session.dest_ip),
                details: format!("Risk: {:.1}%, {} findings, user: {}\\{}",
                    risk_score * 100.0, result.findings.len(), session.domain, session.username),
                path: None,
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Enable SMB signing on all hosts".into(),
                    "Restrict admin share access".into(),
                    "Implement network segmentation".into(),
                    "Enable NTLM audit logging".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn find_lateral_chains(&self, start: &str, max_depth: usize) -> Vec<Vec<String>> {
        let graph = self.lateral_graph.read();
        let mut chains = Vec::new();
        let mut visited = HashSet::new();
        let mut stack = vec![(start.to_string(), vec![start.to_string()])];

        while let Some((node, path)) = stack.pop() {
            if path.len() > max_depth { continue; }
            if path.len() >= 3 { chains.push(path.clone()); }
            visited.insert(node.clone());
            if let Some(neighbors) = graph.get(&node) {
                for next in neighbors {
                    if !visited.contains(next) {
                        let mut new_path = path.clone();
                        new_path.push(next.clone());
                        stack.push((next.clone(), new_path));
                    }
                }
            }
        }
        chains
    }

    fn calculate_risk_score(&self, findings: &[SMBThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                SMBThreatType::NTLMRelay => 1.5,
                SMBThreatType::CredentialDumping => 1.5,
                SMBThreatType::PassTheHash => 1.4,
                SMBThreatType::ImpacketToolUsage => 1.4,
                SMBThreatType::LateralChaining => 1.3,
                SMBThreatType::RemoteServiceCreation => 1.3,
                SMBThreatType::BruteForce => 1.2,
                SMBThreatType::AdminShareAccess => 1.0,
                SMBThreatType::NamedPipeAbuse => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> SMBScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
