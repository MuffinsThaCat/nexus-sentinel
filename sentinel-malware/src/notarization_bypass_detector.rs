//! Module 125: NotarizationBypassDetector — Gatekeeper/Notarization Evasion Detection
//!
//! Detects attempts to bypass macOS Gatekeeper and Apple notarization, which
//! are the primary defenses against unsigned/unnotarized malware execution.
//!
//! ## Detection Capabilities
//!
//! - **Quarantine flag removal**: xattr -d com.apple.quarantine, xattr -c
//! - **Gatekeeper disable**: spctl --master-disable, spctl --disable
//! - **Notarization staple tampering**: Modifying stapled notarization tickets
//! - **Ad-hoc code signing**: codesign with ad-hoc identity (-)
//! - **Code signature invalidation**: Post-signing binary modification
//! - **Translated binary abuse**: Rosetta 2 translated binaries skipping checks
//! - **Archive extraction bypass**: BOMArchiveHelper, ditto, unzip bypasses
//! - **DMG/ISO mount bypass**: Mounted images bypassing Gatekeeper
//! - **Launch Services abuse**: LSQuarantine manipulation
//! - **First-open bypass**: Techniques to avoid first-open Gatekeeper check
//! - **Known bypasses**: CVE-2022-22616, CVE-2022-32910, CVE-2022-42821,
//!   Achilles, CVE-2023-27943 and similar
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const GK_BYPASS_TECHNIQUES: &[(&str, &str, &str, f64)] = &[
    ("xattr -d com.apple.quarantine", "Quarantine flag removal", "T1553.001", 0.85),
    ("xattr -c", "Clear all extended attributes", "T1553.001", 0.7),
    ("xattr -r -d com.apple.quarantine", "Recursive quarantine removal", "T1553.001", 0.9),
    ("spctl --master-disable", "Gatekeeper master disable", "T1553.001", 0.95),
    ("spctl --disable", "Gatekeeper disable", "T1553.001", 0.9),
    ("spctl --add", "Gatekeeper exception addition", "T1553.001", 0.7),
    ("spctl --assess --type execute", "Gatekeeper assessment check", "T1553.001", 0.3),
    ("codesign --force --sign -", "Ad-hoc code signing", "T1553.002", 0.7),
    ("codesign --remove-signature", "Code signature removal", "T1553.002", 0.85),
    ("codesign -f -s -", "Force ad-hoc signing", "T1553.002", 0.75),
    ("stapler validate", "Notarization ticket validation", "T1553.002", 0.3),
    ("stapler staple", "Notarization ticket stapling", "T1553.002", 0.3),
    ("defaults write LSQuarantine", "LaunchServices quarantine override", "T1553.001", 0.8),
    ("defaults write com.apple.LaunchServices", "LaunchServices config change", "T1553.001", 0.6),
    ("hdiutil attach -nobrowse", "Hidden DMG mount (bypass check)", "T1553.001", 0.5),
    ("hdiutil attach -noautoopen", "DMG mount no-auto-open", "T1553.001", 0.4),
    ("ditto --noextattr", "Copy without extended attributes", "T1553.001", 0.6),
    ("curl.*-o.*&&.*chmod.*+x", "Download and execute pattern", "T1204.002", 0.75),
    ("wget.*&&.*chmod.*+x", "Download and execute pattern", "T1204.002", 0.75),
    ("python.*urllib.*exec", "Python download-exec chain", "T1059.006", 0.7),
    ("osascript.*do shell script", "AppleScript shell execution", "T1059.002", 0.6),
];

const GK_BYPASS_CVES: &[(&str, &str, f64)] = &[
    ("CVE-2021-1810", "Gatekeeper bypass via path length", 0.95),
    ("CVE-2021-30657", "Gatekeeper bypass via script apps", 0.95),
    ("CVE-2021-30853", "Gatekeeper bypass via applet", 0.95),
    ("CVE-2022-22616", "Gatekeeper bypass via BOM archive", 0.95),
    ("CVE-2022-32910", "Gatekeeper bypass via archive utility", 0.95),
    ("CVE-2022-42821", "Achilles — Gatekeeper bypass via ACL", 0.95),
    ("CVE-2023-27943", "Gatekeeper bypass via signed DMG", 0.95),
    ("CVE-2023-40434", "Gatekeeper bypass via symlink", 0.95),
];

const UNSIGNED_BINARY_INDICATORS: &[(&str, &str, f64)] = &[
    ("not signed", "Unsigned binary execution", 0.6),
    ("invalid signature", "Invalid code signature", 0.7),
    ("revoked certificate", "Revoked signing certificate", 0.85),
    ("expired certificate", "Expired signing certificate", 0.5),
    ("untrusted certificate", "Untrusted signing certificate", 0.65),
    ("adhoc signed", "Ad-hoc signed binary", 0.5),
    ("no notarization", "Not notarized binary", 0.4),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum GKBypassType {
    QuarantineFlagRemoval,
    GatekeeperDisable,
    GatekeeperException,
    AdHocSigning,
    SignatureRemoval,
    SignatureInvalidation,
    NotarizationBypass,
    ArchiveExtractionBypass,
    DMGMountBypass,
    LaunchServicesManipulation,
    DownloadExecuteChain,
    KnownCVEExploit,
    UnsignedExecution,
    RevokedCertificate,
    TranslatedBinaryAbuse,
    AttributeStripping,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GKBypassFinding {
    pub bypass_type: GKBypassType,
    pub confidence: f64,
    pub description: String,
    pub command_line: Option<String>,
    pub target_path: Option<String>,
    pub cve_id: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GKEvent {
    pub event_type: String,
    pub process_name: String,
    pub process_pid: u32,
    pub command_line: Option<String>,
    pub file_path: Option<String>,
    pub code_sign_status: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GKAnalysisResult {
    pub is_bypass: bool,
    pub events_analyzed: u32,
    pub findings: Vec<GKBypassFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct GKScanStats {
    pub total_events: u64,
    pub bypass_detections: u64,
    pub quarantine_removals: u64,
    pub unsigned_executions: u64,
    pub cve_exploits: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GKSigEntry {
    pub pattern: String,
    pub description: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct NotarizationBypassDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<GKScanStats>>,
    result_cache: TieredCache<String, GKAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, GKScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, GKAnalysisResult>>,
    sig_db: PagedMemory<GKSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<TCCDetectorConfig>,
    stats: RwLock<GKScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCDetectorConfig {
    pub enabled: bool,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for TCCDetectorConfig {
    fn default() -> Self {
        Self { enabled: true, min_confidence: 0.5, memory_budget_bytes: 32 * 1024 * 1024 }
    }
}

impl NotarizationBypassDetector {
    pub fn new() -> Self {
        let cfg = TCCDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, GKScanStats::default(),
                |acc: &mut GKScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(GKScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &GKEvent) -> Option<GKAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.process_name, event.process_pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        let event_text = format!("{} {} {}",
            event.command_line.as_deref().unwrap_or(""),
            event.file_path.as_deref().unwrap_or(""),
            event.event_type);

        for &(pattern, desc, mitre, conf) in GK_BYPASS_TECHNIQUES {
            if event_text.to_lowercase().contains(&pattern.to_lowercase()) {
                let bt = if pattern.contains("xattr") { GKBypassType::QuarantineFlagRemoval }
                    else if pattern.contains("spctl --master") || pattern.contains("spctl --disable") { GKBypassType::GatekeeperDisable }
                    else if pattern.contains("spctl --add") { GKBypassType::GatekeeperException }
                    else if pattern.contains("codesign") && pattern.contains("-s -") { GKBypassType::AdHocSigning }
                    else if pattern.contains("--remove-signature") { GKBypassType::SignatureRemoval }
                    else if pattern.contains("hdiutil") { GKBypassType::DMGMountBypass }
                    else if pattern.contains("ditto") { GKBypassType::AttributeStripping }
                    else if pattern.contains("LSQuarantine") || pattern.contains("LaunchServices") { GKBypassType::LaunchServicesManipulation }
                    else if pattern.contains("curl") || pattern.contains("wget") || pattern.contains("python") { GKBypassType::DownloadExecuteChain }
                    else { GKBypassType::NotarizationBypass };

                findings.push(GKBypassFinding {
                    bypass_type: bt,
                    confidence: conf,
                    description: desc.to_string(),
                    command_line: event.command_line.clone(),
                    target_path: event.file_path.clone(),
                    cve_id: None,
                    mitre_id: mitre.into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // Check code sign status
        if let Some(ref cs_status) = event.code_sign_status {
            let cs_lower = cs_status.to_lowercase();
            for &(indicator, desc, conf) in UNSIGNED_BINARY_INDICATORS {
                if cs_lower.contains(indicator) {
                    let bt = if indicator.contains("revoked") { GKBypassType::RevokedCertificate }
                        else if indicator.contains("adhoc") { GKBypassType::AdHocSigning }
                        else { GKBypassType::UnsignedExecution };
                    findings.push(GKBypassFinding {
                        bypass_type: bt, confidence: conf,
                        description: format!("{}: {}", desc, event.process_name),
                        command_line: event.command_line.clone(),
                        target_path: event.file_path.clone(),
                        cve_id: None, mitre_id: "T1553.002".into(),
                        process_name: Some(event.process_name.clone()),
                        process_pid: Some(event.process_pid),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1553.002".into());
                }
            }
        }

        // Check CVEs
        for &(cve, desc, conf) in GK_BYPASS_CVES {
            if event_text.contains(cve) {
                findings.push(GKBypassFinding {
                    bypass_type: GKBypassType::KnownCVEExploit,
                    confidence: conf,
                    description: format!("{}: {}", cve, desc),
                    command_line: event.command_line.clone(),
                    target_path: event.file_path.clone(),
                    cve_id: Some(cve.into()),
                    mitre_id: "T1553.001".into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1553.001".into());
            }
        }

        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("proc={},type={}", event.process_name, event.event_type));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_bypass = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = GKAnalysisResult {
            is_bypass, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.bypass_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_bypass { s.bypass_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_bypass {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "notarization_bypass_detector".into(),
                title: format!("Gatekeeper bypass: {} (pid {})", event.process_name, event.process_pid),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: event.file_path.clone(),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid), verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Re-enable Gatekeeper: spctl --master-enable".into(),
                    "Verify quarantine attributes on downloaded files".into(),
                    "Block unsigned binary execution via MDM policy".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[GKBypassFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.bypass_type {
                GKBypassType::GatekeeperDisable => 1.5,
                GKBypassType::KnownCVEExploit => 1.5,
                GKBypassType::SignatureRemoval => 1.3,
                GKBypassType::QuarantineFlagRemoval => 1.2,
                GKBypassType::RevokedCertificate => 1.3,
                GKBypassType::DownloadExecuteChain => 1.2,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> GKScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
