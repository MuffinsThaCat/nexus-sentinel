//! Module 149: PowerAnalysisDetector — Electromagnetic & Power Side-Channel Attack Detection
//!
//! Detects power analysis, electromagnetic emanation, acoustic, and thermal
//! side-channel attacks targeting macOS systems. These attacks extract
//! cryptographic keys and sensitive data by measuring physical emissions
//! during computation.
//!
//! ## Detection Capabilities
//!
//! ### Power Analysis Attacks
//! - **Simple Power Analysis (SPA)**: Single-trace attacks that directly
//!   observe power consumption patterns during cryptographic operations
//! - **Differential Power Analysis (DPA)**: Statistical analysis across
//!   many power traces to extract key bits via data-dependent power
//!   consumption differences
//! - **Correlation Power Analysis (CPA)**: Refined DPA using Pearson
//!   correlation to model power consumption
//! - **Template attacks**: Pre-characterized power profiles matched
//!   against target device measurements
//! - **Higher-Order DPA (HO-DPA)**: Attacks that combine multiple
//!   intermediate values to defeat masking countermeasures
//!
//! ### Electromagnetic Emanation Attacks
//! - **EM probe detection**: USB devices or hardware additions that may
//!   be EM measurement probes positioned near the CPU/SoC
//! - **TEMPEST-style attacks**: Remote EM interception of display signals,
//!   keyboard emissions, or CPU computation patterns
//! - **Van Eck phreaking**: EM reconstruction of display content
//! - **Near-field EM probing**: Close-proximity EM measurement of specific
//!   chip regions (Secure Enclave, AES engine, etc.)
//!
//! ### Acoustic Side Channels
//! - **Acoustic cryptanalysis**: RSA/ECDSA key extraction via CPU coil
//!   whine during computation (Genkin et al., 2014)
//! - **Keyboard acoustic emanation**: Keystroke identification via typing
//!   sound analysis
//! - **HDD acoustic attacks**: Data-dependent acoustic emanation from
//!   mechanical hard drives
//! - **Fan noise analysis**: CPU load patterns inferred from fan speed
//!   acoustic signatures
//!
//! ### Thermal Side Channels
//! - **Thermal imaging attacks**: Infrared camera observation of keyboard
//!   heat signatures to recover recently typed passwords
//! - **CPU thermal throttling patterns**: Computation-dependent thermal
//!   behavior leaking cryptographic state
//! - **Thermal covert channels**: Cross-core/cross-VM communication via
//!   temperature modulation
//!
//! ### Software-Observable Physical Side Channels
//! - **RAPL (Running Average Power Limit) exploitation**: Intel RAPL
//!   interface leaking power consumption data (PLATYPUS attack)
//! - **Battery API abuse**: Web-based power monitoring via Battery Status
//!   API for fingerprinting and side-channel data
//! - **CPU frequency monitoring**: Monitoring frequency scaling behavior
//!   to infer computation patterns
//! - **SMC sensor monitoring**: macOS SMC sensor data (temperatures,
//!   fan speeds, power) used for side-channel inference
//! - **IOReport power monitoring**: IOKit power reporting framework data
//!   exfiltration
//!
//! ### Countermeasure Verification
//! - **Constant-time verification**: Checking that cryptographic
//!   implementations use constant-time operations
//! - **Masking verification**: Verifying Boolean/arithmetic masking in
//!   cryptographic implementations
//! - **DIT (Data Independent Timing)**: Apple Silicon DIT mode verification
//! - **Noise injection**: Verifying presence of countermeasure noise in
//!   power/EM traces
//!
//! ## MITRE ATT&CK: T1040, T1003, T1082, T1119
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const RAPL_ACCESS_THRESHOLD: u64 = 1000;
const SMC_SENSOR_ACCESS_THRESHOLD: u64 = 500;

// ── Power Side-Channel Indicators ────────────────────────────────────────────

const POWER_ATTACK_INDICATORS: &[(&str, &str, &str, f64)] = &[
    // RAPL-based attacks
    ("rapl_energy_read", "Intel RAPL energy counter read (power measurement)", "T1082", 0.5),
    ("rapl_high_rate", "High-rate RAPL reads (PLATYPUS-style power analysis)", "T1003", 0.8),
    ("rapl_pkg_energy", "RAPL package energy domain read", "T1082", 0.4),
    ("rapl_pp0_energy", "RAPL PP0 (CPU cores) energy read", "T1082", 0.4),
    ("rapl_dram_energy", "RAPL DRAM energy read", "T1082", 0.3),
    ("rapl_psys_energy", "RAPL Platform energy read (most precise)", "T1003", 0.6),
    ("msr_read_energy", "MSR energy status register direct read", "T1003", 0.7),
    ("platypus_pattern", "PLATYPUS attack pattern (RAPL during crypto)", "T1003", 0.9),
    // macOS power monitoring
    ("smc_sensor_read", "SMC sensor data read via AppleSMC", "T1082", 0.3),
    ("smc_power_sensor", "SMC power sensor read (wattage monitoring)", "T1082", 0.5),
    ("smc_high_rate_read", "High-rate SMC sensor polling (side-channel)", "T1003", 0.7),
    ("ioreport_power", "IOReport power channel monitoring", "T1082", 0.4),
    ("ioreport_energy", "IOReport energy model data access", "T1082", 0.4),
    ("powermetrics_abuse", "powermetrics tool used for power monitoring", "T1082", 0.3),
    ("ioreg_power_data", "ioreg querying power-related IOKit entries", "T1082", 0.3),
    // CPU frequency monitoring
    ("cpufreq_monitor", "CPU frequency monitoring (DVFS side channel)", "T1082", 0.4),
    ("freq_scaling_probe", "Frequency scaling behavior probing", "T1082", 0.5),
    ("turbo_boost_probe", "Turbo Boost state monitoring", "T1082", 0.3),
    ("p_state_monitor", "P-state transition monitoring", "T1082", 0.4),
    // Battery API
    ("battery_api_high_rate", "Battery Status API high-rate polling", "T1082", 0.5),
    ("battery_level_fingerprint", "Battery level used for fingerprinting", "T1082", 0.4),
    ("battery_charging_rate", "Battery charging rate monitoring", "T1082", 0.3),
];

// ── EM Emanation Indicators ──────────────────────────────────────────────────

const EM_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("usb_sdr_device", "Software-Defined Radio USB device connected (EM capture)", "T1040", 0.7),
    ("usb_oscilloscope", "USB oscilloscope connected (power/EM measurement)", "T1040", 0.6),
    ("usb_spectrum_analyzer", "USB spectrum analyzer connected", "T1040", 0.6),
    ("em_probe_detected", "Near-field EM probe hardware detected", "T1040", 0.8),
    ("display_em_leak", "Display EM emanation (Van Eck phreaking risk)", "T1040", 0.3),
    ("keyboard_em_leak", "Keyboard EM emanation detected", "T1040", 0.3),
    ("hdmi_em_signal", "HDMI EM signal interception risk", "T1040", 0.3),
    ("thunderbolt_em_risk", "Thunderbolt high-speed EM emanation", "T1040", 0.2),
    ("tempest_zone_violation", "TEMPEST zone boundary violation", "T1040", 0.5),
];

// ── Acoustic Side-Channel Indicators ─────────────────────────────────────────

const ACOUSTIC_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("microphone_during_crypto", "Microphone active during cryptographic operation", "T1003", 0.6),
    ("audio_recording_continuous", "Continuous audio recording (keystroke analysis risk)", "T1056.001", 0.5),
    ("ultrasonic_monitoring", "Ultrasonic frequency monitoring (covert channel)", "T1040", 0.7),
    ("coil_whine_pattern", "CPU coil whine correlated with computation", "T1003", 0.3),
    ("keyboard_acoustic_capture", "Keyboard acoustic signature capture", "T1056.001", 0.6),
    ("fan_speed_correlation", "Fan speed correlated with sensitive operations", "T1003", 0.3),
    ("hdd_acoustic_pattern", "HDD seek pattern acoustic analysis", "T1003", 0.3),
    ("speaker_data_exfil", "Speaker used for ultrasonic data exfiltration", "T1048", 0.7),
];

// ── Thermal Side-Channel Indicators ──────────────────────────────────────────

const THERMAL_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("thermal_camera_detected", "Thermal/IR camera device detected", "T1003", 0.6),
    ("thermal_keyboard_residue", "Thermal residue on keyboard (post-typing)", "T1003", 0.4),
    ("cpu_thermal_correlation", "CPU thermal output correlated with crypto", "T1003", 0.4),
    ("thermal_covert_channel", "Cross-core thermal covert channel detected", "T1048", 0.7),
    ("throttle_pattern_leak", "Thermal throttling pattern leaks computation", "T1003", 0.4),
    ("smc_temperature_probe", "SMC temperature sensor high-rate probing", "T1082", 0.5),
    ("gpu_thermal_leak", "GPU thermal output correlated with computation", "T1003", 0.3),
];

// ── Countermeasure Status ────────────────────────────────────────────────────

const COUNTERMEASURE_STATUS: &[(&str, &str, f64)] = &[
    ("non_constant_time_crypto", "Cryptographic operation not constant-time", 0.7),
    ("unmasked_aes", "AES implementation without masking countermeasure", 0.5),
    ("unmasked_rsa", "RSA implementation without blinding", 0.6),
    ("dit_disabled", "DIT (Data Independent Timing) not enabled on Apple Silicon", 0.5),
    ("no_rapl_restriction", "RAPL energy counters unrestricted (PLATYPUS risk)", 0.6),
    ("smc_unrestricted", "SMC sensor access unrestricted", 0.4),
    ("no_em_shielding", "No EM shielding detected on sensitive paths", 0.3),
    ("branch_dependent_crypto", "Branch-dependent code path in crypto operation", 0.6),
    ("variable_time_comparison", "Variable-time memory comparison (timing leak)", 0.5),
    ("unblinded_scalar_mult", "Unblinded elliptic curve scalar multiplication", 0.7),
];

// ── Known Power Analysis CVEs ────────────────────────────────────────────────

const POWER_ANALYSIS_CVES: &[(&str, &str, &str, f64)] = &[
    ("CVE-2020-8694", "PLATYPUS: RAPL-based power side-channel (Intel)", "rapl", 0.85),
    ("CVE-2020-8695", "PLATYPUS: Energy filtering attack variant", "rapl", 0.85),
    ("CVE-2022-23823", "Hertzbleed: CPU frequency side-channel (Intel/AMD)", "frequency", 0.8),
    ("CVE-2022-24436", "Hertzbleed variant (Intel)", "frequency", 0.8),
    ("Augury-2022", "Augury: Apple Silicon DMP side channel", "apple_dmp", 0.8),
    ("GoFetch-2024", "GoFetch: Apple M-series DMP crypto key extraction", "apple_dmp", 0.9),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum PhysicalSideChannelType {
    // Power
    SimplePowerAnalysis,
    DifferentialPowerAnalysis,
    CorrelationPowerAnalysis,
    TemplateAttack,
    RAPLAttack,
    PlatypusAttack,
    Hertzbleed,
    SMCSensorAbuse,
    IOReportAbuse,
    BatteryAPIAbuse,
    FrequencyMonitoring,
    // EM
    EMProbeDetected,
    SDRCapture,
    VanEckPhreaking,
    TEMPESTViolation,
    NearFieldEM,
    // Acoustic
    AcousticCryptanalysis,
    KeystrokeAcoustic,
    UltrasonicChannel,
    SpeakerExfiltration,
    CoilWhineAnalysis,
    // Thermal
    ThermalCamera,
    ThermalKeyboardResidue,
    ThermalCovertChannel,
    ThermalThrottleLeak,
    // Countermeasure gaps
    NonConstantTimeCrypto,
    UnmaskedCrypto,
    DITDisabled,
    UnrestrictedRAPL,
    BranchDependentCrypto,
    // CVE
    KnownCVEExploit,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PhysicalSCFinding {
    pub channel_type: PhysicalSideChannelType,
    pub confidence: f64,
    pub description: String,
    pub attack_method: Option<String>,
    pub cve_id: Option<String>,
    pub sensor_name: Option<String>,
    pub access_rate: Option<u64>,
    pub device_name: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub countermeasure: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PowerEvent {
    pub event_type: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub sensor_name: Option<String>,
    pub sensor_access_rate: Option<u64>,
    pub rapl_domain: Option<String>,
    pub rapl_energy_uj: Option<u64>,
    pub smc_key: Option<String>,
    pub smc_value: Option<f64>,
    pub cpu_frequency_mhz: Option<u64>,
    pub device_connected: Option<String>,
    pub device_vendor_id: Option<String>,
    pub microphone_active: bool,
    pub crypto_operation_active: bool,
    pub integrity_check: Option<String>,
    pub countermeasure_status: Vec<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PowerAnalysisResult {
    pub is_attack: bool,
    pub events_analyzed: u32,
    pub findings: Vec<PhysicalSCFinding>,
    pub channel_types: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PowerAnalysisScanStats {
    pub total_events: u64,
    pub attack_detections: u64,
    pub power_attack_detections: u64,
    pub em_attack_detections: u64,
    pub acoustic_attack_detections: u64,
    pub thermal_attack_detections: u64,
    pub countermeasure_gaps: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PowerSigEntry { pub pattern: String, pub channel: String, pub severity: f64 }

pub struct PowerAnalysisDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<PowerAnalysisScanStats>>,
    result_cache: TieredCache<String, PowerAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    power_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, PowerAnalysisScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, PowerAnalysisResult>>,
    sig_db: PagedMemory<PowerSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<PowerAnalysisScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl PowerAnalysisDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            power_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, PowerAnalysisScanStats::default(),
                |acc: &mut PowerAnalysisScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(PowerAnalysisScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &PowerEvent) -> Option<PowerAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("power:{}:{}:{}", event.event_type, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut channels = HashSet::new();

        let ind_text = format!("{} {}",
            event.event_type, event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. Power attack indicators ──────────────────────────────────
        for &(pattern, desc, mitre, conf) in POWER_ATTACK_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("platypus") => PhysicalSideChannelType::PlatypusAttack,
                    p if p.contains("rapl") || p.contains("msr_read") => PhysicalSideChannelType::RAPLAttack,
                    p if p.contains("smc") && p.contains("high_rate") => PhysicalSideChannelType::SMCSensorAbuse,
                    p if p.contains("smc") => PhysicalSideChannelType::SMCSensorAbuse,
                    p if p.contains("ioreport") => PhysicalSideChannelType::IOReportAbuse,
                    p if p.contains("battery") => PhysicalSideChannelType::BatteryAPIAbuse,
                    p if p.contains("freq") || p.contains("turbo") || p.contains("p_state") => PhysicalSideChannelType::FrequencyMonitoring,
                    _ => PhysicalSideChannelType::SimplePowerAnalysis,
                };
                findings.push(PhysicalSCFinding {
                    channel_type: tt, confidence: conf, description: desc.to_string(),
                    attack_method: Some(pattern.to_string()),
                    cve_id: None, sensor_name: event.sensor_name.clone(),
                    access_rate: event.sensor_access_rate,
                    device_name: event.device_connected.clone(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    countermeasure: None, mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                channels.insert("Power".to_string());
            }
        }

        // RAPL rate threshold
        if let Some(rate) = event.sensor_access_rate {
            if ind_lower.contains("rapl") && rate > RAPL_ACCESS_THRESHOLD {
                findings.push(PhysicalSCFinding {
                    channel_type: PhysicalSideChannelType::PlatypusAttack,
                    confidence: 0.8,
                    description: format!("RAPL access rate {} reads/sec (PLATYPUS threshold: {})", rate, RAPL_ACCESS_THRESHOLD),
                    attack_method: Some("platypus_rapl".into()), cve_id: Some("CVE-2020-8694".into()),
                    sensor_name: event.rapl_domain.clone(), access_rate: Some(rate),
                    device_name: None, process_name: event.process_name.clone(),
                    process_pid: event.process_pid, countermeasure: None,
                    mitre_id: "T1003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1003".into());
                channels.insert("RAPL".to_string());
            }
            if ind_lower.contains("smc") && rate > SMC_SENSOR_ACCESS_THRESHOLD {
                findings.push(PhysicalSCFinding {
                    channel_type: PhysicalSideChannelType::SMCSensorAbuse,
                    confidence: 0.7,
                    description: format!("SMC sensor access rate {} reads/sec", rate),
                    attack_method: Some("smc_power_analysis".into()), cve_id: None,
                    sensor_name: event.smc_key.clone(), access_rate: Some(rate),
                    device_name: None, process_name: event.process_name.clone(),
                    process_pid: event.process_pid, countermeasure: None,
                    mitre_id: "T1082".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1082".into());
                channels.insert("SMC".to_string());
            }
        }

        // ── 2. EM emanation indicators ──────────────────────────────────
        for &(pattern, desc, mitre, conf) in EM_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("sdr") => PhysicalSideChannelType::SDRCapture,
                    p if p.contains("oscilloscope") || p.contains("spectrum") => PhysicalSideChannelType::EMProbeDetected,
                    p if p.contains("em_probe") => PhysicalSideChannelType::NearFieldEM,
                    p if p.contains("van_eck") || p.contains("display_em") || p.contains("hdmi") => PhysicalSideChannelType::VanEckPhreaking,
                    p if p.contains("tempest") => PhysicalSideChannelType::TEMPESTViolation,
                    _ => PhysicalSideChannelType::EMProbeDetected,
                };
                findings.push(PhysicalSCFinding {
                    channel_type: tt, confidence: conf, description: desc.to_string(),
                    attack_method: Some(pattern.to_string()), cve_id: None,
                    sensor_name: None, access_rate: None,
                    device_name: event.device_connected.clone(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    countermeasure: None, mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                channels.insert("EM".to_string());
            }
        }

        // ── 3. Acoustic indicators ──────────────────────────────────────
        for &(pattern, desc, mitre, conf) in ACOUSTIC_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("microphone") && p.contains("crypto") => PhysicalSideChannelType::AcousticCryptanalysis,
                    p if p.contains("keyboard") => PhysicalSideChannelType::KeystrokeAcoustic,
                    p if p.contains("ultrasonic") => PhysicalSideChannelType::UltrasonicChannel,
                    p if p.contains("speaker") => PhysicalSideChannelType::SpeakerExfiltration,
                    p if p.contains("coil_whine") => PhysicalSideChannelType::CoilWhineAnalysis,
                    _ => PhysicalSideChannelType::AcousticCryptanalysis,
                };
                findings.push(PhysicalSCFinding {
                    channel_type: tt, confidence: conf, description: desc.to_string(),
                    attack_method: Some(pattern.to_string()), cve_id: None,
                    sensor_name: None, access_rate: None, device_name: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    countermeasure: None, mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                channels.insert("Acoustic".to_string());
            }
        }

        // Microphone + crypto correlation
        if event.microphone_active && event.crypto_operation_active {
            findings.push(PhysicalSCFinding {
                channel_type: PhysicalSideChannelType::AcousticCryptanalysis,
                confidence: 0.7,
                description: "Microphone active during cryptographic operation (acoustic cryptanalysis risk)".into(),
                attack_method: Some("acoustic_crypto".into()), cve_id: None,
                sensor_name: Some("microphone".into()), access_rate: None, device_name: None,
                process_name: event.process_name.clone(), process_pid: event.process_pid,
                countermeasure: None, mitre_id: "T1003".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1003".into());
            channels.insert("Acoustic".to_string());
        }

        // ── 4. Thermal indicators ───────────────────────────────────────
        for &(pattern, desc, mitre, conf) in THERMAL_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("camera") => PhysicalSideChannelType::ThermalCamera,
                    p if p.contains("keyboard") => PhysicalSideChannelType::ThermalKeyboardResidue,
                    p if p.contains("covert") => PhysicalSideChannelType::ThermalCovertChannel,
                    p if p.contains("throttle") || p.contains("smc_temperature") => PhysicalSideChannelType::ThermalThrottleLeak,
                    _ => PhysicalSideChannelType::ThermalThrottleLeak,
                };
                findings.push(PhysicalSCFinding {
                    channel_type: tt, confidence: conf, description: desc.to_string(),
                    attack_method: Some(pattern.to_string()), cve_id: None,
                    sensor_name: event.sensor_name.clone(), access_rate: None,
                    device_name: event.device_connected.clone(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    countermeasure: None, mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                channels.insert("Thermal".to_string());
            }
        }

        // ── 5. Countermeasure gaps ──────────────────────────────────────
        for &(pattern, desc, conf) in COUNTERMEASURE_STATUS {
            if event.countermeasure_status.iter().any(|s| s.to_lowercase().contains(&pattern.to_lowercase())) {
                let tt = match pattern {
                    p if p.contains("constant_time") || p.contains("variable_time") => PhysicalSideChannelType::NonConstantTimeCrypto,
                    p if p.contains("unmasked") || p.contains("unblinded") => PhysicalSideChannelType::UnmaskedCrypto,
                    p if p.contains("dit") => PhysicalSideChannelType::DITDisabled,
                    p if p.contains("rapl") => PhysicalSideChannelType::UnrestrictedRAPL,
                    p if p.contains("branch") => PhysicalSideChannelType::BranchDependentCrypto,
                    _ => PhysicalSideChannelType::NonConstantTimeCrypto,
                };
                findings.push(PhysicalSCFinding {
                    channel_type: tt, confidence: conf, description: desc.to_string(),
                    attack_method: None, cve_id: None, sensor_name: None, access_rate: None,
                    device_name: None, process_name: event.process_name.clone(),
                    process_pid: event.process_pid,
                    countermeasure: Some(pattern.to_string()),
                    mitre_id: "T1082".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1082".into());
                channels.insert("CountermeasureGap".to_string());
            }
        }

        // ── 6. Known CVE matching ───────────────────────────────────────
        for &(cve, desc, variant, conf) in POWER_ANALYSIS_CVES {
            if ind_lower.contains(&cve.to_lowercase()) || ind_lower.contains(&variant.to_lowercase()) {
                findings.push(PhysicalSCFinding {
                    channel_type: PhysicalSideChannelType::KnownCVEExploit,
                    confidence: conf, description: format!("{}: {}", cve, desc),
                    attack_method: Some(variant.to_string()),
                    cve_id: Some(cve.to_string()),
                    sensor_name: None, access_rate: None, device_name: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    countermeasure: None, mitre_id: "T1003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1003".into());
                channels.insert("KnownCVE".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},pid={},findings={}", event.event_type, pid, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_attack = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let chan_vec: Vec<String> = channels.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = PowerAnalysisResult {
            is_attack, events_analyzed: 1, findings,
            channel_types: chan_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_attack {
                s.attack_detections += 1;
                for f in &result.findings {
                    match f.channel_type {
                        PhysicalSideChannelType::SimplePowerAnalysis | PhysicalSideChannelType::DifferentialPowerAnalysis |
                        PhysicalSideChannelType::CorrelationPowerAnalysis | PhysicalSideChannelType::TemplateAttack |
                        PhysicalSideChannelType::RAPLAttack | PhysicalSideChannelType::PlatypusAttack |
                        PhysicalSideChannelType::Hertzbleed | PhysicalSideChannelType::SMCSensorAbuse |
                        PhysicalSideChannelType::IOReportAbuse | PhysicalSideChannelType::BatteryAPIAbuse |
                        PhysicalSideChannelType::FrequencyMonitoring => s.power_attack_detections += 1,
                        PhysicalSideChannelType::EMProbeDetected | PhysicalSideChannelType::SDRCapture |
                        PhysicalSideChannelType::VanEckPhreaking | PhysicalSideChannelType::TEMPESTViolation |
                        PhysicalSideChannelType::NearFieldEM => s.em_attack_detections += 1,
                        PhysicalSideChannelType::AcousticCryptanalysis | PhysicalSideChannelType::KeystrokeAcoustic |
                        PhysicalSideChannelType::UltrasonicChannel | PhysicalSideChannelType::SpeakerExfiltration |
                        PhysicalSideChannelType::CoilWhineAnalysis => s.acoustic_attack_detections += 1,
                        PhysicalSideChannelType::ThermalCamera | PhysicalSideChannelType::ThermalKeyboardResidue |
                        PhysicalSideChannelType::ThermalCovertChannel | PhysicalSideChannelType::ThermalThrottleLeak =>
                            s.thermal_attack_detections += 1,
                        PhysicalSideChannelType::NonConstantTimeCrypto | PhysicalSideChannelType::UnmaskedCrypto |
                        PhysicalSideChannelType::DITDisabled | PhysicalSideChannelType::UnrestrictedRAPL |
                        PhysicalSideChannelType::BranchDependentCrypto => s.countermeasure_gaps += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_attack {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "power_analysis_detector".into(),
                title: format!("PHYSICAL SIDE-CHANNEL: {} ({})",
                    result.channel_types.join(", "),
                    event.process_name.as_deref().unwrap_or("unknown")),
                details: format!("Risk {:.1}%, {} findings, channels: {}",
                    risk_score * 100.0, result.findings.len(),
                    result.channel_types.join(", ")),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Restrict RAPL access: remove unprivileged MSR access".into(),
                    "Enable DIT on Apple Silicon for constant-time crypto".into(),
                    "Use constant-time cryptographic libraries (libsodium, BoringSSL)".into(),
                    "Inspect for unauthorized USB devices (SDR, oscilloscope)".into(),
                    "Consider EM shielding for high-security environments".into(),
                    "Disable microphone during sensitive operations".into(),
                    "Update macOS to latest security patches".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[PhysicalSCFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.channel_type {
                PhysicalSideChannelType::PlatypusAttack => 1.7,
                PhysicalSideChannelType::KnownCVEExploit => 1.6,
                PhysicalSideChannelType::AcousticCryptanalysis => 1.5,
                PhysicalSideChannelType::NearFieldEM => 1.5,
                PhysicalSideChannelType::ThermalCovertChannel | PhysicalSideChannelType::UltrasonicChannel => 1.5,
                PhysicalSideChannelType::SpeakerExfiltration => 1.4,
                PhysicalSideChannelType::DifferentialPowerAnalysis | PhysicalSideChannelType::CorrelationPowerAnalysis => 1.4,
                PhysicalSideChannelType::RAPLAttack => 1.3,
                PhysicalSideChannelType::Hertzbleed | PhysicalSideChannelType::FrequencyMonitoring => 1.2,
                PhysicalSideChannelType::EMProbeDetected | PhysicalSideChannelType::SDRCapture => 1.3,
                PhysicalSideChannelType::NonConstantTimeCrypto | PhysicalSideChannelType::UnmaskedCrypto => 1.0,
                PhysicalSideChannelType::DITDisabled | PhysicalSideChannelType::BranchDependentCrypto => 0.9,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> PowerAnalysisScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
