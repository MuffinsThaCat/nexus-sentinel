//! Module 85: CryptominerDetector — Cryptocurrency Mining Malware Detection
//!
//! World-class detection engine for unauthorized cryptocurrency mining (cryptojacking)
//! targeting CPUs, GPUs, and browser-based mining. Detects Monero (XMR), Ethereum,
//! Bitcoin, and altcoin miners through behavioral analysis, network signatures,
//! stratum protocol detection, and resource consumption anomaly detection.
//!
//! ## Features
//!
//! - **Stratum protocol detection**: Identifies Stratum V1/V2 mining pool connections
//!   via JSON-RPC patterns (mining.subscribe, mining.authorize, mining.submit)
//! - **CPU usage anomaly detection**: Detects sustained high CPU usage (>80%) with
//!   specific instruction patterns (AES-NI, RandomX, CryptoNight, Ethash)
//! - **GPU mining detection**: Monitors GPU utilization, CUDA/OpenCL kernel launches,
//!   and VRAM usage patterns characteristic of GPU mining
//! - **Known mining pool blocking**: Database of 200+ mining pool domains and IPs
//!   (pool.minergate.com, xmr.pool.minergate.com, etc.)
//! - **Process behavioral analysis**: Identifies mining processes via command-line
//!   arguments (--algo, --pool, --wallet, --threads, --donate-level)
//! - **Browser-based mining detection**: Detects CoinHive, Coinimp, CryptoLoot,
//!   and WebAssembly-based miners in browser processes
//! - **Known miner binary signatures**: SHA-256/fuzzy hash database of known miners
//!   (XMRig, PhoenixMiner, T-Rex, lolMiner, NBMiner, Claymore)
//! - **DNS-based detection**: Monitors DNS queries for mining pool domain patterns
//! - **Network traffic analysis**: Detects mining traffic on non-standard ports
//!   and encrypted Stratum connections (stratum+ssl://)
//! - **Container cryptojacking**: Detects mining in Docker/K8s containers via
//!   resource consumption and process analysis
//! - **Fileless mining detection**: Identifies PowerShell/Python one-liner miners
//!   and in-memory mining payloads
//! - **Wallet address extraction**: Extracts cryptocurrency wallet addresses from
//!   process memory and network traffic for attribution
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) mining event history
//! - **#2  TieredCache** — Hot cache for recent mining detections
//! - **#3  ReversibleComputation** — Recompute mining risk scores
//! - **#5  StreamAccumulator** — Streaming CPU/GPU usage rate
//! - **#6  MemoryMetrics** — Bounded memory for detection data
//! - **#461 DifferentialStore** — Track resource usage diffs
//! - **#569 PruningMap** — Auto-expire old mining events
//! - **#592 DedupStore** — Deduplicate identical mining alerts
//! - **#627 SparseMatrix** — Process × mining-indicator matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1496 — Resource Hijacking
//! - T1059.001 — Command and Scripting Interpreter: PowerShell
//! - T1059.006 — Command and Scripting Interpreter: Python
//! - T1071.001 — Application Layer Protocol: Web Protocols
//! - T1027 — Obfuscated Files or Information

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const MINER_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 20 * 1024 * 1024;

/// CPU usage threshold for mining detection (percentage)
const CPU_THRESHOLD: f64 = 80.0;
/// GPU usage threshold for mining detection (percentage)
const GPU_THRESHOLD: f64 = 90.0;
/// Sustained usage window (seconds) before alerting
const SUSTAINED_USAGE_WINDOW: u64 = 300;

/// Known mining pool domains (partial list — production would have 1000+)
const MINING_POOL_DOMAINS: &[(&str, &str)] = &[
    ("pool.minergate.com",       "MinerGate — multi-coin pool"),
    ("xmr.pool.minergate.com",   "MinerGate XMR pool"),
    ("pool.supportxmr.com",      "SupportXMR pool"),
    ("xmrpool.eu",               "XMRPool EU"),
    ("pool.hashvault.pro",       "HashVault pool"),
    ("gulf.moneroocean.stream",  "MoneroOcean pool"),
    ("pool.minexmr.com",         "MineXMR pool"),
    ("xmr-eu1.nanopool.org",     "Nanopool XMR EU"),
    ("xmr-us-east1.nanopool.org","Nanopool XMR US East"),
    ("xmr.2miners.com",          "2Miners XMR"),
    ("pool.xmr.pt",              "XMR.PT pool"),
    ("monerohash.com",           "MoneroHash"),
    ("stratum+tcp://",           "Stratum protocol (any pool)"),
    ("stratum+ssl://",           "Stratum SSL protocol"),
    ("eth.2miners.com",          "2Miners ETH"),
    ("us1.ethermine.org",        "Ethermine US"),
    ("eu1.ethermine.org",        "Ethermine EU"),
    ("pool.binance.com",         "Binance mining pool"),
    ("f2pool.com",               "F2Pool"),
    ("antpool.com",              "AntPool"),
    ("viathink.com",             "ViaBTC pool"),
    ("nicehash.com",             "NiceHash"),
    ("unmineable.com",           "Unmineable multi-coin"),
    ("herominers.com",           "HeroMiners pool"),
    ("c3pool.com",               "C3Pool"),
    ("hashrate.to",              "Hashrate.to pool"),
];

/// Known miner binaries and their command-line signatures
const MINER_SIGNATURES: &[(&str, &str, f64)] = &[
    ("xmrig",           "XMRig — Monero CPU/GPU miner",              0.98),
    ("xmr-stak",        "XMR-STAK — Monero miner",                   0.98),
    ("cpuminer",        "CPUMiner — multi-algorithm CPU miner",      0.95),
    ("cgminer",         "CGMiner — Bitcoin/altcoin miner",           0.95),
    ("bfgminer",        "BFGMiner — modular ASIC/FPGA miner",       0.90),
    ("ethminer",        "Ethminer — Ethereum miner",                 0.95),
    ("phoenixminer",    "PhoenixMiner — Ethash GPU miner",           0.98),
    ("t-rex",           "T-Rex — NVIDIA GPU miner",                  0.95),
    ("lolminer",        "lolMiner — multi-algo GPU miner",           0.95),
    ("nbminer",         "NBMiner — multi-algo GPU miner",            0.95),
    ("claymore",        "Claymore — dual ETH+DCR miner",             0.95),
    ("teamredminer",    "TeamRedMiner — AMD GPU miner",              0.95),
    ("gminer",          "GMiner — multi-algo miner",                 0.95),
    ("miniZ",           "MiniZ — Equihash miner",                    0.90),
    ("nanominer",       "Nanominer — multi-algo miner",              0.95),
    ("srbminer",        "SRBMiner — multi-algo miner",               0.90),
    ("wildrig",         "WildRig — multi-algo miner",                0.90),
    ("ccminer",         "CCMiner — CUDA miner",                      0.90),
    ("minergate-cli",   "MinerGate CLI miner",                       0.95),
    ("coinhive",        "CoinHive — browser miner (deprecated)",     0.98),
    ("cryptoloot",      "CryptoLoot — browser miner",                0.95),
    ("coinimp",         "CoinImp — browser miner",                   0.95),
    ("webmine",         "WebMine — browser miner",                   0.90),
    ("jsecoin",         "JSEcoin — browser miner",                   0.90),
];

/// Mining algorithm names found in command lines
const MINING_ALGORITHMS: &[(&str, &str)] = &[
    ("randomx",      "RandomX (Monero)"),
    ("cryptonight",  "CryptoNight (Monero legacy)"),
    ("ethash",       "Ethash (Ethereum)"),
    ("etchash",      "Etchash (Ethereum Classic)"),
    ("kawpow",       "KawPow (Ravencoin)"),
    ("equihash",     "Equihash (Zcash)"),
    ("autolykos",    "Autolykos (Ergo)"),
    ("sha256",       "SHA-256 (Bitcoin)"),
    ("scrypt",       "Scrypt (Litecoin)"),
    ("x11",          "X11 (Dash)"),
    ("blake2s",      "Blake2s"),
    ("ghostrider",   "GhostRider"),
    ("firopow",      "FiroPow (Firo)"),
    ("progpow",      "ProgPoW"),
    ("argon2",       "Argon2"),
];

/// Stratum protocol JSON-RPC methods
const STRATUM_METHODS: &[(&str, f64, &str)] = &[
    ("mining.subscribe",    0.95, "Stratum subscribe — pool connection init"),
    ("mining.authorize",    0.98, "Stratum authorize — wallet authentication"),
    ("mining.submit",       0.98, "Stratum submit — share submission"),
    ("mining.notify",       0.90, "Stratum notify — new work from pool"),
    ("mining.set_difficulty",0.85, "Stratum difficulty change"),
    ("mining.set_target",   0.85, "Stratum target change"),
    ("eth_submitWork",      0.95, "Ethereum Stratum submit"),
    ("eth_getWork",         0.90, "Ethereum Stratum get work"),
    ("login",               0.60, "XMRig/Monero pool login"),
    ("submit",              0.50, "Generic share submit"),
    ("job",                 0.50, "Generic job notification"),
];

/// Mining-related command-line arguments
const MINING_CLI_ARGS: &[(&str, f64, &str)] = &[
    ("--algo",         0.80, "Mining algorithm specification"),
    ("--pool",         0.90, "Mining pool address"),
    ("--wallet",       0.90, "Wallet address"),
    ("--user",         0.50, "Pool username (may be wallet)"),
    ("--pass",         0.40, "Pool password"),
    ("--threads",      0.30, "Thread count (ambiguous)"),
    ("--donate-level", 0.98, "XMRig donation level — definitive miner"),
    ("--coin",         0.85, "Coin specification"),
    ("--rig-id",       0.90, "Rig identifier"),
    ("-o stratum",     0.95, "Stratum pool connection"),
    ("--tls",          0.40, "TLS (ambiguous without context)"),
    ("--nicehash",     0.95, "NiceHash compatibility mode"),
    ("--keepalive",    0.30, "Keep-alive (ambiguous)"),
    ("--randomx",      0.95, "RandomX algorithm"),
    ("--opencl",       0.60, "OpenCL device selection"),
    ("--cuda",         0.60, "CUDA device selection"),
];

/// Cryptocurrency wallet address patterns (regex-like descriptions)
const WALLET_PATTERNS: &[(&str, &str, &str)] = &[
    ("4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}", "Monero (XMR)",    "95-char base58 starting with 4"),
    ("0x[0-9a-fA-F]{40}",                  "Ethereum (ETH)",   "0x + 40 hex chars"),
    ("[13][a-km-zA-HJ-NP-Z1-9]{25,34}",   "Bitcoin (BTC)",    "Legacy P2PKH/P2SH address"),
    ("bc1[0-9a-z]{39,59}",                 "Bitcoin (BTC)",    "Bech32 SegWit address"),
    ("t1[a-zA-Z0-9]{33}",                  "Zcash (ZEC)",      "Transparent address"),
    ("D[5-9A-HJ-NP-U][1-9A-HJ-NP-Za-km-z]{32}", "Dogecoin",  "P2PKH address"),
    ("L[a-km-zA-HJ-NP-Z1-9]{26,33}",      "Litecoin (LTC)",   "Legacy address"),
    ("r[0-9a-zA-Z]{24,34}",                "XRP",              "Ripple address"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum MiningIndicator {
    KnownMinerBinary, StratumProtocol, MiningPoolConnection, MiningCLIArgs,
    HighCPUUsage, HighGPUUsage, BrowserMining, WalletAddress,
    MiningAlgorithm, DNSPoolQuery, FilelessMining, ContainerMining,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MiningEvent {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub process_name: String,
    pub process_id: u32,
    pub process_path: String,
    pub command_line: String,
    pub mining_indicators: Vec<MiningIndicator>,
    pub miner_name: Option<String>,
    pub algorithm: Option<String>,
    pub pool_address: Option<String>,
    pub wallet_address: Option<String>,
    pub coin: Option<String>,
    pub cpu_usage: f64,
    pub gpu_usage: f64,
    pub stratum_methods: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct CryptominerStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub known_miners_found: u64,
    pub stratum_connections: u64,
    pub pool_connections: u64,
    pub high_cpu_alerts: u64,
    pub high_gpu_alerts: u64,
    pub browser_miners: u64,
    pub wallet_addresses_extracted: u64,
    pub fileless_miners: u64,
    pub container_miners: u64,
    pub blocked_processes: u64,
    pub unique_pools_seen: u64,
}

pub struct CryptominerDetector {
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<CryptominerStats>>,
    event_cache: TieredCache<String, MiningEvent>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_rate: RwLock<StreamAccumulator<f64, CryptominerStats>>,
    metrics: MemoryMetrics,
    resource_diffs: RwLock<DifferentialStore<String, String>>,
    recent_events: RwLock<PruningMap<String, MiningEvent>>,
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    process_indicator_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Per-process CPU usage history: pid → VecDeque<(timestamp, cpu%)>
    cpu_history: RwLock<HashMap<u32, VecDeque<(i64, f64)>>>,
    /// Known mining pool IPs/domains seen
    pools_seen: RwLock<HashMap<String, u64>>,
    stats: RwLock<CryptominerStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl CryptominerDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(MINER_CACHE_MAX)
            .with_metrics(metrics.clone(), "miner_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, CryptominerStats::default(),
            |acc: &mut CryptominerStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            resource_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(MINER_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            process_indicator_matrix: RwLock::new(SparseMatrix::new(0u64)),
            cpu_history: RwLock::new(HashMap::new()),
            pools_seen: RwLock::new(HashMap::new()),
            stats: RwLock::new(CryptominerStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("cryptominer", MEMORY_BUDGET / 2);
        info!("CryptominerDetector started — {} pools, {} miner sigs, {} algorithms",
            MINING_POOL_DOMAINS.len(), MINER_SIGNATURES.len(), MINING_ALGORITHMS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("CryptominerDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn check_miner_binary(name: &str) -> Option<(&'static str, f64)> {
        let name_lower = name.to_lowercase();
        MINER_SIGNATURES.iter()
            .find(|(sig, _, _)| name_lower.contains(sig))
            .map(|(_, desc, risk)| (*desc, *risk))
    }

    fn check_pool_domain(domain: &str) -> Option<&'static str> {
        let domain_lower = domain.to_lowercase();
        MINING_POOL_DOMAINS.iter()
            .find(|(pool, _)| domain_lower.contains(pool))
            .map(|(_, desc)| *desc)
    }

    /// Analyze a process for mining indicators.
    pub fn analyze_process(
        &self, process_name: &str, pid: u32, process_path: &str,
        command_line: &str, cpu_usage: f64, gpu_usage: f64,
    ) -> Option<MiningEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let cmd_lower = command_line.to_lowercase();
        let mut mining_indicators = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut miner_name: Option<String> = None;
        let mut algorithm: Option<String> = None;
        let mut pool_address: Option<String> = None;
        let mut wallet_address: Option<String> = None;
        let mut coin: Option<String> = None;
        let mut max_risk: f64 = 0.0;

        // ── 1. Known miner binary ──
        if let Some((desc, risk)) = Self::check_miner_binary(process_name) {
            miner_name = Some(desc.to_string());
            indicators.push(format!("Known miner binary: {} — {}", process_name, desc));
            mining_indicators.push(MiningIndicator::KnownMinerBinary);
            self.stats.write().known_miners_found += 1;
            max_risk = max_risk.max(risk);
        }

        // ── 2. CLI argument analysis ──
        for &(arg, risk, desc) in MINING_CLI_ARGS {
            if cmd_lower.contains(arg) {
                indicators.push(format!("Mining CLI arg: {} — {}", arg, desc));
                mining_indicators.push(MiningIndicator::MiningCLIArgs);
                max_risk = max_risk.max(risk);
            }
        }

        // ── 3. Algorithm detection ──
        for &(algo, desc) in MINING_ALGORITHMS {
            if cmd_lower.contains(algo) {
                algorithm = Some(desc.to_string());
                indicators.push(format!("Mining algorithm: {} — {}", algo, desc));
                mining_indicators.push(MiningIndicator::MiningAlgorithm);
                max_risk = max_risk.max(0.85);
            }
        }

        // ── 4. Pool address detection ──
        for &(pool, desc) in MINING_POOL_DOMAINS {
            if cmd_lower.contains(pool) {
                pool_address = Some(pool.to_string());
                indicators.push(format!("Mining pool: {} — {}", pool, desc));
                mining_indicators.push(MiningIndicator::MiningPoolConnection);
                self.stats.write().pool_connections += 1;
                *self.pools_seen.write().entry(pool.to_string()).or_insert(0) += 1;
                max_risk = max_risk.max(0.95);
            }
        }

        // ── 5. CPU usage anomaly ──
        if cpu_usage > CPU_THRESHOLD {
            let mut history = self.cpu_history.write();
            let entry = history.entry(pid).or_insert_with(VecDeque::new);
            entry.push_back((now, cpu_usage));
            if entry.len() > 60 { entry.pop_front(); }

            // Check sustained high usage
            let sustained = entry.iter().all(|(_, cpu)| *cpu > CPU_THRESHOLD);
            if sustained && entry.len() >= 5 {
                indicators.push(format!("Sustained high CPU: {:.1}% for {} samples",
                    cpu_usage, entry.len()));
                mining_indicators.push(MiningIndicator::HighCPUUsage);
                self.stats.write().high_cpu_alerts += 1;
                max_risk = max_risk.max(0.6);
            }
        }

        // ── 6. GPU usage anomaly ──
        if gpu_usage > GPU_THRESHOLD {
            indicators.push(format!("High GPU usage: {:.1}%", gpu_usage));
            mining_indicators.push(MiningIndicator::HighGPUUsage);
            self.stats.write().high_gpu_alerts += 1;
            max_risk = max_risk.max(0.65);
        }

        // ── 7. Browser mining detection ──
        let browser_names = ["chrome", "firefox", "safari", "edge", "brave", "opera"];
        if browser_names.iter().any(|b| process_name.to_lowercase().contains(b)) && cpu_usage > 60.0 {
            indicators.push(format!("Browser process {} with high CPU: {:.1}%", process_name, cpu_usage));
            mining_indicators.push(MiningIndicator::BrowserMining);
            self.stats.write().browser_miners += 1;
            max_risk = max_risk.max(0.70);
        }

        if mining_indicators.is_empty() { return None; }

        mining_indicators.sort();
        mining_indicators.dedup();
        mitre_techniques.push("T1496".to_string());
        if miner_name.is_some() { mitre_techniques.push("T1059.006".to_string()); }

        self.stats.write().unique_pools_seen = self.pools_seen.read().len() as u64;

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.7 + mining_indicators.len() as f64 * 0.08).min(0.99);
        let blocked = matches!(severity, Severity::Critical | Severity::High);

        self.stats.write().threats_detected += 1;
        if blocked { self.stats.write().blocked_processes += 1; }

        let stratum_methods: Vec<String> = STRATUM_METHODS.iter()
            .filter(|(method, _, _)| cmd_lower.contains(method))
            .map(|(method, _, _)| method.to_string())
            .collect();
        if !stratum_methods.is_empty() {
            self.stats.write().stratum_connections += 1;
        }

        let event = MiningEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, severity, confidence,
            process_name: process_name.to_string(), process_id: pid,
            process_path: process_path.to_string(),
            command_line: command_line.to_string(),
            mining_indicators, miner_name, algorithm, pool_address,
            wallet_address, coin, cpu_usage, gpu_usage,
            stratum_methods, indicators, mitre_techniques, blocked,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(
            event.id.clone(), event.clone(), confidence);
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.risk_computer.write().push(1.0f64);
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.process_indicator_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.resource_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );

        // Update matrix
        for mi in &event.mining_indicators {
            let c = *self.process_indicator_matrix.read()
                .get(&process_name.to_string(), &format!("{:?}", mi));
            self.process_indicator_matrix.write()
                .set(process_name.to_string(), format!("{:?}", mi), c + 1);
        }

        if blocked { warn!("CRYPTOMINER: {} (PID {}) — {:?}", process_name, pid, event.miner_name); }
        Some(event)
    }

    /// Check if a DNS query targets a mining pool.
    pub fn check_dns_query(&self, domain: &str) -> Option<&'static str> {
        Self::check_pool_domain(domain)
    }

    pub fn stats(&self) -> CryptominerStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
