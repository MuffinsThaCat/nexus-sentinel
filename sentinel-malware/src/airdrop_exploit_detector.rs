//! Module 133: AirdropExploitDetector — Apple AirDrop Abuse & Proximity Attack Detection
//!
//! Detects malicious abuse of AirDrop for targeted file delivery, proximity-based
//! attacks, device fingerprinting, and social engineering via Apple's peer-to-peer
//! file transfer protocol.
//!
//! ## Detection Capabilities
//!
//! - **Malicious file delivery**: Executables, scripts, malicious DMGs/PKGs
//!   delivered via AirDrop bypassing email/web security controls
//! - **AirDrop spam/bombing**: Rapid unsolicited file sends to disrupt or
//!   social engineer targets
//! - **Device fingerprinting**: Exploiting AirDrop's BLE/WiFi discovery to
//!   enumerate nearby Apple devices and their identifiers
//! - **Hash leakage exploitation**: Phone/email hash leakage via AirDrop
//!   discovery (CVE-2019-8567, research by TU Darmstadt)
//! - **Proximity phishing**: Sending crafted files that appear legitimate
//!   (fake receipts, documents, photos) to nearby targets
//! - **AWDL exploitation**: Attacking the Apple Wireless Direct Link protocol
//!   underlying AirDrop (CVE-2020-9906, CVE-2020-3843)
//! - **Directory traversal**: Path traversal in received filenames
//! - **Auto-accept exploitation**: Targeting devices set to receive from Everyone
//! - **Quarantine bypass**: AirDrop files may bypass Gatekeeper quarantine in
//!   certain configurations
//! - **Tracking via AirDrop**: Using AirDrop discovery for physical tracking
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1105 — Ingress Tool Transfer
//! - T1566.001 — Spearphishing Attachment
//! - T1204.002 — User Execution: Malicious File
//! - T1040 — Network Sniffing (AWDL)
//! - T1018 — Remote System Discovery
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const SPAM_THRESHOLD: u32 = 5;
const SPAM_WINDOW_SECS: u64 = 60;
const DISCOVERY_THRESHOLD: u32 = 20;

const DANGEROUS_EXTENSIONS: &[(&str, &str, f64)] = &[
    (".app", "macOS application bundle", 0.9),
    (".pkg", "Installer package", 0.85),
    (".mpkg", "Meta package installer", 0.85),
    (".dmg", "Disk image", 0.7),
    (".command", "Terminal command script", 0.9),
    (".terminal", "Terminal script", 0.85),
    (".sh", "Shell script", 0.8),
    (".py", "Python script", 0.6),
    (".rb", "Ruby script", 0.6),
    (".pl", "Perl script", 0.6),
    (".scpt", "Compiled AppleScript", 0.8),
    (".scptd", "AppleScript bundle", 0.8),
    (".workflow", "Automator workflow", 0.75),
    (".action", "Automator action", 0.75),
    (".jar", "Java archive (executable)", 0.7),
    (".webloc", "Web location file (URL redirect)", 0.5),
    (".url", "URL shortcut file", 0.5),
    (".mobileconfig", "Configuration profile", 0.8),
    (".configprofile", "Configuration profile", 0.8),
    (".kext", "Kernel extension", 0.95),
    (".plugin", "Plugin bundle", 0.7),
    (".prefPane", "Preference pane", 0.7),
];

const AIRDROP_CVES: &[(&str, &str, f64)] = &[
    ("CVE-2019-8567", "AirDrop phone/email hash leakage", 0.85),
    ("CVE-2020-9906", "AWDL kernel memory corruption", 0.95),
    ("CVE-2020-3843", "AWDL buffer overflow (wormable)", 0.95),
    ("CVE-2021-30873", "AirDrop directory traversal", 0.9),
    ("CVE-2022-22672", "AirDrop authentication bypass", 0.9),
    ("CVE-2023-27962", "AirDrop metadata leakage", 0.8),
];

const SOCIAL_ENGINEERING_FILENAMES: &[(&str, &str, f64)] = &[
    ("receipt", "Fake receipt file", 0.4),
    ("invoice", "Fake invoice", 0.4),
    ("photo", "Photo-named lure", 0.3),
    ("document", "Generic document lure", 0.3),
    ("update", "Fake update file", 0.5),
    ("install", "Install lure", 0.5),
    ("free", "Free offer lure", 0.4),
    ("prize", "Prize scam lure", 0.5),
    ("password", "Password-related lure", 0.5),
    ("urgent", "Urgency-based lure", 0.4),
    ("meeting", "Meeting notes lure", 0.3),
    ("salary", "Salary/payroll lure", 0.5),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum AirdropThreatType {
    MaliciousFileDelivery,
    ExecutableDelivery,
    InstallerDelivery,
    ScriptDelivery,
    ConfigProfileDelivery,
    AirdropSpam,
    DeviceFingerprinting,
    HashLeakage,
    ProximityPhishing,
    AWDLExploit,
    DirectoryTraversal,
    QuarantineBypass,
    SocialEngineeringFile,
    UnknownSenderFlood,
    LargeFileDelivery,
    KnownCVEExploit,
    TrackingAttempt,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AirdropThreatFinding {
    pub threat_type: AirdropThreatType,
    pub confidence: f64,
    pub description: String,
    pub sender_name: Option<String>,
    pub sender_device: Option<String>,
    pub file_name: Option<String>,
    pub file_type: Option<String>,
    pub file_size: Option<u64>,
    pub cve_id: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AirdropEvent {
    pub event_type: String,       // "receive", "discover", "send", "reject", "awdl_activity"
    pub sender_name: Option<String>,
    pub sender_device_id: Option<String>,
    pub file_name: Option<String>,
    pub file_extension: Option<String>,
    pub file_size: Option<u64>,
    pub file_path: Option<String>,
    pub file_entropy: Option<f64>,
    pub has_quarantine: bool,
    pub is_contacts_only: bool,
    pub nearby_devices_count: Option<u32>,
    pub awdl_interface_active: bool,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AirdropAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<AirdropThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct AirdropScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub executable_detections: u64,
    pub spam_detections: u64,
    pub fingerprint_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AirdropSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

#[derive(Debug, Clone, Default)]
struct SenderTracker {
    send_count: u64,
    timestamps: Vec<u64>,
    file_types: HashSet<String>,
    total_bytes: u64,
    first_seen: u64,
    last_seen: u64,
}

pub struct AirdropExploitDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<AirdropScanStats>>,
    result_cache: TieredCache<String, AirdropAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, AirdropScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, AirdropAnalysisResult>>,
    sig_db: PagedMemory<AirdropSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<AirdropScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    sender_tracker: RwLock<HashMap<String, SenderTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl AirdropExploitDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, AirdropScanStats::default(),
                |acc: &mut AirdropScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(AirdropScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            sender_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &AirdropEvent) -> Option<AirdropAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("airdrop:{}:{}", event.event_type, event.timestamp);
        let sender = event.sender_name.as_deref().unwrap_or("unknown");
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // Update sender tracker
        {
            let mut tracker = self.sender_tracker.write();
            let st = tracker.entry(sender.to_string()).or_default();
            st.send_count += 1;
            st.timestamps.push(event.timestamp);
            if let Some(ref ext) = event.file_extension { st.file_types.insert(ext.clone()); }
            if let Some(size) = event.file_size { st.total_bytes += size; }
            if st.first_seen == 0 { st.first_seen = event.timestamp; }
            st.last_seen = event.timestamp;
            if st.timestamps.len() > 500 { st.timestamps.drain(..250); }
        }

        // ── File type analysis ──────────────────────────────────────────
        if let Some(ref ext) = event.file_extension {
            let ext_lower = ext.to_lowercase();
            for &(dangerous_ext, desc, conf) in DANGEROUS_EXTENSIONS {
                if ext_lower == dangerous_ext.to_lowercase() || ext_lower.ends_with(&dangerous_ext.to_lowercase()) {
                    let tt = if dangerous_ext.contains("app") || dangerous_ext.contains("command") || dangerous_ext.contains("terminal") {
                        AirdropThreatType::ExecutableDelivery
                    } else if dangerous_ext.contains("pkg") || dangerous_ext.contains("dmg") {
                        AirdropThreatType::InstallerDelivery
                    } else if dangerous_ext.contains("sh") || dangerous_ext.contains("py") || dangerous_ext.contains("scpt") {
                        AirdropThreatType::ScriptDelivery
                    } else if dangerous_ext.contains("config") || dangerous_ext.contains("mobile") {
                        AirdropThreatType::ConfigProfileDelivery
                    } else {
                        AirdropThreatType::MaliciousFileDelivery
                    };

                    findings.push(AirdropThreatFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("Dangerous file via AirDrop: {} ({})", ext, desc),
                        sender_name: event.sender_name.clone(),
                        sender_device: event.sender_device_id.clone(),
                        file_name: event.file_name.clone(),
                        file_type: Some(ext.clone()),
                        file_size: event.file_size,
                        cve_id: None,
                        mitre_id: "T1105".into(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1105".into());
                    break;
                }
            }
        }

        // ── Directory traversal in filename ─────────────────────────────
        if let Some(ref fname) = event.file_name {
            if fname.contains("..") || fname.contains("/") || fname.contains("\\") {
                findings.push(AirdropThreatFinding {
                    threat_type: AirdropThreatType::DirectoryTraversal,
                    confidence: 0.9,
                    description: format!("Path traversal in AirDrop filename: {}", fname),
                    sender_name: event.sender_name.clone(),
                    sender_device: event.sender_device_id.clone(),
                    file_name: Some(fname.clone()),
                    file_type: event.file_extension.clone(),
                    file_size: event.file_size,
                    cve_id: Some("CVE-2021-30873".into()),
                    mitre_id: "T1105".into(),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1105".into());
            }

            // Social engineering filename check
            let fname_lower = fname.to_lowercase();
            for &(lure, desc, conf) in SOCIAL_ENGINEERING_FILENAMES {
                if fname_lower.contains(lure) {
                    findings.push(AirdropThreatFinding {
                        threat_type: AirdropThreatType::SocialEngineeringFile,
                        confidence: conf,
                        description: format!("{}: {}", desc, fname),
                        sender_name: event.sender_name.clone(),
                        sender_device: event.sender_device_id.clone(),
                        file_name: Some(fname.clone()),
                        file_type: event.file_extension.clone(),
                        file_size: event.file_size,
                        cve_id: None,
                        mitre_id: "T1566.001".into(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1566.001".into());
                    break;
                }
            }
        }

        // ── Quarantine bypass check ─────────────────────────────────────
        if !event.has_quarantine && event.file_extension.is_some() {
            let is_executable = event.file_extension.as_ref()
                .map(|e| DANGEROUS_EXTENSIONS.iter().any(|&(de, _, _)| e.to_lowercase().ends_with(&de.to_lowercase())))
                .unwrap_or(false);
            if is_executable {
                findings.push(AirdropThreatFinding {
                    threat_type: AirdropThreatType::QuarantineBypass,
                    confidence: 0.7,
                    description: "AirDrop file missing quarantine attribute".into(),
                    sender_name: event.sender_name.clone(),
                    sender_device: event.sender_device_id.clone(),
                    file_name: event.file_name.clone(),
                    file_type: event.file_extension.clone(),
                    file_size: event.file_size,
                    cve_id: None,
                    mitre_id: "T1553.001".into(),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1553.001".into());
            }
        }

        // ── Spam/flooding detection ─────────────────────────────────────
        {
            let tracker = self.sender_tracker.read();
            if let Some(st) = tracker.get(sender) {
                let recent = st.timestamps.iter()
                    .filter(|&&t| event.timestamp.saturating_sub(SPAM_WINDOW_SECS) <= t)
                    .count() as u32;
                if recent >= SPAM_THRESHOLD {
                    findings.push(AirdropThreatFinding {
                        threat_type: AirdropThreatType::AirdropSpam,
                        confidence: (0.6 + (recent as f64 / 20.0).min(0.3)),
                        description: format!("{} AirDrop sends in {}s from {}", recent, SPAM_WINDOW_SECS, sender),
                        sender_name: event.sender_name.clone(),
                        sender_device: event.sender_device_id.clone(),
                        file_name: None, file_type: None, file_size: None, cve_id: None,
                        mitre_id: "T1498".into(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1498".into());
                }
            }
        }

        // ── Device fingerprinting / discovery abuse ─────────────────────
        if event.event_type == "discover" {
            if let Some(count) = event.nearby_devices_count {
                if count > DISCOVERY_THRESHOLD {
                    findings.push(AirdropThreatFinding {
                        threat_type: AirdropThreatType::DeviceFingerprinting,
                        confidence: 0.6,
                        description: format!("AirDrop discovery enumerated {} devices", count),
                        sender_name: None, sender_device: None,
                        file_name: None, file_type: None, file_size: None, cve_id: None,
                        mitre_id: "T1018".into(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1018".into());
                }
            }
        }

        // ── Contacts-only bypass ────────────────────────────────────────
        if !event.is_contacts_only && event.event_type == "receive" {
            // Device accepting from Everyone — higher risk
            for f in findings.iter_mut() {
                f.confidence = (f.confidence + 0.1).min(0.99);
            }
        }

        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},sender={},ext={:?}", event.event_type, sender, event.file_extension));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = AirdropAnalysisResult {
            is_malicious, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_malicious { s.malicious_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "airdrop_exploit_detector".into(),
                title: format!("AirDrop threat from {}", sender),
                details: format!("Risk: {:.1}%, {} findings, file: {:?}",
                    risk_score * 100.0, result.findings.len(), event.file_name),
                path: event.file_path.clone(),
                process_name: Some("sharingd".into()), process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Set AirDrop to Contacts Only or Off".into(),
                    "Delete the received file immediately".into(),
                    "Do not open any AirDrop files from unknown senders".into(),
                    "Report suspicious AirDrop activity".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[AirdropThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                AirdropThreatType::AWDLExploit => 1.6,
                AirdropThreatType::ExecutableDelivery => 1.5,
                AirdropThreatType::KnownCVEExploit => 1.5,
                AirdropThreatType::DirectoryTraversal => 1.4,
                AirdropThreatType::InstallerDelivery => 1.3,
                AirdropThreatType::ConfigProfileDelivery => 1.3,
                AirdropThreatType::ScriptDelivery => 1.2,
                AirdropThreatType::QuarantineBypass => 1.2,
                AirdropThreatType::AirdropSpam => 1.0,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> AirdropScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
