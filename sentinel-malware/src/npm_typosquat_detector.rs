//! Module 139: NPMTyposquatDetector — Package Manager Typosquatting & Dependency Confusion
//!
//! Detects supply-chain attacks via typosquatting, dependency confusion, and
//! malicious packages across npm, PyPI, RubyGems, Homebrew, and Cargo ecosystems
//! targeting macOS developer environments.
//!
//! ## Detection Capabilities
//!
//! - **Typosquatting**: Package names similar to popular packages (edit distance,
//!   character substitution, hyphen/underscore swaps)
//! - **Dependency confusion**: Internal package names shadowed by public packages
//!   with higher version numbers
//! - **Install script abuse**: preinstall/postinstall scripts that download
//!   payloads, steal credentials, or install persistence
//! - **Homebrew tap poisoning**: Malicious Homebrew taps and formula with
//!   trojanized binaries
//! - **pip install abuse**: setup.py with malicious install commands
//! - **Cargo build.rs abuse**: Malicious build scripts in Rust crates
//! - **Known malicious packages**: Database of known npm/PyPI malware campaigns
//! - **Suspicious package metadata**: Recently created packages with high download
//!   counts, packages with no source repo, packages with obfuscated code
//!
//! ## MITRE ATT&CK: T1195.001, T1059.004, T1204.002
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const POPULAR_NPM_PACKAGES: &[&str] = &[
    "lodash", "express", "react", "axios", "chalk", "commander", "webpack",
    "typescript", "moment", "debug", "uuid", "dotenv", "cors", "jsonwebtoken",
    "mongoose", "passport", "socket.io", "eslint", "prettier", "jest",
    "mocha", "nodemon", "pm2", "next", "nuxt", "vue", "angular", "svelte",
    "fastify", "koa", "hapi", "sequelize", "prisma", "typeorm", "graphql",
    "apollo-server", "redis", "bull", "puppeteer", "cheerio", "sharp",
    "multer", "bcrypt", "helmet", "morgan", "winston", "pino",
];

const POPULAR_PYPI_PACKAGES: &[&str] = &[
    "requests", "numpy", "pandas", "flask", "django", "tensorflow", "torch",
    "scikit-learn", "matplotlib", "pillow", "boto3", "setuptools", "pip",
    "cryptography", "pyyaml", "sqlalchemy", "celery", "redis", "pytest",
    "black", "mypy", "pylint", "fastapi", "uvicorn", "httpx", "aiohttp",
    "beautifulsoup4", "scrapy", "selenium", "paramiko", "fabric",
];

const MALICIOUS_INSTALL_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("curl.*|.*sh", "Pipe-to-shell in install script", "T1059.004", 0.95),
    ("curl.*|.*python", "Pipe-to-python in install", "T1059.004", 0.9),
    ("wget.*|.*bash", "wget pipe-to-bash", "T1059.004", 0.95),
    ("eval(Buffer.from", "Node.js base64 eval (obfuscation)", "T1027", 0.9),
    ("eval(atob(", "Base64 eval in npm script", "T1027", 0.9),
    ("child_process.*exec", "Child process execution", "T1059.004", 0.6),
    ("os.system(", "Python os.system call in setup.py", "T1059.004", 0.7),
    ("subprocess.Popen", "Python subprocess in setup.py", "T1059.004", 0.6),
    ("__import__('os')", "Dynamic os import in setup.py", "T1059.004", 0.8),
    ("exec(compile(", "Python exec(compile()) pattern", "T1027", 0.8),
    ("socket.socket", "Socket creation in install", "T1071", 0.7),
    ("dns.resolver", "DNS resolution in install (C2)", "T1071.004", 0.6),
    ("requests.post", "HTTP POST in install (exfil)", "T1048", 0.7),
    ("os.environ", "Environment variable access (token theft)", "T1552.001", 0.5),
    ("keyring.get_password", "Keyring access in install", "T1555", 0.8),
    ("~/.ssh", "SSH directory access in install", "T1552.004", 0.8),
    ("~/.aws", "AWS credentials access", "T1552.001", 0.8),
    ("~/.npmrc", "npmrc token theft", "T1552.001", 0.8),
    ("~/.pypirc", "PyPI token theft", "T1552.001", 0.8),
    ("~/.gitconfig", "Git config access in install", "T1552.001", 0.6),
    ("/etc/passwd", "Password file access", "T1552.001", 0.7),
    ("LaunchAgents", "macOS persistence in install script", "T1543.001", 0.9),
    ("crontab", "Cron persistence in install", "T1053.003", 0.8),
    ("chrome.*Login Data", "Chrome credential theft", "T1555", 0.9),
    ("firefox.*logins.json", "Firefox credential theft", "T1555", 0.9),
    ("Keychain", "macOS Keychain access in install", "T1555.001", 0.9),
];

const HOMEBREW_ABUSE_PATTERNS: &[(&str, &str, f64)] = &[
    ("system.*curl.*|.*sh", "Pipe-to-shell in Homebrew formula", 0.95),
    ("system.*chmod.*+x", "Make executable in formula", 0.5),
    ("ENV.*DYLD", "DYLD environment manipulation in formula", 0.8),
    ("bin.install.*from_url", "Binary install from URL", 0.5),
    ("resource.*url.*github.com/.*releases", "Release download (verify source)", 0.3),
];

const KNOWN_MALICIOUS_CAMPAIGNS: &[(&str, &str, &str, f64)] = &[
    ("ua-parser-js", "ua-parser-js compromise (Oct 2021)", "npm", 0.95),
    ("event-stream", "event-stream/flatmap-stream attack", "npm", 0.95),
    ("colors", "colors.js protest sabotage", "npm", 0.8),
    ("node-ipc", "node-ipc protestware", "npm", 0.85),
    ("coa", "coa npm hijack", "npm", 0.9),
    ("rc", "rc npm hijack", "npm", 0.9),
    ("ctx", "ctx PyPI malware", "pypi", 0.9),
    ("colorama", "colorama PyPI typosquat", "pypi", 0.85),
    ("python-dateutil", "python-dateutil typosquat", "pypi", 0.85),
    ("jeIlyfish", "jellyfish PyPI typosquat (I vs l)", "pypi", 0.95),
    ("cryptography-rust", "cryptography Rust typosquat", "pypi", 0.9),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum PkgThreatType {
    Typosquatting,
    DependencyConfusion,
    MaliciousInstallScript,
    CredentialTheft,
    PersistenceInstall,
    ObfuscatedCode,
    KnownMaliciousPackage,
    SuspiciousMetadata,
    HomebrewTapPoison,
    CargoBuildRsAbuse,
    DownloadAndExecute,
    TokenExfiltration,
    EnvironmentTheft,
    RecentlyCreatedPackage,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PkgThreatFinding {
    pub threat_type: PkgThreatType,
    pub confidence: f64,
    pub description: String,
    pub package_name: String,
    pub package_version: Option<String>,
    pub registry: String,
    pub similar_to: Option<String>,
    pub edit_distance: Option<u32>,
    pub script_preview: Option<String>,
    pub mitre_id: String,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PackageInstallEvent {
    pub event_type: String,
    pub package_name: String,
    pub package_version: Option<String>,
    pub registry: String,        // "npm", "pypi", "rubygems", "homebrew", "cargo"
    pub install_script: Option<String>,
    pub setup_py_content: Option<String>,
    pub build_rs_content: Option<String>,
    pub formula_content: Option<String>,
    pub package_age_days: Option<u32>,
    pub download_count: Option<u64>,
    pub has_source_repo: bool,
    pub file_path: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PkgAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<PkgThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PkgScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub typosquat_detections: u64,
    pub script_detections: u64,
    pub known_malware_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PkgSigEntry { pub name: String, pub registry: String, pub severity: f64 }

pub struct NPMTyposquatDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<PkgScanStats>>,
    result_cache: TieredCache<String, PkgAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    pkg_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, PkgScanStats>>,
    metrics: MemoryMetrics,
    pkg_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, PkgAnalysisResult>>,
    sig_db: PagedMemory<PkgSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<PkgScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl NPMTyposquatDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            pkg_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, PkgScanStats::default(),
                |acc: &mut PkgScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            pkg_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(PkgScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_install(&self, event: &PackageInstallEvent) -> Option<PkgAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.registry, event.package_name, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // ── 1. Typosquatting detection ──────────────────────────────────
        let popular = match event.registry.as_str() {
            "npm" => POPULAR_NPM_PACKAGES.iter().map(|s| *s).collect::<Vec<_>>(),
            "pypi" => POPULAR_PYPI_PACKAGES.iter().map(|s| *s).collect::<Vec<_>>(),
            _ => vec![],
        };
        let pkg_lower = event.package_name.to_lowercase();
        for &pop in &popular {
            if pkg_lower == pop { break; } // Exact match = legitimate
            let dist = Self::edit_distance(&pkg_lower, pop);
            if dist > 0 && dist <= 2 && pkg_lower != pop {
                findings.push(PkgThreatFinding {
                    threat_type: PkgThreatType::Typosquatting,
                    confidence: if dist == 1 { 0.85 } else { 0.65 },
                    description: format!("'{}' is {} edit(s) from popular package '{}'", event.package_name, dist, pop),
                    package_name: event.package_name.clone(),
                    package_version: event.package_version.clone(),
                    registry: event.registry.clone(),
                    similar_to: Some(pop.to_string()),
                    edit_distance: Some(dist as u32),
                    script_preview: None,
                    mitre_id: "T1195.001".into(),
                    file_path: event.file_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1195.001".into());
                break;
            }
            // Check hyphen/underscore swap
            let swapped = pkg_lower.replace('-', "_");
            let pop_swapped = pop.replace('-', "_");
            if swapped == pop_swapped && pkg_lower != pop {
                findings.push(PkgThreatFinding {
                    threat_type: PkgThreatType::Typosquatting,
                    confidence: 0.7,
                    description: format!("'{}' is hyphen/underscore variant of '{}'", event.package_name, pop),
                    package_name: event.package_name.clone(),
                    package_version: event.package_version.clone(),
                    registry: event.registry.clone(),
                    similar_to: Some(pop.to_string()),
                    edit_distance: Some(1),
                    script_preview: None,
                    mitre_id: "T1195.001".into(),
                    file_path: event.file_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1195.001".into());
                break;
            }
        }

        // ── 2. Install script analysis ──────────────────────────────────
        let script_content = event.install_script.as_deref()
            .or(event.setup_py_content.as_deref())
            .or(event.build_rs_content.as_deref())
            .or(event.formula_content.as_deref());

        if let Some(script) = script_content {
            let script_lower = script.to_lowercase();
            let preview = script.chars().take(300).collect::<String>();

            for &(pattern, desc, mitre, conf) in MALICIOUS_INSTALL_PATTERNS {
                if script_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("curl") && pattern.contains("sh") { PkgThreatType::DownloadAndExecute }
                        else if pattern.contains("ssh") || pattern.contains("aws") || pattern.contains("npmrc") ||
                                pattern.contains("pypirc") || pattern.contains("Keychain") || pattern.contains("chrome") ||
                                pattern.contains("firefox") { PkgThreatType::CredentialTheft }
                        else if pattern.contains("environ") || pattern.contains("keyring") { PkgThreatType::TokenExfiltration }
                        else if pattern.contains("LaunchAgents") || pattern.contains("crontab") { PkgThreatType::PersistenceInstall }
                        else if pattern.contains("eval") || pattern.contains("Buffer.from") || pattern.contains("atob") ||
                                pattern.contains("compile(") { PkgThreatType::ObfuscatedCode }
                        else { PkgThreatType::MaliciousInstallScript };
                    findings.push(PkgThreatFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("[{}/{}] {}", event.registry, event.package_name, desc),
                        package_name: event.package_name.clone(),
                        package_version: event.package_version.clone(),
                        registry: event.registry.clone(),
                        similar_to: None, edit_distance: None,
                        script_preview: Some(preview.clone()),
                        mitre_id: mitre.into(),
                        file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                }
            }
        }

        // ── 3. Homebrew-specific checks ─────────────────────────────────
        if event.registry == "homebrew" {
            if let Some(ref formula) = event.formula_content {
                let f_lower = formula.to_lowercase();
                for &(pattern, desc, conf) in HOMEBREW_ABUSE_PATTERNS {
                    if f_lower.contains(&pattern.to_lowercase()) {
                        findings.push(PkgThreatFinding {
                            threat_type: PkgThreatType::HomebrewTapPoison,
                            confidence: conf, description: desc.to_string(),
                            package_name: event.package_name.clone(),
                            package_version: event.package_version.clone(),
                            registry: "homebrew".into(),
                            similar_to: None, edit_distance: None,
                            script_preview: Some(formula.chars().take(200).collect()),
                            mitre_id: "T1195.001".into(),
                            file_path: event.file_path.clone(), timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1195.001".into());
                    }
                }
            }
        }

        // ── 4. Known malicious campaign matching ────────────────────────
        for &(name, desc, registry, conf) in KNOWN_MALICIOUS_CAMPAIGNS {
            if event.package_name.to_lowercase() == name.to_lowercase() && event.registry == registry {
                findings.push(PkgThreatFinding {
                    threat_type: PkgThreatType::KnownMaliciousPackage,
                    confidence: conf, description: desc.to_string(),
                    package_name: event.package_name.clone(),
                    package_version: event.package_version.clone(),
                    registry: event.registry.clone(),
                    similar_to: None, edit_distance: None, script_preview: None,
                    mitre_id: "T1195.001".into(),
                    file_path: event.file_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1195.001".into());
            }
        }

        // ── 5. Suspicious metadata ──────────────────────────────────────
        if let Some(age) = event.package_age_days {
            if age < 7 && !event.has_source_repo {
                findings.push(PkgThreatFinding {
                    threat_type: PkgThreatType::RecentlyCreatedPackage,
                    confidence: 0.5,
                    description: format!("Package {} created {} days ago with no source repo", event.package_name, age),
                    package_name: event.package_name.clone(),
                    package_version: event.package_version.clone(),
                    registry: event.registry.clone(),
                    similar_to: None, edit_distance: None, script_preview: None,
                    mitre_id: "T1195.001".into(),
                    file_path: event.file_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1195.001".into());
            }
        }

        self.pkg_diffs.write().record_insert(cache_key.clone(),
            format!("pkg={},reg={},findings={}", event.package_name, event.registry, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = PkgAnalysisResult {
            is_malicious, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_malicious { s.malicious_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "npm_typosquat_detector".into(),
                title: format!("Malicious package: {}/{}", event.registry, event.package_name),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    format!("Remove package: {} uninstall {}", event.registry, event.package_name),
                    "Verify package name spelling against official registry".into(),
                    "Check for credential theft: rotate all tokens/keys".into(),
                    "Review install scripts before installing packages".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn edit_distance(a: &str, b: &str) -> usize {
        let a_chars: Vec<char> = a.chars().collect();
        let b_chars: Vec<char> = b.chars().collect();
        let m = a_chars.len();
        let n = b_chars.len();
        if m == 0 { return n; }
        if n == 0 { return m; }
        let mut dp = vec![vec![0usize; n + 1]; m + 1];
        for i in 0..=m { dp[i][0] = i; }
        for j in 0..=n { dp[0][j] = j; }
        for i in 1..=m {
            for j in 1..=n {
                let cost = if a_chars[i-1] == b_chars[j-1] { 0 } else { 1 };
                dp[i][j] = (dp[i-1][j] + 1).min(dp[i][j-1] + 1).min(dp[i-1][j-1] + cost);
            }
        }
        dp[m][n]
    }

    fn calculate_risk_score(&self, findings: &[PkgThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                PkgThreatType::KnownMaliciousPackage => 1.6,
                PkgThreatType::DownloadAndExecute => 1.5,
                PkgThreatType::CredentialTheft => 1.5,
                PkgThreatType::PersistenceInstall => 1.4,
                PkgThreatType::Typosquatting => 1.3,
                PkgThreatType::ObfuscatedCode => 1.2,
                PkgThreatType::TokenExfiltration => 1.2,
                PkgThreatType::DependencyConfusion => 1.3,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> PkgScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
