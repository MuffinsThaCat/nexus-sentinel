//! Module 62: KextMonitor — Kernel Extension Persistence & Rootkit Detection
//!
//! Monitors macOS kernel extensions (kexts) for unauthorized loading, modification,
//! and rootkit-style kernel-level persistence. With Apple's deprecation of third-party
//! kexts, any new kext activity is highly suspicious on modern macOS.
//!
//! ## Features
//!
//! - **Kext directory monitoring**: Watches /Library/Extensions and /System/Library/Extensions
//! - **Kext load/unload detection**: Monitors kextload/kextutil/kmutil invocations
//! - **Kext signing verification**: Validates code signatures and team IDs against allowlists
//! - **StagedExtensions tracking**: Monitors /Library/StagedExtensions for pending kexts
//! - **Kext cache invalidation**: Detects kextcache/kmutil rebuild triggers
//! - **SystemExtensions migration**: Tracks System Extension (dext) installations
//! - **Kext approval database**: Monitors /var/db/SystemPolicyConfiguration for MDM overrides
//! - **Known rootkit kext detection**: Signature database of known macOS kernel rootkits
//! - **IOKit driver monitoring**: Watches IOKit driver registry for unauthorized drivers
//! - **Kernel symbol table inspection**: Detects hidden/hooked kernel symbols
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) kext change history
//! - **#2  TieredCache** — Hot cache for recently scanned kexts
//! - **#3  ReversibleComputation** — Recompute risk scores on kext changes
//! - **#5  StreamAccumulator** — Streaming kext event rate
//! - **#6  MemoryMetrics** — Bounded memory for kext analysis
//! - **#461 DifferentialStore** — Track kext Info.plist diffs between scans
//! - **#569 PruningMap** — Auto-expire old kext analysis results
//! - **#592 DedupStore** — Deduplicate identical kext bundles
//! - **#627 SparseMatrix** — Kext vendor × action frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1547.006 — Boot or Logon Autostart Execution: Kernel Modules and Extensions
//! - T1014 — Rootkit
//! - T1562.001 — Impair Defenses: Disable or Modify Tools
//! - T1068 — Exploitation for Privilege Escalation

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const KEXT_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 16 * 1024 * 1024;

/// Primary kext installation directories
const KEXT_DIRS: &[&str] = &[
    "/Library/Extensions",
    "/System/Library/Extensions",
    "/Library/StagedExtensions",
];

/// System Extension (dext) directories — modern replacement for kexts
const SYSTEM_EXTENSION_DIRS: &[&str] = &[
    "/Library/SystemExtensions",
    "/System/Library/SystemExtensions",
];

/// Kext approval and policy databases
const KEXT_POLICY_PATHS: &[&str] = &[
    "/var/db/SystemPolicyConfiguration/KextPolicy",
    "/var/db/SystemPolicyConfiguration/ExecPolicy",
    "/var/db/SystemPolicy",
];

/// Kext cache paths — rebuilding these can indicate kext manipulation
const KEXT_CACHE_PATHS: &[&str] = &[
    "/System/Library/Caches/com.apple.kext.caches",
    "/System/Library/PrelinkedKernels",
    "/System/Library/KernelCollections",
];

/// Tools used to load/manage kexts
const KEXT_TOOLS: &[&str] = &[
    "kextload", "kextunload", "kextutil", "kextcache",
    "kextstat", "kextfind", "kmutil", "kernelmanagerd",
    "sysextd", "systemextensionsctl",
];

/// Known legitimate Apple kext bundle IDs (subset — production would be comprehensive)
const KNOWN_APPLE_KEXTS: &[&str] = &[
    "com.apple.driver.AppleHIDKeyboard",
    "com.apple.driver.AppleBluetoothMultitouch",
    "com.apple.driver.AppleUSBHub",
    "com.apple.driver.AppleThunderboltNHI",
    "com.apple.iokit.IOUSBHostFamily",
    "com.apple.iokit.IONetworkingFamily",
    "com.apple.iokit.IOStorageFamily",
    "com.apple.iokit.IOGraphicsFamily",
    "com.apple.iokit.IOAudioFamily",
    "com.apple.driver.AppleACPIPlatform",
    "com.apple.driver.AppleIntelCPUPowerManagement",
    "com.apple.driver.AppleAPIC",
    "com.apple.iokit.IOPCIFamily",
    "com.apple.iokit.IOSCSIArchitectureModelFamily",
    "com.apple.filesystems.apfs",
    "com.apple.filesystems.hfs.kext",
    "com.apple.nke.applicationfirewall",
    "com.apple.security.sandbox",
];

/// Known legitimate third-party kext vendors
const KNOWN_VENDORS: &[&str] = &[
    "com.vmware", "com.parallels", "com.virtualbox",
    "com.nvidia", "com.amd",
    "com.crowdstrike", "com.sentinelone", "com.carbonblack",
    "com.cisco", "com.symantec",
];

/// Known macOS rootkit kext signatures/names
const KNOWN_ROOTKIT_KEXTS: &[&str] = &[
    "Rubilyn", "AvLock", "Crisis", "Morcut",
    "HackingTeam", "FinSpy", "Careto",
    "Flashback.kext", "iWorm.kext",
    "Ventir", "Mokes",
];

/// Suspicious kext bundle ID patterns
const SUSPICIOUS_KEXT_PATTERNS: &[&str] = &[
    "hidden", "stealth", "rootkit", "backdoor",
    "keylog", "capture", "sniff", "hook",
    "inject", "patch", "bypass", "disable",
    "test.kext", "debug.kext", "sample.kext",
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum KextType {
    /// Traditional .kext bundle in /Library/Extensions
    ThirdPartyKext,
    /// Apple system kext in /System/Library/Extensions
    SystemKext,
    /// Staged kext awaiting approval
    StagedKext,
    /// Modern System Extension (.dext / .appex)
    SystemExtension,
    /// Kext policy database entry
    KextPolicy,
    /// Kext cache / prelinked kernel
    KextCache,
    /// IOKit driver
    IOKitDriver,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum KextAction {
    Installed,
    Loaded,
    Unloaded,
    Modified,
    Removed,
    PolicyApproved,
    PolicyDenied,
    CacheRebuilt,
    SignatureInvalid,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum KextRisk {
    Trusted,
    KnownVendor,
    Unknown,
    Suspicious,
    Malicious,
    Rootkit,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KextEvent {
    pub id: String,
    pub timestamp: i64,
    pub kext_type: KextType,
    pub action: KextAction,
    pub risk: KextRisk,
    pub severity: Severity,
    pub confidence: f64,
    pub bundle_path: String,
    pub bundle_id: String,
    pub bundle_version: String,
    pub team_id: Option<String>,
    pub code_signed: bool,
    pub signature_valid: bool,
    pub content_hash: String,
    pub file_size: u64,
    pub loading_process: String,
    pub loading_pid: u32,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
    pub is_apple_kext: bool,
    pub is_known_vendor: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct KextStats {
    pub events_analyzed: u64,
    pub kexts_scanned: u64,
    pub threats_detected: u64,
    pub threats_blocked: u64,
    pub unsigned_kexts_found: u64,
    pub unknown_kexts_found: u64,
    pub rootkit_kexts_detected: u64,
    pub policy_changes: u64,
    pub cache_rebuilds: u64,
    pub system_extensions_installed: u64,
    pub kext_types: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// KextMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct KextMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical kext history ──
    monitor_history: RwLock<HierarchicalState<KextStats>>,
    // ── Breakthrough #2: Tiered kext event cache ──
    event_cache: TieredCache<String, KextEvent>,
    // ── Breakthrough #3: Reversible risk computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming kext event rate ──
    event_rate: RwLock<StreamAccumulator<f64, KextStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Kext Info.plist diff tracking ──
    kext_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old kext events ──
    recent_events: RwLock<PruningMap<String, KextEvent>>,
    // ── Breakthrough #592: Deduplicate identical kext bundles ──
    kext_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Vendor × action frequency ──
    vendor_action_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Known kext hashes — maps bundle_id → last known hash
    known_kexts: RwLock<HashMap<String, String>>,
    stats: RwLock<KextStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl KextMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(KEXT_CACHE_MAX)
            .with_metrics(metrics.clone(), "kext_events");
        let risk_computer = ReversibleComputation::new(512,
            |risks: &[f64]| if risks.is_empty() { 0.0 } else { risks.iter().sum::<f64>() / risks.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, KextStats::default(),
            |acc: &mut KextStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            kext_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(KEXT_CACHE_MAX)),
            kext_dedup: RwLock::new(DedupStore::new()),
            vendor_action_matrix: RwLock::new(SparseMatrix::new(0u64)),
            known_kexts: RwLock::new(HashMap::new()),
            stats: RwLock::new(KextStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("kext_monitor", MEMORY_BUDGET / 2);
        info!("KextMonitor started — watching {} kext dirs, {} system ext dirs",
            KEXT_DIRS.len(), SYSTEM_EXTENSION_DIRS.len());
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("KextMonitor stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    // ── Classification ─────────────────────────────────────────────────────

    fn classify_path(path: &str) -> Option<KextType> {
        if path.starts_with("/System/Library/Extensions") {
            return Some(KextType::SystemKext);
        }
        if path.starts_with("/Library/Extensions") {
            return Some(KextType::ThirdPartyKext);
        }
        if path.contains("StagedExtensions") {
            return Some(KextType::StagedKext);
        }
        if SYSTEM_EXTENSION_DIRS.iter().any(|d| path.starts_with(d)) {
            return Some(KextType::SystemExtension);
        }
        if KEXT_POLICY_PATHS.iter().any(|p| path.contains(p)) {
            return Some(KextType::KextPolicy);
        }
        if KEXT_CACHE_PATHS.iter().any(|c| path.starts_with(c)) {
            return Some(KextType::KextCache);
        }
        None
    }

    fn is_apple_kext(bundle_id: &str) -> bool {
        bundle_id.starts_with("com.apple.") || KNOWN_APPLE_KEXTS.contains(&bundle_id)
    }

    fn is_known_vendor(bundle_id: &str) -> bool {
        KNOWN_VENDORS.iter().any(|v| bundle_id.starts_with(v))
    }

    fn is_known_rootkit(bundle_id: &str, bundle_path: &str) -> bool {
        let id_lower = bundle_id.to_lowercase();
        let path_lower = bundle_path.to_lowercase();
        KNOWN_ROOTKIT_KEXTS.iter().any(|r| {
            let r_lower = r.to_lowercase();
            id_lower.contains(&r_lower) || path_lower.contains(&r_lower)
        })
    }

    fn has_suspicious_pattern(bundle_id: &str) -> bool {
        let id_lower = bundle_id.to_lowercase();
        SUSPICIOUS_KEXT_PATTERNS.iter().any(|p| id_lower.contains(p))
    }

    fn classify_risk(bundle_id: &str, bundle_path: &str, code_signed: bool, signature_valid: bool) -> KextRisk {
        if Self::is_known_rootkit(bundle_id, bundle_path) {
            return KextRisk::Rootkit;
        }
        if Self::has_suspicious_pattern(bundle_id) {
            return KextRisk::Suspicious;
        }
        if !code_signed || !signature_valid {
            return KextRisk::Suspicious;
        }
        if Self::is_apple_kext(bundle_id) {
            return KextRisk::Trusted;
        }
        if Self::is_known_vendor(bundle_id) {
            return KextRisk::KnownVendor;
        }
        KextRisk::Unknown
    }

    // ── Primary Analysis ───────────────────────────────────────────────────

    /// Analyze a kext-related filesystem change or load event.
    pub fn analyze_event(
        &self,
        bundle_path: &str,
        bundle_id: &str,
        bundle_version: &str,
        action: KextAction,
        content_hash: &str,
        file_size: u64,
        code_signed: bool,
        signature_valid: bool,
        team_id: Option<&str>,
        process_name: &str,
        pid: u32,
    ) -> Option<KextEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let kext_type = Self::classify_path(bundle_path)
            .unwrap_or(KextType::ThirdPartyKext);
        let risk = Self::classify_risk(bundle_id, bundle_path, code_signed, signature_valid);
        let is_apple = Self::is_apple_kext(bundle_id);
        let is_vendor = Self::is_known_vendor(bundle_id);

        // Skip trusted Apple kexts for routine actions
        if risk == KextRisk::Trusted && matches!(action, KextAction::Loaded | KextAction::Unloaded) {
            return None;
        }

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();

        // ── Rootkit detection ──
        if risk == KextRisk::Rootkit {
            indicators.push(format!("ROOTKIT KEXT DETECTED: {}", bundle_id));
            mitre_techniques.push("T1014".to_string());
            mitre_techniques.push("T1547.006".to_string());
            self.stats.write().rootkit_kexts_detected += 1;
        }

        // ── Unsigned kext ──
        if !code_signed {
            indicators.push(format!("Unsigned kext: {}", bundle_id));
            self.stats.write().unsigned_kexts_found += 1;
        } else if !signature_valid {
            indicators.push(format!("Invalid signature on kext: {}", bundle_id));
            mitre_techniques.push("T1553.002".to_string());
        }

        // ── Unknown vendor kext ──
        if risk == KextRisk::Unknown {
            indicators.push(format!("Unknown vendor kext: {}", bundle_id));
            self.stats.write().unknown_kexts_found += 1;
        }

        // ── Suspicious patterns ──
        if Self::has_suspicious_pattern(bundle_id) {
            indicators.push(format!("Suspicious bundle ID pattern: {}", bundle_id));
        }

        // ── New kext installation on modern macOS is highly suspicious ──
        if action == KextAction::Installed && !is_apple {
            indicators.push(format!("New third-party kext installed: {}", bundle_id));
            mitre_techniques.push("T1547.006".to_string());
        }

        // ── Kext loading by non-standard process ──
        if matches!(action, KextAction::Loaded | KextAction::Installed) {
            if !KEXT_TOOLS.iter().any(|t| process_name.contains(t))
                && process_name != "launchd"
                && process_name != "kernel"
            {
                indicators.push(format!("Kext loaded by unexpected process: {}", process_name));
                mitre_techniques.push("T1068".to_string());
            }
        }

        // ── Policy changes ──
        if kext_type == KextType::KextPolicy {
            indicators.push(format!("Kext policy database modified by {}", process_name));
            self.stats.write().policy_changes += 1;
        }

        // ── Cache rebuild ──
        if kext_type == KextType::KextCache {
            indicators.push(format!("Kext cache rebuilt by {}", process_name));
            self.stats.write().cache_rebuilds += 1;
        }

        // ── System extension ──
        if kext_type == KextType::SystemExtension {
            if action == KextAction::Installed {
                indicators.push(format!("System extension installed: {}", bundle_id));
                self.stats.write().system_extensions_installed += 1;
            }
        }

        // ── Content change detection ──
        if action == KextAction::Modified {
            let previous = self.known_kexts.read().get(bundle_id).cloned();
            if let Some(ref prev_hash) = previous {
                if prev_hash != content_hash {
                    indicators.push(format!("Kext content changed: {} → {}",
                        &prev_hash[..8.min(prev_hash.len())],
                        &content_hash[..8.min(content_hash.len())]));
                }
            }
        }

        if indicators.is_empty() { return None; }

        // Severity based on risk level
        let severity = match risk {
            KextRisk::Rootkit => Severity::Critical,
            KextRisk::Malicious => Severity::Critical,
            KextRisk::Suspicious => Severity::High,
            KextRisk::Unknown => Severity::High,
            KextRisk::KnownVendor => Severity::Medium,
            KextRisk::Trusted => Severity::Low,
        };

        let confidence = match risk {
            KextRisk::Rootkit => 0.98,
            KextRisk::Malicious => 0.95,
            KextRisk::Suspicious => 0.80,
            KextRisk::Unknown => 0.70,
            _ => (0.5 + indicators.len() as f64 * 0.1).min(0.95),
        };

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1547.006".to_string());
        }

        let event = KextEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            kext_type, action, risk, severity, confidence,
            bundle_path: bundle_path.to_string(),
            bundle_id: bundle_id.to_string(),
            bundle_version: bundle_version.to_string(),
            team_id: team_id.map(|s| s.to_string()),
            code_signed, signature_valid,
            content_hash: content_hash.to_string(),
            file_size,
            loading_process: process_name.to_string(),
            loading_pid: pid,
            indicators,
            mitre_techniques,
            blocked: risk == KextRisk::Rootkit,
            is_apple_kext: is_apple,
            is_known_vendor: is_vendor,
        };

        // Update stores
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.kext_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.kext_dedup.write().insert(
            format!("{}:{}", bundle_id, content_hash), vec![]);
        self.known_kexts.write().insert(bundle_id.to_string(), content_hash.to_string());

        // Update sparse matrix
        let vendor_str = if is_apple { "apple".to_string() }
            else if is_vendor { bundle_id.split('.').take(2).collect::<Vec<_>>().join(".") }
            else { "unknown".to_string() };
        let action_str = format!("{:?}", action);
        let current = *self.vendor_action_matrix.read().get(&vendor_str, &action_str);
        self.vendor_action_matrix.write().set(vendor_str, action_str, current + 1);

        // Update stats
        self.stats.write().threats_detected += 1;
        let type_str = format!("{:?}", kext_type);
        *self.stats.write().kext_types.entry(type_str).or_insert(0) += 1;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.kext_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.kext_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(confidence);

        warn!("Kext persistence: {:?} {:?} {} by {} (pid {})",
            action, risk, bundle_id, process_name, pid);

        Some(event)
    }

    /// Analyze a kextload/kextutil/kmutil command invocation.
    pub fn analyze_kext_command(&self, pid: u32, user: &str, cmdline: &str)
        -> Option<KextEvent>
    {
        let now = chrono::Utc::now().timestamp();

        // Only care about kext management commands
        let is_kext_cmd = KEXT_TOOLS.iter().any(|t| cmdline.contains(t));
        if !is_kext_cmd { return None; }

        let mut indicators = Vec::new();
        let mut mitre_techniques = vec!["T1547.006".to_string()];

        if cmdline.contains("kextload") || cmdline.contains("kmutil load") {
            indicators.push(format!("Kext load command by user '{}': {}", user, cmdline));
        }
        if cmdline.contains("kextunload") || cmdline.contains("kmutil unload") {
            indicators.push(format!("Kext unload command: {}", cmdline));
            mitre_techniques.push("T1562.001".to_string());
        }
        if cmdline.contains("kextcache") || cmdline.contains("kmutil rebuild") {
            indicators.push(format!("Kext cache rebuild: {}", cmdline));
        }

        if indicators.is_empty() { return None; }

        let event = KextEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            kext_type: KextType::ThirdPartyKext,
            action: KextAction::Loaded,
            risk: KextRisk::Unknown,
            severity: Severity::High,
            confidence: 0.75,
            bundle_path: String::new(),
            bundle_id: cmdline.to_string(),
            bundle_version: String::new(),
            team_id: None,
            code_signed: false, signature_valid: false,
            content_hash: String::new(),
            file_size: 0,
            loading_process: "shell".to_string(),
            loading_pid: pid,
            indicators,
            mitre_techniques,
            blocked: false,
            is_apple_kext: false,
            is_known_vendor: false,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.stats.write().threats_detected += 1;
        self.event_rate.write().push(1.0);

        warn!("Kext command detected: {} (user: {}, pid: {})", cmdline, user, pid);
        Some(event)
    }

    pub fn stats(&self) -> KextStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }
}
