//! Module 134: EmailHeaderAnalyzer — Email-Based Phishing & Spoofing Detection
//!
//! Analyzes email headers, authentication results, and content patterns to detect
//! phishing, business email compromise (BEC), spoofing, and malware delivery via
//! Apple Mail, Outlook, and other macOS email clients.
//!
//! ## Detection Capabilities
//!
//! - **SPF/DKIM/DMARC failures**: Authentication result analysis for spoofed senders
//! - **Header anomalies**: Mismatched From/Reply-To, suspicious Received chains,
//!   forged Message-ID, unusual X-headers
//! - **Homoglyph/lookalike domains**: Unicode confusable characters in sender
//!   domains (e.g., paypa1.com, micr0soft.com, gооgle.com with Cyrillic)
//! - **Display name spoofing**: "CEO Name <random@attacker.com>" patterns
//! - **BEC indicators**: Urgency language, wire transfer requests, credential
//!   harvesting links, executive impersonation
//! - **Attachment analysis**: Dangerous file types, double extensions (.pdf.exe),
//!   password-protected archives, macro-enabled documents
//! - **URL analysis**: Shortened URLs, data: URIs, credential harvesting domains,
//!   punycode domains, suspicious redirects
//! - **Thread hijacking**: Replies injected into legitimate email threads
//! - **Mail client exploitation**: Apple Mail rendering exploits, HTML/CSS abuse
//! - **Known phishing kit detection**: Evilginx2, Modlishka, Gophish signatures
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1566.001 — Spearphishing Attachment
//! - T1566.002 — Spearphishing Link
//! - T1566.003 — Spearphishing via Service
//! - T1534 — Internal Spearphishing
//! - T1598 — Phishing for Information
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const AUTH_FAILURE_PATTERNS: &[(&str, &str, f64)] = &[
    ("spf=fail", "SPF authentication failed (sender not authorized)", 0.7),
    ("spf=softfail", "SPF soft failure (sender questionable)", 0.5),
    ("spf=none", "No SPF record (no sender authentication)", 0.4),
    ("dkim=fail", "DKIM signature failed (message tampered)", 0.75),
    ("dkim=none", "No DKIM signature (not cryptographically signed)", 0.3),
    ("dmarc=fail", "DMARC failed (domain policy violation)", 0.8),
    ("dmarc=none", "No DMARC policy (no domain protection)", 0.3),
    ("compauth=fail", "Composite authentication failed", 0.7),
    ("arc=fail", "ARC chain validation failed", 0.6),
];

const BEC_URGENCY_PATTERNS: &[(&str, &str, f64)] = &[
    ("wire transfer", "Wire transfer request (BEC indicator)", 0.7),
    ("urgent payment", "Urgent payment request", 0.75),
    ("immediate action required", "Urgency pressure tactic", 0.6),
    ("do not share", "Confidentiality pressure", 0.4),
    ("gift card", "Gift card scam request", 0.8),
    ("bitcoin", "Cryptocurrency payment request", 0.5),
    ("act now", "Urgency language", 0.4),
    ("time sensitive", "Time pressure tactic", 0.4),
    ("verify your account", "Account verification phishing", 0.7),
    ("confirm your identity", "Identity confirmation phishing", 0.6),
    ("suspended", "Account suspension scare", 0.6),
    ("unauthorized access", "Security scare phishing", 0.5),
    ("update your payment", "Payment update phishing", 0.7),
    ("click here to verify", "Verification link phishing", 0.7),
    ("your password will expire", "Password expiry phishing", 0.65),
];

const DANGEROUS_ATTACHMENT_EXTS: &[(&str, &str, f64)] = &[
    (".exe", "Windows executable", 0.9),
    (".scr", "Screensaver (executable)", 0.9),
    (".bat", "Batch script", 0.85),
    (".cmd", "Command script", 0.85),
    (".ps1", "PowerShell script", 0.85),
    (".vbs", "Visual Basic Script", 0.9),
    (".js", "JavaScript file", 0.8),
    (".wsf", "Windows Script File", 0.9),
    (".hta", "HTML Application", 0.9),
    (".iso", "Disk image (used to bypass Mark-of-the-Web)", 0.7),
    (".img", "Disk image", 0.7),
    (".vhd", "Virtual hard disk", 0.7),
    (".lnk", "Windows shortcut (launcher)", 0.85),
    (".docm", "Macro-enabled Word document", 0.8),
    (".xlsm", "Macro-enabled Excel spreadsheet", 0.8),
    (".pptm", "Macro-enabled PowerPoint", 0.75),
    (".dotm", "Macro-enabled Word template", 0.8),
    (".xltm", "Macro-enabled Excel template", 0.8),
    (".xlam", "Excel add-in (macro)", 0.8),
    (".ppam", "PowerPoint add-in (macro)", 0.8),
    (".sldm", "Macro-enabled slide", 0.75),
    (".one", "OneNote file (macro delivery vector)", 0.6),
    (".svg", "SVG with embedded JavaScript", 0.5),
    (".html", "HTML file (credential harvesting page)", 0.5),
    (".htm", "HTML file", 0.5),
    (".mht", "Web archive (embedded scripts)", 0.6),
    (".chm", "Compiled HTML Help (code execution)", 0.85),
    (".application", "ClickOnce application", 0.85),
    (".appref-ms", "Application reference", 0.85),
    (".7z", "7-Zip archive (may hide malware)", 0.4),
    (".rar", "RAR archive", 0.4),
    (".zip", "ZIP archive (may contain executable)", 0.3),
    (".cab", "Cabinet file", 0.5),
    (".app", "macOS application", 0.9),
    (".pkg", "macOS installer", 0.8),
    (".dmg", "macOS disk image", 0.7),
    (".command", "macOS terminal command", 0.9),
];

const SUSPICIOUS_URL_PATTERNS: &[(&str, &str, f64)] = &[
    ("bit.ly/", "URL shortener (hides destination)", 0.4),
    ("tinyurl.com/", "URL shortener", 0.4),
    ("goo.gl/", "Google URL shortener", 0.4),
    ("t.co/", "Twitter URL shortener", 0.3),
    ("is.gd/", "URL shortener", 0.4),
    ("ow.ly/", "URL shortener", 0.4),
    ("data:text/html", "Data URI (embedded HTML/JS)", 0.8),
    ("data:application", "Data URI (embedded application)", 0.85),
    ("javascript:", "JavaScript URI scheme", 0.9),
    (".tk/", "Free TLD (.tk) — common in phishing", 0.5),
    (".ml/", "Free TLD (.ml)", 0.5),
    (".ga/", "Free TLD (.ga)", 0.5),
    (".cf/", "Free TLD (.cf)", 0.5),
    (".gq/", "Free TLD (.gq)", 0.5),
    ("xn--", "Punycode domain (IDN homograph attack)", 0.6),
    ("login.", "Login subdomain (credential harvesting)", 0.5),
    ("signin.", "Sign-in subdomain (credential harvesting)", 0.5),
    ("secure-", "Fake secure prefix", 0.4),
    ("account-verify", "Account verification phishing URL", 0.6),
    ("password-reset", "Password reset phishing URL", 0.6),
    (".000webhostapp.com", "Free hosting (phishing infrastructure)", 0.6),
    ("sites.google.com", "Google Sites (phishing page)", 0.3),
    ("forms.office.com", "Office Forms (credential harvesting)", 0.3),
];

const PHISHING_KIT_SIGNATURES: &[(&str, &str, f64)] = &[
    ("evilginx", "Evilginx2 reverse proxy phishing kit", 0.95),
    ("modlishka", "Modlishka MITM phishing proxy", 0.95),
    ("gophish", "GoPhish phishing framework", 0.9),
    ("king phisher", "King Phisher framework", 0.9),
    ("socialfish", "SocialFish phishing tool", 0.9),
    ("zphisher", "ZPhisher automated phishing", 0.85),
    ("blackeye", "BlackEye phishing tool", 0.85),
    ("seToolkit", "Social Engineering Toolkit (SET)", 0.85),
    ("credsniper", "CredSniper phishing framework", 0.9),
    ("muraena", "Muraena reverse proxy phishing", 0.9),
];

const LOOKALIKE_DOMAINS: &[(&str, &str, f64)] = &[
    ("paypa1", "PayPal lookalike (1 for l)", 0.9),
    ("micr0soft", "Microsoft lookalike (0 for o)", 0.9),
    ("arnazon", "Amazon lookalike (rn for m)", 0.9),
    ("app1e", "Apple lookalike (1 for l)", 0.9),
    ("g00gle", "Google lookalike (0 for o)", 0.9),
    ("faceb00k", "Facebook lookalike", 0.9),
    ("linkedln", "LinkedIn lookalike (l for I)", 0.9),
    ("microsoftonline", "Microsoft Online lookalike", 0.6),
    ("0ffice365", "Office 365 lookalike", 0.85),
    ("dropb0x", "Dropbox lookalike", 0.85),
    ("icloud-", "iCloud phishing domain prefix", 0.7),
    ("apple-id", "Apple ID phishing domain", 0.7),
    ("appleid-", "Apple ID phishing prefix", 0.75),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum EmailThreatType {
    SPFFailure,
    DKIMFailure,
    DMARCFailure,
    DisplayNameSpoof,
    FromReplyToMismatch,
    HomoglyphDomain,
    LookalikeDomain,
    BECIndicator,
    UrgencyLanguage,
    DangerousAttachment,
    DoubleExtension,
    PasswordProtectedArchive,
    MacroEnabledDocument,
    SuspiciousURL,
    DataURI,
    PunycodeURL,
    URLShortener,
    ThreadHijacking,
    PhishingKitSignature,
    CredentialHarvestingLink,
    HeaderAnomaly,
    ForgedMessageID,
    BulkPhishing,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EmailThreatFinding {
    pub threat_type: EmailThreatType,
    pub confidence: f64,
    pub description: String,
    pub header_field: Option<String>,
    pub sender_address: Option<String>,
    pub sender_domain: Option<String>,
    pub attachment_name: Option<String>,
    pub url: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EmailMessage {
    pub message_id: String,
    pub from_address: String,
    pub from_display_name: Option<String>,
    pub reply_to: Option<String>,
    pub to_addresses: Vec<String>,
    pub subject: String,
    pub date: u64,
    pub received_chain: Vec<String>,
    pub authentication_results: Option<String>,
    pub spf_result: Option<String>,
    pub dkim_result: Option<String>,
    pub dmarc_result: Option<String>,
    pub body_text: Option<String>,
    pub body_html: Option<String>,
    pub urls: Vec<String>,
    pub attachments: Vec<EmailAttachment>,
    pub is_reply: bool,
    pub in_reply_to: Option<String>,
    pub x_headers: HashMap<String, String>,
    pub mail_client: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EmailAttachment {
    pub filename: String,
    pub content_type: String,
    pub size: u64,
    pub is_encrypted: bool,
    pub hash: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EmailAnalysisResult {
    pub is_phishing: bool,
    pub emails_analyzed: u32,
    pub findings: Vec<EmailThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct EmailScanStats {
    pub total_emails: u64,
    pub phishing_detections: u64,
    pub spoof_detections: u64,
    pub bec_detections: u64,
    pub attachment_detections: u64,
    pub url_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EmailSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

pub struct EmailHeaderAnalyzer {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<EmailScanStats>>,
    result_cache: TieredCache<String, EmailAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    email_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, EmailScanStats>>,
    metrics: MemoryMetrics,
    email_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, EmailAnalysisResult>>,
    sig_db: PagedMemory<EmailSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<EmailScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_emails: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl EmailHeaderAnalyzer {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            email_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, EmailScanStats::default(),
                |acc: &mut EmailScanStats, vals: &[f64]| { acc.total_emails += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            email_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(EmailScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_emails: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_email(&self, email: &EmailMessage) -> Option<EmailAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_emails.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        if let Some(cached) = self.result_cache.get(&email.message_id) { return Some(cached); }

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let sender_domain = email.from_address.split('@').nth(1).unwrap_or("");

        // ── 1. Authentication analysis ──────────────────────────────────
        let auth_text = format!("{} {} {} {}",
            email.authentication_results.as_deref().unwrap_or(""),
            email.spf_result.as_deref().unwrap_or(""),
            email.dkim_result.as_deref().unwrap_or(""),
            email.dmarc_result.as_deref().unwrap_or(""));
        let auth_lower = auth_text.to_lowercase();

        for &(pattern, desc, conf) in AUTH_FAILURE_PATTERNS {
            if auth_lower.contains(pattern) {
                let tt = if pattern.contains("spf") { EmailThreatType::SPFFailure }
                    else if pattern.contains("dkim") { EmailThreatType::DKIMFailure }
                    else { EmailThreatType::DMARCFailure };
                findings.push(EmailThreatFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    header_field: Some("Authentication-Results".into()),
                    sender_address: Some(email.from_address.clone()),
                    sender_domain: Some(sender_domain.to_string()),
                    attachment_name: None, url: None,
                    mitre_id: "T1566".into(), timestamp: email.timestamp,
                });
                mitre_ids.insert("T1566".into());
            }
        }

        // ── 2. From/Reply-To mismatch ───────────────────────────────────
        if let Some(ref reply_to) = email.reply_to {
            let reply_domain = reply_to.split('@').nth(1).unwrap_or("");
            if !reply_domain.is_empty() && reply_domain != sender_domain {
                findings.push(EmailThreatFinding {
                    threat_type: EmailThreatType::FromReplyToMismatch,
                    confidence: 0.65,
                    description: format!("From domain ({}) ≠ Reply-To domain ({})", sender_domain, reply_domain),
                    header_field: Some("Reply-To".into()),
                    sender_address: Some(email.from_address.clone()),
                    sender_domain: Some(sender_domain.to_string()),
                    attachment_name: None, url: None,
                    mitre_id: "T1566".into(), timestamp: email.timestamp,
                });
                mitre_ids.insert("T1566".into());
            }
        }

        // ── 3. Display name spoofing ────────────────────────────────────
        if let Some(ref display_name) = email.from_display_name {
            // Check if display name looks like an email address different from actual From
            if display_name.contains('@') && !display_name.contains(&email.from_address) {
                findings.push(EmailThreatFinding {
                    threat_type: EmailThreatType::DisplayNameSpoof,
                    confidence: 0.75,
                    description: format!("Display name '{}' contains different email than From: {}", display_name, email.from_address),
                    header_field: Some("From".into()),
                    sender_address: Some(email.from_address.clone()),
                    sender_domain: Some(sender_domain.to_string()),
                    attachment_name: None, url: None,
                    mitre_id: "T1566".into(), timestamp: email.timestamp,
                });
                mitre_ids.insert("T1566".into());
            }
        }

        // ── 4. Lookalike domain detection ───────────────────────────────
        let domain_lower = sender_domain.to_lowercase();
        for &(lookalike, desc, conf) in LOOKALIKE_DOMAINS {
            if domain_lower.contains(lookalike) {
                findings.push(EmailThreatFinding {
                    threat_type: EmailThreatType::LookalikeDomain,
                    confidence: conf, description: format!("{}: {}", desc, sender_domain),
                    header_field: Some("From".into()),
                    sender_address: Some(email.from_address.clone()),
                    sender_domain: Some(sender_domain.to_string()),
                    attachment_name: None, url: None,
                    mitre_id: "T1566".into(), timestamp: email.timestamp,
                });
                mitre_ids.insert("T1566".into());
                break;
            }
        }

        // ── 5. BEC / urgency language ───────────────────────────────────
        let body_text = format!("{} {}",
            email.body_text.as_deref().unwrap_or(""),
            email.subject);
        let body_lower = body_text.to_lowercase();

        let mut bec_count = 0u32;
        for &(pattern, desc, conf) in BEC_URGENCY_PATTERNS {
            if body_lower.contains(pattern) {
                bec_count += 1;
                if bec_count <= 3 { // Limit findings
                    findings.push(EmailThreatFinding {
                        threat_type: if pattern.contains("wire") || pattern.contains("gift card") || pattern.contains("bitcoin") {
                            EmailThreatType::BECIndicator
                        } else { EmailThreatType::UrgencyLanguage },
                        confidence: conf, description: desc.to_string(),
                        header_field: None,
                        sender_address: Some(email.from_address.clone()),
                        sender_domain: Some(sender_domain.to_string()),
                        attachment_name: None, url: None,
                        mitre_id: "T1534".into(), timestamp: email.timestamp,
                    });
                    mitre_ids.insert("T1534".into());
                }
            }
        }
        // Multiple BEC indicators compound risk
        if bec_count >= 3 {
            for f in findings.iter_mut() {
                if matches!(f.threat_type, EmailThreatType::BECIndicator | EmailThreatType::UrgencyLanguage) {
                    f.confidence = (f.confidence + 0.15).min(0.95);
                }
            }
        }

        // ── 6. Attachment analysis ──────────────────────────────────────
        for att in &email.attachments {
            let fname_lower = att.filename.to_lowercase();

            // Double extension check
            let parts: Vec<&str> = att.filename.split('.').collect();
            if parts.len() >= 3 {
                let last_ext = parts.last().unwrap_or(&"");
                let second_last = parts.get(parts.len() - 2).unwrap_or(&"");
                let is_double = DANGEROUS_ATTACHMENT_EXTS.iter().any(|&(e, _, _)| last_ext.to_lowercase() == e.trim_start_matches('.').to_lowercase())
                    && ["pdf", "doc", "xls", "jpg", "png", "txt"].contains(&second_last.to_lowercase().as_str());
                if is_double {
                    findings.push(EmailThreatFinding {
                        threat_type: EmailThreatType::DoubleExtension,
                        confidence: 0.9,
                        description: format!("Double extension: {}", att.filename),
                        header_field: None, sender_address: Some(email.from_address.clone()),
                        sender_domain: Some(sender_domain.to_string()),
                        attachment_name: Some(att.filename.clone()), url: None,
                        mitre_id: "T1566.001".into(), timestamp: email.timestamp,
                    });
                    mitre_ids.insert("T1566.001".into());
                }
            }

            // Dangerous extension check
            for &(ext, desc, conf) in DANGEROUS_ATTACHMENT_EXTS {
                if fname_lower.ends_with(ext) {
                    let tt = if ext.contains("docm") || ext.contains("xlsm") || ext.contains("pptm") || ext.contains("xlam") {
                        EmailThreatType::MacroEnabledDocument
                    } else {
                        EmailThreatType::DangerousAttachment
                    };
                    findings.push(EmailThreatFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("{}: {}", desc, att.filename),
                        header_field: None, sender_address: Some(email.from_address.clone()),
                        sender_domain: Some(sender_domain.to_string()),
                        attachment_name: Some(att.filename.clone()), url: None,
                        mitre_id: "T1566.001".into(), timestamp: email.timestamp,
                    });
                    mitre_ids.insert("T1566.001".into());
                    break;
                }
            }

            // Password-protected archive
            if att.is_encrypted {
                findings.push(EmailThreatFinding {
                    threat_type: EmailThreatType::PasswordProtectedArchive,
                    confidence: 0.6,
                    description: format!("Password-protected archive: {} ({} bytes)", att.filename, att.size),
                    header_field: None, sender_address: Some(email.from_address.clone()),
                    sender_domain: Some(sender_domain.to_string()),
                    attachment_name: Some(att.filename.clone()), url: None,
                    mitre_id: "T1566.001".into(), timestamp: email.timestamp,
                });
                mitre_ids.insert("T1566.001".into());
            }
        }

        // ── 7. URL analysis ─────────────────────────────────────────────
        for url in &email.urls {
            let url_lower = url.to_lowercase();
            for &(pattern, desc, conf) in SUSPICIOUS_URL_PATTERNS {
                if url_lower.contains(pattern) {
                    let tt = if pattern.starts_with("data:") { EmailThreatType::DataURI }
                        else if pattern.contains("xn--") { EmailThreatType::PunycodeURL }
                        else if pattern.contains(".ly") || pattern.contains("tinyurl") || pattern.contains("goo.gl") || pattern.contains("is.gd") || pattern.contains("ow.ly") || pattern.contains("t.co") {
                            EmailThreatType::URLShortener
                        } else {
                            EmailThreatType::SuspiciousURL
                        };
                    findings.push(EmailThreatFinding {
                        threat_type: tt, confidence: conf,
                        description: desc.to_string(),
                        header_field: None, sender_address: Some(email.from_address.clone()),
                        sender_domain: Some(sender_domain.to_string()),
                        attachment_name: None, url: Some(url.clone()),
                        mitre_id: "T1566.002".into(), timestamp: email.timestamp,
                    });
                    mitre_ids.insert("T1566.002".into());
                    break; // One finding per URL
                }
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.email_diffs.write().record_insert(email.message_id.clone(),
            format!("from={},findings={}", email.from_address, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_phishing = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = EmailAnalysisResult {
            is_phishing, emails_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(email.message_id.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(email.message_id.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(email.message_id.clone(), compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_emails += 1;
            if is_phishing { s.phishing_detections += 1; }
            let n = s.total_emails as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_phishing {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "email_header_analyzer".into(),
                title: format!("Phishing email from {}", email.from_address),
                details: format!("Risk: {:.1}%, {} findings, subject: '{}'",
                    risk_score * 100.0, result.findings.len(), email.subject),
                path: None, process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Do not click any links or open attachments".into(),
                    "Report the email as phishing".into(),
                    "If credentials were entered, change passwords immediately".into(),
                    "Block the sender domain".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[EmailThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                EmailThreatType::PhishingKitSignature => 1.6,
                EmailThreatType::DoubleExtension => 1.5,
                EmailThreatType::DataURI => 1.4,
                EmailThreatType::LookalikeDomain | EmailThreatType::HomoglyphDomain => 1.4,
                EmailThreatType::MacroEnabledDocument => 1.3,
                EmailThreatType::BECIndicator => 1.3,
                EmailThreatType::DMARCFailure => 1.2,
                EmailThreatType::DangerousAttachment => 1.2,
                EmailThreatType::DisplayNameSpoof => 1.1,
                EmailThreatType::SPFFailure => 1.1,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> EmailScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
