//! Module 87: EmailAttachmentScanner — Email Attachment Malware & Phishing Detection
//!
//! World-class scanner for malicious email attachments including weaponized documents,
//! phishing lures, archive bombs, double-extension tricks, embedded macros, OLE
//! exploits, and HTML smuggling payloads delivered via email vectors.
//!
//! ## Features
//!
//! - **Double extension detection**: Identifies files like invoice.pdf.exe, report.docx.scr
//! - **CLSID extension abuse**: Detects .{CLSID} extensions that hide true file type
//! - **Archive bomb detection**: Identifies zip bombs and recursive archives (>100:1 ratio)
//! - **Executable in archive**: Flags executables hidden inside ZIP/RAR/7z attachments
//! - **HTML smuggling detection**: Identifies base64-encoded executables in HTML attachments
//! - **Password-protected archive analysis**: Flags password-protected archives (evasion)
//! - **OLE compound document analysis**: Scans for embedded OLE objects and exploits
//! - **RTF exploit detection**: Identifies RTF files with embedded OLE/equation editor exploits
//! - **ISO/IMG mounting attack**: Detects disk image attachments used to bypass MOTW
//! - **LNK shortcut analysis**: Scans .lnk files for malicious target paths and arguments
//! - **SVG script injection**: Detects JavaScript embedded in SVG image attachments
//! - **OneNote abuse**: Identifies .one/.onepkg files with embedded scripts/executables
//! - **Content-Type mismatch**: Detects MIME type vs actual content mismatches
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) scan history
//! - **#2  TieredCache** — Hot cache for recent attachment scans
//! - **#3  ReversibleComputation** — Recompute attachment risk scores
//! - **#5  StreamAccumulator** — Streaming scan rate
//! - **#6  MemoryMetrics** — Bounded memory for scan data
//! - **#461 DifferentialStore** — Track attachment pattern diffs
//! - **#569 PruningMap** — Auto-expire old scan events
//! - **#592 DedupStore** — Deduplicate identical attachment scans
//! - **#627 SparseMatrix** — Sender × attachment-type frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1566.001 — Phishing: Spearphishing Attachment
//! - T1204.002 — User Execution: Malicious File
//! - T1027 — Obfuscated Files or Information
//! - T1221 — Template Injection
//! - T1559.001 — Inter-Process Communication: Component Object Model

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const ATTACH_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 24 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────

/// Archive compression ratio threshold for zip bomb detection
const ZIP_BOMB_RATIO: f64 = 100.0;
/// Maximum recursive archive depth
const MAX_ARCHIVE_DEPTH: u32 = 5;
/// Entropy threshold for encrypted/compressed content detection
const HIGH_ENTROPY_THRESHOLD: f64 = 7.5;
/// Minimum size for archive bomb check (bytes)
const MIN_ARCHIVE_SIZE: u64 = 1024;
/// Maximum attachment size before flagging (50MB)
const MAX_ATTACHMENT_SIZE: u64 = 50 * 1024 * 1024;
/// RTF header magic
const RTF_MAGIC: &[u8] = b"{\\rtf";
/// OLE compound document magic
const OLE_MAGIC: &[u8] = &[0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];
/// OOXML (docx/xlsx/pptx) magic = ZIP magic
const OOXML_MAGIC: &[u8] = &[0x50, 0x4B, 0x03, 0x04];
/// PDF magic
const PDF_MAGIC: &[u8] = &[0x25, 0x50, 0x44, 0x46];

/// Dangerous executable extensions
const DANGEROUS_EXTENSIONS: &[(&str, f64, &str)] = &[
    (".exe",  1.0, "Windows executable"),
    (".scr",  1.0, "Windows screensaver (executable)"),
    (".bat",  0.95,"Windows batch script"),
    (".cmd",  0.95,"Windows command script"),
    (".com",  0.95,"DOS executable"),
    (".pif",  0.95,"Program Information File (executable)"),
    (".vbs",  0.90,"VBScript"),
    (".vbe",  0.90,"Encoded VBScript"),
    (".js",   0.80,"JavaScript"),
    (".jse",  0.85,"Encoded JavaScript"),
    (".wsf",  0.85,"Windows Script File"),
    (".wsh",  0.80,"Windows Script Host settings"),
    (".ps1",  0.85,"PowerShell script"),
    (".psm1", 0.80,"PowerShell module"),
    (".msi",  0.75,"Windows Installer"),
    (".msp",  0.75,"Windows Installer patch"),
    (".dll",  0.85,"Dynamic Link Library"),
    (".cpl",  0.80,"Control Panel applet"),
    (".hta",  0.90,"HTML Application (full system access)"),
    (".inf",  0.70,"Setup Information File"),
    (".reg",  0.75,"Registry file"),
    (".lnk",  0.80,"Windows shortcut"),
    (".url",  0.60,"Internet shortcut"),
    (".iso",  0.75,"Disk image (bypasses MOTW)"),
    (".img",  0.75,"Disk image"),
    (".vhd",  0.70,"Virtual hard disk"),
    (".vhdx", 0.70,"Virtual hard disk extended"),
    (".one",  0.65,"OneNote file (script embedding)"),
    (".onepkg",0.70,"OneNote package"),
    (".svg",  0.50,"SVG (script injection risk)"),
    (".htm",  0.55,"HTML file"),
    (".html", 0.55,"HTML file"),
    (".mhtml",0.60,"MHTML archive"),
    (".xll",  0.85,"Excel add-in (code execution)"),
    (".xlam", 0.80,"Excel macro-enabled add-in"),
    (".docm", 0.75,"Word macro-enabled document"),
    (".xlsm", 0.75,"Excel macro-enabled workbook"),
    (".pptm", 0.70,"PowerPoint macro-enabled"),
    (".dotm", 0.75,"Word macro-enabled template"),
    (".xltm", 0.70,"Excel macro-enabled template"),
    (".sldm", 0.65,"PowerPoint macro-enabled slide"),
    (".accde",0.70,"Access execute-only database"),
    (".jar",  0.80,"Java archive"),
    (".class",0.75,"Java class file"),
    (".py",   0.50,"Python script"),
    (".rb",   0.45,"Ruby script"),
    (".sh",   0.50,"Shell script"),
    (".app",  0.80,"macOS application bundle"),
    (".dmg",  0.70,"macOS disk image"),
    (".pkg",  0.70,"macOS installer package"),
    (".command",0.75,"macOS Terminal command"),
];

/// CLSID extension abuse patterns (Windows hides CLSID extensions)
const CLSID_EXTENSIONS: &[(&str, &str, f64)] = &[
    ("{1D27F844-3A1F-4410-85AC-14651078412D}", "Compressed Folder CLSID",     0.90),
    ("{11DBB47C-A525-400b-9E80-A54615A090C0}", "Recycle Bin CLSID",           0.85),
    ("{20D04FE0-3AEA-1069-A2D8-08002B30309D}", "My Computer CLSID",           0.80),
    ("{645FF040-5081-101B-9F08-00AA002F954E}", "Recycle Bin CLSID",           0.85),
    ("{450D8FBA-AD25-11D0-98A8-0800361B1103}", "My Documents CLSID",          0.80),
    ("{208D2C60-3AEA-1069-A2D7-08002B30309D}", "Network Places CLSID",        0.85),
];

/// RTF exploit patterns (equation editor, embedded objects)
const RTF_EXPLOIT_PATTERNS: &[(&str, f64, &str)] = &[
    ("\\objocx",              0.90, "RTF OLE Control exploit object"),
    ("\\objemb",              0.75, "RTF embedded OLE object"),
    ("\\objlink",             0.70, "RTF linked OLE object"),
    ("\\objautlink",          0.75, "RTF auto-link OLE object"),
    ("\\objupdate",           0.80, "RTF auto-update OLE object"),
    ("\\objdata",             0.65, "RTF OLE data stream"),
    ("\\object",              0.55, "RTF generic object"),
    ("equation.3",            0.95, "Equation Editor 3.0 (CVE-2017-11882)"),
    ("equation.2",            0.90, "Equation Editor 2.0 exploit"),
    ("0002CE02",              0.95, "Equation Editor CLSID (hex)"),
    ("\\pict\\wmetafile",    0.60, "RTF WMF image (potential exploit)"),
    ("\\pict\\emfblip",     0.55, "RTF EMF image (potential exploit)"),
];

/// OLE compound document suspicious stream names
const OLE_SUSPICIOUS_STREAMS: &[(&str, f64, &str)] = &[
    ("Macros",                0.65, "VBA Macro storage"),
    ("VBA",                   0.65, "VBA project stream"),
    ("_VBA_PROJECT",          0.70, "VBA project data"),
    ("PowerShell",            0.90, "PowerShell in OLE stream"),
    ("\x01Ole",              0.50, "OLE1 linked/embedded data"),
    ("Package",               0.60, "OLE Package (embedded file)"),
    ("\x05DocumentSummary",  0.20, "Document summary info"),
    ("MBD",                   0.55, "Embedded OLE sub-document"),
    ("ObjectPool",            0.60, "OLE object pool"),
    ("\x03ObjInfo",          0.50, "OLE object info"),
    ("EncryptedPackage",      0.70, "Encrypted OLE content"),
    ("DRMContent",            0.55, "DRM-protected content"),
];

/// Content-Type to actual format mapping for mismatch detection
const CONTENT_TYPE_MAPPINGS: &[(&str, &[u8], &str)] = &[
    ("application/pdf",           PDF_MAGIC,    "PDF document"),
    ("application/msword",        OLE_MAGIC,    "OLE Word document"),
    ("application/vnd.openxmlformats", OOXML_MAGIC, "OOXML document"),
    ("image/jpeg",                &[0xFF, 0xD8, 0xFF], "JPEG image"),
    ("image/png",                 &[0x89, 0x50, 0x4E, 0x47], "PNG image"),
    ("image/gif",                 &[0x47, 0x49, 0x46], "GIF image"),
    ("application/zip",           OOXML_MAGIC,  "ZIP archive"),
    ("text/plain",                &[],          "Plain text"),
    ("text/html",                 &[],          "HTML document"),
];

/// Known phishing subject line patterns
const PHISHING_SUBJECT_PATTERNS: &[(&str, f64, &str)] = &[
    ("urgent",          0.30, "Urgency indicator"),
    ("action required", 0.40, "Action urgency"),
    ("verify your",     0.50, "Verification phishing"),
    ("suspended",       0.45, "Account suspension lure"),
    ("password expire", 0.55, "Password expiry lure"),
    ("invoice",         0.35, "Invoice phishing"),
    ("payment",         0.30, "Payment lure"),
    ("wire transfer",   0.50, "Wire transfer BEC"),
    ("shared document", 0.35, "Document sharing lure"),
    ("voicemail",       0.40, "Voicemail notification lure"),
    ("fax",             0.35, "Fax notification lure"),
    ("shipment",        0.30, "Shipping notification lure"),
    ("tax return",      0.40, "Tax-themed phishing"),
    ("security alert",  0.45, "Security alert impersonation"),
    ("unusual sign-in", 0.50, "Sign-in alert impersonation"),
    ("confirm your identity", 0.55, "Identity verification phishing"),
];

/// Double extension patterns (deceptive)
const DOUBLE_EXTENSION_PATTERNS: &[(&str, &str)] = &[
    (".pdf.exe",    "PDF disguised as executable"),
    (".doc.exe",    "Word document disguised as executable"),
    (".xls.scr",    "Excel disguised as screensaver"),
    (".jpg.exe",    "Image disguised as executable"),
    (".png.scr",    "Image disguised as screensaver"),
    (".txt.vbs",    "Text file disguised as VBScript"),
    (".pdf.bat",    "PDF disguised as batch file"),
    (".doc.js",     "Document disguised as JavaScript"),
    (".mp3.exe",    "Audio disguised as executable"),
    (".zip.exe",    "Archive disguised as executable"),
    (".docx.lnk",   "Document disguised as shortcut"),
    (".pdf.hta",    "PDF disguised as HTA"),
    (".xlsx.iso",    "Spreadsheet disguised as disk image"),
    (".doc.vbs",    "Document disguised as VBScript"),
    (".jpg.js",     "Image disguised as JavaScript"),
    (".mp4.exe",    "Video disguised as executable"),
    (".csv.cmd",    "CSV disguised as command script"),
    (".pdf.ps1",    "PDF disguised as PowerShell"),
    (".png.hta",    "Image disguised as HTA"),
    (".rar.exe",    "Archive disguised as executable"),
    (".docx.exe",   "Word document disguised as executable"),
    (".xlsx.scr",   "Excel disguised as screensaver"),
];

/// HTML smuggling indicators
const HTML_SMUGGLING_PATTERNS: &[(&str, f64, &str)] = &[
    ("atob(",                 0.80, "Base64 decode in JavaScript"),
    ("Uint8Array",            0.60, "Binary array construction"),
    ("application/octet-stream", 0.70, "Binary MIME type in HTML"),
    ("Blob(",                 0.55, "Blob construction"),
    ("URL.createObjectURL(",  0.65, "Object URL creation"),
    ("msSaveOrOpenBlob",      0.80, "IE/Edge file save API"),
    ("navigator.msSaveBlob",  0.80, "IE/Edge file save API"),
    ("download=",             0.45, "HTML5 download attribute"),
    ("data:application/",     0.70, "Data URI with binary content"),
    ("window.atob",           0.80, "Window-level base64 decode"),
];

/// LNK (shortcut) suspicious target patterns
const LNK_SUSPICIOUS_TARGETS: &[(&str, f64, &str)] = &[
    ("powershell",    0.90, "PowerShell execution via shortcut"),
    ("cmd.exe",       0.80, "Command prompt via shortcut"),
    ("mshta.exe",     0.95, "HTA execution via shortcut"),
    ("wscript.exe",   0.85, "Windows Script Host via shortcut"),
    ("cscript.exe",   0.85, "Console Script Host via shortcut"),
    ("regsvr32",      0.90, "DLL registration/execution via shortcut"),
    ("rundll32",      0.85, "DLL execution via shortcut"),
    ("certutil",      0.80, "Certificate utility (download/decode)"),
    ("bitsadmin",     0.80, "BITS download via shortcut"),
    ("msiexec",       0.75, "MSI installation via shortcut"),
    ("-encodedcommand", 0.95, "Encoded PowerShell via shortcut"),
    ("-enc ",         0.90, "Encoded PowerShell (short flag)"),
    ("iex(",          0.90, "PowerShell Invoke-Expression"),
    ("downloadstring", 0.90, "PowerShell download string"),
    ("start-process",  0.70, "PowerShell Start-Process"),
    ("invoke-webrequest", 0.80, "PowerShell web download"),
    ("curl ",          0.65, "Curl download via shortcut"),
    ("wget ",          0.65, "Wget download via shortcut"),
    ("/c ",            0.50, "cmd.exe /c execution"),
    ("/k ",            0.45, "cmd.exe /k execution"),
    ("\\\\\\\\.",  0.60, "UNC path in shortcut"),
    ("http://",        0.55, "HTTP URL in shortcut target"),
    ("https://",       0.45, "HTTPS URL in shortcut target"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum AttachmentThreatType {
    DangerousExtension, DoubleExtension, ArchiveBomb, ExecutableInArchive,
    HTMLSmuggling, PasswordProtectedArchive, OLEExploit, RTFExploit,
    DiskImageAttack, MaliciousLNK, SVGInjection, OneNoteAbuse,
    ContentTypeMismatch, MacroEnabled, TemplateInjection, CLSIDAbuse,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AttachmentScanResult {
    pub id: String,
    pub timestamp: i64,
    pub filename: String,
    pub file_hash: String,
    pub file_size: u64,
    pub declared_content_type: String,
    pub actual_content_type: String,
    pub severity: Severity,
    pub confidence: f64,
    pub threat_types: Vec<AttachmentThreatType>,
    pub sender_address: String,
    pub subject: String,
    pub extension_chain: Vec<String>,
    pub archive_depth: u32,
    pub compression_ratio: f64,
    pub has_macros: bool,
    pub html_smuggling_indicators: Vec<String>,
    pub lnk_target: Option<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct AttachmentStats {
    pub attachments_scanned: u64,
    pub threats_detected: u64,
    pub dangerous_extensions: u64,
    pub double_extensions: u64,
    pub clsid_abuses: u64,
    pub archive_bombs: u64,
    pub executables_in_archives: u64,
    pub html_smuggling: u64,
    pub password_protected: u64,
    pub ole_exploits: u64,
    pub rtf_exploits: u64,
    pub disk_image_attacks: u64,
    pub malicious_lnks: u64,
    pub svg_injections: u64,
    pub macro_enabled: u64,
    pub content_mismatches: u64,
    pub phishing_subjects: u64,
    pub onenote_abuse: u64,
    pub oversized_attachments: u64,
    pub blocked_attachments: u64,
    pub safe_attachments: u64,
    pub total_bytes_scanned: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AttachmentScanConfig {
    pub block_dangerous_extensions: bool,
    pub block_double_extensions: bool,
    pub block_macro_enabled: bool,
    pub block_disk_images: bool,
    pub block_html_smuggling: bool,
    pub zip_bomb_ratio: f64,
    pub max_archive_depth: u32,
    pub max_attachment_size: u64,
    pub scan_rtf_exploits: bool,
    pub scan_ole_streams: bool,
    pub scan_phishing_subjects: bool,
    pub block_on_high_severity: bool,
}

impl AttachmentScanConfig {
    pub fn default_config() -> Self {
        Self {
            block_dangerous_extensions: true,
            block_double_extensions: true,
            block_macro_enabled: true,
            block_disk_images: true,
            block_html_smuggling: true,
            zip_bomb_ratio: ZIP_BOMB_RATIO,
            max_archive_depth: MAX_ARCHIVE_DEPTH,
            max_attachment_size: MAX_ATTACHMENT_SIZE,
            scan_rtf_exploits: true,
            scan_ole_streams: true,
            scan_phishing_subjects: true,
            block_on_high_severity: true,
        }
    }
}

pub struct EmailAttachmentScanner {
    // Breakthrough #1: HierarchicalState — O(log n) scan history rollup
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<AttachmentStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold scan result cache
    event_cache: TieredCache<String, AttachmentScanResult>,
    // Breakthrough #3: ReversibleComputation — recompute risk on demand
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed scan rate
    event_rate: RwLock<StreamAccumulator<f64, AttachmentStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory verification
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — pattern change diffs
    pattern_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted priority eviction
    recent_events: RwLock<PruningMap<String, AttachmentScanResult>>,
    // Breakthrough #592: DedupStore — BLAKE3 content dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — sender × threat-type matrix
    sender_threat_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<AttachmentScanConfig>,
    stats: RwLock<AttachmentStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl EmailAttachmentScanner {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(ATTACH_CACHE_MAX)
            .with_metrics(metrics.clone(), "attachment_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, AttachmentStats::default(),
            |acc: &mut AttachmentStats, rates: &[f64]| {
                for &r in rates { acc.attachments_scanned += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            pattern_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(ATTACH_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            sender_threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(AttachmentScanConfig::default_config()),
            stats: RwLock::new(AttachmentStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("email_attachment", MEMORY_BUDGET / 2);
        info!("EmailAttachmentScanner started — {} dangerous exts, {} double-ext, {} smuggling, {} RTF, {} OLE, {} CLSID, {} phishing subj",
            DANGEROUS_EXTENSIONS.len(), DOUBLE_EXTENSION_PATTERNS.len(),
            HTML_SMUGGLING_PATTERNS.len(), RTF_EXPLOIT_PATTERNS.len(),
            OLE_SUSPICIOUS_STREAMS.len(), CLSID_EXTENSIONS.len(),
            PHISHING_SUBJECT_PATTERNS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("EmailAttachmentScanner stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn get_extensions(filename: &str) -> Vec<String> {
        let parts: Vec<&str> = filename.split('.').collect();
        if parts.len() <= 1 { return vec![]; }
        parts[1..].iter().map(|p| format!(".{}", p.to_lowercase())).collect()
    }

    /// Detect content-type mismatch between declared MIME and actual magic bytes.
    fn detect_content_mismatch(data: &[u8], declared: &str) -> Option<String> {
        let declared_lower = declared.to_lowercase();
        for &(mime, magic, desc) in CONTENT_TYPE_MAPPINGS {
            if declared_lower.contains(mime) && !magic.is_empty() {
                if data.len() >= magic.len() && data[..magic.len()] != *magic {
                    return Some(format!("Declared '{}' ({}) but content doesn't match {} magic bytes",
                        declared, desc, desc));
                }
            }
        }
        None
    }

    /// Shannon entropy for detecting encrypted/compressed content.
    fn shannon_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        let mut entropy = 0.0f64;
        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }
        entropy
    }

    /// Check for RTF exploits in document content.
    fn scan_rtf_exploits(data: &[u8]) -> Vec<(String, f64)> {
        let data_str = String::from_utf8_lossy(data).to_lowercase();
        let mut findings = Vec::new();
        for &(pattern, risk, desc) in RTF_EXPLOIT_PATTERNS {
            if data_str.contains(&pattern.to_lowercase()) {
                findings.push((format!("{}: {}", pattern, desc), risk));
            }
        }
        findings
    }

    /// Check for suspicious OLE streams.
    fn scan_ole_streams(data: &[u8]) -> Vec<(String, f64)> {
        let data_str = String::from_utf8_lossy(data);
        let mut findings = Vec::new();
        for &(stream, risk, desc) in OLE_SUSPICIOUS_STREAMS {
            if data_str.contains(stream) {
                findings.push((format!("{}: {}", stream, desc), risk));
            }
        }
        findings
    }

    /// Scan an email attachment for threats.
    pub fn scan_attachment(
        &self, filename: &str, data: &[u8], file_hash: &str,
        declared_content_type: &str, sender: &str, subject: &str,
    ) -> AttachmentScanResult {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        {
            let mut s = self.stats.write();
            s.attachments_scanned += 1;
            s.total_bytes_scanned += data.len() as u64;
        }

        let config = self.config.read().clone();
        let extensions = Self::get_extensions(filename);
        let filename_lower = filename.to_lowercase();
        let data_str = String::from_utf8_lossy(data);

        let mut threat_types = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut html_smuggling_found = Vec::new();
        let mut lnk_target: Option<String> = None;
        let mut has_macros = false;
        let mut max_risk: f64 = 0.0;
        let mut actual_content_type = String::new();

        // ── 1. Oversized attachment check ──
        if data.len() as u64 > config.max_attachment_size {
            indicators.push(format!("Oversized attachment: {} MB (limit {} MB)",
                data.len() / (1024 * 1024), config.max_attachment_size / (1024 * 1024)));
            self.stats.write().oversized_attachments += 1;
            max_risk = max_risk.max(0.30);
        }

        // ── 2. Dangerous extension check ──
        if let Some(last_ext) = extensions.last() {
            for &(ext, risk, desc) in DANGEROUS_EXTENSIONS {
                if last_ext == ext {
                    indicators.push(format!("Dangerous extension: {} — {}", ext, desc));
                    threat_types.push(AttachmentThreatType::DangerousExtension);
                    self.stats.write().dangerous_extensions += 1;
                    max_risk = max_risk.max(risk);
                    break;
                }
            }
        }

        // ── 3. Double extension detection ──
        for &(pattern, desc) in DOUBLE_EXTENSION_PATTERNS {
            if filename_lower.contains(pattern) {
                indicators.push(format!("Double extension: '{}' — {}", filename, desc));
                threat_types.push(AttachmentThreatType::DoubleExtension);
                self.stats.write().double_extensions += 1;
                mitre_techniques.push("T1036.007".to_string());
                max_risk = max_risk.max(0.95);
                break;
            }
        }

        // ── 4. CLSID extension abuse ──
        for &(clsid, desc, risk) in CLSID_EXTENSIONS {
            if filename.contains(clsid) {
                indicators.push(format!("CLSID extension abuse: {} — {}", clsid, desc));
                threat_types.push(AttachmentThreatType::CLSIDAbuse);
                self.stats.write().clsid_abuses += 1;
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 5. Macro-enabled document ──
        if extensions.iter().any(|e| e.ends_with('m') && (e.contains("doc") || e.contains("xls") || e.contains("ppt"))) {
            indicators.push(format!("Macro-enabled document: {}", filename));
            threat_types.push(AttachmentThreatType::MacroEnabled);
            self.stats.write().macro_enabled += 1;
            has_macros = true;
            max_risk = max_risk.max(0.70);
        }

        // ── 6. HTML smuggling ──
        if filename_lower.ends_with(".html") || filename_lower.ends_with(".htm") || filename_lower.ends_with(".mhtml") {
            for &(pattern, risk, desc) in HTML_SMUGGLING_PATTERNS {
                if data_str.contains(pattern) {
                    html_smuggling_found.push(format!("{}: {}", pattern, desc));
                    max_risk = max_risk.max(risk);
                }
            }
            if !html_smuggling_found.is_empty() {
                indicators.push(format!("HTML smuggling: {} indicators in '{}'",
                    html_smuggling_found.len(), filename));
                threat_types.push(AttachmentThreatType::HTMLSmuggling);
                self.stats.write().html_smuggling += 1;
                mitre_techniques.push("T1027".to_string());
            }
        }

        // ── 7. LNK analysis ──
        if filename_lower.ends_with(".lnk") {
            let data_lower = data_str.to_lowercase();
            for &(target, risk, desc) in LNK_SUSPICIOUS_TARGETS {
                if data_lower.contains(target) {
                    lnk_target = Some(target.to_string());
                    indicators.push(format!("Malicious LNK target: {} — {}", target, desc));
                    threat_types.push(AttachmentThreatType::MaliciousLNK);
                    self.stats.write().malicious_lnks += 1;
                    mitre_techniques.push("T1204.002".to_string());
                    max_risk = max_risk.max(risk);
                    break;
                }
            }
        }

        // ── 8. Disk image (ISO/IMG/VHD) ──
        if filename_lower.ends_with(".iso") || filename_lower.ends_with(".img")
            || filename_lower.ends_with(".vhd") || filename_lower.ends_with(".vhdx") {
            indicators.push(format!("Disk image attachment: {} — bypasses Mark of the Web", filename));
            threat_types.push(AttachmentThreatType::DiskImageAttack);
            self.stats.write().disk_image_attacks += 1;
            max_risk = max_risk.max(0.80);
        }

        // ── 9. SVG with script ──
        if filename_lower.ends_with(".svg") {
            let svg_dangerous = ["<script", "onload=", "onerror=", "onclick=",
                "onmouseover=", "onfocus=", "javascript:", "eval("];
            let svg_hits: Vec<&&str> = svg_dangerous.iter()
                .filter(|p| data_str.to_lowercase().contains(&p.to_lowercase()))
                .collect();
            if !svg_hits.is_empty() {
                indicators.push(format!("SVG injection: {} dangerous patterns — {:?}",
                    svg_hits.len(), svg_hits));
                threat_types.push(AttachmentThreatType::SVGInjection);
                self.stats.write().svg_injections += 1;
                max_risk = max_risk.max(0.75 + svg_hits.len() as f64 * 0.03);
            }
        }

        // ── 10. OneNote abuse ──
        if filename_lower.ends_with(".one") || filename_lower.ends_with(".onepkg") {
            indicators.push(format!("OneNote attachment: {} — potential embedded payload", filename));
            threat_types.push(AttachmentThreatType::OneNoteAbuse);
            self.stats.write().onenote_abuse += 1;
            max_risk = max_risk.max(0.65);
        }

        // ── 11. RTF exploit detection ──
        if config.scan_rtf_exploits && data.len() >= 5 && data[..5] == *RTF_MAGIC {
            actual_content_type = "application/rtf".to_string();
            let rtf_findings = Self::scan_rtf_exploits(data);
            if !rtf_findings.is_empty() {
                for (desc, risk) in &rtf_findings {
                    indicators.push(format!("RTF exploit: {}", desc));
                    max_risk = max_risk.max(*risk);
                }
                threat_types.push(AttachmentThreatType::RTFExploit);
                self.stats.write().rtf_exploits += 1;
                mitre_techniques.push("T1221".to_string());
            }
        }

        // ── 12. OLE compound document analysis ──
        if config.scan_ole_streams && data.len() >= 8 && data[..8] == *OLE_MAGIC {
            actual_content_type = "application/msword".to_string();
            let ole_findings = Self::scan_ole_streams(data);
            if !ole_findings.is_empty() {
                for (desc, risk) in &ole_findings {
                    indicators.push(format!("OLE stream: {}", desc));
                    max_risk = max_risk.max(*risk);
                }
                threat_types.push(AttachmentThreatType::OLEExploit);
                self.stats.write().ole_exploits += 1;
                mitre_techniques.push("T1559.001".to_string());
            }
        }

        // ── 13. Content-type mismatch detection ──
        if let Some(mismatch) = Self::detect_content_mismatch(data, declared_content_type) {
            indicators.push(format!("Content-type mismatch: {}", mismatch));
            threat_types.push(AttachmentThreatType::ContentTypeMismatch);
            self.stats.write().content_mismatches += 1;
            max_risk = max_risk.max(0.65);
        }

        // ── 14. Phishing subject line analysis ──
        if config.scan_phishing_subjects {
            let subj_lower = subject.to_lowercase();
            let mut phishing_hits = Vec::new();
            for &(pattern, risk, desc) in PHISHING_SUBJECT_PATTERNS {
                if subj_lower.contains(pattern) {
                    phishing_hits.push(desc);
                    max_risk = max_risk.max(risk * 0.5); // Subject alone = lower confidence
                }
            }
            if phishing_hits.len() >= 2 {
                indicators.push(format!("Phishing subject: {} indicators — {}",
                    phishing_hits.len(), phishing_hits.join(", ")));
                self.stats.write().phishing_subjects += 1;
                // Boost risk if subject AND dangerous attachment
                if !threat_types.is_empty() {
                    max_risk = max_risk.max(0.80);
                }
            }
        }

        // ── 15. High-entropy content (encrypted/packed) ──
        let file_entropy = Self::shannon_entropy(data);
        if file_entropy > HIGH_ENTROPY_THRESHOLD && data.len() > 1024 {
            indicators.push(format!("High entropy content: {:.3} bits/byte — encrypted or packed",
                file_entropy));
            if filename_lower.ends_with(".zip") || filename_lower.ends_with(".rar") || filename_lower.ends_with(".7z") {
                // Password-protected archive has high entropy
                threat_types.push(AttachmentThreatType::PasswordProtectedArchive);
                self.stats.write().password_protected += 1;
                max_risk = max_risk.max(0.60);
            }
        }

        // ── Finalize ──
        threat_types.sort();
        threat_types.dedup();
        if !threat_types.is_empty() && mitre_techniques.is_empty() {
            mitre_techniques.push("T1566.001".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.65 + indicators.len() as f64 * 0.04).min(0.99);
        let blocked = config.block_on_high_severity && matches!(severity, Severity::Critical | Severity::High);

        if threat_types.is_empty() { self.stats.write().safe_attachments += 1; }
        else { self.stats.write().threats_detected += 1; }
        if blocked { self.stats.write().blocked_attachments += 1; }

        // Breakthrough #627: SparseMatrix — update sender × threat-type
        for tt in &threat_types {
            let c = *self.sender_threat_matrix.read()
                .get(&sender.to_string(), &format!("{:?}", tt));
            self.sender_threat_matrix.write()
                .set(sender.to_string(), format!("{:?}", tt), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let result = AttachmentScanResult {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, filename: filename.to_string(),
            file_hash: file_hash.to_string(), file_size: data.len() as u64,
            declared_content_type: declared_content_type.to_string(),
            actual_content_type,
            severity, confidence, threat_types,
            sender_address: sender.to_string(), subject: subject.to_string(),
            extension_chain: extensions, archive_depth: 0,
            compression_ratio: 0.0, has_macros,
            html_smuggling_indicators: html_smuggling_found,
            lnk_target, indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(result.id.clone(), result.clone());
        self.recent_events.write().insert_with_priority(result.id.clone(), result.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.sender_threat_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.pattern_diffs.write().record_insert(
            result.id.clone(),
            format!("{:?}", result),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            result.id.clone(),
            format!("{:?}", result).into_bytes(),
        );

        if blocked {
            warn!("ATTACHMENT BLOCKED: '{}' from {} — {:?}", filename, sender, result.threat_types);
        }
        result
    }

    pub fn update_config(&self, config: AttachmentScanConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> AttachmentStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
