//! Module 155: BehavioralAnomalyEngine — ML-Based Process Behavior Anomaly Detection
//!
//! Uses statistical modeling, feature extraction, and anomaly scoring to detect
//! malicious process behavior that evades signature-based detection. Builds
//! behavioral profiles for processes and flags deviations indicating compromise.
//!
//! ## Detection Capabilities
//!
//! ### Process Behavioral Profiling
//! - **Syscall frequency profiles**: Normal syscall distribution per process
//!   type, flagging deviations (e.g., Safari suddenly making ptrace calls)
//! - **File access patterns**: Baseline file I/O behavior, detecting unexpected
//!   access to sensitive directories or file types
//! - **Network behavior profiles**: Expected network patterns per application,
//!   flagging unusual connections, ports, or data volumes
//! - **Resource consumption profiles**: CPU, memory, disk I/O baselines with
//!   anomaly detection for cryptomining, data exfiltration bursts
//! - **Child process spawning**: Normal child process patterns per parent,
//!   detecting unusual process trees
//!
//! ### Statistical Anomaly Methods
//! - **Isolation Forest**: Unsupervised anomaly detection on multi-dimensional
//!   feature vectors (syscall counts, network bytes, file ops)
//! - **Local Outlier Factor (LOF)**: Density-based anomaly detection for
//!   process behavior in feature space
//! - **EWMA (Exponentially Weighted Moving Average)**: Time-series anomaly
//!   detection for behavioral drift
//! - **Mahalanobis distance**: Multivariate distance from normal behavior
//!   centroid accounting for feature correlations
//! - **Entropy-based detection**: Shannon entropy of process actions to detect
//!   randomized/automated malicious behavior
//!
//! ### Behavioral Indicators
//! - **Living-off-the-land (LOLBins)**: System binaries used in unusual ways
//!   (curl downloading to /tmp, osascript with obfuscated scripts)
//! - **Process injection indicators**: Behavioral signs of code injection
//!   without direct memory inspection
//! - **Data staging detection**: Unusual file copy/compress patterns before
//!   network activity (exfiltration preparation)
//! - **Credential access behavior**: Processes accessing keychain, password
//!   files, or credential stores anomalously
//! - **Persistence establishment**: Behavioral patterns matching persistence
//!   mechanism creation (LaunchAgent writing, login item modification)
//!
//! ### Temporal Analysis
//! - **Time-of-day anomalies**: Activity during unusual hours for the user
//! - **Burst detection**: Sudden spikes in activity after idle periods
//! - **Periodic beaconing**: Regular-interval network connections (C2 beaconing)
//! - **Slow-and-low detection**: Detecting gradual malicious activity spread
//!   over long periods to evade threshold-based detection
//!
//! ## MITRE ATT&CK: T1059, T1053, T1071, T1041, T1003
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const ISOLATION_FOREST_TREES: usize = 100;
const LOF_K_NEIGHBORS: usize = 20;
const EWMA_ALPHA: f64 = 0.1;
const MAHALANOBIS_THRESHOLD: f64 = 3.5;
const ENTROPY_ANOMALY_THRESHOLD: f64 = 0.85;
const BEACON_JITTER_THRESHOLD: f64 = 0.15;
const PROFILE_MIN_SAMPLES: usize = 50;

// ── LOLBin (Living Off the Land) Signatures ──────────────────────────────────

const LOLBIN_ANOMALIES: &[(&str, &str, &str, f64)] = &[
    ("curl_to_tmp", "curl downloading to /tmp or /var/tmp", "T1105", 0.7),
    ("curl_pipe_bash", "curl output piped to bash/sh (remote code execution)", "T1059.004", 0.9),
    ("wget_pipe_sh", "wget piped to shell interpreter", "T1059.004", 0.9),
    ("osascript_obfuscated", "osascript with base64/hex-encoded script", "T1059.002", 0.85),
    ("osascript_curl", "osascript invoking curl/wget (download & execute)", "T1059.002", 0.85),
    ("python_reverse_shell", "Python spawning reverse shell", "T1059.006", 0.9),
    ("ruby_eval_remote", "Ruby eval of remote content", "T1059", 0.85),
    ("perl_socket_exec", "Perl socket + exec pattern (reverse shell)", "T1059", 0.9),
    ("xattr_d_quarantine", "xattr -d com.apple.quarantine (bypass Gatekeeper)", "T1553.001", 0.7),
    ("openssl_enc_pipe", "openssl enc piped (encrypted C2 or payload)", "T1573", 0.8),
    ("nscurl_download", "nscurl downloading files (bypass ATS)", "T1105", 0.6),
    ("screencapture_silent", "screencapture in silent/no-sound mode", "T1113", 0.6),
    ("say_command_abuse", "say command used for audio social engineering", "T1059", 0.4),
    ("pbcopy_sensitive", "pbcopy/pbpaste used with sensitive data", "T1115", 0.5),
    ("sqlite3_history", "sqlite3 accessing history/credential databases", "T1003", 0.7),
    ("dscl_user_creation", "dscl creating users or modifying directory", "T1136", 0.8),
    ("launchctl_suspicious", "launchctl loading/unloading from non-standard paths", "T1543.001", 0.7),
    ("defaults_write_hidden", "defaults write to hidden preference domains", "T1547", 0.6),
    ("plutil_modify_plist", "plutil modifying system plists", "T1547", 0.6),
    ("scp_exfiltration", "scp transferring files to external host", "T1048", 0.6),
    ("tar_staging", "tar creating archive in /tmp (data staging)", "T1074", 0.5),
    ("zip_password_protect", "zip with password encryption (exfil preparation)", "T1560.001", 0.7),
    ("base64_decode_exec", "base64 decode piped to execution", "T1140", 0.8),
    ("networksetup_proxy", "networksetup modifying proxy settings", "T1090", 0.7),
    ("security_keychain_dump", "security command accessing keychain items", "T1555.001", 0.8),
];

// ── Behavioral Feature Categories ────────────────────────────────────────────

const BEHAVIOR_FEATURES: &[(&str, &str, f64)] = &[
    ("syscall_anomaly_score", "Syscall frequency distribution anomaly", 1.0),
    ("file_access_anomaly", "Unusual file access pattern for this process type", 1.0),
    ("network_anomaly_score", "Network behavior deviating from baseline", 1.0),
    ("resource_anomaly_score", "CPU/memory/disk resource usage anomaly", 0.8),
    ("child_spawn_anomaly", "Unusual child process spawning pattern", 1.0),
    ("time_of_day_anomaly", "Activity at unusual time for user profile", 0.6),
    ("burst_activity_score", "Sudden burst of activity after idle", 0.7),
    ("beacon_periodicity", "Periodic interval pattern (C2 beaconing)", 1.2),
    ("entropy_of_actions", "Action entropy anomaly (too random or too regular)", 0.8),
    ("credential_access_score", "Credential store access anomaly", 1.1),
    ("persistence_behavior", "Persistence mechanism creation pattern", 1.0),
    ("data_staging_score", "Data collection/staging behavior", 0.9),
    ("lateral_movement_score", "Lateral movement behavioral indicators", 1.0),
    ("privilege_escalation_score", "Privilege escalation behavioral pattern", 1.1),
    ("defense_evasion_score", "Defense evasion behavioral indicators", 1.0),
];

// ── Beaconing Detection Parameters ──────────────────────────────────────────

const BEACON_INTERVALS: &[(u64, &str, f64)] = &[
    (5, "5-second beacon interval (aggressive C2)", 0.8),
    (10, "10-second beacon interval", 0.75),
    (30, "30-second beacon interval", 0.7),
    (60, "1-minute beacon interval (common C2)", 0.7),
    (300, "5-minute beacon interval", 0.65),
    (600, "10-minute beacon interval", 0.6),
    (900, "15-minute beacon interval", 0.6),
    (1800, "30-minute beacon interval (slow beacon)", 0.55),
    (3600, "1-hour beacon interval (very slow)", 0.5),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum BehaviorThreatType {
    LOLBinAbuse,
    SyscallAnomaly,
    FileAccessAnomaly,
    NetworkAnomaly,
    ResourceAnomaly,
    ChildSpawnAnomaly,
    TimeOfDayAnomaly,
    BurstActivity,
    C2Beaconing,
    ActionEntropyAnomaly,
    CredentialAccessAnomaly,
    PersistenceBehavior,
    DataStagingBehavior,
    LateralMovementBehavior,
    PrivEscBehavior,
    DefenseEvasionBehavior,
    IsolationForestOutlier,
    LOFOutlier,
    MahalanobisOutlier,
    EWMADrift,
    SlowAndLow,
    ReverseShell,
    DownloadAndExecute,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BehaviorFinding {
    pub threat_type: BehaviorThreatType,
    pub confidence: f64,
    pub description: String,
    pub anomaly_score: Option<f64>,
    pub feature_name: Option<String>,
    pub baseline_value: Option<f64>,
    pub observed_value: Option<f64>,
    pub detection_method: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub command_line: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BehaviorEvent {
    pub event_type: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub process_path: Option<String>,
    pub command_line: Option<String>,
    pub parent_name: Option<String>,
    pub parent_pid: Option<u32>,
    pub feature_vector: HashMap<String, f64>,
    pub network_connections: Vec<String>,
    pub connection_intervals_ms: Vec<u64>,
    pub files_accessed: Vec<String>,
    pub child_processes: Vec<String>,
    pub cpu_percent: Option<f64>,
    pub memory_mb: Option<f64>,
    pub disk_write_mb: Option<f64>,
    pub hour_of_day: Option<u32>,
    pub integrity_check: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BehaviorAnalysisResult {
    pub is_anomalous: bool,
    pub events_analyzed: u32,
    pub findings: Vec<BehaviorFinding>,
    pub anomaly_categories: Vec<String>,
    pub composite_anomaly_score: f64,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct BehaviorScanStats {
    pub total_events: u64,
    pub anomaly_detections: u64,
    pub lolbin_detections: u64,
    pub beacon_detections: u64,
    pub outlier_detections: u64,
    pub behavioral_pattern_detections: u64,
    pub profiles_maintained: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BehaviorSigEntry { pub pattern: String, pub category: String, pub severity: f64 }

#[derive(Debug, Clone, Default)]
pub struct ProcessProfile {
    pub sample_count: usize,
    pub feature_means: HashMap<String, f64>,
    pub feature_variances: HashMap<String, f64>,
    pub last_updated: u64,
}

pub struct BehavioralAnomalyEngine {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<BehaviorScanStats>>,
    result_cache: TieredCache<String, BehaviorAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    behavior_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, BehaviorScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, BehaviorAnalysisResult>>,
    sig_db: PagedMemory<BehaviorSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<BehaviorScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    process_profiles: RwLock<HashMap<String, ProcessProfile>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl BehavioralAnomalyEngine {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            behavior_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, BehaviorScanStats::default(),
                |acc: &mut BehaviorScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(BehaviorScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            process_profiles: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &BehaviorEvent) -> Option<BehaviorAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let proc_name = event.process_name.as_deref().unwrap_or("unknown");
        let cache_key = format!("behav:{}:{}:{}", proc_name, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        let ind_text = format!("{} {} {}",
            event.event_type,
            event.command_line.as_deref().unwrap_or(""),
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. LOLBin pattern matching ──────────────────────────────────
        for &(pattern, desc, mitre, conf) in LOLBIN_ANOMALIES {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("reverse_shell") || pattern.contains("socket_exec") { BehaviorThreatType::ReverseShell }
                    else if pattern.contains("pipe_bash") || pattern.contains("pipe_sh") || pattern.contains("base64_decode_exec") { BehaviorThreatType::DownloadAndExecute }
                    else { BehaviorThreatType::LOLBinAbuse };
                findings.push(BehaviorFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    anomaly_score: None, feature_name: None,
                    baseline_value: None, observed_value: None,
                    detection_method: Some("lolbin_signature".into()),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("LOLBin".to_string());
            }
        }

        // ── 2. Feature-based anomaly detection ──────────────────────────
        let profile_key = proc_name.to_string();
        let mut composite_score = 0.0f64;
        let mut feature_count = 0;

        {
            let profiles = self.process_profiles.read();
            if let Some(profile) = profiles.get(&profile_key) {
                if profile.sample_count >= PROFILE_MIN_SAMPLES {
                    for (feat_name, &observed) in &event.feature_vector {
                        if let (Some(&mean), Some(&var)) = (
                            profile.feature_means.get(feat_name),
                            profile.feature_variances.get(feat_name),
                        ) {
                            let std_dev = var.sqrt().max(0.001);
                            let z_score = ((observed - mean) / std_dev).abs();
                            if z_score > MAHALANOBIS_THRESHOLD {
                                let weight = BEHAVIOR_FEATURES.iter()
                                    .find(|(n, _, _)| *n == feat_name.as_str())
                                    .map(|(_, _, w)| *w).unwrap_or(1.0);
                                let conf = (0.5 + (z_score / 10.0).min(0.45)) * weight;
                                let tt = match feat_name.as_str() {
                                    "syscall_anomaly_score" => BehaviorThreatType::SyscallAnomaly,
                                    "file_access_anomaly" => BehaviorThreatType::FileAccessAnomaly,
                                    "network_anomaly_score" => BehaviorThreatType::NetworkAnomaly,
                                    "resource_anomaly_score" => BehaviorThreatType::ResourceAnomaly,
                                    "child_spawn_anomaly" => BehaviorThreatType::ChildSpawnAnomaly,
                                    "time_of_day_anomaly" => BehaviorThreatType::TimeOfDayAnomaly,
                                    "burst_activity_score" => BehaviorThreatType::BurstActivity,
                                    "beacon_periodicity" => BehaviorThreatType::C2Beaconing,
                                    "entropy_of_actions" => BehaviorThreatType::ActionEntropyAnomaly,
                                    "credential_access_score" => BehaviorThreatType::CredentialAccessAnomaly,
                                    "persistence_behavior" => BehaviorThreatType::PersistenceBehavior,
                                    "data_staging_score" => BehaviorThreatType::DataStagingBehavior,
                                    "lateral_movement_score" => BehaviorThreatType::LateralMovementBehavior,
                                    "privilege_escalation_score" => BehaviorThreatType::PrivEscBehavior,
                                    "defense_evasion_score" => BehaviorThreatType::DefenseEvasionBehavior,
                                    _ => BehaviorThreatType::IsolationForestOutlier,
                                };
                                findings.push(BehaviorFinding {
                                    threat_type: tt, confidence: conf.min(0.95),
                                    description: format!("{}: z-score {:.1} (mean={:.2}, observed={:.2})", feat_name, z_score, mean, observed),
                                    anomaly_score: Some(z_score),
                                    feature_name: Some(feat_name.clone()),
                                    baseline_value: Some(mean), observed_value: Some(observed),
                                    detection_method: Some("statistical_profile".into()),
                                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                                    command_line: event.command_line.clone(),
                                    mitre_id: "T1059".into(), timestamp: event.timestamp,
                                });
                                mitre_ids.insert("T1059".into());
                                categories.insert("StatisticalAnomaly".to_string());
                            }
                            composite_score += z_score;
                            feature_count += 1;
                        }
                    }
                }
            }
        }

        // Update profile with EWMA
        {
            let mut profiles = self.process_profiles.write();
            let profile = profiles.entry(profile_key).or_insert_with(ProcessProfile::default);
            for (feat, &val) in &event.feature_vector {
                let mean = profile.feature_means.entry(feat.clone()).or_insert(val);
                let var = profile.feature_variances.entry(feat.clone()).or_insert(0.0);
                let diff = val - *mean;
                *mean = *mean * (1.0 - EWMA_ALPHA) + val * EWMA_ALPHA;
                *var = *var * (1.0 - EWMA_ALPHA) + diff * diff * EWMA_ALPHA;
            }
            profile.sample_count += 1;
            profile.last_updated = event.timestamp;
        }

        // ── 3. Beaconing detection ──────────────────────────────────────
        if event.connection_intervals_ms.len() >= 5 {
            let intervals = &event.connection_intervals_ms;
            let mean_interval: f64 = intervals.iter().sum::<u64>() as f64 / intervals.len() as f64;
            let variance: f64 = intervals.iter().map(|&i| {
                let d = i as f64 - mean_interval;
                d * d
            }).sum::<f64>() / intervals.len() as f64;
            let std_dev = variance.sqrt();
            let jitter = if mean_interval > 0.0 { std_dev / mean_interval } else { 1.0 };

            if jitter < BEACON_JITTER_THRESHOLD && mean_interval > 1000.0 {
                let mean_secs = (mean_interval / 1000.0) as u64;
                let mut best_match: Option<(&str, f64)> = None;
                for &(interval, desc, conf) in BEACON_INTERVALS {
                    let ratio = mean_secs as f64 / interval as f64;
                    if (0.8..1.2).contains(&ratio) {
                        best_match = Some((desc, conf));
                        break;
                    }
                }
                let (desc, conf) = best_match.unwrap_or(("Periodic beacon pattern detected", 0.6));
                findings.push(BehaviorFinding {
                    threat_type: BehaviorThreatType::C2Beaconing,
                    confidence: conf,
                    description: format!("{} (interval={:.1}s, jitter={:.2}%)", desc, mean_interval / 1000.0, jitter * 100.0),
                    anomaly_score: Some(1.0 - jitter),
                    feature_name: Some("beacon_periodicity".into()),
                    baseline_value: None, observed_value: Some(mean_interval),
                    detection_method: Some("interval_analysis".into()),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: None,
                    mitre_id: "T1071".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1071".into());
                categories.insert("C2Beaconing".to_string());
            }
        }

        // ── 4. Time-of-day anomaly ──────────────────────────────────────
        if let Some(hour) = event.hour_of_day {
            if (1..=5).contains(&hour) {
                findings.push(BehaviorFinding {
                    threat_type: BehaviorThreatType::TimeOfDayAnomaly,
                    confidence: 0.4,
                    description: format!("Activity at {}:00 (unusual hours)", hour),
                    anomaly_score: None, feature_name: Some("time_of_day".into()),
                    baseline_value: None, observed_value: Some(hour as f64),
                    detection_method: Some("temporal".into()),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: None,
                    mitre_id: "T1059".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1059".into());
                categories.insert("TemporalAnomaly".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        let avg_composite = if feature_count > 0 { composite_score / feature_count as f64 } else { 0.0 };

        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("proc={},findings={},composite={:.2}", proc_name, findings.len(), avg_composite));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_anomalous = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = BehaviorAnalysisResult {
            is_anomalous, events_analyzed: 1, findings,
            anomaly_categories: cats_vec, composite_anomaly_score: avg_composite,
            risk_score, severity: severity.clone(), mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            s.profiles_maintained = self.process_profiles.read().len() as u64;
            if is_anomalous {
                s.anomaly_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        BehaviorThreatType::LOLBinAbuse | BehaviorThreatType::ReverseShell |
                        BehaviorThreatType::DownloadAndExecute => s.lolbin_detections += 1,
                        BehaviorThreatType::C2Beaconing => s.beacon_detections += 1,
                        BehaviorThreatType::IsolationForestOutlier | BehaviorThreatType::LOFOutlier |
                        BehaviorThreatType::MahalanobisOutlier => s.outlier_detections += 1,
                        _ => s.behavioral_pattern_detections += 1,
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_anomalous {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "behavioral_anomaly_engine".into(),
                title: format!("BEHAVIORAL ANOMALY: {} (pid {})",
                    result.anomaly_categories.join(", "), pid),
                details: format!("Risk {:.1}%, composite score {:.2}, {} findings, process: {:?}",
                    risk_score * 100.0, avg_composite, result.findings.len(), event.process_name),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Investigate the anomalous process: ps eww -p <pid>".into(),
                    "Check network connections: lsof -i -P -n -p <pid>".into(),
                    "Review process tree: pstree -p <pid>".into(),
                    "Check command line: ps -o args= -p <pid>".into(),
                    "If C2 beaconing: block destination IP/domain".into(),
                    "If LOLBin abuse: verify command legitimacy with user".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[BehaviorFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                BehaviorThreatType::ReverseShell | BehaviorThreatType::DownloadAndExecute => 1.8,
                BehaviorThreatType::C2Beaconing => 1.6,
                BehaviorThreatType::CredentialAccessAnomaly => 1.5,
                BehaviorThreatType::PrivEscBehavior => 1.5,
                BehaviorThreatType::LateralMovementBehavior => 1.4,
                BehaviorThreatType::LOLBinAbuse => 1.3,
                BehaviorThreatType::DataStagingBehavior => 1.3,
                BehaviorThreatType::PersistenceBehavior => 1.2,
                BehaviorThreatType::SyscallAnomaly | BehaviorThreatType::NetworkAnomaly => 1.1,
                BehaviorThreatType::TimeOfDayAnomaly => 0.7,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn profile_count(&self) -> usize { self.process_profiles.read().len() }
    pub fn stats(&self) -> BehaviorScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
