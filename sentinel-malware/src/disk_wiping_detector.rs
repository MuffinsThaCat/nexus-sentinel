//! Module 152: DiskWipingDetector — Secure Deletion & Evidence Destruction Detection
//!
//! Detects anti-forensic secure deletion, disk wiping, file shredding, and
//! evidence destruction techniques on macOS. Monitors for tools and system
//! calls that irreversibly destroy data to obstruct incident response.
//!
//! ## Detection Capabilities
//!
//! ### Secure File Deletion
//! - **srm/shred detection**: Secure removal tools that overwrite file data
//!   before unlinking (Gutmann, DoD 5220.22-M patterns)
//! - **gshred/wipe/bleachbit**: Third-party secure deletion tools
//! - **APFS clone-aware wiping**: Detection of tools that understand APFS
//!   copy-on-write semantics for thorough deletion
//! - **Unlink after overwrite**: Patterns of write→fsync→unlink that indicate
//!   manual secure deletion
//! - **Sparse file creation**: Overwriting files with sparse data to defeat
//!   forensic recovery
//!
//! ### Disk/Volume Wiping
//! - **diskutil secureErase**: macOS secure erase via diskutil
//! - **dd if=/dev/zero**: Zeroing disk devices or partitions
//! - **dd if=/dev/urandom**: Random data overwrite of storage
//! - **TRIM/UNMAP abuse**: Issuing TRIM commands to SSDs to prevent data
//!   recovery from flash storage
//! - **diskutil eraseDisk/eraseVolume**: Volume-level erasure
//! - **APFS volume deletion**: Deleting APFS volumes to destroy data
//! - **FileVault destruction**: Destroying FileVault encryption keys to
//!   render disk contents unrecoverable
//!
//! ### Log & Artifact Destruction
//! - **Unified log deletion**: Removing /var/db/diagnostics/ contents
//! - **ASL log deletion**: Removing /var/log/asl/ contents
//! - **Audit log deletion**: Removing /var/audit/ BSM audit trails
//! - **Bash/zsh history clearing**: Removing shell command history
//! - **Browser data wiping**: Clearing browser history, cookies, cache
//! - **Recent items clearing**: Clearing macOS recent items lists
//! - **Trash secure empty**: Secure emptying of Trash
//! - **Spotlight index destruction**: Removing Spotlight databases
//! - **QuarantineEvents clearing**: Removing download quarantine history
//! - **KnowledgeC deletion**: Removing application usage knowledge database
//!
//! ### Memory & Swap Wiping
//! - **Swap file wiping**: Overwriting or deleting swap/page files
//! - **Hibernation file deletion**: Removing sleepimage to destroy RAM
//!   contents from hibernation
//! - **Memory zeroing on exit**: Processes that zero their memory before
//!   termination (anti-forensic cleanup)
//!
//! ## MITRE ATT&CK: T1070.001, T1070.002, T1070.003, T1070.004, T1485, T1561
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const BULK_DELETE_THRESHOLD: u32 = 50;
const BULK_DELETE_WINDOW_SECS: u64 = 60;

// ── Secure Deletion Tool Signatures ──────────────────────────────────────────

const SECURE_DELETE_TOOLS: &[(&str, &str, &str, f64)] = &[
    ("srm", "srm (secure remove) — multi-pass file overwrite", "T1070.004", 0.9),
    ("shred", "shred — overwrite file with random data then delete", "T1070.004", 0.85),
    ("gshred", "gshred (GNU shred) — secure file deletion", "T1070.004", 0.85),
    ("wipe", "wipe utility — secure file/directory removal", "T1070.004", 0.85),
    ("bleachbit", "BleachBit — system cleaner/evidence destroyer", "T1070.004", 0.8),
    ("eraser", "Eraser — secure file deletion tool", "T1070.004", 0.85),
    ("fileshredder", "File Shredder — GUI secure deletion", "T1070.004", 0.8),
    ("ccleaner", "CCleaner — system cleaner (may destroy evidence)", "T1070.004", 0.6),
    ("cleanmymac", "CleanMyMac — macOS cleaner (artifact destruction)", "T1070.004", 0.5),
    ("macbleach", "MacBleach — macOS evidence cleaner", "T1070.004", 0.8),
    ("securedelete", "Secure Delete framework/tool", "T1070.004", 0.85),
    ("sdelete", "SDelete-style secure deletion", "T1070.004", 0.85),
    ("nwipe", "nwipe — disk wiping utility", "T1561.001", 0.9),
    ("dban", "DBAN — Darik's Boot and Nuke", "T1561.001", 0.95),
];

// ── Disk/Volume Wiping Indicators ────────────────────────────────────────────

const DISK_WIPE_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("diskutil_secureErase", "diskutil secureErase — Apple secure erase", "T1561.001", 0.9),
    ("diskutil_eraseDisk", "diskutil eraseDisk — volume erasure", "T1561.001", 0.85),
    ("diskutil_eraseVolume", "diskutil eraseVolume — volume-level wipe", "T1561.001", 0.85),
    ("diskutil_apfs_deleteVolume", "APFS volume deletion", "T1561.001", 0.8),
    ("dd_dev_zero", "dd if=/dev/zero — zeroing disk/partition", "T1561.001", 0.9),
    ("dd_dev_urandom", "dd if=/dev/urandom — random overwrite", "T1561.001", 0.9),
    ("dd_dev_rdisk", "dd writing to raw disk device (/dev/rdisk*)", "T1561.001", 0.95),
    ("trim_manual", "Manual TRIM/UNMAP commands to SSD", "T1561.001", 0.7),
    ("fstrim", "fstrim — filesystem TRIM operation", "T1561.001", 0.6),
    ("filevault_destroy_keys", "FileVault encryption keys destroyed", "T1561.001", 0.95),
    ("cs_revert_volume", "CoreStorage revert (decryption removal)", "T1561.001", 0.8),
    ("apfs_crypto_erase", "APFS cryptographic erase", "T1561.001", 0.95),
    ("hdiutil_destroy", "hdiutil destroying disk image", "T1561.001", 0.7),
];

// ── Log & Artifact Destruction ───────────────────────────────────────────────

const LOG_DESTRUCTION_INDICATORS: &[(&str, &str, &str, f64)] = &[
    // System logs
    ("rm_var_log", "Deleting files in /var/log/", "T1070.001", 0.85),
    ("rm_unified_log", "Deleting unified log data (/var/db/diagnostics/)", "T1070.001", 0.95),
    ("rm_asl_log", "Deleting ASL logs (/var/log/asl/)", "T1070.001", 0.9),
    ("rm_audit_log", "Deleting audit trails (/var/audit/)", "T1070.002", 0.95),
    ("rm_install_log", "Deleting install.log", "T1070.001", 0.7),
    ("rm_system_log", "Deleting system.log", "T1070.001", 0.8),
    ("rm_wifi_log", "Deleting WiFi logs", "T1070.001", 0.6),
    ("rm_crashreporter", "Deleting CrashReporter data", "T1070.001", 0.7),
    ("rm_diagnostic_reports", "Deleting DiagnosticReports", "T1070.001", 0.7),
    // Shell history
    ("rm_bash_history", "Deleting .bash_history", "T1070.003", 0.85),
    ("rm_zsh_history", "Deleting .zsh_history", "T1070.003", 0.85),
    ("history_c", "Running 'history -c' to clear shell history", "T1070.003", 0.8),
    ("unset_histfile", "Unsetting HISTFILE to prevent history recording", "T1070.003", 0.8),
    ("histsize_zero", "Setting HISTSIZE=0 to disable history", "T1070.003", 0.8),
    ("ln_dev_null_history", "Symlink history file to /dev/null", "T1070.003", 0.9),
    // Browser data
    ("rm_safari_history", "Deleting Safari history", "T1070.004", 0.7),
    ("rm_chrome_history", "Deleting Chrome history/cookies", "T1070.004", 0.7),
    ("rm_firefox_history", "Deleting Firefox places.sqlite", "T1070.004", 0.7),
    ("browser_clear_all", "Browser clear all browsing data", "T1070.004", 0.6),
    // macOS artifacts
    ("rm_quarantine_events", "Deleting QuarantineEventsV2 database", "T1070.004", 0.9),
    ("rm_lsquarantine", "Deleting LSQuarantineEvents", "T1070.004", 0.9),
    ("rm_knowledgec", "Deleting KnowledgeC.db (app usage database)", "T1070.004", 0.85),
    ("rm_recent_items", "Clearing recent items (com.apple.LSSharedFileList)", "T1070.004", 0.7),
    ("rm_recent_servers", "Clearing recent servers list", "T1070.004", 0.6),
    ("rm_spotlight_db", "Deleting Spotlight database (.Spotlight-V100)", "T1070.004", 0.8),
    ("rm_fsevents", "Deleting FSEvents data (/.fseventsd/)", "T1070.004", 0.9),
    ("rm_launch_services", "Clearing Launch Services database", "T1070.004", 0.7),
    ("rm_dock_plist", "Deleting Dock recent apps plist", "T1070.004", 0.6),
    ("rm_finder_recents", "Deleting Finder recent places", "T1070.004", 0.6),
    ("trash_secure_empty", "Secure Empty Trash (multi-pass overwrite)", "T1070.004", 0.7),
    ("rm_rf_trash", "rm -rf ~/.Trash/* (bulk trash deletion)", "T1070.004", 0.6),
];

// ── Memory/Swap Wiping ───────────────────────────────────────────────────────

const MEMORY_WIPE_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("swap_file_deleted", "Swap file deleted or overwritten", "T1070.004", 0.8),
    ("sleepimage_deleted", "Hibernation sleepimage deleted", "T1070.004", 0.75),
    ("memory_zero_on_exit", "Process zeroing memory before exit (anti-forensic)", "T1070.004", 0.6),
    ("vm_swapfile_wipe", "VM swap files wiped", "T1070.004", 0.7),
    ("purge_command", "purge command executed (memory cache flush)", "T1070.004", 0.4),
    ("pmset_hibernate_off", "pmset hibernatemode 0 (disable hibernation)", "T1070.004", 0.5),
    ("sudo_purge", "sudo purge — force memory purge", "T1070.004", 0.5),
];

// ── Overwrite Patterns ───────────────────────────────────────────────────────

const OVERWRITE_PATTERNS: &[(&str, &str, f64)] = &[
    ("gutmann_35_pass", "Gutmann 35-pass overwrite pattern", 0.95),
    ("dod_3_pass", "DoD 5220.22-M 3-pass overwrite", 0.9),
    ("dod_7_pass", "DoD 5220.22-M 7-pass overwrite", 0.95),
    ("zero_fill", "Zero-fill overwrite (single pass)", 0.7),
    ("random_fill", "Random data fill overwrite", 0.75),
    ("pattern_fill", "Repeating pattern fill (0xAA/0x55)", 0.8),
    ("write_fsync_unlink", "write→fsync→unlink sequence (manual secure delete)", 0.75),
    ("mmap_overwrite_munmap", "mmap→memset→msync→munmap (memory-mapped overwrite)", 0.7),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum WipingThreatType {
    SecureDeleteTool,
    ShredTool,
    SystemCleaner,
    DiskSecureErase,
    VolumeErase,
    APFSVolumeDelete,
    DDZeroing,
    TRIMAbuse,
    FileVaultKeyDestruction,
    CryptoErase,
    UnifiedLogDeletion,
    ASLDeletion,
    AuditLogDeletion,
    ShellHistoryClearing,
    BrowserDataWiping,
    QuarantineEventsDeletion,
    KnowledgeCDeletion,
    SpotlightDBDeletion,
    FSEventsDeletion,
    RecentItemsClearing,
    TrashSecureEmpty,
    SwapFileWiping,
    HibernationFileDelete,
    MemoryZeroing,
    BulkFileDeletion,
    GutmannOverwrite,
    DoDOverwrite,
    ManualSecureDelete,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WipingFinding {
    pub threat_type: WipingThreatType,
    pub confidence: f64,
    pub description: String,
    pub tool_name: Option<String>,
    pub target_path: Option<String>,
    pub overwrite_pattern: Option<String>,
    pub pass_count: Option<u32>,
    pub files_affected: Option<u32>,
    pub bytes_wiped: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub command_line: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WipingEvent {
    pub event_type: String,
    pub tool_name: Option<String>,
    pub target_path: Option<String>,
    pub command_line: Option<String>,
    pub files_deleted: Option<u32>,
    pub bytes_written: Option<u64>,
    pub overwrite_passes: Option<u32>,
    pub is_disk_device: bool,
    pub disk_device: Option<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WipingAnalysisResult {
    pub is_wiping: bool,
    pub events_analyzed: u32,
    pub findings: Vec<WipingFinding>,
    pub wiping_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct WipingScanStats {
    pub total_events: u64,
    pub wiping_detections: u64,
    pub secure_delete_detections: u64,
    pub disk_wipe_detections: u64,
    pub log_destruction_detections: u64,
    pub artifact_destruction_detections: u64,
    pub memory_wipe_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WipingSigEntry { pub tool: String, pub description: String, pub severity: f64 }

pub struct DiskWipingDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<WipingScanStats>>,
    result_cache: TieredCache<String, WipingAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    wipe_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, WipingScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, WipingAnalysisResult>>,
    sig_db: PagedMemory<WipingSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<WipingScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl DiskWipingDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            wipe_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, WipingScanStats::default(),
                |acc: &mut WipingScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(WipingScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &WipingEvent) -> Option<WipingAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("wipe:{}:{}:{}", event.event_type, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        let ind_text = format!("{} {} {} {}",
            event.event_type,
            event.command_line.as_deref().unwrap_or(""),
            event.tool_name.as_deref().unwrap_or(""),
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. Secure deletion tool detection ───────────────────────────
        for &(tool, desc, mitre, conf) in SECURE_DELETE_TOOLS {
            if ind_lower.contains(&tool.to_lowercase()) {
                let tt = match tool {
                    "shred" | "gshred" | "srm" | "securedelete" | "sdelete" => WipingThreatType::ShredTool,
                    "nwipe" | "dban" => WipingThreatType::DiskSecureErase,
                    "bleachbit" | "ccleaner" | "cleanmymac" | "macbleach" => WipingThreatType::SystemCleaner,
                    _ => WipingThreatType::SecureDeleteTool,
                };
                findings.push(WipingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    tool_name: Some(tool.to_string()), target_path: event.target_path.clone(),
                    overwrite_pattern: None, pass_count: event.overwrite_passes,
                    files_affected: event.files_deleted, bytes_wiped: event.bytes_written,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("SecureDeletion".to_string());
            }
        }

        // ── 2. Disk/volume wiping ───────────────────────────────────────
        for &(pattern, desc, mitre, conf) in DISK_WIPE_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("secureErase") => WipingThreatType::DiskSecureErase,
                    p if p.contains("eraseDisk") || p.contains("eraseVolume") => WipingThreatType::VolumeErase,
                    p if p.contains("apfs_deleteVolume") => WipingThreatType::APFSVolumeDelete,
                    p if p.contains("dd_dev_zero") || p.contains("dd_dev_urandom") || p.contains("dd_dev_rdisk") => WipingThreatType::DDZeroing,
                    p if p.contains("trim") || p.contains("fstrim") => WipingThreatType::TRIMAbuse,
                    p if p.contains("filevault") => WipingThreatType::FileVaultKeyDestruction,
                    p if p.contains("crypto_erase") => WipingThreatType::CryptoErase,
                    _ => WipingThreatType::DiskSecureErase,
                };
                findings.push(WipingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    tool_name: event.tool_name.clone(), target_path: event.disk_device.clone().or(event.target_path.clone()),
                    overwrite_pattern: None, pass_count: None,
                    files_affected: None, bytes_wiped: event.bytes_written,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("DiskWiping".to_string());
            }
        }

        // ── 3. Log & artifact destruction ───────────────────────────────
        for &(pattern, desc, mitre, conf) in LOG_DESTRUCTION_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("unified_log") => WipingThreatType::UnifiedLogDeletion,
                    p if p.contains("asl") => WipingThreatType::ASLDeletion,
                    p if p.contains("audit") => WipingThreatType::AuditLogDeletion,
                    p if p.contains("bash_history") || p.contains("zsh_history") || p.contains("history_c") || p.contains("histfile") || p.contains("histsize") || p.contains("dev_null_history") => WipingThreatType::ShellHistoryClearing,
                    p if p.contains("safari") || p.contains("chrome") || p.contains("firefox") || p.contains("browser") => WipingThreatType::BrowserDataWiping,
                    p if p.contains("quarantine") || p.contains("lsquarantine") => WipingThreatType::QuarantineEventsDeletion,
                    p if p.contains("knowledgec") => WipingThreatType::KnowledgeCDeletion,
                    p if p.contains("spotlight") => WipingThreatType::SpotlightDBDeletion,
                    p if p.contains("fsevents") => WipingThreatType::FSEventsDeletion,
                    p if p.contains("recent") || p.contains("dock") || p.contains("finder") => WipingThreatType::RecentItemsClearing,
                    p if p.contains("trash") => WipingThreatType::TrashSecureEmpty,
                    _ => WipingThreatType::UnifiedLogDeletion,
                };
                findings.push(WipingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    tool_name: event.tool_name.clone(), target_path: event.target_path.clone(),
                    overwrite_pattern: None, pass_count: None,
                    files_affected: event.files_deleted, bytes_wiped: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                let cat = if mitre.contains("001") || mitre.contains("002") { "LogDestruction" } else { "ArtifactDestruction" };
                categories.insert(cat.to_string());
            }
        }

        // ── 4. Memory/swap wiping ───────────────────────────────────────
        for &(pattern, desc, mitre, conf) in MEMORY_WIPE_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("swap") || p.contains("vm_swapfile") => WipingThreatType::SwapFileWiping,
                    p if p.contains("sleepimage") || p.contains("hibernate") => WipingThreatType::HibernationFileDelete,
                    p if p.contains("memory_zero") => WipingThreatType::MemoryZeroing,
                    _ => WipingThreatType::MemoryZeroing,
                };
                findings.push(WipingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    tool_name: event.tool_name.clone(), target_path: event.target_path.clone(),
                    overwrite_pattern: None, pass_count: None,
                    files_affected: None, bytes_wiped: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("MemoryWiping".to_string());
            }
        }

        // ── 5. Overwrite pattern detection ──────────────────────────────
        for &(pattern, desc, conf) in OVERWRITE_PATTERNS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "gutmann_35_pass" => WipingThreatType::GutmannOverwrite,
                    p if p.contains("dod") => WipingThreatType::DoDOverwrite,
                    p if p.contains("write_fsync") || p.contains("mmap_overwrite") => WipingThreatType::ManualSecureDelete,
                    _ => WipingThreatType::SecureDeleteTool,
                };
                findings.push(WipingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    tool_name: None, target_path: event.target_path.clone(),
                    overwrite_pattern: Some(pattern.to_string()),
                    pass_count: event.overwrite_passes,
                    files_affected: event.files_deleted, bytes_wiped: event.bytes_written,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: "T1070.004".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.004".into());
                categories.insert("OverwritePattern".to_string());
            }
        }

        // ── 6. Bulk deletion heuristic ──────────────────────────────────
        if let Some(count) = event.files_deleted {
            if count > BULK_DELETE_THRESHOLD {
                findings.push(WipingFinding {
                    threat_type: WipingThreatType::BulkFileDeletion,
                    confidence: (0.5 + (count as f64 / 500.0).min(0.4)),
                    description: format!("{} files deleted in rapid succession", count),
                    tool_name: event.tool_name.clone(), target_path: event.target_path.clone(),
                    overwrite_pattern: None, pass_count: None,
                    files_affected: Some(count), bytes_wiped: event.bytes_written,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    command_line: event.command_line.clone(),
                    mitre_id: "T1070.004".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.004".into());
                categories.insert("BulkDeletion".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},findings={}", event.event_type, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_wiping = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = WipingAnalysisResult {
            is_wiping, events_analyzed: 1, findings,
            wiping_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_wiping {
                s.wiping_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        WipingThreatType::SecureDeleteTool | WipingThreatType::ShredTool |
                        WipingThreatType::GutmannOverwrite | WipingThreatType::DoDOverwrite |
                        WipingThreatType::ManualSecureDelete => s.secure_delete_detections += 1,
                        WipingThreatType::DiskSecureErase | WipingThreatType::VolumeErase |
                        WipingThreatType::APFSVolumeDelete | WipingThreatType::DDZeroing |
                        WipingThreatType::FileVaultKeyDestruction | WipingThreatType::CryptoErase =>
                            s.disk_wipe_detections += 1,
                        WipingThreatType::UnifiedLogDeletion | WipingThreatType::ASLDeletion |
                        WipingThreatType::AuditLogDeletion => s.log_destruction_detections += 1,
                        WipingThreatType::ShellHistoryClearing | WipingThreatType::BrowserDataWiping |
                        WipingThreatType::QuarantineEventsDeletion | WipingThreatType::KnowledgeCDeletion |
                        WipingThreatType::SpotlightDBDeletion | WipingThreatType::FSEventsDeletion |
                        WipingThreatType::RecentItemsClearing => s.artifact_destruction_detections += 1,
                        WipingThreatType::SwapFileWiping | WipingThreatType::HibernationFileDelete |
                        WipingThreatType::MemoryZeroing => s.memory_wipe_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_wiping {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "disk_wiping_detector".into(),
                title: format!("EVIDENCE DESTRUCTION: {} ({})",
                    result.wiping_categories.join(", "),
                    event.process_name.as_deref().unwrap_or("unknown")),
                details: format!("Risk {:.1}%, {} findings, target: {:?}, cmd: {:?}",
                    risk_score * 100.0, result.findings.len(),
                    event.target_path, event.command_line),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "STOP the wiping process immediately: kill -STOP <pid>".into(),
                    "Preserve remaining evidence: create disk image before remediation".into(),
                    "Check Time Machine for backup copies of destroyed data".into(),
                    "Check APFS snapshots: tmutil listlocalsnapshots /".into(),
                    "Examine FSEvents for records of deleted files".into(),
                    "Check unified log for process activity timeline".into(),
                    "Consider professional data recovery for overwritten data".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[WipingFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                WipingThreatType::FileVaultKeyDestruction | WipingThreatType::CryptoErase => 1.8,
                WipingThreatType::AuditLogDeletion => 1.7,
                WipingThreatType::DiskSecureErase | WipingThreatType::DDZeroing => 1.7,
                WipingThreatType::UnifiedLogDeletion => 1.6,
                WipingThreatType::FSEventsDeletion => 1.5,
                WipingThreatType::GutmannOverwrite | WipingThreatType::DoDOverwrite => 1.5,
                WipingThreatType::VolumeErase | WipingThreatType::APFSVolumeDelete => 1.5,
                WipingThreatType::QuarantineEventsDeletion | WipingThreatType::KnowledgeCDeletion => 1.3,
                WipingThreatType::ShredTool | WipingThreatType::SecureDeleteTool => 1.3,
                WipingThreatType::ASLDeletion => 1.3,
                WipingThreatType::ShellHistoryClearing => 1.1,
                WipingThreatType::BrowserDataWiping | WipingThreatType::RecentItemsClearing => 0.9,
                WipingThreatType::SystemCleaner => 0.8,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> WipingScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
