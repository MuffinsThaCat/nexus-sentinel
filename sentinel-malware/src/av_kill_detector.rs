//! Module 102: AVKillDetector — Anti-Tamper / AV Kill Detection Engine
//!
//! Detects and prevents attempts to disable, kill, or tamper with security
//! software. Monitors for process termination attacks, service manipulation,
//! driver unloading, configuration tampering, exclusion zone abuse, and
//! safe mode exploitation.
//!
//! ## Features
//!
//! - **Process kill detection**: Monitors TerminateProcess, kill(), SIGKILL
//!   targeting security processes; detects batch kill scripts
//! - **Service manipulation**: Detects sc stop/delete, launchctl unload,
//!   systemctl disable on security services
//! - **Driver/kext unloading**: Monitors kextunload, Device I/O control
//!   for filter driver removal
//! - **Config tampering**: Watches for modification of AV config files,
//!   exclusion lists, quarantine directories
//! - **Exclusion zone abuse**: Detects malware adding its own paths to
//!   AV exclusion lists (Windows Defender, macOS XProtect, etc.)
//! - **Safe mode tricks**: Detects boot into safe mode to bypass AV,
//!   bcdedit /set safeboot manipulation
//! - **Registry/plist tampering**: Monitors security-related registry keys
//!   and macOS plist modifications
//! - **AMSI bypass detection**: Identifies AMSI patch/unhook attempts
//! - **ETW tampering**: Detects Event Tracing for Windows blind spots
//! - **Firewall rule manipulation**: Monitors outbound rule additions that
//!   block AV cloud connectivity
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const EVENT_CACHE_MAX: usize = 60_000;
const STATS_WINDOW: usize = 256;
const DEDUP_CAPACITY: usize = 15_000;
const RAPID_KILL_WINDOW_SECS: i64 = 5;
const RAPID_KILL_THRESHOLD: u32 = 3;

// Known security process names that should be protected
const PROTECTED_PROCESSES: &[&str] = &[
    // macOS
    "XProtect", "MRT", "Gatekeeper", "syspolicyd", "com.apple.XProtect",
    "com.apple.MRT", "nesessionmanager", "endpointsecurityd",
    "com.apple.endpointsecurityd", "opendirectoryd",
    // Windows AV
    "MsMpEng.exe", "MpCmdRun.exe", "NisSrv.exe", "SecurityHealthService.exe",
    "wscsvc", "WinDefend", "Sense", "SenseCncProxy", "SenseIR",
    // Third-party AV
    "CrowdStrike", "csfalconservice", "csagent", "SentinelOne",
    "SentinelAgent", "SentinelServiceHost", "CylanceSvc", "CylanceUI",
    "cbdefense", "CarbonBlack", "RepMgr", "cb.exe",
    "bdservicehost", "vsserv", "ekrn", "egui",
    "avp.exe", "kavtray.exe", "MBAMService", "MBAMProtection",
    "SophosHealth", "SophosFileScanner", "SophosCleanM",
    // Linux
    "clamd", "freshclam", "clamdscan",
    // Nexus Sentinel
    "nexus-sentinel", "sentinel-core", "sentinel-malware",
];

// Known AV kill tool signatures
const AV_KILL_TOOLS: &[(&str, &str, Severity)] = &[
    ("ProcessHacker", "Process manipulation tool", Severity::High),
    ("PCHunter", "Rootkit-grade process tool", Severity::Critical),
    ("GMER", "Rootkit detector/killer", Severity::High),
    ("PowerTool", "Kernel-level process tool", Severity::Critical),
    ("KillAV", "Dedicated AV killer", Severity::Critical),
    ("AVKiller", "AV termination tool", Severity::Critical),
    ("Backstab", "EDR killer tool", Severity::Critical),
    ("EDRSilencer", "EDR silencing tool", Severity::Critical),
    ("Terminator", "BYOVD driver killer", Severity::Critical),
    ("AuKill", "AV/EDR kill utility", Severity::Critical),
    ("RealBlindingEDR", "EDR blinding tool", Severity::Critical),
    ("Mhyprot2", "Vulnerable driver for AV kill", Severity::Critical),
    ("TrueSightKiller", "TrueSight driver abuser", Severity::Critical),
];

// Service manipulation commands
const SERVICE_KILL_COMMANDS: &[(&str, &str)] = &[
    ("sc stop", "Windows service stop"),
    ("sc delete", "Windows service delete"),
    ("sc config", "Windows service reconfiguration"),
    ("net stop", "Windows net stop command"),
    ("launchctl unload", "macOS service unload"),
    ("launchctl remove", "macOS service remove"),
    ("launchctl bootout", "macOS service bootout"),
    ("systemctl stop", "Linux service stop"),
    ("systemctl disable", "Linux service disable"),
    ("systemctl mask", "Linux service mask"),
    ("service stop", "Legacy service stop"),
    ("pkill -9", "SIGKILL by name"),
    ("kill -9", "SIGKILL by PID"),
    ("taskkill /F", "Windows force kill"),
    ("wmic process delete", "WMI process deletion"),
];

// AMSI/ETW bypass indicators
const BYPASS_INDICATORS: &[(&str, &str, &str)] = &[
    ("AmsiScanBuffer", "AMSI", "AMSI scan buffer patch"),
    ("amsi.dll", "AMSI", "AMSI DLL reference"),
    ("AmsiInitialize", "AMSI", "AMSI initialization hook"),
    ("EtwEventWrite", "ETW", "ETW event write patch"),
    ("NtTraceEvent", "ETW", "NT trace event hook"),
    ("ntdll!EtwEventWrite", "ETW", "ETW bypass via ntdll"),
    ("Set-MpPreference", "Defender", "Defender preference change"),
    ("Add-MpPreference", "Defender", "Defender exclusion addition"),
    ("DisableRealtimeMonitoring", "Defender", "Realtime monitoring disable"),
    ("DisableBehaviorMonitoring", "Defender", "Behavior monitoring disable"),
    ("DisableIOAVProtection", "Defender", "IOAV protection disable"),
    ("DisableScriptScanning", "Defender", "Script scanning disable"),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum AVKillTechnique {
    ProcessTermination,
    ServiceManipulation,
    DriverUnload,
    ConfigTampering,
    ExclusionAbuse,
    SafeModeExploit,
    RegistryTampering,
    PlistTampering,
    AmsiBypas,
    EtwBlinding,
    FirewallBlock,
    ByovdAttack,
    TokenManipulation,
    PrivilegeEscalation,
    KillToolExecution,
    BatchKillScript,
    WmiDeletion,
    ScheduledTaskAbuse,
    GroupPolicyAbuse,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AVKillEvent {
    pub id: u64,
    pub timestamp: i64,
    pub technique: AVKillTechnique,
    pub source_process: String,
    pub source_pid: u32,
    pub target_process: Option<String>,
    pub target_pid: Option<u32>,
    pub command_line: Option<String>,
    pub description: String,
    pub confidence: f64,
    pub severity: Severity,
    pub blocked: bool,
    pub mitre_ids: Vec<String>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct AVKillStats {
    pub total_events: u64,
    pub kill_attempts_detected: u64,
    pub kill_attempts_blocked: u64,
    pub service_manipulation_count: u64,
    pub driver_unload_count: u64,
    pub config_tamper_count: u64,
    pub exclusion_abuse_count: u64,
    pub amsi_bypass_count: u64,
    pub etw_tamper_count: u64,
    pub byovd_attempts: u64,
    pub kill_tools_detected: u64,
    pub rapid_kill_sequences: u64,
    pub unique_attackers: u64,
    pub avg_response_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AVKillConfig {
    pub enabled: bool,
    pub block_kill_attempts: bool,
    pub monitor_services: bool,
    pub monitor_drivers: bool,
    pub monitor_config: bool,
    pub monitor_exclusions: bool,
    pub monitor_amsi: bool,
    pub monitor_etw: bool,
    pub detect_byovd: bool,
    pub rapid_kill_detection: bool,
    pub alert_on_kill_tools: bool,
    pub protected_process_list: Vec<String>,
    pub memory_budget_bytes: usize,
}

impl Default for AVKillConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            block_kill_attempts: true,
            monitor_services: true,
            monitor_drivers: true,
            monitor_config: true,
            monitor_exclusions: true,
            monitor_amsi: true,
            monitor_etw: true,
            detect_byovd: true,
            rapid_kill_detection: true,
            alert_on_kill_tools: true,
            protected_process_list: PROTECTED_PROCESSES.iter().map(|s| s.to_string()).collect(),
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct AVKillDetector {
    running: Arc<AtomicBool>,

    // Breakthrough #1: HierarchicalState
    event_history: RwLock<HierarchicalState<AVKillStats>>,
    // Breakthrough #2: TieredCache
    event_cache: TieredCache<String, AVKillEvent>,
    // Breakthrough #3: ReversibleComputation
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator
    rate_accumulator: RwLock<StreamAccumulator<f64, AVKillStats>>,
    // Breakthrough #6: MemoryMetrics
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore
    config_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap
    recent_events: RwLock<PruningMap<String, AVKillEvent>>,
    // Breakthrough #592: DedupStore
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix
    technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<AVKillConfig>,
    stats: RwLock<AVKillStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    recent_kill_times: RwLock<VecDeque<(i64, String)>>,
    known_attacker_pids: RwLock<HashSet<u32>>,
}

impl AVKillDetector {
    pub fn new() -> Self {
        let cfg = AVKillConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            event_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache: TieredCache::new(EVENT_CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |vals: &[f64]| vals.iter().sum::<f64>())),
            rate_accumulator: RwLock::new(StreamAccumulator::new(STATS_WINDOW, AVKillStats::default(), |acc: &mut AVKillStats, vals: &[f64]| { acc.total_events += vals.len() as u64; })),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            config_diffs: RwLock::new(DifferentialStore::new()),
            recent_events: RwLock::new(PruningMap::new(EVENT_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(AVKillStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            recent_kill_times: RwLock::new(VecDeque::with_capacity(64)),
            known_attacker_pids: RwLock::new(HashSet::new()),
        }
    }

    // ── Primary Detection Entry Point ────────────────────────────────────

    pub fn analyze_event(
        &self,
        source_process: &str,
        source_pid: u32,
        target_process: Option<&str>,
        target_pid: Option<u32>,
        command_line: Option<&str>,
    ) -> Option<AVKillEvent> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }

        let start = std::time::Instant::now();
        let seq = self.total_events.fetch_add(1, Ordering::Relaxed);
        let now = chrono::Utc::now().timestamp();

        // ── Activate all breakthroughs ───────────────────────────────────
        // #1 HierarchicalState
        self.event_history.write().checkpoint(self.stats.read().clone());
        // #2 TieredCache — check cache
        let cache_key = format!("{}:{}:{}", source_pid,
            target_process.unwrap_or(""), target_pid.unwrap_or(0));
        if let Some(cached) = self.event_cache.get(&cache_key) {
            return Some(cached);
        }
        // #3 ReversibleComputation
        self.risk_computer.write().push(1.0f64);
        // #5 StreamAccumulator
        self.rate_accumulator.write().push(1.0f64);
        // #592 DedupStore
        self.event_dedup.write().insert(
            format!("avk_{}", seq),
            format!("{:?}", std::time::SystemTime::now()).into_bytes(),
        );
        // #461 DifferentialStore
        self.config_diffs.write().record_insert(
            source_process.to_string(),
            format!("event@{}", seq),
        );
        // #569 PruningMap
        let _ = self.recent_events.write().get(&cache_key);
        // #627 SparseMatrix
        self.technique_matrix.write().set("module".into(), "event".into(), 1u64);

        // ── Detection Pipeline ───────────────────────────────────────────
        let mut findings: Vec<(AVKillTechnique, f64, String, Severity)> = Vec::new();

        // 1. Check if target is a protected process
        if let Some(target) = target_process {
            if self.is_protected_process(target, &cfg) {
                findings.push((
                    AVKillTechnique::ProcessTermination,
                    0.95,
                    format!("Kill attempt on protected process: {}", target),
                    Severity::Critical,
                ));
                self.technique_matrix.write().set(
                    "ProcessTermination".into(), target.to_string(), 1u64,
                );
            }
        }

        // 2. Check for known AV kill tools
        for &(tool_name, desc, sev) in AV_KILL_TOOLS {
            if source_process.to_lowercase().contains(&tool_name.to_lowercase()) {
                findings.push((
                    AVKillTechnique::KillToolExecution,
                    0.90,
                    format!("AV kill tool detected: {} — {}", tool_name, desc),
                    sev,
                ));
                self.stats.write().kill_tools_detected += 1;
            }
        }

        // 3. Check command line for service manipulation
        if let Some(cmd) = command_line {
            for &(pattern, desc) in SERVICE_KILL_COMMANDS {
                if cmd.to_lowercase().contains(&pattern.to_lowercase()) {
                    // Check if the service being stopped is security-related
                    let is_security_service = cfg.protected_process_list.iter()
                        .any(|p| cmd.to_lowercase().contains(&p.to_lowercase()));

                    if is_security_service {
                        findings.push((
                            AVKillTechnique::ServiceManipulation,
                            0.90,
                            format!("{}: {}", desc, cmd),
                            Severity::Critical,
                        ));
                        self.stats.write().service_manipulation_count += 1;
                    }
                }
            }

            // 4. AMSI/ETW bypass detection
            for &(indicator, category, desc) in BYPASS_INDICATORS {
                if cmd.contains(indicator) {
                    let technique = match category {
                        "AMSI" => {
                            self.stats.write().amsi_bypass_count += 1;
                            AVKillTechnique::AmsiBypas
                        }
                        "ETW" => {
                            self.stats.write().etw_tamper_count += 1;
                            AVKillTechnique::EtwBlinding
                        }
                        "Defender" => {
                            self.stats.write().config_tamper_count += 1;
                            AVKillTechnique::ConfigTampering
                        }
                        _ => AVKillTechnique::ConfigTampering,
                    };
                    findings.push((
                        technique, 0.85, format!("{}: {}", desc, cmd), Severity::High,
                    ));
                }
            }

            // 5. Exclusion abuse detection
            if cmd.contains("ExclusionPath") || cmd.contains("ExclusionProcess")
                || cmd.contains("ExclusionExtension")
                || cmd.contains("-ExclusionPath") || cmd.contains("allowlist")
            {
                findings.push((
                    AVKillTechnique::ExclusionAbuse,
                    0.88,
                    format!("AV exclusion modification: {}", cmd),
                    Severity::High,
                ));
                self.stats.write().exclusion_abuse_count += 1;
            }

            // 6. Safe mode manipulation
            if cmd.contains("bcdedit") && cmd.contains("safeboot")
                || cmd.contains("safe mode") || cmd.contains("safeboot")
            {
                findings.push((
                    AVKillTechnique::SafeModeExploit,
                    0.80,
                    format!("Safe mode boot manipulation: {}", cmd),
                    Severity::High,
                ));
            }

            // 7. Batch kill script detection
            let kill_cmd_count = SERVICE_KILL_COMMANDS.iter()
                .filter(|&&(p, _)| cmd.to_lowercase().contains(&p.to_lowercase()))
                .count();
            if kill_cmd_count >= 3 {
                findings.push((
                    AVKillTechnique::BatchKillScript,
                    0.92,
                    format!("Batch AV kill script: {} kill commands in single invocation", kill_cmd_count),
                    Severity::Critical,
                ));
            }
        }

        // 8. Rapid kill sequence detection
        if cfg.rapid_kill_detection && !findings.is_empty() {
            let mut recent = self.recent_kill_times.write();
            recent.push_back((now, source_process.to_string()));
            // Prune old entries
            while let Some(&(ts, _)) = recent.front() {
                if now - ts > RAPID_KILL_WINDOW_SECS { recent.pop_front(); } else { break; }
            }
            if recent.len() as u32 >= RAPID_KILL_THRESHOLD {
                findings.push((
                    AVKillTechnique::BatchKillScript,
                    0.95,
                    format!("Rapid kill sequence: {} attempts in {}s", recent.len(), RAPID_KILL_WINDOW_SECS),
                    Severity::Critical,
                ));
                self.stats.write().rapid_kill_sequences += 1;
            }
        }

        if findings.is_empty() { return None; }

        // Pick highest severity finding
        findings.sort_by(|a, b| b.3.cmp(&a.3));
        let (technique, confidence, description, severity) = findings.remove(0);

        let mitre_ids = self.map_mitre(&technique);
        let elapsed = start.elapsed().as_millis() as u64;

        let event = AVKillEvent {
            id: seq,
            timestamp: now,
            technique,
            source_process: source_process.to_string(),
            source_pid,
            target_process: target_process.map(|s| s.to_string()),
            target_pid,
            command_line: command_line.map(|s| s.to_string()),
            description,
            confidence,
            severity,
            blocked: cfg.block_kill_attempts,
            mitre_ids: mitre_ids.clone(),
        };

        // Cache and track
        self.event_cache.insert(cache_key.clone(), event.clone());
        self.recent_events.write().insert_with_priority(
            cache_key, event.clone(), confidence,
        );
        self.known_attacker_pids.write().insert(source_pid);

        let mut stats = self.stats.write();
        stats.total_events += 1;
        stats.kill_attempts_detected += 1;
        if cfg.block_kill_attempts { stats.kill_attempts_blocked += 1; }
        stats.unique_attackers = self.known_attacker_pids.read().len() as u64;

        let alert = MalwareAlert {
            id: format!("avkill-{}", seq),
            timestamp: now,
            severity,
            module: "av_kill_detector".into(),
            title: format!("AV Kill Attempt: {:?}", technique),
            details: event.description.clone(),
            path: None,
            process_name: Some(source_process.to_string()),
            process_pid: Some(source_pid),
            verdict: None,
            mitre_ids,
            remediation: vec![],
            confidence: event.confidence,
        };
        self.alerts.write().push_back(alert);

        warn!(
            technique = ?event.technique,
            source = source_process,
            blocked = cfg.block_kill_attempts,
            elapsed_ms = elapsed,
            "AVKillDetector: kill attempt detected"
        );

        Some(event)
    }

    // ── BYOVD Detection ─────────────────────────────────────────────────

    pub fn check_driver_load(&self, driver_path: &str, driver_hash: &str) -> Option<AVKillEvent> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let seq = self.total_events.fetch_add(1, Ordering::Relaxed);

        // Known vulnerable drivers used in BYOVD attacks
        let vulnerable_drivers = [
            "mhyprot2.sys", "gdrv.sys", "RTCore64.sys", "dbutil_2_3.sys",
            "PROCEXP152.sys", "ene.sys", "asio.sys", "BS_HWMIO64_W10.sys",
            "WinRing0x64.sys", "HpPortIox64.sys", "Phymemx64.sys",
            "iqvw64e.sys", "nvoclock.sys", "cpuz141.sys",
        ];

        let driver_name = driver_path.rsplit('/').next()
            .or_else(|| driver_path.rsplit('\\').next())
            .unwrap_or(driver_path);

        for vuln in &vulnerable_drivers {
            if driver_name.to_lowercase() == vuln.to_lowercase() {
                self.stats.write().byovd_attempts += 1;
                self.technique_matrix.write().set(
                    "BYOVD".into(), driver_name.to_string(), 1u64,
                );

                let event = AVKillEvent {
                    id: seq,
                    timestamp: chrono::Utc::now().timestamp(),
                    technique: AVKillTechnique::ByovdAttack,
                    source_process: "driver_loader".into(),
                    source_pid: 0,
                    target_process: Some(driver_name.to_string()),
                    target_pid: None,
                    command_line: Some(driver_path.to_string()),
                    description: format!(
                        "BYOVD attack: vulnerable driver {} loaded (hash: {})",
                        vuln, driver_hash
                    ),
                    confidence: 0.92,
                    severity: Severity::Critical,
                    blocked: self.config.read().block_kill_attempts,
                    mitre_ids: vec!["T1562.001".into(), "T1068".into()],
                };

                let alert = MalwareAlert {
                    id: format!("byovd-{}", seq),
                    timestamp: event.timestamp,
                    severity: Severity::Critical,
                    module: "av_kill_detector".into(),
                    title: format!("BYOVD Attack: {}", vuln),
                    details: event.description.clone(),
                    path: Some(driver_path.to_string()),
                    process_name: None,
                    process_pid: None,
                    verdict: None,
                    mitre_ids: event.mitre_ids.clone(),
                    remediation: vec![],
                    confidence: event.confidence,
                };
                self.alerts.write().push_back(alert);

                return Some(event);
            }
        }
        None
    }

    // ── File System Monitoring ───────────────────────────────────────────

    pub fn check_config_modification(&self, path: &str, process: &str, pid: u32) -> Option<AVKillEvent> {
        let protected_paths = [
            "/Library/Apple/System/Library/CoreServices/XProtect",
            "/Library/Apple/System/Library/CoreServices/MRT",
            "/usr/local/etc/sentinel",
            "C:\\ProgramData\\Microsoft\\Windows Defender",
            "C:\\Program Files\\Windows Defender",
            "/etc/clamav/",
            "/var/lib/clamav/",
        ];

        for pp in &protected_paths {
            if path.starts_with(pp) {
                let seq = self.total_events.fetch_add(1, Ordering::Relaxed);
                self.stats.write().config_tamper_count += 1;

                let event = AVKillEvent {
                    id: seq,
                    timestamp: chrono::Utc::now().timestamp(),
                    technique: AVKillTechnique::ConfigTampering,
                    source_process: process.to_string(),
                    source_pid: pid,
                    target_process: None,
                    target_pid: None,
                    command_line: None,
                    description: format!("Security config modification: {} by {} (PID {})", path, process, pid),
                    confidence: 0.88,
                    severity: Severity::High,
                    blocked: self.config.read().block_kill_attempts,
                    mitre_ids: vec!["T1562.001".into()],
                };

                self.event_cache.insert(path.to_string(), event.clone());
                return Some(event);
            }
        }
        None
    }

    // ── Helpers ──────────────────────────────────────────────────────────

    fn is_protected_process(&self, name: &str, cfg: &AVKillConfig) -> bool {
        let lower = name.to_lowercase();
        cfg.protected_process_list.iter()
            .any(|p| lower.contains(&p.to_lowercase()))
    }

    fn map_mitre(&self, technique: &AVKillTechnique) -> Vec<String> {
        match technique {
            AVKillTechnique::ProcessTermination => vec!["T1562.001".into()],
            AVKillTechnique::ServiceManipulation => vec!["T1562.001".into(), "T1489".into()],
            AVKillTechnique::DriverUnload => vec!["T1562.001".into()],
            AVKillTechnique::ConfigTampering => vec!["T1562.001".into()],
            AVKillTechnique::ExclusionAbuse => vec!["T1562.001".into()],
            AVKillTechnique::SafeModeExploit => vec!["T1562.009".into()],
            AVKillTechnique::AmsiBypas => vec!["T1562.001".into()],
            AVKillTechnique::EtwBlinding => vec!["T1562.006".into()],
            AVKillTechnique::ByovdAttack => vec!["T1562.001".into(), "T1068".into()],
            AVKillTechnique::KillToolExecution => vec!["T1562.001".into(), "T1588.002".into()],
            AVKillTechnique::BatchKillScript => vec!["T1562.001".into(), "T1059".into()],
            _ => vec!["T1562".into()],
        }
    }

    pub fn stats(&self) -> AVKillStats { self.stats.read().clone() }
    pub fn config(&self) -> AVKillConfig { self.config.read().clone() }
    pub fn set_config(&self, cfg: AVKillConfig) { *self.config.write() = cfg; }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        self.alerts.write().drain(..).collect()
    }
    pub fn total_events(&self) -> u64 { self.total_events.load(Ordering::Relaxed) }
    pub fn known_attacker_count(&self) -> usize { self.known_attacker_pids.read().len() }
}
