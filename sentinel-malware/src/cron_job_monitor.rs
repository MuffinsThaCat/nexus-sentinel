//! Module 57: CronJobMonitor — Cron/Launchd Persistence Detection
//!
//! World-class scheduled task persistence detection engine monitoring cron jobs,
//! launchd plists, at jobs, and periodic scripts for unauthorized persistence
//! mechanisms with command analysis and behavioral profiling.
//!
//! ## Features
//!
//! - **Cron job monitoring**: Detects crontab modifications and suspicious commands
//! - **LaunchDaemon/Agent**: Monitors macOS launchd plist creation/modification
//! - **At job detection**: Tracks one-time scheduled task creation
//! - **Periodic scripts**: Monitors /etc/periodic for unauthorized additions
//! - **Command analysis**: Identifies suspicious commands in scheduled tasks
//! - **Process legitimacy**: Validates modifying process against expected tools
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) detection history
//! - **#2  TieredCache** — Hot cache for recent events
//! - **#3  ReversibleComputation** — Recompute risk aggregates
//! - **#5  StreamAccumulator** — Streaming event rate
//! - **#6  MemoryMetrics** — Bounded memory
//! - **#461 DifferentialStore** — Task state tracking
//! - **#569 PruningMap** — Auto-expire old events
//! - **#592 DedupStore** — Deduplicate task events
//! - **#627 SparseMatrix** — TaskType × action frequency
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1053.003 — Cron
//! - T1543.004 — Launch Daemon/Agent
//! - T1053.002 — At

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CRON_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 32 * 1024 * 1024;

const CRONTAB_DIRS: &[&str] = &[
    "/var/at/tabs", "/var/spool/cron/crontabs", "/etc/crontab",
    "/etc/cron.d", "/etc/cron.daily", "/etc/cron.hourly",
    "/etc/cron.weekly", "/etc/cron.monthly",
];

const LAUNCHD_DIRS: &[&str] = &[
    "/Library/LaunchDaemons", "/Library/LaunchAgents",
    "/System/Library/LaunchDaemons", "/System/Library/LaunchAgents",
];

const SUSPICIOUS_COMMANDS: &[&str] = &[
    "curl", "wget", "nc", "ncat", "bash -i", "/dev/tcp",
    "python -c", "perl -e", "ruby -e", "base64 --decode",
    "openssl s_client", "reverse", "bind shell",
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ScheduledTaskType { CronJob, LaunchDaemon, LaunchAgent, AtJob, PeriodicScript }

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TaskAction { Created, Modified, Deleted, Loaded, Unloaded }

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ScheduledTaskEvent {
    pub id: String,
    pub timestamp: i64,
    pub task_type: ScheduledTaskType,
    pub action: TaskAction,
    pub severity: Severity,
    pub confidence: f64,
    pub file_path: String,
    pub command: Option<String>,
    pub schedule: Option<String>,
    pub modifying_process: String,
    pub modifying_pid: u32,
    pub modifying_user: String,
    pub indicators: Vec<String>,
    pub mitre_technique: String,
    pub blocked: bool,
    pub label: Option<String>,
    pub run_at_load: bool,
    pub keep_alive: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct CronMonitorStats {
    pub events_analyzed: u64,
    pub suspicious_tasks: u64,
    pub tasks_blocked: u64,
    pub cron_modifications: u64,
    pub launchd_modifications: u64,
    pub at_job_creations: u64,
    pub task_types: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// CronJobMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct CronJobMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical history ──
    monitor_history: RwLock<HierarchicalState<CronMonitorStats>>,
    // ── Breakthrough #2: Tiered event cache ──
    event_cache: TieredCache<String, ScheduledTaskEvent>,
    // ── Breakthrough #3: Reversible risk computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming event rate ──
    event_rate: RwLock<StreamAccumulator<f64, CronMonitorStats>>,
    // ── Breakthrough #6: Memory bounds ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Task state tracking ──
    task_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Pruning old events ──
    recent_events: RwLock<PruningMap<String, ScheduledTaskEvent>>,
    // ── Breakthrough #592: Deduplicate task events ──
    task_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: TaskType × action frequency ──
    type_action_matrix: RwLock<SparseMatrix<String, String, u64>>,

    known_tasks: RwLock<HashMap<String, String>>,
    stats: RwLock<CronMonitorStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl CronJobMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(CRON_CACHE_MAX)
            .with_metrics(metrics.clone(), "cron_monitor_events");
        let risk_computer = ReversibleComputation::new(512,
            |risks: &[f64]| if risks.is_empty() { 0.0 } else { risks.iter().sum::<f64>() / risks.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, CronMonitorStats::default(),
            |acc: &mut CronMonitorStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            task_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(CRON_CACHE_MAX)),
            task_dedup: RwLock::new(DedupStore::new()),
            type_action_matrix: RwLock::new(SparseMatrix::new(0u64)),
            known_tasks: RwLock::new(HashMap::new()),
            stats: RwLock::new(CronMonitorStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("cron_monitor", MEMORY_BUDGET / 2);
        info!("CronJobMonitor started");
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("CronJobMonitor stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn classify_path(path: &str) -> Option<ScheduledTaskType> {
        if CRONTAB_DIRS.iter().any(|d| path.starts_with(d)) { return Some(ScheduledTaskType::CronJob); }
        if path.contains("LaunchDaemons") { return Some(ScheduledTaskType::LaunchDaemon); }
        if path.contains("LaunchAgents") { return Some(ScheduledTaskType::LaunchAgent); }
        if path.contains("/var/at/") { return Some(ScheduledTaskType::AtJob); }
        if path.contains("/etc/periodic") { return Some(ScheduledTaskType::PeriodicScript); }
        None
    }

    /// Analyze a file modification in scheduled task directories.
    pub fn analyze_task_change(&self, file_path: &str, action: TaskAction,
        process_name: &str, pid: u32, user: &str, command: Option<&str>)
        -> Option<ScheduledTaskEvent>
    {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let task_type = Self::classify_path(file_path)?;
        let mut indicators = Vec::new();

        // Check command for suspicious content
        if let Some(cmd) = command {
            let cmd_lower = cmd.to_lowercase();
            for susp in SUSPICIOUS_COMMANDS {
                if cmd_lower.contains(susp) {
                    indicators.push(format!("Suspicious command in scheduled task: '{}'", susp));
                }
            }
            if cmd.contains("base64") { indicators.push("Base64 encoded command".into()); }
            if cmd.contains("/tmp/") || cmd.contains("/var/tmp/") {
                indicators.push("Command references temp directory".into());
            }
        }

        // Non-standard process modifying scheduled tasks
        let proc_lower = process_name.to_lowercase();
        if !["crontab", "launchctl", "launchd", "installer", "plutil", "defaults"].iter()
            .any(|p| proc_lower.contains(p))
        {
            indicators.push(format!("Non-standard process '{}' modifying scheduled tasks", process_name));
        }

        // User-level LaunchDaemon creation (requires root, suspicious if from user)
        if task_type == ScheduledTaskType::LaunchDaemon && user != "root" {
            indicators.push(format!("Non-root user '{}' modifying LaunchDaemon", user));
        }

        if indicators.is_empty() && action == TaskAction::Deleted { return None; }

        let confidence = (0.5 + indicators.len() as f64 * 0.15).min(0.95);
        let severity = match task_type {
            ScheduledTaskType::LaunchDaemon => Severity::Critical,
            ScheduledTaskType::LaunchAgent | ScheduledTaskType::CronJob => Severity::High,
            _ => Severity::Medium,
        };

        let mitre = match task_type {
            ScheduledTaskType::CronJob => "T1053.003",
            ScheduledTaskType::LaunchDaemon | ScheduledTaskType::LaunchAgent => "T1543.004",
            ScheduledTaskType::AtJob => "T1053.002",
            ScheduledTaskType::PeriodicScript => "T1053.003",
        };

        let event = ScheduledTaskEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, task_type, action, severity, confidence,
            file_path: file_path.to_string(),
            command: command.map(|s| s.to_string()),
            schedule: None,
            modifying_process: process_name.to_string(),
            modifying_pid: pid,
            modifying_user: user.to_string(),
            indicators,
            mitre_technique: mitre.to_string(),
            blocked: false, label: None,
            run_at_load: false, keep_alive: false,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.task_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.task_dedup.write().insert(format!("{}:{}", file_path, action as u8), vec![]);

        let type_str = format!("{:?}", task_type);
        let action_str = format!("{:?}", action);
        let current = *self.type_action_matrix.read().get(&type_str, &action_str);
        self.type_action_matrix.write().set(type_str.clone(), action_str, current + 1);

        {
            let mut stats = self.stats.write();
            stats.suspicious_tasks += 1;
            *stats.task_types.entry(type_str).or_insert(0) += 1;
            match task_type {
                ScheduledTaskType::CronJob => stats.cron_modifications += 1,
                ScheduledTaskType::LaunchDaemon | ScheduledTaskType::LaunchAgent =>
                    stats.launchd_modifications += 1,
                ScheduledTaskType::AtJob => stats.at_job_creations += 1,
                _ => {}
            }
        }

        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.risk_computer.write().push(1.0f64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.task_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.task_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        warn!("Scheduled task persistence: {:?} {:?} at {} by {} (pid {})",
            action, task_type, file_path, process_name, pid);

        Some(event)
    }

    pub fn stats(&self) -> CronMonitorStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
