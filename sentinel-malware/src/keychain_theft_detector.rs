//! Module 128: KeychainTheftDetector — macOS Keychain Credential Theft Detection
//!
//! Detects unauthorized access to macOS Keychain data including passwords,
//! certificates, encryption keys, WiFi credentials, and authentication tokens.
//! The Keychain is the single highest-value credential store on macOS and a
//! prime target for both commodity and APT malware.
//!
//! ## Detection Capabilities
//!
//! - **`security` command abuse**: find-generic-password, find-internet-password,
//!   dump-keychain, export, find-certificate, find-key — all with -w (password
//!   output) and -g (get password) flags
//! - **Keychain file direct access**: Reading ~/Library/Keychains/login.keychain-db,
//!   System.keychain, or .keychain-db files outside of Security framework
//! - **Keychain unlock abuse**: `security unlock-keychain` with password piping,
//!   `security set-keychain-settings` to remove auto-lock
//! - **Keychain creation for staging**: Creating new keychains to stage stolen creds
//! - **SecItemCopyMatching abuse**: Programmatic Keychain API calls from
//!   non-standard processes (not Safari, Mail, etc.)
//! - **Keychain migration theft**: Copying keychain files for offline cracking
//! - **iCloud Keychain extraction**: Accessing iCloud Keychain sync data
//! - **Safari password extraction**: Reading Safari's credential store
//! - **Certificate/key export**: Extracting private keys and certificates
//! - **Known malware patterns**: Atomic Stealer, MacStealer, Pureland, AMOS,
//!   Realst, KeySteal, Cuckoo patterns
//! - **Chainbreaker tool detection**: Offline keychain cracking tool
//! - **Keychain Services API monitoring**: SecKeychainFindGenericPassword,
//!   SecKeychainItemCopyContent from suspicious callers
//! - **Password prompt spoofing**: Fake Keychain unlock dialogs
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1555.001 — Keychain
//! - T1555 — Credentials from Password Stores
//! - T1552.001 — Credentials In Files
//! - T1539 — Steal Web Session Cookie
//! - T1056.002 — GUI Input Capture (fake prompts)
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const RAPID_ACCESS_THRESHOLD: u32 = 10;
const RAPID_ACCESS_WINDOW_SECS: u64 = 30;
const BULK_EXPORT_THRESHOLD: u32 = 5;
const BULK_EXPORT_WINDOW_SECS: u64 = 60;

// ── Keychain File Paths ──────────────────────────────────────────────────────

const KEYCHAIN_PATHS: &[(&str, &str, f64)] = &[
    ("login.keychain-db", "User login keychain", 0.7),
    ("login.keychain", "User login keychain (legacy)", 0.7),
    ("System.keychain", "System keychain", 0.8),
    ("/Library/Keychains/System.keychain", "System keychain (absolute)", 0.8),
    ("~/Library/Keychains/", "User keychain directory", 0.6),
    (".keychain-db", "Keychain database file", 0.65),
    ("LocalItems/", "Local items keychain (data protection)", 0.75),
    ("com.apple.security.keychain", "Keychain security domain", 0.5),
    ("iCloud Keychain", "iCloud Keychain sync data", 0.8),
    ("Safari/Passwords", "Safari password store", 0.8),
    ("com.apple.Safari.Passwords", "Safari password domain", 0.8),
];

// ── Security Command Patterns ────────────────────────────────────────────────

const SECURITY_CMD_PATTERNS: &[(&str, &str, &str, f64)] = &[
    // Password extraction
    ("security find-generic-password -w", "Extract generic password (plaintext)", "T1555.001", 0.9),
    ("security find-generic-password -g", "Get generic password with metadata", "T1555.001", 0.85),
    ("security find-generic-password -a", "Find by account (targeted extraction)", "T1555.001", 0.7),
    ("security find-generic-password -s", "Find by service (targeted extraction)", "T1555.001", 0.7),
    ("security find-internet-password -w", "Extract internet password (plaintext)", "T1555.001", 0.9),
    ("security find-internet-password -g", "Get internet password with metadata", "T1555.001", 0.85),
    ("security find-internet-password -s", "Find internet password by server", "T1555.001", 0.7),

    // Keychain dumping
    ("security dump-keychain", "Full keychain dump", "T1555.001", 0.95),
    ("security dump-keychain -d", "Dump keychain with decrypted data", "T1555.001", 0.98),
    ("security export", "Export items from keychain", "T1555.001", 0.85),
    ("security export -t identities", "Export identities (certs+keys)", "T1555.001", 0.9),
    ("security export -t certs", "Export certificates", "T1555.001", 0.7),
    ("security export -t keys", "Export private keys", "T1555.001", 0.9),
    ("security export -t all", "Export all keychain items", "T1555.001", 0.95),

    // Certificate/key extraction
    ("security find-certificate", "Find certificate in keychain", "T1555.001", 0.5),
    ("security find-certificate -a -p", "Export all certs as PEM", "T1555.001", 0.75),
    ("security find-key", "Find key in keychain", "T1555.001", 0.6),
    ("security find-identity", "Find signing identity", "T1555.001", 0.5),

    // Keychain manipulation
    ("security unlock-keychain", "Unlock keychain (programmatic)", "T1555.001", 0.8),
    ("security unlock-keychain -p", "Unlock keychain with password", "T1555.001", 0.9),
    ("security set-keychain-settings", "Modify keychain lock settings", "T1555.001", 0.7),
    ("security set-keychain-settings -t", "Set keychain lock timeout", "T1555.001", 0.6),
    ("security set-keychain-settings -u", "Disable auto-lock on keychain", "T1555.001", 0.85),
    ("security create-keychain", "Create new keychain (staging)", "T1555.001", 0.5),
    ("security delete-keychain", "Delete keychain", "T1555.001", 0.7),
    ("security default-keychain -s", "Change default keychain", "T1555.001", 0.7),
    ("security import", "Import items into keychain", "T1555.001", 0.4),
    ("security list-keychains", "Enumerate available keychains", "T1555.001", 0.4),
    ("security show-keychain-info", "Show keychain metadata", "T1555.001", 0.3),
];

// ── Known Malware Patterns ───────────────────────────────────────────────────

const KNOWN_MALWARE_KC_PATTERNS: &[(&str, &str, &str, f64)] = &[
    // Atomic Stealer (AMOS)
    ("osascript.*password.*keychain", "Atomic Stealer/AMOS keychain prompt spoof", "T1056.002", 0.95),
    ("osascript.*System Preferences needs", "AMOS fake system prompt", "T1056.002", 0.9),
    ("osascript.*administrative privileges", "Fake admin privilege dialog", "T1056.002", 0.85),
    ("osascript.*unlock your keychain", "Fake keychain unlock dialog", "T1056.002", 0.95),

    // MacStealer patterns
    ("python.*keychain", "Python-based keychain stealer", "T1555.001", 0.7),
    ("python.*security find", "Python invoking security command", "T1555.001", 0.8),
    ("python.*SecItemCopyMatching", "Python using Keychain API", "T1555.001", 0.8),

    // Chainbreaker (offline cracking)
    ("chainbreaker", "Chainbreaker keychain cracker", "T1555.001", 0.95),
    ("keychaindump", "KeychainDump tool", "T1555.001", 0.95),
    ("keychain-dumper", "Keychain Dumper tool", "T1555.001", 0.95),
    ("dumpkeychain", "Dump keychain variant", "T1555.001", 0.9),

    // Cuckoo stealer
    ("launchctl.*keychain", "LaunchAgent-based keychain theft", "T1555.001", 0.75),

    // Realst stealer
    ("pkgutil.*keychain", "PKG installer keychain theft", "T1555.001", 0.7),

    // KeySteal
    ("keysteal", "KeySteal malware", "T1555.001", 0.95),

    // Generic stealer patterns
    ("curl.*keychain", "Curl exfiltrating keychain", "T1555.001", 0.8),
    ("base64.*keychain", "Base64 encoding keychain data", "T1555.001", 0.8),
    ("zip.*keychain", "Archiving keychain files", "T1555.001", 0.85),
    ("tar.*keychain", "Tar archiving keychain", "T1555.001", 0.85),
    ("cp.*Keychains", "Copying keychain directory", "T1555.001", 0.8),
    ("rsync.*Keychains", "Rsync keychain files", "T1555.001", 0.8),
    ("scp.*keychain", "SCP exfiltrating keychain", "T1555.001", 0.85),
];

// ── Programmatic API Patterns ────────────────────────────────────────────────

const KEYCHAIN_API_CALLS: &[(&str, &str, f64)] = &[
    ("SecItemCopyMatching", "Keychain item query API", 0.5),
    ("SecKeychainItemCopyContent", "Keychain item content copy", 0.6),
    ("SecKeychainFindGenericPassword", "Find generic password API", 0.7),
    ("SecKeychainFindInternetPassword", "Find internet password API", 0.7),
    ("SecKeychainItemCopyAttributesAndData", "Copy item attributes and data", 0.65),
    ("SecKeychainCopyDefault", "Get default keychain handle", 0.4),
    ("SecKeychainOpen", "Open keychain programmatically", 0.5),
    ("SecKeychainUnlock", "Unlock keychain programmatically", 0.7),
    ("SecItemExport", "Export keychain item API", 0.7),
    ("SecPKCS12Import", "PKCS12 import (cert extraction)", 0.5),
    ("SecIdentityCopyCertificate", "Copy identity certificate", 0.5),
    ("SecIdentityCopyPrivateKey", "Copy private key from identity", 0.8),
    ("SecKeyCreateDecryptedData", "Decrypt data with keychain key", 0.6),
];

// ── Trusted Processes (reduce false positives) ───────────────────────────────

const TRUSTED_KC_ACCESSORS: &[&str] = &[
    "Safari", "Mail", "Messages", "Calendar", "Contacts",
    "Keychain Access", "System Preferences", "System Settings",
    "securityd", "secd", "trustd", "authd",
    "AppleIDAuthAgent", "IMDPersistenceAgent", "nsurlsessiond",
    "CloudKeychainProxy", "com.apple.security.cloudkeychainproxy3",
    "Xcode", "codesign", "pkgbuild", "productbuild",
    "ssh-agent", "ssh-add", "git-credential-osxkeychain",
    "swcd", "accountsd", "coreservicesd",
];

// ── Safari/Browser Credential Paths ──────────────────────────────────────────

const BROWSER_CREDENTIAL_PATHS: &[(&str, &str, f64)] = &[
    ("Safari/Passwords.db", "Safari password database", 0.85),
    ("Safari/Bookmarks.plist", "Safari bookmarks (contains form data)", 0.3),
    ("Google/Chrome/Default/Login Data", "Chrome login data (SQLite)", 0.8),
    ("Google/Chrome/Default/Cookies", "Chrome cookies", 0.6),
    ("Firefox/Profiles", "Firefox profiles (key4.db, logins.json)", 0.75),
    ("Microsoft Edge/Default/Login Data", "Edge login data", 0.8),
    ("Brave-Browser/Default/Login Data", "Brave login data", 0.8),
    ("Arc/User Data/Default/Login Data", "Arc login data", 0.8),
    ("Vivaldi/Default/Login Data", "Vivaldi login data", 0.8),
    ("Opera/Login Data", "Opera login data", 0.8),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum KeychainThreatType {
    PasswordExtraction,
    KeychainDump,
    KeychainFileAccess,
    KeychainFileCopy,
    KeychainUnlock,
    CertificateExport,
    PrivateKeyExport,
    IdentityExport,
    FakePromptDialog,
    OfflineCrackingTool,
    BulkExtraction,
    RapidAccess,
    StagingKeychain,
    BrowserCredentialTheft,
    KeychainExfiltration,
    ProgrammaticAPIAbuse,
    KeychainSettingsManipulation,
    iCloudKeychainTheft,
    WifiPasswordExtraction,
    KnownMalwarePattern,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeychainThreatFinding {
    pub threat_type: KeychainThreatType,
    pub confidence: f64,
    pub description: String,
    pub command_line: Option<String>,
    pub target_keychain: Option<String>,
    pub target_service: Option<String>,
    pub target_account: Option<String>,
    pub malware_family: Option<String>,
    pub mitre_id: String,
    pub process_name: String,
    pub process_pid: u32,
    pub parent_process: Option<String>,
    pub file_path: Option<String>,
    pub items_accessed: u32,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeychainAccessEvent {
    pub event_type: String,           // "exec", "open", "read", "write", "api_call"
    pub process_name: String,
    pub process_pid: u32,
    pub parent_process: Option<String>,
    pub parent_pid: Option<u32>,
    pub command_line: Option<String>,
    pub file_path: Option<String>,
    pub api_function: Option<String>,
    pub target_service: Option<String>,
    pub target_account: Option<String>,
    pub bundle_id: Option<String>,
    pub is_signed: bool,
    pub is_notarized: bool,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeychainAnalysisResult {
    pub is_theft: bool,
    pub events_analyzed: u32,
    pub findings: Vec<KeychainThreatFinding>,
    pub items_potentially_stolen: u32,
    pub targeted_services: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct KeychainScanStats {
    pub total_events: u64,
    pub theft_detections: u64,
    pub dump_detections: u64,
    pub fake_prompt_detections: u64,
    pub tool_detections: u64,
    pub browser_cred_detections: u64,
    pub bulk_extraction_detections: u64,
    pub items_potentially_stolen: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeychainDetectorConfig {
    pub enabled: bool,
    pub monitor_security_cmd: bool,
    pub monitor_file_access: bool,
    pub monitor_api_calls: bool,
    pub detect_fake_prompts: bool,
    pub detect_known_malware: bool,
    pub detect_browser_creds: bool,
    pub rapid_access_threshold: u32,
    pub rapid_access_window_secs: u64,
    pub bulk_export_threshold: u32,
    pub trusted_processes: Vec<String>,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for KeychainDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            monitor_security_cmd: true,
            monitor_file_access: true,
            monitor_api_calls: true,
            detect_fake_prompts: true,
            detect_known_malware: true,
            detect_browser_creds: true,
            rapid_access_threshold: RAPID_ACCESS_THRESHOLD,
            rapid_access_window_secs: RAPID_ACCESS_WINDOW_SECS,
            bulk_export_threshold: BULK_EXPORT_THRESHOLD,
            trusted_processes: TRUSTED_KC_ACCESSORS.iter().map(|s| s.to_string()).collect(),
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KCSigEntry {
    pub pattern: String,
    pub malware_family: String,
    pub severity: f64,
}

#[derive(Debug, Clone, Default)]
struct ProcessAccessTracker {
    access_count: u64,
    services_accessed: HashSet<String>,
    timestamps: Vec<u64>,
    commands: Vec<String>,
    first_seen: u64,
    last_seen: u64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct KeychainTheftDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<KeychainScanStats>>,
    result_cache: TieredCache<String, KeychainAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, KeychainScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, KeychainAnalysisResult>>,
    sig_db: PagedMemory<KCSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<KeychainDetectorConfig>,
    stats: RwLock<KeychainScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    process_tracker: RwLock<HashMap<String, ProcessAccessTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl KeychainTheftDetector {
    pub fn new() -> Self {
        let cfg = KeychainDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, KeychainScanStats::default(),
                |acc: &mut KeychainScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(KeychainScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            process_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    /// Analyze a keychain access event for potential credential theft.
    pub fn analyze_event(&self, event: &KeychainAccessEvent) -> Option<KeychainAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.process_name, event.process_pid, event.timestamp);
        let is_trusted = self.is_trusted_process(&cfg, &event.process_name, event.bundle_id.as_deref());

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut items_accessed = 0u32;
        let mut targeted_services = Vec::new();

        // ── 1. Security command analysis ─────────────────────────────────
        if cfg.monitor_security_cmd {
            if let Some(ref cmd) = event.command_line {
                let cmd_lower = cmd.to_lowercase();

                for &(pattern, desc, mitre, conf) in SECURITY_CMD_PATTERNS {
                    if cmd_lower.contains(&pattern.to_lowercase()) {
                        let threat_type = if pattern.contains("dump") {
                            KeychainThreatType::KeychainDump
                        } else if pattern.contains("find-generic-password") || pattern.contains("find-internet-password") {
                            KeychainThreatType::PasswordExtraction
                        } else if pattern.contains("export") && pattern.contains("keys") {
                            KeychainThreatType::PrivateKeyExport
                        } else if pattern.contains("export") && pattern.contains("identities") {
                            KeychainThreatType::IdentityExport
                        } else if pattern.contains("export") && pattern.contains("cert") {
                            KeychainThreatType::CertificateExport
                        } else if pattern.contains("export") {
                            KeychainThreatType::KeychainDump
                        } else if pattern.contains("unlock") {
                            KeychainThreatType::KeychainUnlock
                        } else if pattern.contains("set-keychain-settings") {
                            KeychainThreatType::KeychainSettingsManipulation
                        } else if pattern.contains("create-keychain") {
                            KeychainThreatType::StagingKeychain
                        } else {
                            KeychainThreatType::PasswordExtraction
                        };

                        // Reduce confidence for trusted processes
                        let adjusted_conf = if is_trusted { (conf * 0.4).max(0.2) } else { conf };

                        if adjusted_conf >= cfg.min_confidence {
                            items_accessed += 1;
                            if let Some(ref svc) = event.target_service {
                                targeted_services.push(svc.clone());
                            }

                            findings.push(KeychainThreatFinding {
                                threat_type,
                                confidence: adjusted_conf,
                                description: desc.to_string(),
                                command_line: Some(cmd.clone()),
                                target_keychain: self.extract_keychain_from_cmd(cmd),
                                target_service: event.target_service.clone(),
                                target_account: event.target_account.clone(),
                                malware_family: None,
                                mitre_id: mitre.into(),
                                process_name: event.process_name.clone(),
                                process_pid: event.process_pid,
                                parent_process: event.parent_process.clone(),
                                file_path: event.file_path.clone(),
                                items_accessed,
                                timestamp: event.timestamp,
                            });
                            mitre_ids.insert(mitre.into());
                        }
                    }
                }
            }
        }

        // ── 2. Known malware pattern matching ────────────────────────────
        if cfg.detect_known_malware {
            let event_text = format!("{} {} {}",
                event.command_line.as_deref().unwrap_or(""),
                event.file_path.as_deref().unwrap_or(""),
                event.process_name);

            for &(pattern, desc, mitre, conf) in KNOWN_MALWARE_KC_PATTERNS {
                if event_text.to_lowercase().contains(&pattern.to_lowercase()) {
                    let threat_type = if pattern.contains("osascript") && (pattern.contains("password") || pattern.contains("unlock")) {
                        KeychainThreatType::FakePromptDialog
                    } else if pattern.contains("chainbreaker") || pattern.contains("keychaindump") || pattern.contains("keychain-dumper") {
                        KeychainThreatType::OfflineCrackingTool
                    } else if pattern.contains("curl") || pattern.contains("scp") {
                        KeychainThreatType::KeychainExfiltration
                    } else if pattern.contains("cp") || pattern.contains("rsync") || pattern.contains("zip") || pattern.contains("tar") {
                        KeychainThreatType::KeychainFileCopy
                    } else {
                        KeychainThreatType::KnownMalwarePattern
                    };

                    let malware_family = if pattern.contains("osascript") && pattern.contains("keychain") {
                        Some("Atomic Stealer (AMOS)".to_string())
                    } else if pattern.contains("chainbreaker") {
                        Some("Chainbreaker".to_string())
                    } else if pattern.contains("keysteal") {
                        Some("KeySteal".to_string())
                    } else { None };

                    findings.push(KeychainThreatFinding {
                        threat_type,
                        confidence: conf,
                        description: desc.to_string(),
                        command_line: event.command_line.clone(),
                        target_keychain: None,
                        target_service: event.target_service.clone(),
                        target_account: event.target_account.clone(),
                        malware_family,
                        mitre_id: mitre.into(),
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid,
                        parent_process: event.parent_process.clone(),
                        file_path: event.file_path.clone(),
                        items_accessed: 0,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                }
            }
        }

        // ── 3. Fake prompt detection (osascript dialog spoofing) ─────────
        if cfg.detect_fake_prompts {
            if let Some(ref cmd) = event.command_line {
                let cmd_lower = cmd.to_lowercase();
                if cmd_lower.contains("osascript") && (
                    (cmd_lower.contains("display dialog") && cmd_lower.contains("password")) ||
                    (cmd_lower.contains("display dialog") && cmd_lower.contains("keychain")) ||
                    (cmd_lower.contains("with hidden answer") && cmd_lower.contains("password")) ||
                    (cmd_lower.contains("system preferences") && cmd_lower.contains("password"))
                ) {
                    findings.push(KeychainThreatFinding {
                        threat_type: KeychainThreatType::FakePromptDialog,
                        confidence: 0.9,
                        description: "Fake password prompt dialog via osascript (credential phishing)".into(),
                        command_line: Some(cmd.clone()),
                        target_keychain: None, target_service: None, target_account: None,
                        malware_family: Some("Credential Phishing".into()),
                        mitre_id: "T1056.002".into(),
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid,
                        parent_process: event.parent_process.clone(),
                        file_path: event.file_path.clone(),
                        items_accessed: 0,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1056.002".into());
                }
            }
        }

        // ── 4. File access to keychain databases ─────────────────────────
        if cfg.monitor_file_access {
            if let Some(ref path) = event.file_path {
                let path_lower = path.to_lowercase();
                for &(kc_path, desc, conf) in KEYCHAIN_PATHS {
                    if path_lower.contains(&kc_path.to_lowercase()) {
                        let is_write = event.event_type.contains("write") || event.event_type.contains("copy")
                            || event.event_type.contains("rename");
                        let is_read = event.event_type.contains("read") || event.event_type.contains("open");

                        let threat_type = if is_write {
                            KeychainThreatType::KeychainFileCopy
                        } else {
                            KeychainThreatType::KeychainFileAccess
                        };

                        let adjusted_conf = if is_trusted { (conf * 0.3).max(0.15) }
                            else if is_write { (conf + 0.15).min(0.95) }
                            else { conf };

                        if adjusted_conf >= cfg.min_confidence && (is_read || is_write) {
                            findings.push(KeychainThreatFinding {
                                threat_type,
                                confidence: adjusted_conf,
                                description: format!("{}: {} by {}", desc,
                                    if is_write { "write/copy" } else { "read" }, event.process_name),
                                command_line: event.command_line.clone(),
                                target_keychain: Some(kc_path.to_string()),
                                target_service: None, target_account: None,
                                malware_family: None,
                                mitre_id: "T1555.001".into(),
                                process_name: event.process_name.clone(),
                                process_pid: event.process_pid,
                                parent_process: event.parent_process.clone(),
                                file_path: Some(path.clone()),
                                items_accessed: 0,
                                timestamp: event.timestamp,
                            });
                            mitre_ids.insert("T1555.001".into());
                        }
                    }
                }

                // Browser credential theft
                if cfg.detect_browser_creds {
                    for &(browser_path, desc, conf) in BROWSER_CREDENTIAL_PATHS {
                        if path_lower.contains(&browser_path.to_lowercase()) {
                            let adjusted_conf = if is_trusted { (conf * 0.3).max(0.15) } else { conf };
                            if adjusted_conf >= cfg.min_confidence {
                                findings.push(KeychainThreatFinding {
                                    threat_type: KeychainThreatType::BrowserCredentialTheft,
                                    confidence: adjusted_conf,
                                    description: format!("{} access by {}", desc, event.process_name),
                                    command_line: event.command_line.clone(),
                                    target_keychain: None, target_service: Some(desc.to_string()),
                                    target_account: None, malware_family: None,
                                    mitre_id: "T1555".into(),
                                    process_name: event.process_name.clone(),
                                    process_pid: event.process_pid,
                                    parent_process: event.parent_process.clone(),
                                    file_path: Some(path.clone()),
                                    items_accessed: 0,
                                    timestamp: event.timestamp,
                                });
                                mitre_ids.insert("T1555".into());
                            }
                        }
                    }
                }
            }
        }

        // ── 5. Programmatic API call analysis ────────────────────────────
        if cfg.monitor_api_calls {
            if let Some(ref api_fn) = event.api_function {
                for &(api_name, desc, conf) in KEYCHAIN_API_CALLS {
                    if api_fn.contains(api_name) {
                        let adjusted_conf = if is_trusted { (conf * 0.3).max(0.1) } else { conf };
                        if adjusted_conf >= cfg.min_confidence {
                            let threat_type = if api_name.contains("PrivateKey") {
                                KeychainThreatType::PrivateKeyExport
                            } else if api_name.contains("Export") {
                                KeychainThreatType::CertificateExport
                            } else {
                                KeychainThreatType::ProgrammaticAPIAbuse
                            };

                            findings.push(KeychainThreatFinding {
                                threat_type,
                                confidence: adjusted_conf,
                                description: format!("{} from {}", desc, event.process_name),
                                command_line: event.command_line.clone(),
                                target_keychain: None,
                                target_service: event.target_service.clone(),
                                target_account: event.target_account.clone(),
                                malware_family: None,
                                mitre_id: "T1555.001".into(),
                                process_name: event.process_name.clone(),
                                process_pid: event.process_pid,
                                parent_process: event.parent_process.clone(),
                                file_path: event.file_path.clone(),
                                items_accessed: 1,
                                timestamp: event.timestamp,
                            });
                            mitre_ids.insert("T1555.001".into());
                        }
                    }
                }
            }
        }

        // ── 6. Rapid access / bulk extraction detection ──────────────────
        {
            let proc_key = format!("{}:{}", event.process_name, event.process_pid);
            let mut tracker = self.process_tracker.write();
            let pt = tracker.entry(proc_key.clone()).or_default();
            pt.access_count += 1;
            pt.timestamps.push(event.timestamp);
            if let Some(ref svc) = event.target_service {
                pt.services_accessed.insert(svc.clone());
            }
            if let Some(ref cmd) = event.command_line {
                pt.commands.push(cmd.clone());
            }
            if pt.first_seen == 0 { pt.first_seen = event.timestamp; }
            pt.last_seen = event.timestamp;
            if pt.timestamps.len() > 500 { pt.timestamps.drain(..250); }
            if pt.commands.len() > 200 { pt.commands.drain(..100); }

            // Rapid access check
            let recent_count = pt.timestamps.iter()
                .filter(|&&t| event.timestamp.saturating_sub(cfg.rapid_access_window_secs) <= t)
                .count() as u32;
            if recent_count >= cfg.rapid_access_threshold && !is_trusted {
                findings.push(KeychainThreatFinding {
                    threat_type: KeychainThreatType::RapidAccess,
                    confidence: (0.7 + (recent_count as f64 / 30.0).min(0.25)),
                    description: format!("{} keychain accesses in {}s by {}",
                        recent_count, cfg.rapid_access_window_secs, event.process_name),
                    command_line: event.command_line.clone(),
                    target_keychain: None, target_service: None, target_account: None,
                    malware_family: None, mitre_id: "T1555.001".into(),
                    process_name: event.process_name.clone(),
                    process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: None,
                    items_accessed: recent_count,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1555.001".into());
            }

            // Bulk extraction (many different services)
            if pt.services_accessed.len() as u32 >= cfg.bulk_export_threshold && !is_trusted {
                findings.push(KeychainThreatFinding {
                    threat_type: KeychainThreatType::BulkExtraction,
                    confidence: (0.75 + (pt.services_accessed.len() as f64 / 20.0).min(0.2)),
                    description: format!("{} unique services queried by {}",
                        pt.services_accessed.len(), event.process_name),
                    command_line: event.command_line.clone(),
                    target_keychain: None, target_service: None, target_account: None,
                    malware_family: None, mitre_id: "T1555.001".into(),
                    process_name: event.process_name.clone(),
                    process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: None,
                    items_accessed: pt.services_accessed.len() as u32,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1555.001".into());
            }
        }

        // ── 7. Unsigned/unnotarized process accessing keychain ───────────
        if !is_trusted && !event.is_signed && !findings.is_empty() {
            // Boost all finding confidences for unsigned processes
            for f in findings.iter_mut() {
                f.confidence = (f.confidence + 0.1).min(0.99);
            }
        }

        // ── Store differential state ─────────────────────────────────────
        self.event_diffs.write().record_insert(
            cache_key.clone(),
            format!("proc={},type={},trusted={},findings={}",
                event.process_name, event.event_type, is_trusted, findings.len()),
        );

        // ── Risk scoring & result assembly ───────────────────────────────
        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_theft = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = KeychainAnalysisResult {
            is_theft,
            events_analyzed: 1,
            findings,
            items_potentially_stolen: items_accessed,
            targeted_services,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        // ── Cache & matrix updates ───────────────────────────────────────
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        // ── Stats update ─────────────────────────────────────────────────
        {
            let mut stats = self.stats.write();
            stats.total_events += 1;
            if is_theft {
                stats.theft_detections += 1;
                stats.items_potentially_stolen += items_accessed as u64;
                for f in &result.findings {
                    match f.threat_type {
                        KeychainThreatType::KeychainDump => stats.dump_detections += 1,
                        KeychainThreatType::FakePromptDialog => stats.fake_prompt_detections += 1,
                        KeychainThreatType::OfflineCrackingTool | KeychainThreatType::KnownMalwarePattern => stats.tool_detections += 1,
                        KeychainThreatType::BrowserCredentialTheft => stats.browser_cred_detections += 1,
                        KeychainThreatType::BulkExtraction => stats.bulk_extraction_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = stats.total_events as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        // ── Alert generation ─────────────────────────────────────────────
        if is_theft {
            let top_finding = result.findings.iter()
                .max_by(|a, b| a.confidence.partial_cmp(&b.confidence).unwrap_or(std::cmp::Ordering::Equal));
            let alert_title = if let Some(top) = top_finding {
                match top.threat_type {
                    KeychainThreatType::KeychainDump => format!("Keychain dump: {} (pid {})", event.process_name, event.process_pid),
                    KeychainThreatType::FakePromptDialog => format!("Fake keychain prompt: {} (pid {})", event.process_name, event.process_pid),
                    KeychainThreatType::OfflineCrackingTool => format!("Keychain cracking tool: {} (pid {})", event.process_name, event.process_pid),
                    _ => format!("Keychain theft: {} (pid {})", event.process_name, event.process_pid),
                }
            } else {
                format!("Keychain theft: {} (pid {})", event.process_name, event.process_pid)
            };

            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "keychain_theft_detector".into(),
                title: alert_title,
                details: format!("Risk: {:.1}%, {} findings, {} items at risk, signed: {}, notarized: {}",
                    risk_score * 100.0, result.findings.len(), items_accessed,
                    event.is_signed, event.is_notarized),
                path: event.file_path.clone(),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid),
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the suspicious process immediately".into(),
                    "Change all passwords stored in Keychain".into(),
                    "Revoke any exported certificates/keys".into(),
                    "Review Keychain Access audit log".into(),
                    "Rotate WiFi passwords and API tokens".into(),
                    "Check for unauthorized keychain unlock settings".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn is_trusted_process(&self, cfg: &KeychainDetectorConfig, process_name: &str, bundle_id: Option<&str>) -> bool {
        let proc_lower = process_name.to_lowercase();
        for trusted in &cfg.trusted_processes {
            if proc_lower.contains(&trusted.to_lowercase()) { return true; }
        }
        if let Some(bid) = bundle_id {
            let bid_lower = bid.to_lowercase();
            if bid_lower.starts_with("com.apple.") { return true; }
        }
        false
    }

    fn extract_keychain_from_cmd(&self, cmd: &str) -> Option<String> {
        // Extract keychain path from command line arguments
        for part in cmd.split_whitespace() {
            if part.contains("keychain") || part.contains("Keychains") || part.ends_with(".keychain-db") {
                return Some(part.to_string());
            }
        }
        None
    }

    fn calculate_risk_score(&self, findings: &[KeychainThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                KeychainThreatType::KeychainDump => 1.6,
                KeychainThreatType::OfflineCrackingTool => 1.6,
                KeychainThreatType::FakePromptDialog => 1.5,
                KeychainThreatType::KnownMalwarePattern => 1.5,
                KeychainThreatType::PrivateKeyExport => 1.4,
                KeychainThreatType::BulkExtraction => 1.4,
                KeychainThreatType::KeychainExfiltration => 1.4,
                KeychainThreatType::KeychainFileCopy => 1.3,
                KeychainThreatType::PasswordExtraction => 1.3,
                KeychainThreatType::IdentityExport => 1.2,
                KeychainThreatType::RapidAccess => 1.2,
                KeychainThreatType::BrowserCredentialTheft => 1.2,
                KeychainThreatType::KeychainUnlock => 1.1,
                KeychainThreatType::iCloudKeychainTheft => 1.3,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> KeychainScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
