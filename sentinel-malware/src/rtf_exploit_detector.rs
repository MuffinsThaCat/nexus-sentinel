//! Module 112: RTFExploitDetector — RTF Document Exploit Detection Engine
//!
//! Detects OLE object embedding, equation editor exploits (CVE-2017-11882 and
//! variants), malicious ActiveX controls, and obfuscated RTF content designed
//! to exploit document parsers.
//!
//! ## Detection Capabilities
//!
//! - **Equation Editor exploits**: CVE-2017-11882, CVE-2018-0802 (EQNEDT32.OBE)
//! - **OLE object embedding**: Embedded executables, scripts, shellcode in OLE streams
//! - **RTF obfuscation**: Hex-encoded control words, nested groups, Unicode abuse,
//!   {\*\objdata} manipulation, fragmented keywords
//! - **ActiveX controls**: Malicious ActiveX instantiation via {\object} groups
//! - **Template injection**: {\*\template} remote template loading
//! - **Font table abuse**: Malformed font entries targeting parser vulnerabilities
//! - **Exploit kit patterns**: Known RTF exploit builders (Royal Road, 8.t)
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 40_000;
const STATS_WINDOW: usize = 256;
const MAX_RTF_SIZE: u64 = 128 * 1024 * 1024;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 10;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

// ── Known RTF Exploit Signatures ─────────────────────────────────────────────

const RTF_EXPLOIT_SIGS: &[(&str, &str, &str, f64)] = &[
    ("CVE-2017-11882", "Equation.3", "Equation Editor stack overflow", 0.95),
    ("CVE-2018-0802", "Equation.3", "Equation Editor type confusion", 0.95),
    ("CVE-2017-0199", "\\objupdate", "OLE auto-update HTA execution", 0.9),
    ("CVE-2014-1761", "\\listoverride", "RTF list override heap corruption", 0.85),
    ("CVE-2012-0158", "MSCOMCTL.OCX", "ActiveX ListView heap overflow", 0.9),
    ("CVE-2015-1641", "\\objdata", "RTF object data type confusion", 0.85),
    ("Royal-Road", "8.t", "Royal Road RTF exploit builder (APT)", 0.92),
    ("Royal-Road-v2", "b.t", "Royal Road variant 2", 0.92),
    ("Royal-Road-v3", "v.t", "Royal Road variant 3", 0.92),
];

const RTF_SUSPICIOUS_PATTERNS: &[(&str, &str, f64)] = &[
    ("\\objdata", "OLE object data stream", 0.6),
    ("\\objocx", "ActiveX OLE object", 0.8),
    ("\\objemb", "Embedded OLE object", 0.65),
    ("\\objlink", "Linked OLE object", 0.6),
    ("\\objupdate", "Auto-update OLE object", 0.85),
    ("\\object", "Generic OLE object", 0.5),
    ("\\template", "Remote template reference", 0.8),
    ("\\*\\datastore", "XML data store", 0.4),
    ("\\pict", "Embedded picture (potential polyglot)", 0.3),
    ("\\*\\shppict", "Shape picture", 0.3),
    ("\\bin", "Binary data in RTF", 0.5),
    ("Equation.3", "Equation editor CLSID", 0.9),
    ("Package", "OLE Package shell", 0.75),
    ("\\*\\objclass", "OLE object class", 0.5),
    ("\\*\\oleclsid", "OLE class ID specification", 0.6),
    ("d0cf11e0a1b11ae1", "OLE2 magic in hex", 0.7),
    ("4d5a", "MZ header in hex (PE executable)", 0.95),
    ("4d534346", "MSCF (CAB file) in hex", 0.7),
    ("504b0304", "PK (ZIP) in hex", 0.6),
    ("7b5c7274", "Nested RTF document", 0.5),
];

const EQUATION_EDITOR_CLSIDS: &[&str] = &[
    "0002CE02-0000-0000-C000-000000000046",
    "00021700-0000-0000-C000-000000000046",
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum RTFThreatType {
    EquationEditorExploit,
    OLEObjectEmbedding,
    ActiveXControl,
    TemplateInjection,
    ObfuscatedContent,
    EmbeddedExecutable,
    ShellcodePayload,
    ExploitKitPattern,
    FontTableAbuse,
    NestedRTFDocument,
    HexEncodedPayload,
    MalformedStructure,
    UnicodeEvasion,
    FragmentedKeyword,
    AutoUpdateObject,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RTFThreatFinding {
    pub threat_type: RTFThreatType,
    pub offset: u64,
    pub confidence: f64,
    pub cve_id: Option<String>,
    pub description: String,
    pub raw_hex: Option<String>,
    pub mitre_id: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RTFStructure {
    pub nesting_depth: u32,
    pub object_count: u32,
    pub ole_object_count: u32,
    pub equation_objects: u32,
    pub embedded_pictures: u32,
    pub hex_data_regions: u32,
    pub hex_data_bytes: u64,
    pub total_groups: u64,
    pub has_template: bool,
    pub has_equation_editor: bool,
    pub obfuscation_indicators: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RTFAnalysisResult {
    pub path: String,
    pub file_size: u64,
    pub is_malicious: bool,
    pub structure: RTFStructure,
    pub findings: Vec<RTFThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct RTFScanStats {
    pub total_scanned: u64,
    pub malicious_count: u64,
    pub clean_count: u64,
    pub equation_exploits: u64,
    pub ole_object_detections: u64,
    pub exploit_kit_detections: u64,
    pub template_injections: u64,
    pub avg_scan_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RTFScanConfig {
    pub enabled: bool,
    pub max_file_size: u64,
    pub scan_ole_objects: bool,
    pub scan_equation_editor: bool,
    pub scan_hex_data: bool,
    pub max_nesting_depth: u32,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for RTFScanConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_file_size: MAX_RTF_SIZE,
            scan_ole_objects: true,
            scan_equation_editor: true,
            scan_hex_data: true,
            max_nesting_depth: 64,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RTFExploitSigEntry {
    pub cve_id: String,
    pub pattern: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct RTFExploitDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<RTFScanStats>>,
    result_cache: TieredCache<String, RTFAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    rtf_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, RTFScanStats>>,
    metrics: MemoryMetrics,
    structure_diffs: RwLock<DifferentialStore<String, String>>,
    recent_scans: RwLock<PruningMap<String, RTFAnalysisResult>>,
    exploit_sig_db: PagedMemory<RTFExploitSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<RTFScanConfig>,
    stats: RwLock<RTFScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_scans: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl RTFExploitDetector {
    pub fn new() -> Self {
        let cfg = RTFScanConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            rtf_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, RTFScanStats::default(),
                |acc: &mut RTFScanStats, vals: &[f64]| { acc.total_scanned += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            structure_diffs: RwLock::new(DifferentialStore::new()),
            recent_scans: RwLock::new(PruningMap::new(CACHE_MAX)),
            exploit_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(RTFScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_scans: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn scan_rtf(&self, path: &str, data: &[u8]) -> Option<RTFAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled || data.len() as u64 > cfg.max_file_size { return None; }
        let start = std::time::Instant::now();
        self.total_scans.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        if let Some(cached) = self.result_cache.get(&path.to_string()) {
            return Some(cached);
        }

        if !Self::is_valid_rtf(data) { return None; }

        let text = String::from_utf8_lossy(data);
        let structure = self.parse_rtf_structure(data, &text);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // Scan for known exploit signatures
        for &(cve, pattern, desc, conf) in RTF_EXPLOIT_SIGS {
            if text.contains(pattern) {
                findings.push(RTFThreatFinding {
                    threat_type: if cve.starts_with("CVE-2017-11882") || cve.starts_with("CVE-2018-0802") {
                        RTFThreatType::EquationEditorExploit
                    } else if cve.starts_with("Royal") {
                        RTFThreatType::ExploitKitPattern
                    } else {
                        RTFThreatType::OLEObjectEmbedding
                    },
                    offset: 0, confidence: conf,
                    cve_id: if cve.starts_with("CVE") { Some(cve.into()) } else { None },
                    description: format!("{}: {}", cve, desc),
                    raw_hex: None, mitre_id: "T1203".into(),
                });
                mitre_ids.insert("T1203".into());
            }
        }

        // Scan suspicious patterns
        for &(pattern, desc, conf) in RTF_SUSPICIOUS_PATTERNS {
            let count = text.matches(pattern).count();
            if count > 0 && conf >= cfg.min_confidence {
                let tt = if pattern.contains("4d5a") { RTFThreatType::EmbeddedExecutable }
                    else if pattern.contains("Equation") { RTFThreatType::EquationEditorExploit }
                    else if pattern.contains("objupdate") { RTFThreatType::AutoUpdateObject }
                    else if pattern.contains("template") { RTFThreatType::TemplateInjection }
                    else if pattern.contains("objocx") { RTFThreatType::ActiveXControl }
                    else { RTFThreatType::OLEObjectEmbedding };
                findings.push(RTFThreatFinding {
                    threat_type: tt,
                    offset: 0, confidence: conf,
                    cve_id: None,
                    description: format!("{} (×{}): {}", pattern, count, desc),
                    raw_hex: None,
                    mitre_id: "T1204.002".into(),
                });
                mitre_ids.insert("T1204.002".into());
            }
        }

        // Check for obfuscation: fragmented control words
        let obfuscation_indicators = self.detect_obfuscation(&text);
        if obfuscation_indicators > 3 {
            findings.push(RTFThreatFinding {
                threat_type: RTFThreatType::ObfuscatedContent,
                offset: 0, confidence: (0.5 + obfuscation_indicators as f64 * 0.1).min(0.95),
                cve_id: None,
                description: format!("{} obfuscation indicators detected", obfuscation_indicators),
                raw_hex: None, mitre_id: "T1027".into(),
            });
            mitre_ids.insert("T1027".into());
        }

        // Check excessive nesting
        if structure.nesting_depth > cfg.max_nesting_depth {
            findings.push(RTFThreatFinding {
                threat_type: RTFThreatType::MalformedStructure,
                offset: 0, confidence: 0.7,
                cve_id: None,
                description: format!("Excessive nesting depth: {} (max {})", structure.nesting_depth, cfg.max_nesting_depth),
                raw_hex: None, mitre_id: "T1027".into(),
            });
            mitre_ids.insert("T1027".into());
        }

        let risk_score = self.calculate_risk_score(&findings, &structure);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.6;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = RTFAnalysisResult {
            path: path.to_string(),
            file_size: data.len() as u64,
            is_malicious,
            structure,
            findings,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(path.to_string(), result.clone());
        self.recent_scans.write().insert_with_priority(path.to_string(), result.clone(), risk_score);
        {
            let mut matrix = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *matrix.get(&k, &path.to_string());
                matrix.set(k, path.to_string(), c + 1);
            }
        }
        if let Ok(json) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(path.to_string(), compression::compress_lz4(&json));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_scanned += 1;
            if is_malicious { stats.malicious_count += 1; } else { stats.clean_count += 1; }
            let n = stats.total_scanned as f64;
            stats.avg_scan_time_ms = stats.avg_scan_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "rtf_exploit_detector".into(),
                title: format!("Malicious RTF: {}", path.rsplit('/').next().unwrap_or(path)),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: Some(path.to_string()),
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Quarantine the RTF file".into(),
                    "Block RTF attachments at email gateway".into(),
                    "Disable Equation Editor via registry".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn is_valid_rtf(data: &[u8]) -> bool {
        data.len() >= 6 && data.starts_with(b"{\\rtf")
    }

    fn parse_rtf_structure(&self, data: &[u8], text: &str) -> RTFStructure {
        let mut max_depth = 0u32;
        let mut cur_depth = 0u32;
        for &b in data {
            match b {
                b'{' => { cur_depth += 1; if cur_depth > max_depth { max_depth = cur_depth; } }
                b'}' => { cur_depth = cur_depth.saturating_sub(1); }
                _ => {}
            }
        }
        let object_count = text.matches("\\object").count() as u32;
        let ole_count = text.matches("\\objdata").count() as u32 + text.matches("\\objemb").count() as u32;
        let eq_count = text.matches("Equation.3").count() as u32 + text.matches("Equation.").count() as u32;
        let pic_count = text.matches("\\pict").count() as u32;
        let hex_regions = text.matches("\\objdata").count() as u32;
        let has_template = text.contains("\\template") || text.contains("\\*\\template");
        let has_eq_editor = eq_count > 0 || EQUATION_EDITOR_CLSIDS.iter().any(|c| text.contains(c));
        let obf = self.detect_obfuscation(text);

        self.structure_diffs.write().record_insert(
            "rtf_struct".into(),
            format!("depth={},obj={},ole={},eq={}", max_depth, object_count, ole_count, eq_count),
        );

        RTFStructure {
            nesting_depth: max_depth,
            object_count,
            ole_object_count: ole_count,
            equation_objects: eq_count,
            embedded_pictures: pic_count,
            hex_data_regions: hex_regions,
            hex_data_bytes: 0,
            total_groups: max_depth as u64,
            has_template,
            has_equation_editor: has_eq_editor,
            obfuscation_indicators: obf,
        }
    }

    fn detect_obfuscation(&self, text: &str) -> u32 {
        let mut score = 0u32;
        // Fragmented control words: "\\ob" + "jd" + "ata"
        let short_controls = text.matches("\\").count();
        let avg_control_len = if short_controls > 0 { text.len() / short_controls } else { 100 };
        if avg_control_len < 3 { score += 2; }
        // Hex escaping of ASCII
        let hex_escapes = text.matches("\\'").count();
        if hex_escapes > 100 { score += 2; }
        if hex_escapes > 500 { score += 2; }
        // Unicode direction overrides
        if text.contains("\\uc0") || text.contains("\\u-") { score += 1; }
        // Excessive whitespace between control words
        let multi_space = text.matches("  ").count();
        if multi_space > 1000 { score += 1; }
        score
    }

    fn calculate_risk_score(&self, findings: &[RTFThreatFinding], structure: &RTFStructure) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                RTFThreatType::EquationEditorExploit => 1.5,
                RTFThreatType::EmbeddedExecutable => 1.4,
                RTFThreatType::ExploitKitPattern => 1.4,
                RTFThreatType::ShellcodePayload => 1.3,
                RTFThreatType::AutoUpdateObject => 1.2,
                RTFThreatType::ActiveXControl => 1.2,
                RTFThreatType::TemplateInjection => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        let max = findings.len() as f64 * 1.5;
        score = (score / max).min(1.0);
        if structure.has_equation_editor { score = (score + 0.1).min(1.0); }
        if structure.obfuscation_indicators > 3 { score = (score + 0.05).min(1.0); }
        score
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical }
        else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium }
        else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> RTFScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
