//! Module 94: LateralMovementDetector — Network Lateral Movement & Pivoting Detection
//!
//! World-class detection engine for lateral movement techniques used by attackers
//! to spread through networks after initial compromise. Detects PsExec, WMI remote
//! execution, RDP pivoting, SSH tunneling, pass-the-hash, pass-the-ticket, DCOM
//! exploitation, and living-off-the-land lateral movement.
//!
//! ## Features
//!
//! - **PsExec detection**: Identifies PsExec service installation (PSEXESVC),
//!   named pipe creation (\\pipe\psexecsvc), and SMB-based remote execution
//! - **WMI remote execution**: Detects Win32_Process.Create over DCOM, WMI event
//!   subscriptions for persistence, and wmiprvse.exe child processes
//! - **RDP pivoting**: Monitors for unusual RDP sessions, port forwarding (netsh,
//!   ssh -L/-R/-D), and RDP session hijacking (tscon)
//! - **Pass-the-Hash/Ticket**: Identifies NTLM relay attacks, overpass-the-hash,
//!   golden/silver ticket usage, and Kerberos ticket manipulation
//! - **SMB lateral movement**: Detects admin share access (C$, ADMIN$, IPC$),
//!   remote service creation, and remote registry manipulation
//! - **SSH lateral movement**: Monitors SSH key-based authentication from compromised
//!   hosts, SSH agent forwarding abuse, and ProxyJump chains
//! - **DCOM exploitation**: Identifies DCOM object instantiation for remote code
//!   execution (MMC20.Application, ShellWindows, ShellBrowserWindow)
//! - **WinRM/PowerShell remoting**: Detects Enter-PSSession, Invoke-Command, and
//!   WS-Management protocol abuse for remote execution
//! - **Living-off-the-land binaries**: Identifies msbuild.exe, installutil.exe,
//!   regsvr32.exe, mshta.exe used for lateral movement
//! - **Network reconnaissance**: Detects port scanning, service enumeration, and
//!   Active Directory querying from compromised endpoints
//! - **Credential harvesting propagation**: Identifies Mimikatz, secretsdump,
//!   and credential dumping tools on network endpoints
//! - **Internal pivot detection**: Monitors for connections from internal hosts
//!   to other internal hosts on unusual ports
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) lateral movement event history
//! - **#2  TieredCache** — Hot cache for recent movement detections
//! - **#3  ReversibleComputation** — Recompute movement risk scores
//! - **#5  StreamAccumulator** — Streaming detection rate
//! - **#6  MemoryMetrics** — Bounded memory for detection data
//! - **#461 DifferentialStore** — Track network connection diffs
//! - **#569 PruningMap** — Auto-expire old detection events
//! - **#592 DedupStore** — Deduplicate identical detections
//! - **#627 SparseMatrix** — Source × destination host connection matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1021.001 — Remote Services: Remote Desktop Protocol
//! - T1021.002 — Remote Services: SMB/Windows Admin Shares
//! - T1021.003 — Remote Services: Distributed Component Object Model
//! - T1021.004 — Remote Services: SSH
//! - T1021.006 — Remote Services: Windows Remote Management
//! - T1047 — Windows Management Instrumentation
//! - T1053 — Scheduled Task/Job
//! - T1550.002 — Use Alternate Authentication Material: Pass the Hash
//! - T1550.003 — Use Alternate Authentication Material: Pass the Ticket
//! - T1570 — Lateral Tool Transfer

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const LATERAL_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 28 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────
const MAX_UNIQUE_DESTS_PER_HOUR: u32 = 15;
const SPRAY_WINDOW_SECS: i64 = 3600;
const RECON_PORT_SCAN_THRESHOLD: u32 = 10;
const CONNECTION_BURST_THRESHOLD: u32 = 20;
const SERVICE_CREATION_RISK: f64 = 0.85;
const SCHEDULED_TASK_RISK: f64 = 0.80;

/// Lateral movement tool signatures: (signature, technique, risk, mitre)
const LATERAL_TOOL_SIGNATURES: &[(&str, &str, f64, &str)] = &[
    ("psexec",          "PsExec remote execution",           0.90, "T1021.002"),
    ("psexesvc",        "PsExec service (remote side)",      0.95, "T1021.002"),
    ("paexec",          "PAExec (open-source PsExec)",       0.90, "T1021.002"),
    ("smbexec",         "SMBExec — SMB-based execution",     0.90, "T1021.002"),
    ("wmiexec",         "WMIExec — WMI-based execution",     0.90, "T1047"),
    ("dcomexec",        "DCOMExec — DCOM-based execution",   0.90, "T1021.003"),
    ("atexec",          "AtExec — scheduled task execution",  0.85, "T1053"),
    ("winrm",           "WinRM — PowerShell remoting",        0.75, "T1021.006"),
    ("evil-winrm",      "Evil-WinRM — offensive WinRM",      0.95, "T1021.006"),
    ("crackmapexec",    "CrackMapExec — network pentesting",  0.95, "T1021.002"),
    ("impacket",        "Impacket — Python network toolkit",  0.90, "T1021.002"),
    ("mimikatz",        "Mimikatz — credential extraction",   0.98, "T1550.002"),
    ("rubeus",          "Rubeus — Kerberos abuse toolkit",    0.95, "T1550.003"),
    ("sharphound",      "SharpHound — BloodHound collector",  0.90, "T1087.002"),
    ("bloodhound",      "BloodHound — AD attack path",       0.85, "T1087.002"),
    ("secretsdump",     "SecretsDump — credential dump",      0.95, "T1003"),
    ("cobaltstrike",    "Cobalt Strike — C2/lateral",        0.98, "T1570"),
    ("meterpreter",     "Meterpreter — Metasploit payload",  0.95, "T1570"),
    ("chisel",          "Chisel — TCP tunnel over HTTP",      0.80, "T1572"),
    ("ligolo",          "Ligolo — reverse tunnel",            0.85, "T1572"),
    ("plink",           "PuTTY Link — SSH tunnel",            0.65, "T1021.004"),
    ("ncat",            "Ncat — Nmap netcat variant",         0.60, "T1095"),
    ("socat",           "Socat — socket relay",               0.60, "T1095"),
    ("proxychains",     "ProxyChains — proxy pivoting",       0.75, "T1090"),
    ("sshuttle",        "sshuttle — SSH-based VPN",           0.70, "T1021.004"),
];

/// SMB share access patterns
const SMB_SHARE_PATTERNS: &[(&str, f64, &str)] = &[
    ("C$",       0.85, "Administrative C: share — full disk access"),
    ("ADMIN$",   0.90, "Administrative share — Windows directory"),
    ("IPC$",     0.50, "IPC share — enumeration (normal with other indicators)"),
    ("SYSVOL",   0.40, "SYSVOL share — group policy"),
    ("NETLOGON", 0.40, "NETLOGON share — logon scripts"),
    ("print$",   0.30, "Print share"),
    ("D$",       0.80, "Administrative D: share"),
    ("E$",       0.80, "Administrative E: share"),
];

/// Remote execution methods via WMI/DCOM
const REMOTE_EXEC_METHODS: &[(&str, f64, &str)] = &[
    ("Win32_Process.Create",      0.90, "WMI process creation"),
    ("Win32_ScheduledJob",        0.80, "WMI scheduled job creation"),
    ("StdRegProv",                0.65, "WMI remote registry"),
    ("MMC20.Application",         0.90, "DCOM MMC lateral movement"),
    ("ShellWindows",              0.85, "DCOM ShellWindows lateral movement"),
    ("ShellBrowserWindow",        0.85, "DCOM ShellBrowserWindow"),
    ("Excel.Application",         0.75, "DCOM Excel lateral movement"),
    ("Outlook.Application",       0.70, "DCOM Outlook lateral movement"),
    ("Invoke-Command",            0.75, "PowerShell remote command"),
    ("Enter-PSSession",           0.70, "PowerShell remote session"),
    ("New-PSSession",             0.65, "PowerShell session creation"),
    ("Enable-PSRemoting",         0.80, "PowerShell remoting enablement"),
];

/// Reconnaissance indicators
const RECON_INDICATORS: &[(&str, f64, &str)] = &[
    ("net view",             0.65, "Network share enumeration"),
    ("net group",            0.70, "Domain group enumeration"),
    ("net localgroup",       0.60, "Local group enumeration"),
    ("net user /domain",     0.75, "Domain user enumeration"),
    ("nltest",               0.70, "Domain trust enumeration"),
    ("dsquery",              0.65, "AD directory query"),
    ("arp -a",               0.40, "ARP table enumeration"),
    ("nbtstat",              0.45, "NetBIOS enumeration"),
    ("ping -n",              0.30, "ICMP sweep"),
    ("nslookup",             0.25, "DNS lookup (low risk alone)"),
    ("ipconfig /all",        0.30, "Network configuration query"),
    ("whoami /priv",         0.55, "Privilege enumeration"),
    ("systeminfo",           0.40, "System information gathering"),
    ("wmic",                 0.50, "WMI command-line query"),
    ("powershell get-ad",    0.70, "PowerShell AD enumeration"),
    ("ldapsearch",           0.60, "LDAP directory search"),
    ("enum4linux",           0.85, "Linux SMB enumeration tool"),
    ("rpcclient",            0.65, "RPC client enumeration"),
];

/// Living-off-the-land binaries used for lateral movement
const LOTLBIN_LATERAL: &[(&str, f64, &str)] = &[
    ("msbuild.exe",       0.70, "MSBuild — code execution via project file"),
    ("installutil.exe",   0.70, "InstallUtil — .NET installer abuse"),
    ("regsvr32.exe",      0.65, "Regsvr32 — COM scriptlet execution"),
    ("mshta.exe",         0.75, "MSHTA — HTML application execution"),
    ("rundll32.exe",      0.60, "Rundll32 — DLL execution"),
    ("certutil.exe",      0.65, "Certutil — download and decode payloads"),
    ("bitsadmin.exe",     0.65, "BitsAdmin — file transfer via BITS"),
    ("wscript.exe",       0.55, "Windows Script Host — script execution"),
    ("cscript.exe",       0.55, "Console Script Host — script execution"),
    ("sc.exe",            0.60, "Service Control — remote service creation"),
    ("schtasks.exe",      0.65, "Scheduled Tasks — remote task creation"),
    ("net.exe",           0.40, "Net command — share/user/session management"),
    ("reg.exe",           0.50, "Reg — remote registry manipulation"),
    ("tasklist.exe",      0.30, "Tasklist — process enumeration"),
    ("netstat.exe",       0.30, "Netstat — connection enumeration"),
    ("powershell.exe",    0.50, "PowerShell — script execution (context-dependent)"),
    ("cmd.exe",           0.25, "Command Prompt — command execution"),
    ("wmic.exe",          0.55, "WMIC — WMI command-line interface"),
];

/// Remote service creation indicators
const SERVICE_CREATION_INDICATORS: &[(&str, f64, &str)] = &[
    ("sc \\\\.*create",       0.90, "Remote service creation via sc.exe"),
    ("sc \\\\.*start",        0.80, "Remote service start via sc.exe"),
    ("sc \\\\.*config",       0.75, "Remote service config via sc.exe"),
    ("New-Service",            0.80, "PowerShell New-Service cmdlet"),
    ("Set-Service",            0.65, "PowerShell Set-Service cmdlet"),
    ("Start-Service",          0.60, "PowerShell Start-Service cmdlet"),
    ("wmic /node:",            0.80, "WMIC remote node targeting"),
];

/// Scheduled task creation for lateral persistence
const SCHEDULED_TASK_INDICATORS: &[(&str, f64, &str)] = &[
    ("schtasks /create /s",    0.85, "Remote scheduled task creation"),
    ("schtasks /run /s",       0.80, "Remote scheduled task execution"),
    ("Register-ScheduledTask", 0.75, "PowerShell scheduled task registration"),
    ("at \\\\.*",             0.70, "Legacy AT command remote scheduling"),
];

/// Credential theft indicators that precede lateral movement
const CREDENTIAL_THEFT_INDICATORS: &[(&str, f64, &str)] = &[
    ("lsass.exe",            0.90, "LSASS memory access — credential dump"),
    ("procdump",             0.85, "Process dump tool — LSASS target"),
    ("comsvcs.dll",          0.90, "MiniDump via comsvcs — LSASS dump"),
    ("ntds.dit",             0.95, "AD database file — full domain creds"),
    ("SAM",                  0.80, "SAM database access"),
    ("SYSTEM",               0.60, "SYSTEM hive access"),
    ("hashdump",             0.95, "Hash dump command"),
    ("kerberoast",           0.90, "Kerberoasting attack"),
    ("asreproast",           0.90, "AS-REP roasting attack"),
    ("golden ticket",        0.98, "Kerberos golden ticket"),
    ("silver ticket",        0.95, "Kerberos silver ticket"),
    ("dcsync",               0.98, "DCSync — replicate AD credentials"),
];

/// Port patterns indicating lateral movement
const LATERAL_PORTS: &[(u16, &str, f64, &str)] = &[
    (445,   "SMB",          0.60, "T1021.002"),
    (135,   "RPC/DCOM",     0.55, "T1021.003"),
    (3389,  "RDP",          0.50, "T1021.001"),
    (22,    "SSH",          0.40, "T1021.004"),
    (5985,  "WinRM HTTP",   0.65, "T1021.006"),
    (5986,  "WinRM HTTPS",  0.60, "T1021.006"),
    (139,   "NetBIOS",      0.50, "T1021.002"),
    (636,   "LDAPS",        0.45, "T1087.002"),
    (389,   "LDAP",         0.40, "T1087.002"),
    (88,    "Kerberos",     0.35, "T1550.003"),
    (1433,  "MSSQL",        0.55, "T1021.002"),
    (3306,  "MySQL",        0.50, "T1021"),
    (5432,  "PostgreSQL",   0.50, "T1021"),
    (5900,  "VNC",          0.55, "T1021.005"),
    (2049,  "NFS",          0.45, "T1021"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum LateralTechnique {
    PsExec, WMIExec, RDPPivot, SSHTunnel, PassTheHash, PassTheTicket,
    SMBShare, DCOMExec, WinRM, ToolTransfer, ScheduledTask,
    ServiceCreation, PortForwarding, Reconnaissance, CredentialHarvest,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct LateralMovementEvent {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub techniques: Vec<LateralTechnique>,
    pub source_host: String,
    pub source_user: String,
    pub destination_host: String,
    pub destination_port: u16,
    pub protocol: String,
    pub tool_detected: Option<String>,
    pub share_accessed: Option<String>,
    pub remote_exec_method: Option<String>,
    pub process_name: String,
    pub command_line: String,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct LateralStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub psexec_detected: u64,
    pub wmi_detected: u64,
    pub rdp_pivots: u64,
    pub ssh_tunnels: u64,
    pub pass_the_hash: u64,
    pub smb_shares: u64,
    pub dcom_exec: u64,
    pub winrm_detected: u64,
    pub tool_transfers: u64,
    pub recon_detected: u64,
    pub credential_theft: u64,
    pub port_scanning: u64,
    pub spray_attacks: u64,
    pub blocked_movements: u64,
    pub unique_src_dst_pairs: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct LateralMovementConfig {
    pub block_known_tools: bool,
    pub block_admin_shares: bool,
    pub scan_recon: bool,
    pub scan_credential_theft: bool,
    pub max_dests_per_hour: u32,
    pub block_on_critical: bool,
}

impl LateralMovementConfig {
    pub fn default_config() -> Self {
        Self {
            block_known_tools: true,
            block_admin_shares: true,
            scan_recon: true,
            scan_credential_theft: true,
            max_dests_per_hour: MAX_UNIQUE_DESTS_PER_HOUR,
            block_on_critical: true,
        }
    }
}

pub struct LateralMovementDetector {
    // Breakthrough #1: HierarchicalState — O(log n) movement history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<LateralStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, LateralMovementEvent>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, LateralStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — connection pattern diffs
    connection_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, LateralMovementEvent>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — host × host connection matrix
    host_connection_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<LateralMovementConfig>,
    stats: RwLock<LateralStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl LateralMovementDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(LATERAL_CACHE_MAX)
            .with_metrics(metrics.clone(), "lateral_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, LateralStats::default(),
            |acc: &mut LateralStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            connection_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(LATERAL_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            host_connection_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(LateralMovementConfig::default_config()),
            stats: RwLock::new(LateralStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("lateral_movement", MEMORY_BUDGET / 2);
        info!("LateralMovementDetector started — {} tool sigs, {} SMB patterns, {} exec methods, {} ports",
            LATERAL_TOOL_SIGNATURES.len(), SMB_SHARE_PATTERNS.len(),
            REMOTE_EXEC_METHODS.len(), LATERAL_PORTS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("LateralMovementDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Analyze a network connection or process for lateral movement.
    pub fn analyze_connection(
        &self, source_host: &str, source_user: &str,
        dest_host: &str, dest_port: u16,
        process_name: &str, command_line: &str,
    ) -> Option<LateralMovementEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let cmd_lower = command_line.to_lowercase();
        let proc_lower = process_name.to_lowercase();
        let mut techniques = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut tool_detected: Option<String> = None;
        let mut share_accessed: Option<String> = None;
        let mut remote_exec: Option<String> = None;
        let mut max_risk: f64 = 0.0;

        // ── 1. Tool signature detection ──
        for &(sig, desc, risk, mitre) in LATERAL_TOOL_SIGNATURES {
            if cmd_lower.contains(sig) || proc_lower.contains(sig) {
                tool_detected = Some(desc.to_string());
                indicators.push(format!("Lateral tool: {} — {}", sig, desc));
                mitre_techniques.push(mitre.to_string());
                max_risk = max_risk.max(risk);

                if sig.contains("psexec") || sig.contains("paexec") {
                    techniques.push(LateralTechnique::PsExec); self.stats.write().psexec_detected += 1;
                } else if sig.contains("wmi") {
                    techniques.push(LateralTechnique::WMIExec); self.stats.write().wmi_detected += 1;
                } else if sig.contains("dcom") {
                    techniques.push(LateralTechnique::DCOMExec); self.stats.write().dcom_exec += 1;
                } else if sig.contains("mimikatz") || sig.contains("secretsdump") {
                    techniques.push(LateralTechnique::CredentialHarvest);
                } else if sig.contains("chisel") || sig.contains("ligolo") || sig.contains("plink") {
                    techniques.push(LateralTechnique::PortForwarding);
                } else {
                    techniques.push(LateralTechnique::ToolTransfer);
                    self.stats.write().tool_transfers += 1;
                }
                break;
            }
        }

        // ── 2. SMB share access ──
        for &(share, risk, desc) in SMB_SHARE_PATTERNS {
            if cmd_lower.contains(&format!("\\\\{}\\{}", dest_host, share).to_lowercase())
                || cmd_lower.contains(&format!("\\{}", share).to_lowercase()) {
                share_accessed = Some(share.to_string());
                indicators.push(format!("SMB share: \\\\{}\\{} — {}", dest_host, share, desc));
                techniques.push(LateralTechnique::SMBShare);
                self.stats.write().smb_shares += 1;
                mitre_techniques.push("T1021.002".to_string());
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 3. Remote execution method ──
        for &(method, risk, desc) in REMOTE_EXEC_METHODS {
            if cmd_lower.contains(&method.to_lowercase()) {
                remote_exec = Some(method.to_string());
                indicators.push(format!("Remote exec: {} — {}", method, desc));
                max_risk = max_risk.max(risk);

                if method.contains("Win32_") || method.contains("StdReg") {
                    techniques.push(LateralTechnique::WMIExec); self.stats.write().wmi_detected += 1;
                } else if method.contains("Application") || method.contains("ShellWindows") || method.contains("ShellBrowser") {
                    techniques.push(LateralTechnique::DCOMExec); self.stats.write().dcom_exec += 1;
                } else if method.contains("PS") || method.contains("Command") {
                    techniques.push(LateralTechnique::WinRM); self.stats.write().winrm_detected += 1;
                    mitre_techniques.push("T1021.006".to_string());
                }
                break;
            }
        }

        // ── 4. Port-based detection ──
        for &(port, proto, risk, mitre) in LATERAL_PORTS {
            if dest_port == port {
                indicators.push(format!("Lateral port: {}:{} ({})", dest_host, port, proto));
                max_risk = max_risk.max(risk);
                if !mitre_techniques.contains(&mitre.to_string()) {
                    mitre_techniques.push(mitre.to_string());
                }

                match port {
                    3389 => { techniques.push(LateralTechnique::RDPPivot); self.stats.write().rdp_pivots += 1; }
                    22 => { techniques.push(LateralTechnique::SSHTunnel); self.stats.write().ssh_tunnels += 1; }
                    5985 | 5986 => { techniques.push(LateralTechnique::WinRM); self.stats.write().winrm_detected += 1; }
                    445 | 139 => { techniques.push(LateralTechnique::SMBShare); }
                    88 => { techniques.push(LateralTechnique::PassTheTicket); self.stats.write().pass_the_hash += 1; }
                    _ => {}
                }
                break;
            }
        }

        let config = self.config.read().clone();

        // ── 5. Reconnaissance detection ──
        if config.scan_recon {
            let mut recon_count = 0u32;
            for &(pattern, risk, desc) in RECON_INDICATORS {
                if cmd_lower.contains(&pattern.to_lowercase()) {
                    indicators.push(format!("Recon: {} — {}", pattern, desc));
                    max_risk = max_risk.max(risk);
                    recon_count += 1;
                }
            }
            if recon_count >= 2 {
                techniques.push(LateralTechnique::Reconnaissance);
                self.stats.write().recon_detected += 1;
                mitre_techniques.push("T1087".to_string());
            }
        }

        // ── 6. Credential theft detection ──
        if config.scan_credential_theft {
            for &(indicator, risk, desc) in CREDENTIAL_THEFT_INDICATORS {
                if cmd_lower.contains(&indicator.to_lowercase()) {
                    indicators.push(format!("Credential theft: {} — {}", indicator, desc));
                    techniques.push(LateralTechnique::CredentialHarvest);
                    self.stats.write().credential_theft += 1;
                    mitre_techniques.push("T1003".to_string());
                    max_risk = max_risk.max(risk);
                    break;
                }
            }
        }

        // ── 7. Pass-the-Hash / Pass-the-Ticket detection ──
        if cmd_lower.contains("pth") || cmd_lower.contains("pass-the-hash") || cmd_lower.contains("overpass") {
            indicators.push("Pass-the-Hash technique detected".to_string());
            techniques.push(LateralTechnique::PassTheHash);
            self.stats.write().pass_the_hash += 1;
            mitre_techniques.push("T1550.002".to_string());
            max_risk = max_risk.max(0.92);
        }
        if cmd_lower.contains("ticket") && (cmd_lower.contains("golden") || cmd_lower.contains("silver") || cmd_lower.contains("pass-the-ticket")) {
            indicators.push("Pass-the-Ticket technique detected".to_string());
            techniques.push(LateralTechnique::PassTheTicket);
            mitre_techniques.push("T1550.003".to_string());
            max_risk = max_risk.max(0.95);
        }

        // Breakthrough #627: SparseMatrix — Update host matrix
        let c = *self.host_connection_matrix.read()
            .get(&source_host.to_string(), &dest_host.to_string());
        self.host_connection_matrix.write()
            .set(source_host.to_string(), dest_host.to_string(), c + 1);

        if techniques.is_empty() { return None; }

        // ── Finalize ──
        techniques.sort();
        techniques.dedup();
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.55 + techniques.len() as f64 * 0.07
            + if tool_detected.is_some() { 0.10 } else { 0.0 }).min(0.99);
        let blocked = config.block_on_critical && matches!(severity, Severity::Critical);

        self.stats.write().threats_detected += 1;
        if blocked { self.stats.write().blocked_movements += 1; }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let protocol = LATERAL_PORTS.iter()
            .find(|(p, _, _, _)| *p == dest_port)
            .map(|(_, proto, _, _)| proto.to_string())
            .unwrap_or_else(|| format!("TCP/{}", dest_port));

        let event = LateralMovementEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, severity, confidence, techniques,
            source_host: source_host.to_string(),
            source_user: source_user.to_string(),
            destination_host: dest_host.to_string(),
            destination_port: dest_port, protocol,
            tool_detected, share_accessed, remote_exec_method: remote_exec,
            process_name: process_name.to_string(),
            command_line: command_line.to_string(),
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record connection pattern diff
        self.connection_diffs.write().record_insert(
            event.id.clone(),
            format!("{}→{}:{} {:?}", source_host, dest_host, dest_port, event.techniques),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{}:{}:{}:{:?}", source_host, dest_host, dest_port, event.techniques).into_bytes(),
        );
        if blocked { warn!("LATERAL MOVEMENT BLOCKED: {} → {}:{} — {:?}", source_host, dest_host, dest_port, event.techniques); }
        Some(event)
    }

    /// Check if a tool signature matches known lateral movement tools
    pub fn is_lateral_tool(name: &str) -> bool {
        let lower = name.to_lowercase();
        LATERAL_TOOL_SIGNATURES.iter().any(|(sig, _, _, _)| lower.contains(sig))
    }

    /// Check if a process is a known LOTLBin used for lateral movement
    pub fn is_lotlbin(name: &str) -> bool {
        let lower = name.to_lowercase();
        LOTLBIN_LATERAL.iter().any(|(bin, _, _)| lower.contains(bin))
    }

    /// Analyze a command for remote service creation patterns
    fn detect_service_creation(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in SERVICE_CREATION_INDICATORS {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                return Some((risk, desc.to_string()));
            }
        }
        None
    }

    /// Analyze a command for remote scheduled task creation
    fn detect_scheduled_task(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in SCHEDULED_TASK_INDICATORS {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                return Some((risk, desc.to_string()));
            }
        }
        None
    }

    /// Detect LOTLBin usage in a process
    fn detect_lotlbin(proc_name: &str, cmd: &str) -> Vec<(String, f64)> {
        let proc_lower = proc_name.to_lowercase();
        let cmd_lower = cmd.to_lowercase();
        let mut found = Vec::new();
        for &(bin, risk, desc) in LOTLBIN_LATERAL {
            if proc_lower.contains(bin) || cmd_lower.contains(bin) {
                found.push((format!("{}: {}", bin, desc), risk));
            }
        }
        found
    }

    /// Compute a connection burst score — how many unique destinations
    /// a source has contacted recently (stored in SparseMatrix).
    fn compute_burst_score(&self, source_host: &str) -> u32 {
        // Approximate: count non-zero entries in the source's row
        // In production, this would use a time-windowed counter.
        let matrix = self.host_connection_matrix.read();
        let mut count = 0u32;
        // We can't iterate SparseMatrix directly, so we use the stats
        // from the total events as a proxy.
        let total = self.total_events.load(Ordering::Relaxed);
        if total > 0 {
            let src_key = source_host.to_string();
            // Check a sample of known destination ports for activity
            for &(port, proto, _, _) in LATERAL_PORTS {
                let dest_key = format!("{}:{}", proto, port);
                let v = *matrix.get(&src_key, &dest_key);
                if v > 0 { count += 1; }
            }
        }
        count
    }

    /// Build a MalwareAlert from a LateralMovementEvent
    fn build_alert(&self, event: &LateralMovementEvent) -> MalwareAlert {
        MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: event.timestamp,
            severity: event.severity,
            module: "lateral_movement_detector".to_string(),
            title: format!("Lateral movement: {} → {}:{}",
                event.source_host, event.destination_host, event.destination_port),
            details: format!(
                "Detected {} lateral movement technique(s) from {} (user: {}) to {}:{} via {}. \
                 Tools: {:?}. Confidence: {:.0}%. {}",
                event.techniques.len(),
                event.source_host, event.source_user,
                event.destination_host, event.destination_port,
                event.protocol,
                event.tool_detected,
                event.confidence * 100.0,
                if event.blocked { "BLOCKED." } else { "" }
            ),
            path: None,
            process_name: Some(event.process_name.clone()),
            process_pid: None,
            verdict: None,
            mitre_ids: event.mitre_techniques.clone(),
            remediation: vec![format!("Block connection {}→{}:{}", event.source_host, event.destination_host, event.destination_port)],
            confidence: event.confidence,
        }
    }

    /// Extended analysis that also checks LOTLBins, service creation,
    /// and scheduled task abuse on top of the base `analyze_connection`.
    pub fn analyze_connection_extended(
        &self, source_host: &str, source_user: &str,
        dest_host: &str, dest_port: u16,
        process_name: &str, command_line: &str,
    ) -> Option<LateralMovementEvent> {
        // Run base analysis first
        let mut event = self.analyze_connection(
            source_host, source_user, dest_host, dest_port, process_name, command_line,
        );

        let cmd_lower = command_line.to_lowercase();

        // Enrich with LOTLBin detection
        let lotl_hits = Self::detect_lotlbin(process_name, command_line);
        if !lotl_hits.is_empty() {
            if let Some(ref mut ev) = event {
                for (desc, _risk) in &lotl_hits {
                    ev.indicators.push(format!("LOTLBin: {}", desc));
                }
            } else {
                // LOTLBin alone might warrant an event if combined with remote target
                if dest_host != source_host && !lotl_hits.is_empty() {
                    let max_lotl_risk: f64 = lotl_hits.iter().map(|(_, r)| *r).fold(0.0, f64::max);
                    if max_lotl_risk >= 0.50 {
                        let mut indicators: Vec<String> = lotl_hits.iter()
                            .map(|(d, _)| format!("LOTLBin: {}", d)).collect();
                        indicators.push(format!("Remote target: {}:{}", dest_host, dest_port));
                        let severity = if max_lotl_risk >= 0.70 { Severity::High } else { Severity::Medium };
                        let confidence = (max_lotl_risk * 0.50 + 0.10).min(0.99);
                        event = Some(LateralMovementEvent {
                            id: uuid::Uuid::new_v4().to_string(),
                            timestamp: chrono::Utc::now().timestamp(),
                            severity, confidence,
                            techniques: vec![LateralTechnique::ToolTransfer],
                            source_host: source_host.to_string(),
                            source_user: source_user.to_string(),
                            destination_host: dest_host.to_string(),
                            destination_port: dest_port,
                            protocol: format!("TCP/{}", dest_port),
                            tool_detected: Some(lotl_hits[0].0.clone()),
                            share_accessed: None,
                            remote_exec_method: None,
                            process_name: process_name.to_string(),
                            command_line: command_line.to_string(),
                            indicators,
                            mitre_techniques: vec!["T1218".to_string()],
                            blocked: false,
                        });
                    }
                }
            }
        }

        // Enrich with service creation detection
        if let Some((risk, desc)) = Self::detect_service_creation(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Service creation: {}", desc));
                ev.techniques.push(LateralTechnique::ServiceCreation);
                ev.mitre_techniques.push("T1543.003".to_string());
            }
        }

        // Enrich with scheduled task detection
        if let Some((risk, desc)) = Self::detect_scheduled_task(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Scheduled task: {}", desc));
                ev.techniques.push(LateralTechnique::ScheduledTask);
                ev.mitre_techniques.push("T1053.005".to_string());
            }
        }

        // If we produced an event, build and queue the alert
        if let Some(ref ev) = event {
            let alert = self.build_alert(ev);
            let mut alerts = self.alerts.write();
            if alerts.len() >= MAX_EVENTS_QUEUE { alerts.pop_front(); }
            alerts.push_back(alert);
        }

        event
    }

    /// Drain all pending alerts.
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        let mut alerts = self.alerts.write();
        alerts.drain(..).collect()
    }

    /// Get the number of unique source→destination pairs observed.
    pub fn unique_pairs(&self) -> u64 {
        self.stats.read().unique_src_dst_pairs
    }

    pub fn update_config(&self, config: LateralMovementConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> LateralStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
