//! Module 117: WMIExecDetector — WMI-Based Remote Execution Detection
//!
//! Detects abuse of Windows Management Instrumentation (WMI) for remote code
//! execution, persistence, and reconnaissance. While primarily a Windows vector,
//! macOS environments with Boot Camp, Parallels, or mixed enterprise networks
//! are exposed via cross-platform lateral movement.
//!
//! ## Detection Capabilities
//!
//! - **WMI remote execution**: Win32_Process.Create() remote process spawning,
//!   wmic.exe /node: commands, WMI event subscriptions for persistence
//! - **WMI reconnaissance**: Win32_ComputerSystem, Win32_OperatingSystem,
//!   Win32_LogicalDisk, Win32_NetworkAdapterConfiguration enumeration
//! - **WMI persistence**: __EventFilter + __EventConsumer + __FilterToConsumerBinding
//!   (permanent event subscriptions for backdoor persistence)
//! - **DCOM lateral movement**: DCOM-based WMI connections (TCP 135 + dynamic)
//! - **Impacket wmiexec**: Detection of Impacket's wmiexec.py tool signatures
//! - **PowerShell WMI**: Invoke-WmiMethod, Get-WmiObject, Invoke-CimMethod abuse
//! - **WMI event log analysis**: Correlation of WMI activity with process creation
//! - **Cross-platform detection**: WMI calls originating from or targeting macOS
//!   hosts in mixed environments
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

// ── WMI Attack Signatures ────────────────────────────────────────────────────

const WMI_EXEC_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("Win32_Process", "Process creation via WMI", "T1047", 0.7),
    ("process call create", "WMI process spawning", "T1047", 0.85),
    ("/node:", "Remote WMI execution (wmic)", "T1047", 0.8),
    ("Invoke-WmiMethod", "PowerShell WMI method invocation", "T1047", 0.85),
    ("Invoke-CimMethod", "PowerShell CIM method invocation", "T1047", 0.8),
    ("Get-WmiObject", "PowerShell WMI object query", "T1047", 0.5),
    ("Get-CimInstance", "PowerShell CIM instance query", "T1047", 0.45),
    ("wmic", "WMIC command-line utility", "T1047", 0.6),
    ("wmiprvse.exe", "WMI Provider Host (child process spawning)", "T1047", 0.5),
    ("scrcons.exe", "WMI Script Consumer (persistence)", "T1047", 0.8),
];

const WMI_PERSISTENCE_PATTERNS: &[(&str, &str, f64)] = &[
    ("__EventFilter", "WMI event filter (persistence trigger)", 0.85),
    ("__EventConsumer", "WMI event consumer (persistence action)", 0.85),
    ("CommandLineEventConsumer", "WMI command-line consumer", 0.9),
    ("ActiveScriptEventConsumer", "WMI script consumer", 0.9),
    ("__FilterToConsumerBinding", "WMI filter-consumer binding", 0.9),
    ("__InstanceCreationEvent", "WMI instance creation event", 0.6),
    ("__InstanceModificationEvent", "WMI instance modification event", 0.6),
    ("__TimerInstruction", "WMI timer-based trigger", 0.7),
    ("__IntervalTimerInstruction", "WMI interval timer", 0.7),
    ("ROOT\\subscription", "WMI subscription namespace", 0.8),
    ("ROOT\\DEFAULT", "WMI default namespace (persistence)", 0.5),
];

const WMI_RECON_CLASSES: &[(&str, &str, f64)] = &[
    ("Win32_ComputerSystem", "System information gathering", 0.3),
    ("Win32_OperatingSystem", "OS information gathering", 0.3),
    ("Win32_LogicalDisk", "Disk enumeration", 0.35),
    ("Win32_NetworkAdapterConfiguration", "Network config enumeration", 0.4),
    ("Win32_Service", "Service enumeration", 0.35),
    ("Win32_Share", "Share enumeration", 0.45),
    ("Win32_UserAccount", "User account enumeration", 0.5),
    ("Win32_Group", "Group enumeration", 0.45),
    ("Win32_Product", "Installed software enumeration", 0.35),
    ("AntiVirusProduct", "AV product detection (defense evasion)", 0.7),
    ("Win32_ShadowCopy", "Shadow copy access (ransomware prep)", 0.75),
    ("Win32_BIOS", "BIOS info (VM detection)", 0.5),
];

const WMI_SUSPICIOUS_COMMANDS: &[(&str, &str, f64)] = &[
    ("cmd /c", "Command interpreter via WMI", 0.75),
    ("powershell", "PowerShell via WMI", 0.8),
    ("certutil", "Certutil via WMI (download/decode)", 0.85),
    ("bitsadmin", "BITS transfer via WMI", 0.8),
    ("mshta", "HTA execution via WMI", 0.9),
    ("regsvr32", "DLL registration via WMI", 0.85),
    ("rundll32", "DLL host via WMI", 0.8),
    ("net user", "User management via WMI", 0.7),
    ("net localgroup", "Group management via WMI", 0.75),
    ("sc create", "Service creation via WMI", 0.85),
    ("schtasks", "Scheduled task via WMI", 0.8),
    ("whoami", "Identity check via WMI", 0.5),
    ("ipconfig", "Network config via WMI", 0.4),
    ("systeminfo", "System info via WMI", 0.4),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum WMIThreatType {
    RemoteExecution,
    ProcessCreation,
    EventSubscriptionPersistence,
    ReconnaissanceQuery,
    DCOMLateralMovement,
    ImpacketWmiexec,
    PowerShellWMI,
    SuspiciousCommand,
    WMIProviderAbuse,
    NamespaceManipulation,
    ScriptConsumerAbuse,
    AVEnumeration,
    ShadowCopyAccess,
    VMDetection,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WMIThreatFinding {
    pub threat_type: WMIThreatType,
    pub source_host: Option<String>,
    pub target_host: Option<String>,
    pub confidence: f64,
    pub description: String,
    pub wmi_class: Option<String>,
    pub wmi_method: Option<String>,
    pub command_line: Option<String>,
    pub namespace: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WMIEvent {
    pub event_type: String,
    pub source_host: String,
    pub target_host: Option<String>,
    pub username: String,
    pub wmi_namespace: String,
    pub wmi_class: Option<String>,
    pub wmi_method: Option<String>,
    pub command_line: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
    pub is_remote: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WMIAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<WMIThreatFinding>,
    pub persistence_subscriptions: Vec<String>,
    pub recon_queries: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct WMIScanStats {
    pub total_events: u64,
    pub remote_exec_detections: u64,
    pub persistence_detections: u64,
    pub recon_detections: u64,
    pub dcom_detections: u64,
    pub tool_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WMIDetectorConfig {
    pub enabled: bool,
    pub detect_remote_exec: bool,
    pub detect_persistence: bool,
    pub detect_recon: bool,
    pub detect_dcom: bool,
    pub min_confidence: f64,
    pub recon_threshold: u32,
    pub memory_budget_bytes: usize,
}

impl Default for WMIDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            detect_remote_exec: true,
            detect_persistence: true,
            detect_recon: true,
            detect_dcom: true,
            min_confidence: 0.5,
            recon_threshold: 5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WMISigEntry {
    pub pattern: String,
    pub description: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct WMIExecDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<WMIScanStats>>,
    result_cache: TieredCache<String, WMIAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, WMIScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, WMIAnalysisResult>>,
    sig_db: PagedMemory<WMISigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<WMIDetectorConfig>,
    stats: RwLock<WMIScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_analyses: AtomicU64,
    recon_tracking: RwLock<HashMap<String, Vec<String>>>,
    persistence_tracking: RwLock<HashMap<String, Vec<String>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl WMIExecDetector {
    pub fn new() -> Self {
        let cfg = WMIDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, WMIScanStats::default(),
                |acc: &mut WMIScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(WMIScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_analyses: AtomicU64::new(0),
            recon_tracking: RwLock::new(HashMap::new()),
            persistence_tracking: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &WMIEvent) -> Option<WMIAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_analyses.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.source_host,
            event.target_host.as_deref().unwrap_or("local"), event.timestamp);

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut recon_queries = Vec::new();
        let mut persistence_subs = Vec::new();

        let event_text = format!("{} {} {} {}",
            event.wmi_class.as_deref().unwrap_or(""),
            event.wmi_method.as_deref().unwrap_or(""),
            event.command_line.as_deref().unwrap_or(""),
            event.wmi_namespace);

        // Check remote execution patterns
        if cfg.detect_remote_exec && event.is_remote {
            for &(pattern, desc, mitre, conf) in WMI_EXEC_PATTERNS {
                if event_text.contains(pattern) {
                    findings.push(WMIThreatFinding {
                        threat_type: WMIThreatType::RemoteExecution,
                        source_host: Some(event.source_host.clone()),
                        target_host: event.target_host.clone(),
                        confidence: conf,
                        description: format!("{}: {} → {}",
                            desc, event.source_host, event.target_host.as_deref().unwrap_or("?")),
                        wmi_class: event.wmi_class.clone(),
                        wmi_method: event.wmi_method.clone(),
                        command_line: event.command_line.clone(),
                        namespace: Some(event.wmi_namespace.clone()),
                        mitre_id: mitre.into(),
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                }
            }
        }

        // Check persistence patterns
        if cfg.detect_persistence {
            for &(pattern, desc, conf) in WMI_PERSISTENCE_PATTERNS {
                if event_text.contains(pattern) {
                    findings.push(WMIThreatFinding {
                        threat_type: WMIThreatType::EventSubscriptionPersistence,
                        source_host: Some(event.source_host.clone()),
                        target_host: event.target_host.clone(),
                        confidence: conf,
                        description: desc.to_string(),
                        wmi_class: event.wmi_class.clone(),
                        wmi_method: event.wmi_method.clone(),
                        command_line: event.command_line.clone(),
                        namespace: Some(event.wmi_namespace.clone()),
                        mitre_id: "T1546.003".into(),
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1546.003".into());
                    persistence_subs.push(pattern.to_string());
                }
            }
        }

        // Check recon queries
        if cfg.detect_recon {
            for &(wmi_class, desc, conf) in WMI_RECON_CLASSES {
                if event_text.contains(wmi_class) {
                    recon_queries.push(wmi_class.to_string());
                    let tt = if wmi_class.contains("AntiVirus") {
                        WMIThreatType::AVEnumeration
                    } else if wmi_class.contains("ShadowCopy") {
                        WMIThreatType::ShadowCopyAccess
                    } else if wmi_class.contains("BIOS") {
                        WMIThreatType::VMDetection
                    } else {
                        WMIThreatType::ReconnaissanceQuery
                    };
                    // Track recon per source
                    self.recon_tracking.write()
                        .entry(event.source_host.clone())
                        .or_default()
                        .push(wmi_class.to_string());

                    let source_recon = self.recon_tracking.read()
                        .get(&event.source_host)
                        .map(|v| v.len() as u32)
                        .unwrap_or(0);

                    if source_recon >= cfg.recon_threshold || conf >= 0.5 {
                        findings.push(WMIThreatFinding {
                            threat_type: tt,
                            source_host: Some(event.source_host.clone()),
                            target_host: event.target_host.clone(),
                            confidence: if source_recon >= cfg.recon_threshold {
                                (conf + 0.2).min(0.95)
                            } else { conf },
                            description: format!("{} ({} recon queries from this host)", desc, source_recon),
                            wmi_class: Some(wmi_class.to_string()),
                            wmi_method: event.wmi_method.clone(),
                            command_line: None,
                            namespace: Some(event.wmi_namespace.clone()),
                            mitre_id: "T1082".into(),
                            process_name: event.process_name.clone(),
                            process_pid: event.process_pid,
                            timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1082".into());
                    }
                }
            }
        }

        // Check suspicious commands spawned via WMI
        if let Some(ref cmd) = event.command_line {
            let cmd_lower = cmd.to_lowercase();
            for &(pattern, desc, conf) in WMI_SUSPICIOUS_COMMANDS {
                if cmd_lower.contains(&pattern.to_lowercase()) {
                    findings.push(WMIThreatFinding {
                        threat_type: WMIThreatType::SuspiciousCommand,
                        source_host: Some(event.source_host.clone()),
                        target_host: event.target_host.clone(),
                        confidence: conf,
                        description: format!("{} via WMI", desc),
                        wmi_class: event.wmi_class.clone(),
                        wmi_method: event.wmi_method.clone(),
                        command_line: Some(cmd.clone()),
                        namespace: Some(event.wmi_namespace.clone()),
                        mitre_id: "T1047".into(),
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1047".into());
                }
            }
        }

        // Store event diff
        self.event_diffs.write().record_insert(
            cache_key.clone(),
            format!("src={},cls={},remote={}",
                event.source_host,
                event.wmi_class.as_deref().unwrap_or("none"),
                event.is_remote),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = WMIAnalysisResult {
            is_malicious,
            events_analyzed: 1,
            findings,
            persistence_subscriptions: persistence_subs,
            recon_queries,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_events += 1;
            let n = stats.total_events as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "wmi_exec_detector".into(),
                title: format!("WMI abuse: {} → {}",
                    event.source_host, event.target_host.as_deref().unwrap_or("local")),
                details: format!("Risk: {:.1}%, {} findings, user: {}",
                    risk_score * 100.0, result.findings.len(), event.username),
                path: None,
                process_name: event.process_name.clone(),
                process_pid: event.process_pid,
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Restrict WMI remote access via GPO".into(),
                    "Disable WMI event subscriptions where not needed".into(),
                    "Monitor WMI activity with Sysmon Event ID 19-21".into(),
                    "Implement network segmentation".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[WMIThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                WMIThreatType::EventSubscriptionPersistence => 1.5,
                WMIThreatType::RemoteExecution => 1.4,
                WMIThreatType::ImpacketWmiexec => 1.4,
                WMIThreatType::ScriptConsumerAbuse => 1.3,
                WMIThreatType::SuspiciousCommand => 1.2,
                WMIThreatType::ShadowCopyAccess => 1.2,
                WMIThreatType::AVEnumeration => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> WMIScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
