//! Module 84: WebshellDetector — Web Shell & Backdoor Detection
//!
//! World-class detection engine for web shells — malicious scripts planted on web
//! servers that provide remote command execution. Detects PHP, JSP, ASP, ASPX,
//! Python, Perl, and Node.js web shells through static analysis, behavioral
//! fingerprinting, opcode analysis, and entropy-based detection.
//!
//! ## Features
//!
//! - **PHP web shell detection**: Detects eval(), system(), passthru(), shell_exec(),
//!   proc_open(), popen(), assert(), preg_replace /e, and backtick execution in PHP
//! - **JSP/Java web shell detection**: Identifies Runtime.exec(), ProcessBuilder,
//!   ScriptEngine eval, JNDI injection, and deserialization-based shells
//! - **ASP/ASPX detection**: Detects wscript.shell, Server.Execute, Process.Start,
//!   and PowerShell invocation from ASP.NET
//! - **Python web shell detection**: Flask/Django backdoor routes, os.system(),
//!   subprocess usage in web handlers, and pickle-based RCE
//! - **Obfuscation detection**: Base64, ROT13, gzinflate, str_rot13, hex2bin,
//!   chr() construction, variable function calls, and string concatenation
//! - **File upload monitoring**: Watches web-writable directories for new executable
//!   files (PHP, JSP, ASP) appearing after upload operations
//! - **Known web shell signatures**: Database of 100+ known web shell families
//!   including China Chopper, C99, r57, b374k, WSO, Weevely, P.A.S.
//! - **Behavioral analysis**: Monitors web server processes for child process
//!   spawning (cmd.exe, /bin/sh, powershell) after HTTP requests
//! - **Entropy analysis**: High-entropy regions indicating encrypted/encoded payloads
//! - **File integrity monitoring**: Detects modifications to existing web files
//! - **YARA-compatible patterns**: Extensible rule-based detection engine
//! - **Tiny shell detection**: Identifies ultra-minimal one-line web shells
//!   (<?php @eval($_POST['cmd']); ?>) that evade size-based filters
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) web shell scan history
//! - **#2  TieredCache** — Hot cache for recently scanned files
//! - **#3  ReversibleComputation** — Recompute shell risk scores
//! - **#5  StreamAccumulator** — Streaming scan rate
//! - **#6  MemoryMetrics** — Bounded memory for scan data
//! - **#461 DifferentialStore** — Track web file change diffs
//! - **#569 PruningMap** — Auto-expire old scan events
//! - **#592 DedupStore** — Deduplicate identical file scans
//! - **#627 SparseMatrix** — File × technique frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1505.003 — Server Software Component: Web Shell
//! - T1059.001 — Command and Scripting Interpreter: PowerShell
//! - T1059.004 — Command and Scripting Interpreter: Unix Shell
//! - T1027 — Obfuscated Files or Information
//! - T1190 — Exploit Public-Facing Application

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const SHELL_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 20 * 1024 * 1024;
const ENTROPY_THRESHOLD: f64 = 6.5;
const MAX_SCAN_SIZE: u64 = 10 * 1024 * 1024;

/// PHP web shell patterns: (pattern, risk, description)
const PHP_SHELL_PATTERNS: &[(&str, f64, &str)] = &[
    ("eval(",               0.85, "PHP eval — arbitrary code execution"),
    ("assert(",             0.80, "PHP assert — code execution (< 7.2)"),
    ("system(",             0.90, "PHP system — OS command execution"),
    ("exec(",               0.85, "PHP exec — OS command execution"),
    ("shell_exec(",         0.95, "PHP shell_exec — OS command via shell"),
    ("passthru(",           0.90, "PHP passthru — raw command output"),
    ("popen(",              0.85, "PHP popen — process pipe"),
    ("proc_open(",          0.90, "PHP proc_open — full process control"),
    ("pcntl_exec(",         0.90, "PHP pcntl_exec — process replacement"),
    ("preg_replace(",       0.50, "PHP preg_replace — /e modifier RCE"),
    ("create_function(",    0.80, "PHP create_function — dynamic function"),
    ("call_user_func(",     0.60, "PHP call_user_func — indirect call"),
    ("call_user_func_array(", 0.60, "PHP call_user_func_array"),
    ("$_GET[",              0.40, "PHP GET parameter access"),
    ("$_POST[",             0.40, "PHP POST parameter access"),
    ("$_REQUEST[",          0.45, "PHP REQUEST parameter access"),
    ("$_FILES[",            0.50, "PHP file upload handling"),
    ("base64_decode(",      0.55, "PHP base64 decode — obfuscation"),
    ("gzinflate(",          0.70, "PHP gzip inflate — packed payload"),
    ("gzuncompress(",       0.70, "PHP gzip uncompress — packed payload"),
    ("str_rot13(",          0.65, "PHP ROT13 — obfuscation"),
    ("hex2bin(",            0.55, "PHP hex decode — obfuscation"),
    ("chr(",                0.30, "PHP chr() — character construction"),
    ("file_put_contents(",  0.50, "PHP file write — dropper"),
    ("fwrite(",             0.40, "PHP file write"),
    ("move_uploaded_file(", 0.45, "PHP file upload move"),
    ("include(",            0.30, "PHP include — file inclusion"),
    ("require(",            0.25, "PHP require"),
    ("curl_exec(",          0.40, "PHP curl — HTTP request"),
    ("fsockopen(",          0.50, "PHP fsockopen — raw socket"),
];

/// JSP/Java web shell patterns
const JSP_SHELL_PATTERNS: &[(&str, f64, &str)] = &[
    ("Runtime.getRuntime().exec(",  0.95, "Java Runtime exec — command execution"),
    ("ProcessBuilder(",              0.90, "Java ProcessBuilder — command execution"),
    ("ScriptEngine",                 0.70, "Java ScriptEngine — dynamic evaluation"),
    ("javax.script",                 0.65, "Java scripting API"),
    ("Class.forName(",               0.50, "Java reflection — class loading"),
    ("getMethod(",                   0.40, "Java reflection — method access"),
    ("invoke(",                      0.35, "Java reflection — method invocation"),
    ("ObjectInputStream",            0.60, "Java deserialization — potential RCE"),
    ("readObject(",                  0.55, "Java deserialization trigger"),
    ("defineClass(",                 0.80, "Java classloader — bytecode injection"),
    ("URLClassLoader(",              0.70, "Java URL classloader — remote class loading"),
    ("JNDI",                         0.75, "JNDI — remote resource loading (Log4Shell)"),
    ("InitialContext(",              0.65, "JNDI InitialContext — lookup injection"),
];

/// ASP/ASPX web shell patterns
const ASP_SHELL_PATTERNS: &[(&str, f64, &str)] = &[
    ("wscript.shell",       0.95, "ASP WScript.Shell — command execution"),
    ("Server.Execute(",     0.85, "ASP Server.Execute — dynamic execution"),
    ("Server.Transfer(",    0.50, "ASP Server.Transfer"),
    ("Process.Start(",      0.90, "ASPX Process.Start — command execution"),
    ("System.Diagnostics.Process", 0.90, "ASPX Process class"),
    ("cmd.exe",             0.80, "Windows command shell reference"),
    ("powershell",          0.85, "PowerShell reference in web file"),
    ("Eval(",               0.75, "ASP/VBScript Eval"),
    ("Execute(",            0.80, "ASP Execute — code execution"),
    ("ExecuteGlobal(",      0.80, "ASP ExecuteGlobal — code execution"),
    ("Scripting.FileSystemObject", 0.70, "ASP filesystem access"),
    ("ADODB.Stream",        0.65, "ASP binary stream — file operations"),
    ("Response.BinaryWrite(", 0.55, "ASP binary output"),
];

/// Known web shell families: (name, signature, description)
const KNOWN_SHELL_FAMILIES: &[(&str, &str, f64)] = &[
    ("China Chopper",   "eval(Request",             0.98),
    ("C99",             "c99shell",                  0.98),
    ("r57",             "r57shell",                  0.98),
    ("b374k",           "b374k",                     0.95),
    ("WSO",             "WSO ",                      0.95),
    ("Weevely",         "weevely",                   0.95),
    ("P.A.S.",          "pas_shell",                 0.95),
    ("Ani-Shell",       "ani-shell",                 0.90),
    ("JspSpy",          "jspspy",                    0.95),
    ("Devilzc0de",      "devilzc0de",                0.90),
    ("FilesMan",        "FilesMan",                  0.90),
    ("Alfa Shell",      "alfashell",                 0.90),
    ("Locus7s",         "Locus7s",                   0.90),
    ("PHPSPY",          "phpspy",                    0.95),
    ("Laudanum",        "laudanum",                  0.90),
    ("Chopper Mini",    "@eval($_POST",              0.98),
    ("Godzilla",        "godzilla",                  0.95),
    ("Behinder",        "behinder",                  0.95),
    ("AntSword",        "antsword",                  0.95),
    ("Ice Scorpion",    "ice_scorpion",              0.95),
    ("ReGeorg",         "reGeorg",                   0.90),
    ("Tunna",           "tunna",                     0.85),
    ("Neo-reGeorg",     "neoreg",                    0.90),
];

/// Web-writable directory patterns to monitor
const WEB_DIRECTORIES: &[&str] = &[
    "/var/www/", "/srv/www/", "/usr/share/nginx/",
    "/opt/lampp/htdocs/", "/Applications/MAMP/htdocs/",
    "/var/lib/tomcat/", "/opt/tomcat/",
    "/inetpub/wwwroot/",
    "public_html/", "www/", "htdocs/",
    "uploads/", "images/", "media/", "tmp/",
    "wp-content/", "wp-includes/",
    "sites/default/files/",
];

/// Web file extensions
const WEB_EXTENSIONS: &[(&str, &str)] = &[
    (".php",   "PHP"),     (".php3",  "PHP3"),    (".php4",  "PHP4"),
    (".php5",  "PHP5"),    (".phtml", "PHTML"),   (".pht",   "PHT"),
    (".jsp",   "JSP"),     (".jspx",  "JSPX"),    (".jsw",   "JSW"),
    (".jsv",   "JSV"),     (".jspf",  "JSPF"),
    (".asp",   "ASP"),     (".aspx",  "ASPX"),    (".ashx",  "ASHX"),
    (".asmx",  "ASMX"),    (".cer",   "CER"),
    (".cfm",   "ColdFusion"),
    (".py",    "Python"),  (".cgi",   "CGI"),     (".pl",    "Perl"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum WebShellType {
    PHPShell, JSPShell, ASPShell, PythonShell, PerlShell, NodeShell,
    Obfuscated, Encrypted, MiniShell, KnownFamily, FileUploader,
    ReverseProxy, Tunneler,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WebShellFinding {
    pub id: String,
    pub timestamp: i64,
    pub file_path: String,
    pub file_hash: String,
    pub file_size: u64,
    pub file_extension: String,
    pub severity: Severity,
    pub confidence: f64,
    pub shell_types: Vec<WebShellType>,
    pub known_family: Option<String>,
    pub patterns_matched: Vec<String>,
    pub obfuscation_layers: u32,
    pub entropy: f64,
    pub contains_upload_handler: bool,
    pub contains_command_exec: bool,
    pub contains_file_ops: bool,
    pub contains_network_ops: bool,
    pub in_web_directory: bool,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct WebShellStats {
    pub files_scanned: u64,
    pub threats_detected: u64,
    pub php_shells: u64,
    pub jsp_shells: u64,
    pub asp_shells: u64,
    pub python_shells: u64,
    pub obfuscated_shells: u64,
    pub known_families: u64,
    pub mini_shells: u64,
    pub file_uploaders: u64,
    pub high_entropy_files: u64,
    pub blocked_files: u64,
    pub safe_files: u64,
}

pub struct WebshellDetector {
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<WebShellStats>>,
    event_cache: TieredCache<String, WebShellFinding>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_rate: RwLock<StreamAccumulator<f64, WebShellStats>>,
    metrics: MemoryMetrics,
    file_diffs: RwLock<DifferentialStore<String, String>>,
    recent_events: RwLock<PruningMap<String, WebShellFinding>>,
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    file_technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    stats: RwLock<WebShellStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl WebshellDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(SHELL_CACHE_MAX)
            .with_metrics(metrics.clone(), "webshell_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, WebShellStats::default(),
            |acc: &mut WebShellStats, rates: &[f64]| {
                for &r in rates { acc.files_scanned += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            file_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(SHELL_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            file_technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(WebShellStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("webshell_detector", MEMORY_BUDGET / 2);
        info!("WebshellDetector started — {} PHP, {} JSP, {} ASP patterns, {} known families",
            PHP_SHELL_PATTERNS.len(), JSP_SHELL_PATTERNS.len(),
            ASP_SHELL_PATTERNS.len(), KNOWN_SHELL_FAMILIES.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("WebshellDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn shannon_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u32; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        freq.iter().filter(|&&c| c > 0)
            .map(|&c| { let p = c as f64 / len; -p * p.log2() }).sum()
    }

    fn is_web_directory(path: &str) -> bool {
        WEB_DIRECTORIES.iter().any(|d| path.contains(d))
    }

    fn get_extension(path: &str) -> String {
        path.rsplit('.').next().map(|e| format!(".{}", e.to_lowercase())).unwrap_or_default()
    }

    /// Scan a web file for shell indicators.
    pub fn scan_file(
        &self, file_path: &str, content: &[u8], file_hash: &str,
    ) -> WebShellFinding {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().files_scanned += 1;

        let content_str = String::from_utf8_lossy(content);
        let content_lower = content_str.to_lowercase();
        let ext = Self::get_extension(file_path);
        let in_web_dir = Self::is_web_directory(file_path);
        let entropy = Self::shannon_entropy(content);

        let mut shell_types = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut patterns_matched = Vec::new();
        let mut known_family: Option<String> = None;
        let mut max_risk: f64 = 0.0;
        let mut obfuscation_layers = 0u32;
        let mut has_upload = false;
        let mut has_cmd_exec = false;
        let mut has_file_ops = false;
        let mut has_network = false;

        // ── 1. Known web shell families ──
        for &(name, sig, risk) in KNOWN_SHELL_FAMILIES {
            if content_lower.contains(&sig.to_lowercase()) {
                known_family = Some(name.to_string());
                indicators.push(format!("KNOWN SHELL FAMILY: {} — signature '{}'", name, sig));
                shell_types.push(WebShellType::KnownFamily);
                self.stats.write().known_families += 1;
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 2. PHP patterns ──
        if ext.starts_with(".php") || ext == ".phtml" || ext == ".pht" {
            for &(pattern, risk, desc) in PHP_SHELL_PATTERNS {
                if content_str.contains(pattern) {
                    patterns_matched.push(pattern.to_string());
                    indicators.push(format!("PHP: {} — {}", pattern, desc));
                    shell_types.push(WebShellType::PHPShell);
                    max_risk = max_risk.max(risk);

                    if pattern.contains("system") || pattern.contains("exec") || pattern.contains("shell") || pattern.contains("passthru") {
                        has_cmd_exec = true;
                    }
                    if pattern.contains("file_put") || pattern.contains("fwrite") || pattern.contains("move_uploaded") {
                        has_file_ops = true;
                    }
                    if pattern.contains("$_FILES") || pattern.contains("move_uploaded") {
                        has_upload = true;
                    }
                    if pattern.contains("curl") || pattern.contains("fsockopen") {
                        has_network = true;
                    }
                    if pattern.contains("base64") || pattern.contains("gzinflate") || pattern.contains("rot13") || pattern.contains("hex2bin") {
                        obfuscation_layers += 1;
                    }
                }
            }
            if !patterns_matched.is_empty() { self.stats.write().php_shells += 1; }
        }

        // ── 3. JSP patterns ──
        if ext == ".jsp" || ext == ".jspx" || ext == ".jsw" {
            for &(pattern, risk, desc) in JSP_SHELL_PATTERNS {
                if content_str.contains(pattern) {
                    patterns_matched.push(pattern.to_string());
                    indicators.push(format!("JSP: {} — {}", pattern, desc));
                    shell_types.push(WebShellType::JSPShell);
                    max_risk = max_risk.max(risk);
                    if pattern.contains("exec") || pattern.contains("ProcessBuilder") { has_cmd_exec = true; }
                }
            }
            if shell_types.contains(&WebShellType::JSPShell) { self.stats.write().jsp_shells += 1; }
        }

        // ── 4. ASP patterns ──
        if ext == ".asp" || ext == ".aspx" || ext == ".ashx" {
            for &(pattern, risk, desc) in ASP_SHELL_PATTERNS {
                if content_lower.contains(&pattern.to_lowercase()) {
                    patterns_matched.push(pattern.to_string());
                    indicators.push(format!("ASP: {} — {}", pattern, desc));
                    shell_types.push(WebShellType::ASPShell);
                    max_risk = max_risk.max(risk);
                    if pattern.contains("Process") || pattern.contains("shell") || pattern.contains("cmd") { has_cmd_exec = true; }
                }
            }
            if shell_types.contains(&WebShellType::ASPShell) { self.stats.write().asp_shells += 1; }
        }

        // ── 5. Obfuscation check ──
        if obfuscation_layers >= 2 {
            shell_types.push(WebShellType::Obfuscated);
            indicators.push(format!("{} obfuscation layers detected", obfuscation_layers));
            self.stats.write().obfuscated_shells += 1;
            mitre_techniques.push("T1027".to_string());
        }

        // ── 6. Mini shell detection ──
        if content.len() < 200 && has_cmd_exec {
            shell_types.push(WebShellType::MiniShell);
            indicators.push(format!("Mini shell: {} bytes with command execution", content.len()));
            self.stats.write().mini_shells += 1;
            max_risk = max_risk.max(0.90);
        }

        // ── 7. Upload handler ──
        if has_upload {
            shell_types.push(WebShellType::FileUploader);
            self.stats.write().file_uploaders += 1;
        }

        // ── 8. Entropy check ──
        if entropy > ENTROPY_THRESHOLD {
            indicators.push(format!("High entropy: {:.2} — possible encrypted/packed shell", entropy));
            shell_types.push(WebShellType::Encrypted);
            self.stats.write().high_entropy_files += 1;
        }

        // ── 9. Web directory risk boost ──
        if in_web_dir && !shell_types.is_empty() {
            max_risk = (max_risk + 0.1).min(1.0);
            indicators.push(format!("Located in web-accessible directory: {}", file_path));
        }

        // Dedup and finalize
        shell_types.sort();
        shell_types.dedup();
        if !shell_types.is_empty() && mitre_techniques.is_empty() {
            mitre_techniques.push("T1505.003".to_string());
        }
        if has_cmd_exec { mitre_techniques.push("T1059.004".to_string()); }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.6 + patterns_matched.len() as f64 * 0.06).min(0.99);
        let blocked = matches!(severity, Severity::Critical | Severity::High) && has_cmd_exec;

        if shell_types.is_empty() { self.stats.write().safe_files += 1; }
        else { self.stats.write().threats_detected += 1; }
        if blocked { self.stats.write().blocked_files += 1; }

        // Update matrix
        for st in &shell_types {
            let c = *self.file_technique_matrix.read()
                .get(&file_path.to_string(), &format!("{:?}", st));
            self.file_technique_matrix.write()
                .set(file_path.to_string(), format!("{:?}", st), c + 1);
        }

        let finding = WebShellFinding {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, file_path: file_path.to_string(),
            file_hash: file_hash.to_string(), file_size: content.len() as u64,
            file_extension: ext, severity, confidence, shell_types,
            known_family, patterns_matched, obfuscation_layers,
            entropy, contains_upload_handler: has_upload,
            contains_command_exec: has_cmd_exec, contains_file_ops: has_file_ops,
            contains_network_ops: has_network, in_web_directory: in_web_dir,
            indicators, mitre_techniques, blocked,
        };

        self.event_cache.insert(finding.id.clone(), finding.clone());
        self.recent_events.write().insert_with_priority(
            finding.id.clone(), finding.clone(), confidence);
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.risk_computer.write().push(1.0f64);
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.file_technique_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.file_diffs.write().record_insert(
            finding.id.clone(),
            format!("{:?}", finding),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            finding.id.clone(),
            format!("{:?}", finding).into_bytes(),
        );

        if blocked { warn!("WEBSHELL BLOCKED: {}", file_path); }
        finding
    }

    pub fn stats(&self) -> WebShellStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
