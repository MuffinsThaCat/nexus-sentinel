//! Module 70: PPCMonitor — Privacy Preferences (TCC) Database Monitor
//!
//! World-class monitoring engine for the macOS Transparency, Consent, and Control
//! (TCC) framework. Detects unauthorized access grants, TCC database tampering,
//! synthetic click attacks, and privacy bypass techniques used by spyware and
//! adware to gain camera, microphone, screen recording, and accessibility access.
//!
//! ## Features
//!
//! - **TCC database monitoring**: Watches /Library/Application Support/com.apple.TCC/TCC.db
//!   and ~/Library/Application Support/com.apple.TCC/TCC.db for unauthorized modifications
//! - **Access grant validation**: Verifies TCC grants match expected approval workflows
//!   (user consent, MDM profile, or system policy)
//! - **Synthetic click detection**: Detects CGEvent-based synthetic UI clicks designed
//!   to auto-approve TCC prompts without genuine user interaction
//! - **FDA (Full Disk Access) monitoring**: Tracks grants of kTCCServiceSystemPolicyAllFiles
//!   which provide unrestricted filesystem access
//! - **Camera/Microphone access tracking**: Monitors kTCCServiceCamera and
//!   kTCCServiceMicrophone for unexpected grants to non-media applications
//! - **Screen recording grants**: Watches kTCCServiceScreenCapture for spyware indicators
//! - **Accessibility API abuse**: Detects kTCCServiceAccessibility grants that enable
//!   keystroke injection, UI automation, and process manipulation
//! - **Input monitoring**: Tracks kTCCServiceListenEvent for keylogger detection
//! - **Automation grants**: Monitors AppleEvents/Automation TCC entries for
//!   cross-application scripting abuse
//! - **TCC bypass detection**: Identifies known TCC bypass techniques including
//!   mounted DMG exploitation, bundle ID spoofing, and SQL injection in TCC.db
//! - **MDM profile correlation**: Validates TCC entries granted via MDM PPPC profiles
//! - **Historical grant analysis**: Maintains timeline of TCC changes for forensic review
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) TCC grant history with rollback
//! - **#2  TieredCache** — Hot/warm/cold cache for TCC event data
//! - **#3  ReversibleComputation** — Recompute privacy risk score on changes
//! - **#5  StreamAccumulator** — Streaming TCC modification rate
//! - **#6  MemoryMetrics** — Bounded memory for all TCC monitoring data
//! - **#461 DifferentialStore** — Track TCC database diffs between scans
//! - **#569 PruningMap** — Auto-expire old TCC events beyond retention
//! - **#592 DedupStore** — Deduplicate identical TCC grant events
//! - **#627 SparseMatrix** — App × service permission matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1548 — Abuse Elevation Control Mechanism
//! - T1548.004 — TCC Manipulation
//! - T1056.001 — Input Capture: Keylogging (via Accessibility)
//! - T1113 — Screen Capture (via ScreenCapture TCC)
//! - T1123 — Audio Capture (via Microphone TCC)
//! - T1125 — Video Capture (via Camera TCC)
//! - T1557 — Adversary-in-the-Middle (via FDA)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Tunables ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const TCC_CACHE_MAX: usize = 8_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 16 * 1024 * 1024;
/// Maximum TCC grants per minute before bulk-grant alert
const BULK_GRANT_THRESHOLD: u64 = 10;
/// Maximum tracked applications
const MAX_TRACKED_APPS: usize = 2048;

// ── TCC Database Paths ──────────────────────────────────────────────────────

/// System-level TCC database (requires FDA/root to read)
const SYSTEM_TCC_DB: &str = "/Library/Application Support/com.apple.TCC/TCC.db";
/// User-level TCC database path template (replace ~ with home dir)
const USER_TCC_DB_SUFFIX: &str = "Library/Application Support/com.apple.TCC/TCC.db";

// ── TCC Service Constants ───────────────────────────────────────────────────

/// TCC services with privacy risk weight and MITRE technique
const TCC_SERVICES: &[(&str, &str, f64, &str)] = &[
    // Critical privacy services
    ("kTCCServiceSystemPolicyAllFiles",   "Full Disk Access",       1.0, "T1557"),
    ("kTCCServiceAccessibility",          "Accessibility",          0.9, "T1056.001"),
    ("kTCCServiceScreenCapture",          "Screen Recording",       0.9, "T1113"),
    ("kTCCServiceCamera",                 "Camera",                 0.8, "T1125"),
    ("kTCCServiceMicrophone",             "Microphone",             0.8, "T1123"),
    ("kTCCServiceListenEvent",            "Input Monitoring",       0.9, "T1056.001"),
    ("kTCCServicePostEvent",              "Input Injection",        0.9, "T1056.001"),
    // High-risk services
    ("kTCCServiceSystemPolicySysAdminFiles", "Admin File Access",   0.7, "T1548"),
    ("kTCCServiceSystemPolicyDesktopFolder", "Desktop Access",      0.5, "T1005"),
    ("kTCCServiceSystemPolicyDocumentsFolder","Documents Access",   0.5, "T1005"),
    ("kTCCServiceSystemPolicyDownloadsFolder","Downloads Access",   0.4, "T1005"),
    ("kTCCServiceSystemPolicyNetworkVolumes","Network Volumes",     0.6, "T1005"),
    ("kTCCServiceSystemPolicyRemovableVolumes","Removable Volumes", 0.5, "T1005"),
    // Automation services
    ("kTCCServiceAppleEvents",            "AppleEvents/Automation", 0.6, "T1059.002"),
    ("kTCCServiceEndpointSecurityClient", "ES Client",             0.8, "T1562.001"),
    // Location services
    ("kTCCServiceLocation",               "Location",              0.4, "T1614"),
    ("kTCCServiceAddressBook",            "Contacts",              0.5, "T1005"),
    ("kTCCServiceCalendar",               "Calendar",              0.4, "T1005"),
    ("kTCCServiceReminders",              "Reminders",             0.3, "T1005"),
    ("kTCCServicePhotos",                 "Photos Library",        0.5, "T1005"),
    ("kTCCServiceMediaLibrary",           "Media Library",         0.4, "T1005"),
    ("kTCCServiceBluetoothAlways",        "Bluetooth",             0.4, "T1011"),
];

/// Known TCC bypass techniques with description
const TCC_BYPASS_TECHNIQUES: &[(&str, &str)] = &[
    ("mounted_dmg",    "TCC.db accessed from mounted DMG to bypass SIP protection"),
    ("sql_injection",  "SQL injection in TCC.db — CVE-2020-9934 style"),
    ("bundle_spoof",   "Bundle identifier spoofing to inherit TCC grants"),
    ("symlink_race",   "Symlink race condition to redirect TCC checks"),
    ("plugin_inject",  "Loading plugin into TCC-granted app to inherit permissions"),
    ("fda_bootstrap",  "Using FDA to grant additional TCC permissions"),
    ("ssh_tcc_copy",   "Remote copy of TCC.db via SSH/FDA"),
    ("direct_db_write","Direct SQLite write to TCC.db (requires SIP disable or FDA)"),
    ("automation_chain","Chaining Automation grants to control TCC-privileged apps"),
    ("synthetic_click","CGEvent synthetic click to approve TCC dialog"),
    ("env_override",   "Environment variable override to redirect TCC checks"),
    ("mdm_abuse",      "Malicious MDM profile granting TCC permissions silently"),
];

/// Applications commonly targeted for TCC inheritance via plugin injection
const PLUGIN_INJECTION_TARGETS: &[&str] = &[
    "com.apple.Terminal",
    "com.apple.Safari",
    "com.apple.finder",
    "com.apple.systempreferences",
    "com.apple.dt.Xcode",
    "com.microsoft.VSCode",
    "com.googlecode.iterm2",
];

/// Suspicious application patterns that should not have sensitive TCC grants
const SUSPICIOUS_APP_PATTERNS: &[&str] = &[
    "com.unknown.", "temp.", "test.", ".debug",
    "payload", "agent", "beacon", "inject",
    "backdoor", "reverse", "shell", "exploit",
    "rat.", "keylog", "capture", "monitor",
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TCCEventType {
    /// New TCC permission granted
    PermissionGranted,
    /// TCC permission revoked
    PermissionRevoked,
    /// TCC database directly modified (bypass)
    DatabaseModified,
    /// Synthetic click detected on TCC dialog
    SyntheticClick,
    /// Bulk grant pattern detected
    BulkGrant,
    /// TCC bypass technique detected
    BypassDetected,
    /// Plugin injection into TCC-granted app
    PluginInjection,
    /// MDM profile TCC grant
    MDMGrant,
    /// TCC database integrity check
    IntegrityCheck,
    /// Automation chain escalation
    AutomationChain,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TCCAuthReason {
    /// User clicked Allow in TCC prompt
    UserConsent,
    /// Granted via MDM PPPC profile
    MDMProfile,
    /// System policy (Apple system app)
    SystemPolicy,
    /// Unknown or no reason recorded
    Unknown,
    /// Direct database manipulation (bypass)
    DirectWrite,
    /// Synthetic click automation
    SyntheticEvent,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TCCAccessLevel {
    /// Permission denied
    Denied,
    /// Permission allowed
    Allowed,
    /// Limited (time-bound or scope-limited)
    Limited,
    /// Permission not determined yet
    NotDetermined,
}

// ── TCC Grant Record ────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCGrantRecord {
    pub service: String,
    pub service_display: String,
    pub client_bundle_id: String,
    pub client_path: String,
    pub access_level: TCCAccessLevel,
    pub auth_reason: TCCAuthReason,
    pub risk_weight: f64,
    pub granted_at: i64,
    pub last_used: i64,
    pub code_signed: bool,
    pub signer: String,
    pub is_system_app: bool,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TCCEvent {
    pub id: String,
    pub timestamp: i64,
    pub event_type: TCCEventType,
    pub severity: Severity,
    pub confidence: f64,
    pub service: String,
    pub service_display: String,
    pub client_bundle_id: String,
    pub client_path: String,
    pub access_level: TCCAccessLevel,
    pub auth_reason: TCCAuthReason,
    pub risk_weight: f64,
    pub process_name: String,
    pub process_pid: u32,
    pub user_id: u32,
    pub code_signed: bool,
    pub signer: String,
    pub bypass_technique: Option<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TCCStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub grants_observed: u64,
    pub revocations_observed: u64,
    pub database_modifications: u64,
    pub synthetic_clicks: u64,
    pub bulk_grants: u64,
    pub bypass_attempts: u64,
    pub plugin_injections: u64,
    pub mdm_grants: u64,
    pub automation_chains: u64,
    pub unsigned_grants: u64,
    pub fda_grants: u64,
    pub camera_grants: u64,
    pub mic_grants: u64,
    pub screen_grants: u64,
    pub accessibility_grants: u64,
    pub input_monitor_grants: u64,
    pub privacy_risk_score: f64,
    pub service_counts: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// PPCMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct PPCMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical TCC history ──
    monitor_history: RwLock<HierarchicalState<TCCStats>>,
    // ── Breakthrough #2: Tiered TCC event cache ──
    event_cache: TieredCache<String, TCCEvent>,
    // ── Breakthrough #3: Reversible privacy risk score ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming TCC modification rate ──
    event_rate: RwLock<StreamAccumulator<f64, TCCStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: TCC database diffs between scans ──
    tcc_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old TCC events ──
    recent_events: RwLock<PruningMap<String, TCCEvent>>,
    // ── Breakthrough #592: Deduplicate identical TCC grant events ──
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: App × service permission matrix ──
    app_service_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Current TCC grant database snapshot
    grant_database: RwLock<HashMap<String, TCCGrantRecord>>,
    /// Per-minute grant counter for bulk grant detection
    grant_rate: RwLock<VecDeque<i64>>,
    stats: RwLock<TCCStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl PPCMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(TCC_CACHE_MAX)
            .with_metrics(metrics.clone(), "tcc_events");
        let risk_computer = ReversibleComputation::new(512,
            |scores: &[f64]| if scores.is_empty() { 0.0 }
            else { scores.iter().sum::<f64>() / scores.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, TCCStats::default(),
            |acc: &mut TCCStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(
                HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache,
            risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate),
            metrics,
            tcc_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(TCC_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            app_service_matrix: RwLock::new(SparseMatrix::new(0u64)),
            grant_database: RwLock::new(HashMap::new()),
            grant_rate: RwLock::new(VecDeque::with_capacity(256)),
            stats: RwLock::new(TCCStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("ppc_monitor", MEMORY_BUDGET / 2);
        info!(
            "PPCMonitor started — tracking {} TCC services, {} bypass techniques",
            TCC_SERVICES.len(),
            TCC_BYPASS_TECHNIQUES.len()
        );
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        let grants = self.grant_database.read().len();
        info!("PPCMonitor stopped — {} TCC grants tracked", grants);
    }

    pub fn is_running(&self) -> bool {
        self.running.load(Ordering::SeqCst)
    }

    // ── Service Classification ──────────────────────────────────────────────

    fn get_service_info(service: &str) -> Option<(&'static str, f64, &'static str)> {
        TCC_SERVICES.iter()
            .find(|(s, _, _, _)| *s == service)
            .map(|(_, display, weight, technique)| (*display, *weight, *technique))
    }

    fn is_suspicious_app(bundle_id: &str) -> bool {
        let lower = bundle_id.to_lowercase();
        SUSPICIOUS_APP_PATTERNS.iter().any(|p| lower.contains(p))
    }

    fn is_plugin_injection_target(bundle_id: &str) -> bool {
        PLUGIN_INJECTION_TARGETS.contains(&bundle_id)
    }

    // ── Bulk Grant Detection ────────────────────────────────────────────────

    fn check_bulk_grant(&self, now: i64) -> bool {
        let mut rate = self.grant_rate.write();
        rate.push_back(now);
        // Remove entries older than 60 seconds
        while rate.front().map_or(false, |&t| now - t > 60) {
            rate.pop_front();
        }
        rate.len() as u64 > BULK_GRANT_THRESHOLD
    }

    // ── Primary Analysis: TCC Grant Event ───────────────────────────────────

    /// Analyze a TCC permission change event.
    pub fn analyze_tcc_event(
        &self,
        service: &str,
        client_bundle_id: &str,
        client_path: &str,
        access_level: TCCAccessLevel,
        auth_reason: TCCAuthReason,
        process_name: &str,
        pid: u32,
        uid: u32,
        code_signed: bool,
        signer: &str,
    ) -> Option<TCCEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let (service_display, risk_weight, base_technique) =
            Self::get_service_info(service)
                .unwrap_or(("Unknown Service", 0.3, "T1548"));

        let mut indicators = Vec::new();
        let mut mitre_techniques = vec![base_technique.to_string()];
        let mut event_type = if access_level == TCCAccessLevel::Allowed {
            TCCEventType::PermissionGranted
        } else {
            TCCEventType::PermissionRevoked
        };
        let mut bypass_technique = None;

        // Only analyze grants for threats (revocations are fine)
        if access_level != TCCAccessLevel::Allowed {
            self.stats.write().revocations_observed += 1;
            return None;
        }

        self.stats.write().grants_observed += 1;

        // ── 1. Track per-service grant stats ──
        match service {
            "kTCCServiceSystemPolicyAllFiles" => self.stats.write().fda_grants += 1,
            "kTCCServiceCamera" => self.stats.write().camera_grants += 1,
            "kTCCServiceMicrophone" => self.stats.write().mic_grants += 1,
            "kTCCServiceScreenCapture" => self.stats.write().screen_grants += 1,
            "kTCCServiceAccessibility" => self.stats.write().accessibility_grants += 1,
            "kTCCServiceListenEvent" => self.stats.write().input_monitor_grants += 1,
            _ => {}
        }
        *self.stats.write().service_counts
            .entry(service_display.to_string()).or_insert(0) += 1;

        // ── 2. Auth reason validation ──
        match auth_reason {
            TCCAuthReason::DirectWrite => {
                indicators.push(format!(
                    "TCC grant via DIRECT DB WRITE: '{}' granted {} to '{}'",
                    service_display, "Allow", client_bundle_id));
                mitre_techniques.push("T1548.004".to_string());
                bypass_technique = Some("direct_db_write".to_string());
                event_type = TCCEventType::BypassDetected;
                self.stats.write().bypass_attempts += 1;
            }
            TCCAuthReason::SyntheticEvent => {
                indicators.push(format!(
                    "TCC grant via SYNTHETIC CLICK: '{}' for '{}'",
                    service_display, client_bundle_id));
                mitre_techniques.push("T1548.004".to_string());
                bypass_technique = Some("synthetic_click".to_string());
                event_type = TCCEventType::SyntheticClick;
                self.stats.write().synthetic_clicks += 1;
            }
            TCCAuthReason::MDMProfile => {
                indicators.push(format!(
                    "TCC grant via MDM profile: '{}' for '{}'",
                    service_display, client_bundle_id));
                event_type = TCCEventType::MDMGrant;
                self.stats.write().mdm_grants += 1;
            }
            TCCAuthReason::Unknown => {
                indicators.push(format!(
                    "TCC grant with UNKNOWN auth reason: '{}' for '{}'",
                    service_display, client_bundle_id));
            }
            _ => {}
        }

        // ── 3. Suspicious application check ──
        if Self::is_suspicious_app(client_bundle_id) {
            indicators.push(format!(
                "Suspicious app '{}' granted '{}' access",
                client_bundle_id, service_display));
            mitre_techniques.push("T1548.004".to_string());
        }

        // ── 4. Unsigned application with sensitive grant ──
        if !code_signed && risk_weight >= 0.7 {
            indicators.push(format!(
                "UNSIGNED app '{}' granted sensitive '{}' access",
                client_bundle_id, service_display));
            self.stats.write().unsigned_grants += 1;
        }

        // ── 5. Bulk grant detection ──
        if self.check_bulk_grant(now) {
            indicators.push(format!(
                "Bulk TCC grant pattern: >{}  grants in 60 seconds",
                BULK_GRANT_THRESHOLD));
            event_type = TCCEventType::BulkGrant;
            self.stats.write().bulk_grants += 1;
        }

        // ── 6. High-risk service grants to non-system apps ──
        let is_system = client_bundle_id.starts_with("com.apple.");
        if risk_weight >= 0.8 && !is_system {
            indicators.push(format!(
                "High-risk TCC service '{}' (weight {:.1}) granted to non-Apple app '{}'",
                service_display, risk_weight, client_bundle_id));
        }

        // ── 7. Plugin injection target check ──
        if Self::is_plugin_injection_target(client_bundle_id)
            && (service == "kTCCServiceAccessibility"
                || service == "kTCCServiceSystemPolicyAllFiles")
        {
            indicators.push(format!(
                "Plugin injection target '{}' granted '{}' — may be used as TCC proxy",
                client_bundle_id, service_display));
            self.stats.write().plugin_injections += 1;
        }

        // ── 8. Update grant database ──
        let grant_key = format!("{}:{}", client_bundle_id, service);
        self.grant_database.write().insert(grant_key.clone(), TCCGrantRecord {
            service: service.to_string(),
            service_display: service_display.to_string(),
            client_bundle_id: client_bundle_id.to_string(),
            client_path: client_path.to_string(),
            access_level, auth_reason, risk_weight,
            granted_at: now, last_used: now,
            code_signed, signer: signer.to_string(),
            is_system_app: is_system,
        });

        if indicators.is_empty() { return None; }

        // ── Severity & confidence ──
        let severity = match event_type {
            TCCEventType::BypassDetected => Severity::Critical,
            TCCEventType::SyntheticClick => Severity::Critical,
            TCCEventType::BulkGrant => Severity::Critical,
            _ if risk_weight >= 0.9 && !is_system => Severity::Critical,
            _ if risk_weight >= 0.7 && !code_signed => Severity::Critical,
            _ if risk_weight >= 0.7 => Severity::High,
            _ => Severity::Medium,
        };

        let confidence = match event_type {
            TCCEventType::BypassDetected => 0.96,
            TCCEventType::SyntheticClick => 0.93,
            TCCEventType::BulkGrant => 0.88,
            _ if !code_signed => 0.85,
            _ => (0.5 + indicators.len() as f64 * 0.1).min(0.92),
        };

        let event = TCCEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, event_type, severity, confidence,
            service: service.to_string(),
            service_display: service_display.to_string(),
            client_bundle_id: client_bundle_id.to_string(),
            client_path: client_path.to_string(),
            access_level, auth_reason, risk_weight,
            process_name: process_name.to_string(),
            process_pid: pid, user_id: uid,
            code_signed, signer: signer.to_string(),
            bypass_technique,
            indicators, mitre_techniques,
            blocked: matches!(severity, Severity::Critical),
        };

        // ── Update stores ──
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(
            event.id.clone(), event.clone(), confidence);
        self.tcc_diffs.write().record_insert(
            event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());

        let app = client_bundle_id.to_string();
        let svc = service_display.to_string();
        let current = *self.app_service_matrix.read().get(&app, &svc);
        self.app_service_matrix.write().set(app, svc, current + 1);

        self.stats.write().threats_detected += 1;
        self.stats.write().privacy_risk_score =
            (self.stats.read().privacy_risk_score + risk_weight * confidence).min(100.0);
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.tcc_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(risk_weight);

        warn!("TCC: {:?} '{}' → '{}' by {} (pid {})",
            event_type, service_display, client_bundle_id, process_name, pid);
        Some(event)
    }

    // ── TCC Bypass Detection ────────────────────────────────────────────────

    /// Detect a specific TCC bypass technique.
    pub fn report_bypass(
        &self,
        technique_id: &str,
        details: &str,
        process_name: &str,
        pid: u32,
    ) -> Option<TCCEvent> {
        let now = chrono::Utc::now().timestamp();

        let technique_desc = TCC_BYPASS_TECHNIQUES.iter()
            .find(|(id, _)| *id == technique_id)
            .map(|(_, desc)| *desc)
            .unwrap_or("Unknown bypass technique");

        let mut indicators = vec![
            format!("TCC bypass: {} — {}", technique_id, technique_desc),
            format!("Details: {}", details),
        ];
        let mitre_techniques = vec!["T1548.004".to_string()];

        let event = TCCEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            event_type: TCCEventType::BypassDetected,
            severity: Severity::Critical,
            confidence: 0.95,
            service: "N/A".to_string(),
            service_display: "TCC Bypass".to_string(),
            client_bundle_id: String::new(),
            client_path: String::new(),
            access_level: TCCAccessLevel::NotDetermined,
            auth_reason: TCCAuthReason::Unknown,
            risk_weight: 1.0,
            process_name: process_name.to_string(),
            process_pid: pid, user_id: 0,
            code_signed: false, signer: String::new(),
            bypass_technique: Some(technique_id.to_string()),
            indicators, mitre_techniques,
            blocked: true,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.stats.write().bypass_attempts += 1;
        self.stats.write().threats_detected += 1;

        warn!("TCC BYPASS: {} by {} (pid {})", technique_id, process_name, pid);
        Some(event)
    }

    // ── Database Integrity ──────────────────────────────────────────────────

    /// Report a direct TCC database modification.
    pub fn report_db_modification(
        &self,
        db_path: &str,
        process_name: &str,
        pid: u32,
        uid: u32,
    ) -> Option<TCCEvent> {
        let now = chrono::Utc::now().timestamp();

        let indicators = vec![
            format!("Direct TCC.db modification: {} by {} (pid {}, uid {})",
                db_path, process_name, pid, uid),
            format!("TCC database path: {}", db_path),
        ];

        let event = TCCEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            event_type: TCCEventType::DatabaseModified,
            severity: Severity::Critical,
            confidence: 0.97,
            service: "TCC.db".to_string(),
            service_display: "TCC Database".to_string(),
            client_bundle_id: process_name.to_string(),
            client_path: db_path.to_string(),
            access_level: TCCAccessLevel::NotDetermined,
            auth_reason: TCCAuthReason::DirectWrite,
            risk_weight: 1.0,
            process_name: process_name.to_string(),
            process_pid: pid, user_id: uid,
            code_signed: false, signer: String::new(),
            bypass_technique: Some("direct_db_write".to_string()),
            indicators,
            mitre_techniques: vec!["T1548.004".to_string()],
            blocked: true,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.stats.write().database_modifications += 1;
        self.stats.write().threats_detected += 1;

        warn!("TCC.db MODIFIED: {} by {} (pid {})", db_path, process_name, pid);
        Some(event)
    }

    // ── Accessors ───────────────────────────────────────────────────────────

    pub fn stats(&self) -> TCCStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn grant_count(&self) -> usize { self.grant_database.read().len() }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }

    /// Get all grants for a specific application.
    pub fn grants_for_app(&self, bundle_id: &str) -> Vec<TCCGrantRecord> {
        self.grant_database.read().values()
            .filter(|g| g.client_bundle_id == bundle_id)
            .cloned()
            .collect()
    }

    /// Get all applications with a specific TCC service grant.
    pub fn apps_with_service(&self, service: &str) -> Vec<TCCGrantRecord> {
        self.grant_database.read().values()
            .filter(|g| g.service == service)
            .cloned()
            .collect()
    }
}
