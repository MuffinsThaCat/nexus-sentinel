//! Module 164: FilelessMalwareDetector — In-Memory & Script-Based Threat Detection
//!
//! Detects malware that operates entirely in memory without writing persistent
//! files to disk, including script-based attacks, reflective injection, living-
//! off-the-land binary abuse, and memory-only implants on macOS.
//!
//! ## Detection Capabilities
//!
//! ### In-Memory Execution
//! - **Reflective dylib injection**: Dylibs loaded directly from memory
//!   without touching the filesystem
//! - **Memory-only shellcode**: Shellcode executed in allocated memory
//!   regions without file backing
//! - **JIT compilation abuse**: Exploiting JIT engines (JavaScriptCore,
//!   WebKit) to execute arbitrary code in memory
//! - **Process memory manipulation**: Code injected into existing process
//!   memory via Mach APIs
//! - **Anonymous memory execution**: Executable code in anonymous (non-
//!   file-backed) memory regions
//!
//! ### Script-Based Attacks
//! - **osascript/AppleScript abuse**: Malicious AppleScript execution for
//!   system manipulation, data theft, and persistence
//! - **Python/Ruby/Perl one-liners**: Interpreted language one-liner
//!   payloads that avoid file creation
//! - **JavaScript execution**: JXA (JavaScript for Automation) abuse and
//!   WebKit-based script execution
//! - **Shell script chains**: Complex bash/zsh command chains that
//!   download, decode, and execute payloads in memory
//! - **PowerShell-equivalent**: osascript and automation framework abuse
//!   equivalent to Windows PowerShell attacks
//!
//! ### Living-off-the-Land (LOLBins)
//! - **curl/wget pipe execution**: Downloading and piping to interpreters
//! - **base64 decode chains**: base64 -D | sh patterns
//! - **openssl encryption**: Using openssl for C2 encryption
//! - **sqlite3 abuse**: Database queries for credential theft
//! - **ditto/tar staging**: Archive tools for data staging
//! - **networksetup abuse**: Network configuration manipulation
//! - **security command abuse**: Keychain manipulation
//! - **launchctl abuse**: Service manipulation for persistence
//!
//! ### Memory Forensic Indicators
//! - **Unbacked executable pages**: Memory pages with execute permission
//!   that don't correspond to any file on disk
//! - **Modified code pages**: Code pages that differ from their on-disk
//!   backing (indicating runtime modification)
//! - **Suspicious memory patterns**: Known shellcode patterns, C2 configs,
//!   or implant signatures in process memory
//! - **Thread injection artifacts**: Threads whose entry points are in
//!   non-image memory regions
//!
//! ## MITRE ATT&CK: T1059, T1620, T1055, T1027.011
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

// ── In-Memory Execution Indicators ───────────────────────────────────────────

const MEMORY_EXEC_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("reflective_dylib_load", "Reflective dylib loaded from memory (no file backing)", "T1620", 0.9),
    ("anonymous_rwx_exec", "Executable code in anonymous RWX memory region", "T1055", 0.85),
    ("shellcode_in_memory", "Known shellcode pattern in process memory", "T1059", 0.9),
    ("jit_code_injection", "JIT engine abused for code execution", "T1059", 0.8),
    ("mach_vm_allocate_exec", "mach_vm_allocate with execute permission", "T1055", 0.7),
    ("mmap_anonymous_exec", "mmap MAP_ANONYMOUS with PROT_EXEC", "T1055", 0.75),
    ("unbacked_exec_page", "Executable page with no file backing", "T1055", 0.8),
    ("modified_code_page", "Code page differs from on-disk image", "T1055.012", 0.85),
    ("thread_in_anonymous", "Thread entry point in anonymous memory", "T1055", 0.85),
    ("dyld_shared_cache_patch", "dyld shared cache patched in memory", "T1055", 0.9),
    ("trampolined_function", "Function trampolined to anonymous memory", "T1055", 0.8),
    ("heap_exec_code", "Executable code found in heap memory", "T1055", 0.85),
];

// ── Script-Based Attack Indicators ───────────────────────────────────────────

const SCRIPT_ATTACK_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("osascript_hidden", "osascript executing hidden/obfuscated AppleScript", "T1059.002", 0.8),
    ("osascript_download_exec", "osascript downloading and executing payload", "T1059.002", 0.9),
    ("osascript_keychain", "osascript accessing keychain items", "T1059.002", 0.85),
    ("osascript_system_events", "osascript via System Events (UI manipulation)", "T1059.002", 0.6),
    ("jxa_execution", "JavaScript for Automation (JXA) execution", "T1059.007", 0.7),
    ("jxa_objc_bridge", "JXA using ObjC bridge for system access", "T1059.007", 0.8),
    ("python_c_exec", "Python -c with inline payload execution", "T1059.006", 0.7),
    ("python_reverse_shell", "Python reverse shell one-liner", "T1059.006", 0.9),
    ("python_import_ctypes", "Python ctypes used for native code execution", "T1059.006", 0.75),
    ("ruby_e_exec", "Ruby -e with inline payload execution", "T1059", 0.7),
    ("perl_socket_exec", "Perl socket-based reverse shell", "T1059", 0.9),
    ("bash_process_substitution", "Bash process substitution for fileless exec", "T1059.004", 0.7),
    ("zsh_eval_payload", "zsh eval with encoded payload", "T1059.004", 0.75),
    ("swift_repl_abuse", "Swift REPL used for code execution", "T1059", 0.6),
];

// ── LOLBin Abuse Indicators ──────────────────────────────────────────────────

const LOLBIN_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("curl_pipe_sh", "curl | sh (download and execute)", "T1059.004", 0.9),
    ("curl_pipe_bash", "curl | bash (download and execute)", "T1059.004", 0.9),
    ("curl_pipe_python", "curl | python (download and execute)", "T1059.006", 0.9),
    ("wget_pipe_sh", "wget -O- | sh (download and execute)", "T1059.004", 0.9),
    ("base64_decode_exec", "base64 -D | sh (decode and execute)", "T1140", 0.85),
    ("openssl_enc_exec", "openssl enc -d | sh (decrypt and execute)", "T1140", 0.85),
    ("xxd_decode_exec", "xxd -r | sh (hex decode and execute)", "T1140", 0.8),
    ("printf_decode_exec", "printf decode to execution", "T1140", 0.75),
    ("pbpaste_exec", "pbpaste | sh (clipboard to execution)", "T1059.004", 0.8),
    ("sqlite3_credential_dump", "sqlite3 querying credential databases", "T1555", 0.75),
    ("security_dump_keychain", "security dump-keychain (credential theft)", "T1555.001", 0.85),
    ("ditto_staging", "ditto used for data staging/collection", "T1074", 0.5),
    ("tar_exfil_staging", "tar creating archive for exfiltration", "T1560", 0.5),
    ("launchctl_hidden_load", "launchctl loading from hidden/temp path", "T1543.001", 0.75),
    ("networksetup_proxy", "networksetup configuring proxy (MitM)", "T1090", 0.7),
    ("screencapture_silent", "screencapture in silent mode", "T1113", 0.6),
    ("say_social_eng", "say command for audio social engineering", "T1204", 0.4),
    ("sips_image_convert", "sips for suspicious image manipulation", "T1027", 0.3),
    ("mdls_recon", "mdls for file metadata reconnaissance", "T1083", 0.3),
    ("mdfind_recon", "mdfind (Spotlight) for file discovery", "T1083", 0.4),
];

// ── Memory Forensic Indicators ───────────────────────────────────────────────

const MEMORY_FORENSIC_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("c2_config_in_memory", "C2 configuration structure found in memory", "T1071", 0.9),
    ("beacon_config_memory", "Cobalt Strike/Sliver beacon config in memory", "T1071", 0.95),
    ("implant_string_memory", "Known implant framework strings in memory", "T1059", 0.85),
    ("encrypted_payload_memory", "Encrypted payload blob in heap memory", "T1027", 0.7),
    ("xor_encoded_memory", "XOR-encoded data in executable memory", "T1027", 0.65),
    ("stack_shellcode", "Shellcode on stack (stack-based execution)", "T1055", 0.85),
    ("heap_spray_detected", "Heap spray pattern in process memory", "T1203", 0.8),
    ("rop_chain_memory", "ROP chain constructed in memory", "T1203", 0.85),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum FilelessThreatType {
    ReflectiveDylibLoad, AnonymousExec, ShellcodeInMemory,
    JITAbuse, UnbackedExecPage, ModifiedCodePage,
    ThreadInAnonymous, HeapExecCode,
    OsascriptAbuse, JXAExecution, PythonPayload,
    RubyPayload, PerlPayload, ShellChain,
    CurlPipeExec, Base64DecodeExec, OpenSSLDecrypt,
    ClipboardExec, CredentialDump, KeychainDump,
    DataStaging, ProxyManipulation, SilentCapture,
    C2ConfigInMemory, BeaconInMemory, ImplantInMemory,
    EncryptedPayloadMemory, HeapSpray, ROPChainMemory,
    LOLBinAbuse,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FilelessFinding {
    pub threat_type: FilelessThreatType,
    pub confidence: f64,
    pub description: String,
    pub indicator_rule: String,
    pub command_line: Option<String>,
    pub memory_address: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FilelessEvent {
    pub event_type: String,
    pub command_line: Option<String>,
    pub script_content: Option<String>,
    pub memory_regions: Vec<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub parent_name: Option<String>,
    pub integrity_check: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FilelessAnalysisResult {
    pub is_fileless_threat: bool,
    pub findings: Vec<FilelessFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct FilelessStats {
    pub total_events: u64,
    pub memory_exec_detections: u64,
    pub script_attack_detections: u64,
    pub lolbin_detections: u64,
    pub memory_forensic_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FilelessSigEntry { pub pattern: String, pub severity: f64 }

pub struct FilelessMalwareDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<FilelessStats>>,
    result_cache: TieredCache<String, FilelessAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    fileless_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, FilelessStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, FilelessAnalysisResult>>,
    sig_db: PagedMemory<FilelessSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<FilelessStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl FilelessMalwareDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            fileless_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, FilelessStats::default(),
                |acc: &mut FilelessStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(FilelessStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(128)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &FilelessEvent) -> Option<FilelessAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("fileless:{}:{}:{}", event.event_type, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        let ind_text = format!("{} {} {}",
            event.event_type,
            event.command_line.as_deref().unwrap_or(""),
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // 1. In-memory execution
        for &(pattern, desc, mitre, conf) in MEMORY_EXEC_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "reflective_dylib_load" => FilelessThreatType::ReflectiveDylibLoad,
                    "anonymous_rwx_exec" | "mmap_anonymous_exec" | "mach_vm_allocate_exec" =>
                        FilelessThreatType::AnonymousExec,
                    "shellcode_in_memory" => FilelessThreatType::ShellcodeInMemory,
                    "jit_code_injection" => FilelessThreatType::JITAbuse,
                    "unbacked_exec_page" => FilelessThreatType::UnbackedExecPage,
                    "modified_code_page" => FilelessThreatType::ModifiedCodePage,
                    "thread_in_anonymous" => FilelessThreatType::ThreadInAnonymous,
                    "heap_exec_code" => FilelessThreatType::HeapExecCode,
                    _ => FilelessThreatType::AnonymousExec,
                };
                findings.push(FilelessFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    indicator_rule: pattern.to_string(),
                    command_line: event.command_line.clone(), memory_address: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 2. Script attacks
        for &(pattern, desc, mitre, conf) in SCRIPT_ATTACK_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("osascript") => FilelessThreatType::OsascriptAbuse,
                    p if p.contains("jxa") => FilelessThreatType::JXAExecution,
                    p if p.contains("python") => FilelessThreatType::PythonPayload,
                    p if p.contains("ruby") => FilelessThreatType::RubyPayload,
                    p if p.contains("perl") => FilelessThreatType::PerlPayload,
                    _ => FilelessThreatType::ShellChain,
                };
                findings.push(FilelessFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    indicator_rule: pattern.to_string(),
                    command_line: event.command_line.clone(), memory_address: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 3. LOLBin abuse
        for &(pattern, desc, mitre, conf) in LOLBIN_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("curl_pipe") || p.contains("wget_pipe") => FilelessThreatType::CurlPipeExec,
                    p if p.contains("base64") => FilelessThreatType::Base64DecodeExec,
                    p if p.contains("openssl") => FilelessThreatType::OpenSSLDecrypt,
                    p if p.contains("pbpaste") => FilelessThreatType::ClipboardExec,
                    p if p.contains("sqlite3") => FilelessThreatType::CredentialDump,
                    p if p.contains("security") || p.contains("keychain") => FilelessThreatType::KeychainDump,
                    p if p.contains("ditto") || p.contains("tar") => FilelessThreatType::DataStaging,
                    p if p.contains("networksetup") || p.contains("proxy") => FilelessThreatType::ProxyManipulation,
                    p if p.contains("screencapture") => FilelessThreatType::SilentCapture,
                    _ => FilelessThreatType::LOLBinAbuse,
                };
                findings.push(FilelessFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    indicator_rule: pattern.to_string(),
                    command_line: event.command_line.clone(), memory_address: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 4. Memory forensic indicators
        for &(pattern, desc, mitre, conf) in MEMORY_FORENSIC_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "c2_config_in_memory" => FilelessThreatType::C2ConfigInMemory,
                    "beacon_config_memory" => FilelessThreatType::BeaconInMemory,
                    "implant_string_memory" => FilelessThreatType::ImplantInMemory,
                    "encrypted_payload_memory" | "xor_encoded_memory" => FilelessThreatType::EncryptedPayloadMemory,
                    "heap_spray_detected" => FilelessThreatType::HeapSpray,
                    "rop_chain_memory" | "stack_shellcode" => FilelessThreatType::ROPChainMemory,
                    _ => FilelessThreatType::ImplantInMemory,
                };
                findings.push(FilelessFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    indicator_rule: pattern.to_string(),
                    command_line: None, memory_address: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        let risk_score = if findings.is_empty() { 0.0 } else {
            let s: f64 = findings.iter().map(|f| f.confidence * match f.threat_type {
                FilelessThreatType::BeaconInMemory | FilelessThreatType::C2ConfigInMemory => 1.7,
                FilelessThreatType::ReflectiveDylibLoad | FilelessThreatType::ShellcodeInMemory => 1.6,
                FilelessThreatType::CurlPipeExec | FilelessThreatType::PerlPayload => 1.5,
                FilelessThreatType::KeychainDump | FilelessThreatType::CredentialDump => 1.4,
                FilelessThreatType::ROPChainMemory | FilelessThreatType::HeapSpray => 1.4,
                FilelessThreatType::ModifiedCodePage | FilelessThreatType::ThreadInAnonymous => 1.3,
                _ => 1.0,
            }).sum();
            (s / (findings.len() as f64 * 1.6)).min(1.0)
        };
        self.risk_computer.write().push(risk_score);
        let severity = if risk_score >= 0.85 { Severity::Critical } else if risk_score >= 0.65 { Severity::High }
            else if risk_score >= 0.45 { Severity::Medium } else if risk_score >= 0.25 { Severity::Low }
            else { Severity::Info };
        let is_threat = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = FilelessAnalysisResult {
            is_fileless_threat: is_threat, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
          if is_threat { for f in &result.findings { match f.threat_type {
              FilelessThreatType::ReflectiveDylibLoad | FilelessThreatType::AnonymousExec |
              FilelessThreatType::ShellcodeInMemory | FilelessThreatType::JITAbuse |
              FilelessThreatType::UnbackedExecPage | FilelessThreatType::ModifiedCodePage |
              FilelessThreatType::ThreadInAnonymous | FilelessThreatType::HeapExecCode =>
                  s.memory_exec_detections += 1,
              FilelessThreatType::OsascriptAbuse | FilelessThreatType::JXAExecution |
              FilelessThreatType::PythonPayload | FilelessThreatType::RubyPayload |
              FilelessThreatType::PerlPayload | FilelessThreatType::ShellChain =>
                  s.script_attack_detections += 1,
              FilelessThreatType::CurlPipeExec | FilelessThreatType::Base64DecodeExec |
              FilelessThreatType::OpenSSLDecrypt | FilelessThreatType::ClipboardExec |
              FilelessThreatType::CredentialDump | FilelessThreatType::KeychainDump |
              FilelessThreatType::DataStaging | FilelessThreatType::ProxyManipulation |
              FilelessThreatType::SilentCapture | FilelessThreatType::LOLBinAbuse =>
                  s.lolbin_detections += 1,
              FilelessThreatType::C2ConfigInMemory | FilelessThreatType::BeaconInMemory |
              FilelessThreatType::ImplantInMemory | FilelessThreatType::EncryptedPayloadMemory |
              FilelessThreatType::HeapSpray | FilelessThreatType::ROPChainMemory =>
                  s.memory_forensic_detections += 1,
          } } }
          let n = s.total_events as f64;
          s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_threat {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "fileless_malware_detector".into(),
                title: format!("FILELESS THREAT: {} findings (pid {})",
                    result.findings.len(), pid),
                details: format!("Risk {:.1}%, cmd: {:?}, process: {:?}",
                    risk_score*100.0, event.command_line, event.process_name),
                path: event.file_path.clone(), process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None, mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the suspicious process: kill -9 <pid>".into(),
                    "Dump process memory for analysis: vmmap <pid>".into(),
                    "Check command line: ps -o args= -p <pid>".into(),
                    "Block outbound network for the process".into(),
                    "Review parent process chain for initial vector".into(),
                ], confidence: risk_score,
            });
        }
        Some(result)
    }

    pub fn stats(&self) -> FilelessStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
