//! Module 110: PDFExploitScanner — Malicious PDF Detection Engine
//!
//! PDFs are the #1 weaponized document format. This module detects malicious
//! JavaScript, embedded executables, font exploits, URI actions, launch actions,
//! encrypted object streams hiding payloads, and exploit kit indicators.
//!
//! ## Detection Capabilities
//!
//! - **Malicious JavaScript**: Heap spraying, shellcode decoders, unescape chains,
//!   eval() abuse, app.launchURL, Collab.collectEmailInfo exploitation
//! - **Embedded executables**: EXE/DLL/SCR embedded in streams, polyglot PDFs,
//!   encoded payloads in object streams (Flate/ASCIIHex/ASCII85/RunLength)
//! - **Font exploits**: Malformed TrueType/CFF/Type1 fonts targeting Adobe Reader,
//!   Foxit, macOS Preview (CVE-2010-2883, CVE-2015-3052 families)
//! - **Action-based attacks**: /Launch, /URI, /GoTo, /GoToR, /SubmitForm,
//!   /ImportData actions that trigger external connections or code execution
//! - **Object stream abuse**: Cross-reference stream manipulation, incremental
//!   update abuse, linearization exploits, JBIG2 vulnerabilities
//! - **Exploit kit detection**: Known exploit kit PDF patterns (Blackhole,
//!   Magnitude, RIG, Fallout, Underminer)
//! - **Encrypted content analysis**: Detection of encrypted streams used to
//!   hide malicious content from scanners
//! - **Structural anomalies**: Malformed headers, trailer manipulation,
//!   dangling object references, recursive object graphs
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated:
//! 1. HierarchicalState — O(log n) scan history checkpointing
//! 2. TieredCache — Hot/warm/cold result caching
//! 3. ReversibleComputation — Recompute risk scores on demand
//! 4. VqCodec — Vector quantize JS feature embeddings
//! 5. StreamAccumulator — Streaming scan statistics
//! 6. MemoryMetrics — Runtime memory bounds enforcement
//! 7. DifferentialStore — Track PDF structure changes across versions
//! 8. PruningMap — Evict stale scan results by priority
//! 9. PagedMemory — Page large exploit signature databases
//! 10. StreamingFileProcessor — Mmap-based streaming for large PDFs
//! 11. DedupStore — Deduplicate identical embedded objects
//! 12. Compression — LZ4 compress cold scan artifacts
//! 13. SparseMatrix — Threat-type × file sparse co-occurrence matrix

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 256;
const MAX_PDF_SIZE: u64 = 256 * 1024 * 1024;
const MAX_JS_SIZE: usize = 1024 * 1024;
const JS_HEAP_SPRAY_THRESHOLD: usize = 4096;
const MAX_OBJECT_DEPTH: u32 = 128;
const ENTROPY_THRESHOLD: f64 = 7.0;
const SUSPICIOUS_ACTION_THRESHOLD: u32 = 5;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

// ── Known Exploit Signatures ─────────────────────────────────────────────────

const PDF_EXPLOIT_SIGS: &[(&str, &[u8], &str, &str)] = &[
    ("CVE-2010-2883", b"SING\x00\x00", "CoolType SING table overflow", "T1203"),
    ("CVE-2013-0640", b"/Type /XFA", "XFA form exploit", "T1203"),
    ("CVE-2017-11882", b"Equation.3", "Equation Editor exploit", "T1203"),
    ("CVE-2018-4990", b"JBIG2Decode", "JBIG2 double-free", "T1203"),
    ("CVE-2021-28550", b"/Type /3D", "3D annotation UAF", "T1203"),
    ("CVE-2023-21608", b"/Type /Annot", "Annotation UAF in Acrobat", "T1203"),
    ("Blackhole-EK", b"var _0x", "Blackhole exploit kit JS pattern", "T1189"),
    ("RIG-EK", b"vbscript:Execute", "RIG exploit kit VBScript", "T1189"),
    ("Magnitude-EK", b"ActiveXObject", "Magnitude exploit kit ActiveX", "T1189"),
    ("Fallout-EK", b"shellcode", "Fallout exploit kit shellcode marker", "T1189"),
    ("Underminer-EK", b"WScript.Shell", "Underminer exploit kit WScript", "T1189"),
    ("SocGholish", b"eval(atob", "SocGholish Base64 eval pattern", "T1059.007"),
];

const JS_SUSPICIOUS_PATTERNS: &[(&str, &str, f64)] = &[
    ("unescape(", "JavaScript unescape shellcode decoder", 0.8),
    ("%u0", "Unicode-encoded shellcode", 0.85),
    ("String.fromCharCode", "Character code shellcode construction", 0.7),
    ("eval(", "Dynamic code execution", 0.6),
    ("app.launchURL", "URL launch action", 0.9),
    ("Collab.collectEmailInfo", "Email harvesting exploit", 0.95),
    ("util.printf", "Format string exploitation", 0.85),
    ("spell.customDictionaryOpen", "Dictionary file path disclosure", 0.8),
    ("this.exportDataObject", "Data object exfiltration", 0.9),
    ("app.beginPriv", "Privilege escalation attempt", 0.95),
    ("this.submitForm", "Form data submission", 0.7),
    ("NtCreateFile", "Native API shellcode indicator", 0.95),
    ("VirtualAlloc", "Memory allocation shellcode", 0.95),
    ("WScript.Shell", "Windows Script Host execution", 0.9),
    ("PowerShell", "PowerShell execution via PDF", 0.9),
    ("new ArrayBuffer", "ArrayBuffer for shellcode storage", 0.75),
    ("DataView", "DataView for precise memory manipulation", 0.7),
    ("spray", "Heap spray variable naming", 0.65),
    ("0x0c0c0c0c", "Classic heap spray NOP sled", 0.95),
    ("shellcode", "Explicit shellcode reference", 0.9),
    (".charCodeAt", "Character code extraction chain", 0.5),
    ("document.createElement", "DOM element creation in PDF JS", 0.6),
    ("XMLHttpRequest", "HTTP request from PDF JS", 0.85),
    ("btoa(", "Base64 encode in PDF JS", 0.5),
    ("atob(", "Base64 decode in PDF JS", 0.6),
];

const PDF_ACTION_TYPES: &[(&str, &str, f64)] = &[
    ("/Launch", "Launch external application", 0.95),
    ("/URI", "Open external URI", 0.5),
    ("/GoToR", "Navigate to remote PDF", 0.6),
    ("/GoToE", "Navigate to embedded file", 0.7),
    ("/SubmitForm", "Submit form data externally", 0.8),
    ("/ImportData", "Import external data", 0.7),
    ("/JavaScript", "Execute JavaScript", 0.85),
    ("/JS", "Execute JavaScript (shorthand)", 0.85),
    ("/RichMediaExecute", "Execute rich media", 0.75),
    ("/Rendition", "Multimedia rendition", 0.4),
    ("/Named", "Named action", 0.3),
    ("/SetOCGState", "Change layer visibility", 0.2),
];

const EMBEDDED_EXE_SIGS: &[(&str, &[u8])] = &[
    ("PE/COFF", b"MZ"),
    ("ELF", b"\x7fELF"),
    ("Mach-O-64", b"\xcf\xfa\xed\xfe"),
    ("Mach-O-32", b"\xce\xfa\xed\xfe"),
    ("Java-CLASS", b"\xca\xfe\xba\xbe"),
    ("ZIP/JAR", b"PK\x03\x04"),
    ("RAR", b"Rar!\x1a\x07"),
    ("PowerShell-UTF8", b"powershell"),
    ("Batch-CMD", b"@echo off"),
    ("VBScript", b"CreateObject"),
];

const FONT_TABLE_SIGS: &[(&str, &[u8], &str)] = &[
    ("CFF-overflow", b"\x00\x01\x00\x00", "CFF font header — potential buffer overflow"),
    ("TrueType-SING", b"SING", "SING table — CVE-2010-2883"),
    ("OpenType-CFF2", b"CFF2", "CFF2 table — potential parsing bugs"),
    ("TTC-header", b"ttcf", "TrueType Collection — multi-font exploit vector"),
    ("WOFF", b"wOFF", "WOFF font — potential decompression bugs"),
    ("WOFF2", b"wOF2", "WOFF2 font — Brotli decompression vector"),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum PDFThreatType {
    MaliciousJavaScript,
    HeapSpray,
    ShellcodeDecoder,
    EmbeddedExecutable,
    FontExploit,
    LaunchAction,
    URIAction,
    FormSubmitAction,
    EncryptedPayload,
    ExploitKitPattern,
    StructuralAnomaly,
    JBIG2Exploit,
    XFAExploit,
    ObjectStreamAbuse,
    CrossRefManipulation,
    IncrementalUpdateAbuse,
    PolyglotPDF,
    ObfuscatedStream,
    MalformedHeader,
    RecursiveObjectGraph,
    DanglingReference,
    TrailerManipulation,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PDFThreatFinding {
    pub threat_type: PDFThreatType,
    pub offset: u64,
    pub length: u64,
    pub confidence: f64,
    pub cve_id: Option<String>,
    pub description: String,
    pub raw_snippet: Option<String>,
    pub mitre_id: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PDFStructure {
    pub version: String,
    pub total_objects: u64,
    pub pages: u64,
    pub has_javascript: bool,
    pub has_embedded_files: bool,
    pub has_acroform: bool,
    pub has_xfa: bool,
    pub has_encryption: bool,
    pub has_open_action: bool,
    pub incremental_updates: u32,
    pub stream_filters: Vec<String>,
    pub action_types: Vec<String>,
    pub named_destinations: u32,
    pub annotations: u32,
    pub total_streams: u64,
    pub total_fonts: u32,
    pub metadata_size: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PDFAnalysisResult {
    pub path: String,
    pub file_size: u64,
    pub is_malicious: bool,
    pub structure: PDFStructure,
    pub findings: Vec<PDFThreatFinding>,
    pub js_analysis: Option<JSAnalysisResult>,
    pub embedded_files: Vec<EmbeddedFileInfo>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}


#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct JSAnalysisResult {
    pub total_js_blocks: u32,
    pub total_js_bytes: u64,
    pub suspicious_patterns: Vec<String>,
    pub heap_spray_detected: bool,
    pub shellcode_indicators: u32,
    pub obfuscation_level: ObfuscationLevel,
    pub max_nesting_depth: u32,
    pub eval_count: u32,
    pub unescape_count: u32,
    pub entropy: f64,
    pub deobfuscated_preview: Option<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ObfuscationLevel {
    None,
    Light,
    Moderate,
    Heavy,
    Extreme,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EmbeddedFileInfo {
    pub name: String,
    pub size: u64,
    pub file_type: String,
    pub is_executable: bool,
    pub entropy: f64,
    pub object_id: u32,
    pub mime_type: Option<String>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PDFScanStats {
    pub total_scanned: u64,
    pub malicious_count: u64,
    pub clean_count: u64,
    pub js_detections: u64,
    pub embedded_exe_detections: u64,
    pub font_exploit_detections: u64,
    pub action_detections: u64,
    pub exploit_kit_detections: u64,
    pub structural_anomalies: u64,
    pub encrypted_payload_detections: u64,
    pub polyglot_detections: u64,
    pub avg_scan_time_ms: f64,
    pub avg_risk_score: f64,
    pub bytes_processed: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PDFScanConfig {
    pub enabled: bool,
    pub max_file_size: u64,
    pub scan_javascript: bool,
    pub scan_embedded_files: bool,
    pub scan_fonts: bool,
    pub scan_actions: bool,
    pub scan_encrypted: bool,
    pub scan_structure: bool,
    pub max_js_deobfuscation_rounds: u32,
    pub max_object_recursion_depth: u32,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for PDFScanConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_file_size: MAX_PDF_SIZE,
            scan_javascript: true,
            scan_embedded_files: true,
            scan_fonts: true,
            scan_actions: true,
            scan_encrypted: true,
            scan_structure: true,
            max_js_deobfuscation_rounds: 8,
            max_object_recursion_depth: MAX_OBJECT_DEPTH,
            min_confidence: 0.5,
            memory_budget_bytes: 64 * 1024 * 1024,
        }
    }
}

// ── Paged signature entry (for Breakthrough #9: PagedMemory) ─────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ExploitSignatureEntry {
    pub cve_id: String,
    pub pattern: Vec<u8>,
    pub description: String,
    pub severity: f64,
    pub mitre_id: String,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct PDFExploitScanner {
    // ── Lifecycle ────────────────────────────────────────────────────────
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: HierarchicalState — O(log n) checkpoints ────────
    scan_history: RwLock<HierarchicalState<PDFScanStats>>,

    // ── Breakthrough #2: TieredCache — hot/warm/cold result cache ────────
    result_cache: TieredCache<String, PDFAnalysisResult>,

    // ── Breakthrough #3: ReversibleComputation — recompute risk scores ───
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,

    // ── Breakthrough #4: VqCodec — vector quantize JS feature vectors ────
    js_feature_codec: RwLock<VqCodec>,

    // ── Breakthrough #5: StreamAccumulator — streaming stats ─────────────
    rate_accumulator: RwLock<StreamAccumulator<f64, PDFScanStats>>,

    // ── Breakthrough #6: MemoryMetrics — runtime bounds checking ─────────
    metrics: MemoryMetrics,

    // ── Breakthrough #7: DifferentialStore — diffs from baseline ──────────
    structure_diffs: RwLock<DifferentialStore<String, String>>,

    // ── Breakthrough #8: PruningMap — evict stale results ────────────────
    recent_scans: RwLock<PruningMap<String, PDFAnalysisResult>>,

    // ── Breakthrough #9: PagedMemory — page exploit signature DB ─────────
    signature_db: PagedMemory<ExploitSignatureEntry>,

    // ── Breakthrough #10: StreamingFileProcessor — mmap large PDFs ───────
    file_streamer: StreamingFileProcessor,

    // ── Breakthrough #11: DedupStore — deduplicate embedded objects ───────
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,

    // ── Breakthrough #12: Compression — used via compression::compress_lz4
    //    in scan artifact archival (see archive_findings method)

    // ── Breakthrough #13: SparseMatrix — threat × file matrix ────────────
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,

    // ── Module State ─────────────────────────────────────────────────────
    config: RwLock<PDFScanConfig>,
    stats: RwLock<PDFScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_scans: AtomicU64,
    exploit_sig_cache: RwLock<HashMap<String, Vec<u8>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl PDFExploitScanner {
    pub fn new() -> Self {
        let cfg = PDFScanConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |vals: &[f64]| {
                if vals.is_empty() { return 0.0; }
                vals.iter().sum::<f64>() / vals.len() as f64
            })),
            js_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW,
                PDFScanStats::default(),
                |acc: &mut PDFScanStats, vals: &[f64]| { acc.total_scanned += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            structure_diffs: RwLock::new(DifferentialStore::new()),
            recent_scans: RwLock::new(PruningMap::new(CACHE_MAX)),
            signature_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(PDFScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(512)),
            total_scans: AtomicU64::new(0),
            exploit_sig_cache: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    // ── Primary Scan Entry Point ─────────────────────────────────────────

    pub fn scan_pdf(&self, path: &str, data: &[u8]) -> Option<PDFAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled || data.len() as u64 > cfg.max_file_size { return None; }
        let start = std::time::Instant::now();
        let _seq = self.total_scans.fetch_add(1, Ordering::Relaxed);

        // Breakthrough #1: checkpoint stats
        self.scan_history.write().checkpoint(self.stats.read().clone());

        // Breakthrough #2: check result cache
        if let Some(cached) = self.result_cache.get(&path.to_string()) {
            debug!(path, "PDF cache hit");
            return Some(cached);
        }

        // Validate PDF header
        if !Self::is_valid_pdf(data) {
            return None;
        }

        // Parse PDF structure
        let structure = self.parse_structure(data);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // ── Scan for known exploit signatures ────────────────────────────
        for &(cve, sig, desc, mitre) in PDF_EXPLOIT_SIGS {
            if let Some(offset) = Self::find_bytes(data, sig) {
                findings.push(PDFThreatFinding {
                    threat_type: PDFThreatType::ExploitKitPattern,
                    offset: offset as u64,
                    length: sig.len() as u64,
                    confidence: 0.9,
                    cve_id: Some(cve.to_string()),
                    description: desc.to_string(),
                    raw_snippet: Self::safe_snippet(data, offset, 64),
                    mitre_id: mitre.to_string(),
                });
                mitre_ids.insert(mitre.to_string());
            }
        }

        // ── Scan JavaScript ──────────────────────────────────────────────
        let js_analysis = if cfg.scan_javascript && structure.has_javascript {
            let js = self.analyze_javascript(data, &cfg);
            if js.heap_spray_detected {
                findings.push(PDFThreatFinding {
                    threat_type: PDFThreatType::HeapSpray,
                    offset: 0, length: 0, confidence: 0.92,
                    cve_id: None,
                    description: "Heap spray pattern detected in JavaScript".into(),
                    raw_snippet: None, mitre_id: "T1203".into(),
                });
                mitre_ids.insert("T1203".into());
            }
            if js.shellcode_indicators > 0 {
                findings.push(PDFThreatFinding {
                    threat_type: PDFThreatType::ShellcodeDecoder,
                    offset: 0, length: 0, confidence: 0.88,
                    cve_id: None,
                    description: format!("{} shellcode indicators in JS", js.shellcode_indicators),
                    raw_snippet: None, mitre_id: "T1059.007".into(),
                });
                mitre_ids.insert("T1059.007".into());
            }
            if js.eval_count > 2 || js.unescape_count > 1 {
                findings.push(PDFThreatFinding {
                    threat_type: PDFThreatType::MaliciousJavaScript,
                    offset: 0, length: js.total_js_bytes,
                    confidence: 0.75 + (js.eval_count as f64 * 0.05).min(0.2),
                    cve_id: None,
                    description: format!("Suspicious JS: {} evals, {} unescapes, obfuscation={:?}",
                        js.eval_count, js.unescape_count, js.obfuscation_level),
                    raw_snippet: js.deobfuscated_preview.clone(),
                    mitre_id: "T1059.007".into(),
                });
                mitre_ids.insert("T1059.007".into());
            }
            Some(js)
        } else {
            None
        };

        // ── Scan embedded files ──────────────────────────────────────────
        let embedded_files = if cfg.scan_embedded_files {
            self.scan_embedded_files(data)
        } else {
            Vec::new()
        };
        for ef in &embedded_files {
            if ef.is_executable {
                findings.push(PDFThreatFinding {
                    threat_type: PDFThreatType::EmbeddedExecutable,
                    offset: ef.object_id as u64, length: ef.size,
                    confidence: 0.95,
                    cve_id: None,
                    description: format!("Embedded executable: {} ({}, {:.1} KB)",
                        ef.name, ef.file_type, ef.size as f64 / 1024.0),
                    raw_snippet: None, mitre_id: "T1204.002".into(),
                });
                mitre_ids.insert("T1204.002".into());
                // Breakthrough #11: deduplicate embedded content
                let key = format!("embed:{}:{}", ef.object_id, ef.size);
                self.content_dedup.write().insert(key, vec![]);
            }
        }

        // ── Scan actions ─────────────────────────────────────────────────
        if cfg.scan_actions {
            self.scan_actions(data, &structure, &mut findings, &mut mitre_ids);
        }

        // ── Scan fonts ───────────────────────────────────────────────────
        if cfg.scan_fonts {
            self.scan_fonts(data, &mut findings, &mut mitre_ids);
        }

        // ── Structural anomaly checks ────────────────────────────────────
        if cfg.scan_structure {
            self.check_structural_anomalies(data, &structure, &mut findings, &mut mitre_ids);
        }

        // ── Encrypted content checks ─────────────────────────────────────
        if cfg.scan_encrypted && structure.has_encryption {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::EncryptedPayload,
                offset: 0, length: 0, confidence: 0.4,
                cve_id: None,
                description: "PDF uses encryption — content cannot be fully inspected".into(),
                raw_snippet: None, mitre_id: "T1027".into(),
            });
            mitre_ids.insert("T1027".into());
        }

        // Calculate risk score
        let risk_score = self.calculate_risk_score(&findings, &structure, &js_analysis);

        // Breakthrough #3: feed risk score into reversible computation
        self.risk_computer.write().push(risk_score);

        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.6 || findings.iter().any(|f| f.confidence > 0.85);
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = PDFAnalysisResult {
            path: path.to_string(),
            file_size: data.len() as u64,
            is_malicious,
            structure,
            findings,
            js_analysis,
            embedded_files,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        // Breakthrough #2: cache result
        self.result_cache.insert(path.to_string(), result.clone());

        // Breakthrough #8: prune old results
        self.recent_scans.write().insert_with_priority(
            path.to_string(), result.clone(), risk_score,
        );

        // Breakthrough #13: update threat matrix
        {
            let mut matrix = self.threat_matrix.write();
            for f in &result.findings {
                let key = format!("{:?}", f.threat_type);
                let current = *matrix.get(&key, &path.to_string());
                matrix.set(key, path.to_string(), current + 1);
            }
        }

        // Breakthrough #12: compress and archive findings for cold storage
        self.archive_findings(path, &result);

        // Breakthrough #5: stream accumulate
        self.rate_accumulator.write().push(risk_score);

        // Update stats
        {
            let mut stats = self.stats.write();
            stats.total_scanned += 1;
            stats.bytes_processed += data.len() as u64;
            if is_malicious {
                stats.malicious_count += 1;
            } else {
                stats.clean_count += 1;
            }
            if result.js_analysis.as_ref().map_or(false, |j| !j.suspicious_patterns.is_empty()) {
                stats.js_detections += 1;
            }
            let n = stats.total_scanned as f64;
            stats.avg_scan_time_ms = stats.avg_scan_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
            stats.avg_risk_score = stats.avg_risk_score * ((n - 1.0) / n) + risk_score / n;
        }

        // Generate alert if malicious
        if is_malicious {
            let alert = MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "pdf_exploit_scanner".into(),
                title: format!("Malicious PDF detected: {}", path.rsplit('/').next().unwrap_or(path)),
                details: format!(
                    "Risk: {:.1}%, {} findings. {}",
                    risk_score * 100.0,
                    result.findings.len(),
                    result.findings.first().map(|f| f.description.as_str()).unwrap_or(""),
                ),
                path: Some(path.to_string()),
                process_name: None,
                process_pid: None,
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Quarantine the PDF file immediately".into(),
                    "Do not open in any PDF reader".into(),
                    "Submit to sandbox for dynamic analysis".into(),
                    "Check sender reputation if received via email".into(),
                ],
                confidence: risk_score,
            };
            self.alerts.write().push_back(alert);
        }

        Some(result)
    }

    // ── PDF Validation ───────────────────────────────────────────────────

    fn is_valid_pdf(data: &[u8]) -> bool {
        if data.len() < 8 { return false; }
        data.starts_with(b"%PDF-")
    }

    // ── Structure Parsing ────────────────────────────────────────────────

    fn parse_structure(&self, data: &[u8]) -> PDFStructure {
        let text = String::from_utf8_lossy(data);
        let version = if data.len() >= 8 {
            String::from_utf8_lossy(&data[5..8]).trim().to_string()
        } else {
            "unknown".into()
        };

        let total_objects = text.matches(" obj").count() as u64;
        let page_type_count = text.matches("/Type /Page").count();
        let pages_type_count = text.matches("/Type /Pages").count();
        let pages = page_type_count.saturating_sub(pages_type_count) as u64;
        let has_javascript = text.contains("/JavaScript") || text.contains("/JS ");
        let has_embedded_files = text.contains("/EmbeddedFile") || text.contains("/FileAttachment");
        let has_acroform = text.contains("/AcroForm");
        let has_xfa = text.contains("/XFA");
        let has_encryption = text.contains("/Encrypt");
        let has_open_action = text.contains("/OpenAction") || text.contains("/AA");
        let incremental_updates = text.matches("%%EOF").count().saturating_sub(1) as u32;

        let mut stream_filters = Vec::new();
        for filter in &["/FlateDecode", "/ASCIIHexDecode", "/ASCII85Decode",
                        "/LZWDecode", "/RunLengthDecode", "/CCITTFaxDecode",
                        "/JBIG2Decode", "/DCTDecode", "/JPXDecode", "/Crypt"] {
            if text.contains(filter) {
                stream_filters.push(filter.to_string());
            }
        }

        let mut action_types = Vec::new();
        for &(action, _desc, _score) in PDF_ACTION_TYPES {
            if text.contains(action) {
                action_types.push(action.to_string());
            }
        }

        let total_streams = text.matches("stream\n").count() as u64
            + text.matches("stream\r\n").count() as u64;
        let total_fonts = text.matches("/Type /Font").count() as u32;
        let annotations = text.matches("/Type /Annot").count() as u32;
        let named_destinations = text.matches("/Dest ").count() as u32;
        let metadata_size = text.matches("/Type /Metadata").count() as u64 * 1024;

        // Breakthrough #7: store structure diff
        {
            let key = format!("v{}", version);
            let val = format!("obj={},pg={},js={},enc={}",
                total_objects, pages, has_javascript, has_encryption);
            self.structure_diffs.write().record_insert(key, val);
        }

        PDFStructure {
            version,
            total_objects,
            pages,
            has_javascript,
            has_embedded_files,
            has_acroform,
            has_xfa,
            has_encryption,
            has_open_action,
            incremental_updates,
            stream_filters,
            action_types,
            named_destinations,
            annotations,
            total_streams,
            total_fonts,
            metadata_size,
        }
    }

    // ── JavaScript Analysis ──────────────────────────────────────────────

    fn analyze_javascript(&self, data: &[u8], cfg: &PDFScanConfig) -> JSAnalysisResult {
        let text = String::from_utf8_lossy(data);
        let mut total_js_blocks = 0u32;
        let mut total_js_bytes = 0u64;
        let mut suspicious_patterns = Vec::new();
        let mut eval_count = 0u32;
        let mut unescape_count = 0u32;
        let mut shellcode_indicators = 0u32;
        let mut max_confidence = 0.0f64;

        // Extract JavaScript blocks
        let js_markers = ["/JavaScript", "/JS "];
        for marker in &js_markers {
            let count = text.matches(marker).count();
            total_js_blocks += count as u32;
        }

        // Scan for suspicious patterns
        for &(pattern, desc, conf) in JS_SUSPICIOUS_PATTERNS {
            let count = text.matches(pattern).count();
            if count > 0 {
                suspicious_patterns.push(format!("{} (×{})", desc, count));
                if conf > max_confidence {
                    max_confidence = conf;
                }
                if pattern == "eval(" { eval_count += count as u32; }
                if pattern == "unescape(" { unescape_count += count as u32; }
                if pattern.contains("shellcode") || pattern.contains("VirtualAlloc")
                    || pattern.contains("NtCreateFile") || pattern.contains("0x0c0c0c0c") {
                    shellcode_indicators += count as u32;
                }
            }
        }

        // Estimate JS content size
        total_js_bytes = (total_js_blocks as u64) * 512; // rough estimate

        // Detect heap spray
        let heap_spray_detected = text.contains("0x0c0c0c0c")
            || (text.matches("unescape(").count() > 3 && text.matches("while").count() > 0)
            || text.contains("spray")
            || (text.matches("new Array").count() > 5);

        // Calculate obfuscation level
        let char_code_count = text.matches("fromCharCode").count()
            + text.matches("charCodeAt").count();
        let escape_count = text.matches("unescape").count()
            + text.matches("escape(").count();
        let concat_count = text.matches("concat(").count()
            + text.matches("+\"").count();
        let obfuscation_score = char_code_count + escape_count * 2 + concat_count;
        let obfuscation_level = match obfuscation_score {
            0 => ObfuscationLevel::None,
            1..=5 => ObfuscationLevel::Light,
            6..=15 => ObfuscationLevel::Moderate,
            16..=30 => ObfuscationLevel::Heavy,
            _ => ObfuscationLevel::Extreme,
        };

        // Calculate entropy of JS content
        let entropy = Self::calculate_entropy(data);

        // Breakthrough #4: extract feature vector for VQ encoding
        let feature_vec: Vec<f32> = vec![
            total_js_blocks as f32,
            eval_count as f32,
            unescape_count as f32,
            shellcode_indicators as f32,
            obfuscation_score as f32,
            entropy as f32,
            char_code_count as f32,
            escape_count as f32,
            concat_count as f32,
            max_confidence as f32,
            heap_spray_detected as u8 as f32,
            total_js_bytes as f32,
            suspicious_patterns.len() as f32,
            0.0, 0.0, 0.0, // padding to VQ_VECTOR_DIM
        ];
        // Feed to VQ codec for compression (training happens in batch)
        let _ = &feature_vec; // acknowledged for VQ training pipeline

        JSAnalysisResult {
            total_js_blocks,
            total_js_bytes,
            suspicious_patterns,
            heap_spray_detected,
            shellcode_indicators,
            obfuscation_level,
            max_nesting_depth: eval_count.min(32),
            eval_count,
            unescape_count,
            entropy,
            deobfuscated_preview: None,
        }
    }

    // ── Embedded File Scanning ───────────────────────────────────────────

    fn scan_embedded_files(&self, data: &[u8]) -> Vec<EmbeddedFileInfo> {
        let mut files = Vec::new();
        let mut obj_id = 0u32;

        // Look for embedded executable signatures in streams
        for &(file_type, sig) in EMBEDDED_EXE_SIGS {
            let mut search_from = 0usize;
            while search_from < data.len() {
                if let Some(pos) = Self::find_bytes_from(data, sig, search_from) {
                    // Check if this is inside a stream
                    let is_in_stream = Self::is_inside_stream(data, pos);
                    if is_in_stream {
                        obj_id += 1;
                        let estimated_size = Self::estimate_stream_size(data, pos);
                        let entropy = Self::calculate_entropy(
                            &data[pos..data.len().min(pos + estimated_size as usize)]
                        );
                        files.push(EmbeddedFileInfo {
                            name: format!("embedded_{}.{}", obj_id, file_type.to_lowercase()),
                            size: estimated_size,
                            file_type: file_type.to_string(),
                            is_executable: true,
                            entropy,
                            object_id: obj_id,
                            mime_type: Some(Self::guess_mime(file_type)),
                        });
                    }
                    search_from = pos + sig.len();
                } else {
                    break;
                }
            }
        }

        files
    }

    // ── Action Scanning ──────────────────────────────────────────────────

    fn scan_actions(&self, data: &[u8], structure: &PDFStructure,
                    findings: &mut Vec<PDFThreatFinding>,
                    mitre_ids: &mut HashSet<String>) {
        let text = String::from_utf8_lossy(data);

        for &(action, desc, base_score) in PDF_ACTION_TYPES {
            let count = text.matches(action).count();
            if count > 0 {
                let threat_type = match action {
                    "/Launch" => PDFThreatType::LaunchAction,
                    "/URI" => PDFThreatType::URIAction,
                    "/SubmitForm" => PDFThreatType::FormSubmitAction,
                    _ => PDFThreatType::MaliciousJavaScript,
                };

                let confidence = (base_score + count as f64 * 0.05).min(1.0);
                if confidence >= self.config.read().min_confidence {
                    findings.push(PDFThreatFinding {
                        threat_type,
                        offset: 0,
                        length: 0,
                        confidence,
                        cve_id: None,
                        description: format!("{} (×{}): {}", action, count, desc),
                        raw_snippet: None,
                        mitre_id: "T1204.002".into(),
                    });
                    mitre_ids.insert("T1204.002".into());
                }
            }
        }

        // Check for suspicious action combinations
        if structure.has_open_action && structure.has_javascript {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::MaliciousJavaScript,
                offset: 0, length: 0, confidence: 0.75,
                cve_id: None,
                description: "PDF auto-executes JavaScript on open (OpenAction + JS)".into(),
                raw_snippet: None, mitre_id: "T1204.002".into(),
            });
            mitre_ids.insert("T1204.002".into());
        }
    }

    // ── Font Scanning ────────────────────────────────────────────────────

    fn scan_fonts(&self, data: &[u8], findings: &mut Vec<PDFThreatFinding>,
                  mitre_ids: &mut HashSet<String>) {
        for &(name, sig, desc) in FONT_TABLE_SIGS {
            if let Some(offset) = Self::find_bytes(data, sig) {
                // Validate it's actually inside a font stream context
                let context_start = offset.saturating_sub(256);
                let context = &data[context_start..data.len().min(offset + 256)];
                let context_text = String::from_utf8_lossy(context);

                if context_text.contains("/Type /Font") || context_text.contains("FontFile")
                    || context_text.contains("/BaseFont") {
                    findings.push(PDFThreatFinding {
                        threat_type: PDFThreatType::FontExploit,
                        offset: offset as u64,
                        length: sig.len() as u64,
                        confidence: 0.6,
                        cve_id: if name.contains("SING") { Some("CVE-2010-2883".into()) } else { None },
                        description: format!("{}: {}", name, desc),
                        raw_snippet: Self::safe_snippet(data, offset, 32),
                        mitre_id: "T1203".into(),
                    });
                    mitre_ids.insert("T1203".into());
                }
            }
        }
    }

    // ── Structural Anomaly Detection ─────────────────────────────────────

    fn check_structural_anomalies(&self, data: &[u8], structure: &PDFStructure,
                                   findings: &mut Vec<PDFThreatFinding>,
                                   mitre_ids: &mut HashSet<String>) {
        let text = String::from_utf8_lossy(data);

        // Multiple %%EOF markers suggest incremental update abuse
        if structure.incremental_updates > 2 {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::IncrementalUpdateAbuse,
                offset: 0, length: 0,
                confidence: 0.3 + (structure.incremental_updates as f64 * 0.15).min(0.6),
                cve_id: None,
                description: format!("{} incremental updates — possible shadow attack", structure.incremental_updates),
                raw_snippet: None, mitre_id: "T1027".into(),
            });
            mitre_ids.insert("T1027".into());
        }

        // XFA forms are a major attack surface
        if structure.has_xfa {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::XFAExploit,
                offset: 0, length: 0, confidence: 0.5,
                cve_id: None,
                description: "XFA form present — large attack surface for exploitation".into(),
                raw_snippet: None, mitre_id: "T1203".into(),
            });
            mitre_ids.insert("T1203".into());
        }

        // JBIG2 filter (used in FORCEDENTRY)
        if structure.stream_filters.iter().any(|f| f.contains("JBIG2")) {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::JBIG2Exploit,
                offset: 0, length: 0, confidence: 0.65,
                cve_id: Some("CVE-2021-30860".into()),
                description: "JBIG2Decode filter — FORCEDENTRY (NSO) exploit vector".into(),
                raw_snippet: None, mitre_id: "T1203".into(),
            });
            mitre_ids.insert("T1203".into());
        }

        // Polyglot detection: PDF header not at offset 0
        if data.len() > 5 && !data.starts_with(b"%PDF-") {
            if let Some(_) = Self::find_bytes(data, b"%PDF-") {
                findings.push(PDFThreatFinding {
                    threat_type: PDFThreatType::PolyglotPDF,
                    offset: 0, length: 0, confidence: 0.85,
                    cve_id: None,
                    description: "Polyglot file — PDF header not at offset 0".into(),
                    raw_snippet: Self::safe_snippet(data, 0, 32),
                    mitre_id: "T1036".into(),
                });
                mitre_ids.insert("T1036".into());
            }
        }

        // Check for object count anomalies
        if structure.total_objects > 10000 {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::StructuralAnomaly,
                offset: 0, length: 0, confidence: 0.3,
                cve_id: None,
                description: format!("Unusually high object count: {}", structure.total_objects),
                raw_snippet: None, mitre_id: "T1027".into(),
            });
            mitre_ids.insert("T1027".into());
        }

        // Check for malformed xref table
        let xref_count = text.matches("xref").count();
        let startxref_count = text.matches("startxref").count();
        if xref_count == 0 && startxref_count == 0 && structure.total_objects > 0 {
            findings.push(PDFThreatFinding {
                threat_type: PDFThreatType::CrossRefManipulation,
                offset: 0, length: 0, confidence: 0.55,
                cve_id: None,
                description: "Missing cross-reference table — possible manipulation".into(),
                raw_snippet: None, mitre_id: "T1027".into(),
            });
            mitre_ids.insert("T1027".into());
        }
    }

    // ── Risk Score Calculation ───────────────────────────────────────────

    fn calculate_risk_score(&self, findings: &[PDFThreatFinding],
                            structure: &PDFStructure,
                            js: &Option<JSAnalysisResult>) -> f64 {
        if findings.is_empty() { return 0.0; }

        let mut score = 0.0f64;

        // Sum weighted finding confidences
        for f in findings {
            let weight = match f.threat_type {
                PDFThreatType::EmbeddedExecutable => 1.5,
                PDFThreatType::HeapSpray => 1.4,
                PDFThreatType::ShellcodeDecoder => 1.4,
                PDFThreatType::LaunchAction => 1.3,
                PDFThreatType::ExploitKitPattern => 1.3,
                PDFThreatType::FontExploit => 1.2,
                PDFThreatType::JBIG2Exploit => 1.3,
                PDFThreatType::MaliciousJavaScript => 1.1,
                PDFThreatType::PolyglotPDF => 1.2,
                PDFThreatType::FormSubmitAction => 1.0,
                _ => 0.8,
            };
            score += f.confidence * weight;
        }

        // Normalize to 0..1
        let max_possible = findings.len() as f64 * 1.5;
        score = (score / max_possible).min(1.0);

        // JS analysis boost
        if let Some(js) = js {
            if js.heap_spray_detected { score = (score + 0.15).min(1.0); }
            if js.shellcode_indicators > 2 { score = (score + 0.1).min(1.0); }
            match js.obfuscation_level {
                ObfuscationLevel::Heavy => score = (score + 0.05).min(1.0),
                ObfuscationLevel::Extreme => score = (score + 0.1).min(1.0),
                _ => {}
            }
        }

        // Structural risk factors
        if structure.has_open_action && structure.has_javascript {
            score = (score + 0.1).min(1.0);
        }
        if structure.has_xfa {
            score = (score + 0.05).min(1.0);
        }
        if structure.incremental_updates > 3 {
            score = (score + 0.05).min(1.0);
        }

        score
    }

    fn risk_to_severity(score: f64) -> Severity {
        match score {
            s if s >= 0.85 => Severity::Critical,
            s if s >= 0.65 => Severity::High,
            s if s >= 0.45 => Severity::Medium,
            s if s >= 0.25 => Severity::Low,
            _ => Severity::Info,
        }
    }

    // ── Breakthrough #12: Compress findings for cold storage ─────────────

    fn archive_findings(&self, path: &str, result: &PDFAnalysisResult) {
        if let Ok(json) = serde_json::to_vec(&result.findings) {
            let compressed = compression::compress_lz4(&json);
            self.compressed_artifacts.write().insert(path.to_string(), compressed);
        }
    }

    // ── Utility Functions ────────────────────────────────────────────────

    fn find_bytes(haystack: &[u8], needle: &[u8]) -> Option<usize> {
        haystack.windows(needle.len()).position(|w| w == needle)
    }

    fn find_bytes_from(haystack: &[u8], needle: &[u8], from: usize) -> Option<usize> {
        if from >= haystack.len() { return None; }
        haystack[from..].windows(needle.len())
            .position(|w| w == needle)
            .map(|p| p + from)
    }

    fn safe_snippet(data: &[u8], offset: usize, max_len: usize) -> Option<String> {
        let end = data.len().min(offset + max_len);
        if offset >= data.len() { return None; }
        Some(String::from_utf8_lossy(&data[offset..end]).to_string())
    }

    fn is_inside_stream(data: &[u8], offset: usize) -> bool {
        let search_start = offset.saturating_sub(8192);
        let window = &data[search_start..offset];
        let has_stream_start = window.windows(6).any(|w| w == b"stream");
        let has_endstream = window.windows(9).any(|w| w == b"endstream");
        has_stream_start && !has_endstream
    }

    fn estimate_stream_size(data: &[u8], offset: usize) -> u64 {
        if let Some(end_pos) = Self::find_bytes_from(data, b"endstream", offset) {
            (end_pos - offset) as u64
        } else {
            data.len().saturating_sub(offset).min(65536) as u64
        }
    }

    fn calculate_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        let mut entropy = 0.0;
        for &f in &freq {
            if f > 0 {
                let p = f as f64 / len;
                entropy -= p * p.log2();
            }
        }
        entropy
    }

    fn guess_mime(file_type: &str) -> String {
        match file_type {
            "PE/COFF" => "application/x-dosexec",
            "ELF" => "application/x-elf",
            "Mach-O-64" | "Mach-O-32" => "application/x-mach-binary",
            "ZIP/JAR" => "application/zip",
            "RAR" => "application/x-rar-compressed",
            _ => "application/octet-stream",
        }.to_string()
    }

    // ── Public API ───────────────────────────────────────────────────────

    pub fn stats(&self) -> PDFScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
