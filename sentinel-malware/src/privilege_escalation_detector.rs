//! Module 95: PrivilegeEscalationDetector — Local Privilege Escalation Detection
//!
//! World-class detection engine for local privilege escalation attacks across Windows,
//! macOS, and Linux. Detects SUID/SGID abuse, sudo misconfiguration exploitation,
//! kernel exploits, DLL hijacking, service permission weaknesses, unquoted service
//! paths, and token manipulation techniques.
//!
//! ## Features
//!
//! - **SUID/SGID binary abuse**: Monitors execution of SUID binaries (find, vim,
//!   python, perl, nmap, etc.) for GTFOBins-style privilege escalation
//! - **Sudo misconfiguration**: Detects sudo NOPASSWD abuse, sudoers file
//!   modification, and sudo token reuse attacks
//! - **Kernel exploit detection**: Identifies known kernel exploit patterns
//!   (DirtyPipe, DirtyCow, PwnKit, Baron Samedit, GameOver(lay))
//! - **Windows token manipulation**: Detects SeDebugPrivilege abuse, token
//!   impersonation (Potato attacks), and privilege token theft
//! - **DLL hijacking**: Identifies DLL search order hijacking, phantom DLL
//!   loading, and DLL side-loading for privilege escalation
//! - **Service permission weakness**: Detects writable service binaries, modifiable
//!   service configurations, and unquoted service paths
//! - **macOS privilege escalation**: Monitors for Authorization plugin abuse,
//!   TCC database manipulation, and entitlement exploitation
//! - **Scheduled task abuse**: Detects writable scheduled task binaries and
//!   task creation with SYSTEM privileges
//! - **Named pipe impersonation**: Identifies named pipe creation for token
//!   impersonation (PrintSpoofer, RoguePotato)
//! - **UAC bypass detection**: Monitors for User Account Control bypass
//!   techniques (fodhelper, eventvwr, sdclt, computerdefaults)
//! - **PATH manipulation**: Detects PATH environment variable manipulation
//!   to hijack binary execution
//! - **Capability abuse**: Identifies Linux capability escalation via
//!   cap_setuid, cap_setgid, cap_dac_override
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) escalation event history
//! - **#2  TieredCache** — Hot cache for recent escalation detections
//! - **#3  ReversibleComputation** — Recompute escalation risk scores
//! - **#5  StreamAccumulator** — Streaming detection rate
//! - **#6  MemoryMetrics** — Bounded memory for detection data
//! - **#461 DifferentialStore** — Track privilege state diffs
//! - **#569 PruningMap** — Auto-expire old escalation events
//! - **#592 DedupStore** — Deduplicate identical detections
//! - **#627 SparseMatrix** — Process × technique frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1068 — Exploitation for Privilege Escalation
//! - T1548.001 — Abuse Elevation Control: Setuid and Setgid
//! - T1548.002 — Abuse Elevation Control: Bypass UAC
//! - T1548.003 — Abuse Elevation Control: Sudo and Sudo Caching
//! - T1134 — Access Token Manipulation
//! - T1574.001 — Hijack Execution Flow: DLL Search Order Hijacking
//! - T1574.002 — Hijack Execution Flow: DLL Side-Loading

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const PRIVESC_CACHE_MAX: usize = 8_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 24 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;
const CRON_ABUSE_RISK: f64 = 0.75;
const WRITABLE_SERVICE_RISK: f64 = 0.80;

/// GTFOBins SUID binaries that can escalate privileges
const GTFOBINS_SUID: &[(&str, f64, &str)] = &[
    ("find",       0.85, "find -exec — command execution as owner"),
    ("vim",        0.80, "vim — shell escape via :!sh"),
    ("vi",         0.80, "vi — shell escape"),
    ("nano",       0.60, "nano — limited shell escape"),
    ("python",     0.90, "python — os.system() as owner"),
    ("python3",    0.90, "python3 — os.system() as owner"),
    ("perl",       0.85, "perl — system() as owner"),
    ("ruby",       0.85, "ruby — system() as owner"),
    ("lua",        0.80, "lua — os.execute() as owner"),
    ("nmap",       0.85, "nmap — interactive mode shell"),
    ("bash",       0.95, "bash -p — preserves SUID privileges"),
    ("sh",         0.90, "sh — SUID shell"),
    ("dash",       0.90, "dash — SUID shell"),
    ("zsh",        0.90, "zsh — SUID shell"),
    ("less",       0.70, "less — !sh shell escape"),
    ("more",       0.65, "more — !sh shell escape"),
    ("awk",        0.80, "awk — system() execution"),
    ("gawk",       0.80, "gawk — system() execution"),
    ("cp",         0.70, "cp — overwrite /etc/passwd or SUID binary"),
    ("mv",         0.70, "mv — replace binaries"),
    ("chmod",      0.75, "chmod — modify file permissions"),
    ("chown",      0.75, "chown — change file ownership"),
    ("tar",        0.65, "tar — checkpoint action execution"),
    ("zip",        0.60, "zip — command execution via -TT"),
    ("gcc",        0.70, "gcc — compile and execute code"),
    ("make",       0.65, "make — command execution"),
    ("docker",     0.95, "docker — container escape to root"),
    ("pkexec",     0.90, "pkexec — PolicyKit privilege escalation"),
    ("env",        0.75, "env — environment manipulation"),
    ("strace",     0.80, "strace — ptrace privilege escalation"),
    ("ltrace",     0.75, "ltrace — library trace escalation"),
    ("gdb",        0.85, "gdb — debugging privilege escalation"),
    ("mount",      0.70, "mount — filesystem mount escalation"),
    ("umount",     0.60, "umount — unmount manipulation"),
    ("systemctl",  0.80, "systemctl — service manipulation"),
    ("journalctl", 0.65, "journalctl — less pager escape"),
    ("screen",     0.70, "screen — SUID screen escalation"),
    ("tmux",       0.60, "tmux — shared session escalation"),
];

/// Known kernel privilege escalation CVEs
const KERNEL_EXPLOITS: &[(&str, &str, f64, &str)] = &[
    ("CVE-2022-0847",  "DirtyPipe — overwrite read-only files",         1.0,  "Linux 5.8+"),
    ("CVE-2016-5195",  "DirtyCow — copy-on-write race condition",       0.95, "Linux < 4.8.3"),
    ("CVE-2021-4034",  "PwnKit — pkexec SUID privilege escalation",     1.0,  "Polkit < 0.120"),
    ("CVE-2021-3156",  "Baron Samedit — sudo heap overflow",            1.0,  "sudo < 1.9.5p2"),
    ("CVE-2023-2640",  "GameOver(lay) — OverlayFS privilege escalation",0.95, "Ubuntu kernels"),
    ("CVE-2023-32629", "GameOver(lay) — OverlayFS variant",             0.95, "Ubuntu kernels"),
    ("CVE-2022-0185",  "Heap overflow in legacy_parse_param",           0.90, "Linux 5.1+"),
    ("CVE-2022-2588",  "Route4 use-after-free",                         0.90, "Linux < 5.19.2"),
    ("CVE-2023-0386",  "OverlayFS privilege escalation",                0.95, "Linux < 6.2"),
    ("CVE-2021-22555", "Netfilter heap OOB write",                      0.90, "Linux 2.6.19+"),
    ("CVE-2022-34918", "Netfilter nft_set_elem_init heap overflow",     0.90, "Linux 5.8+"),
    ("CVE-2023-4911",  "Looney Tunables — glibc ld.so buffer overflow", 0.95, "glibc < 2.39"),
];

/// Windows UAC bypass techniques
const UAC_BYPASSES: &[(&str, f64, &str)] = &[
    ("fodhelper.exe",          0.90, "FodHelper UAC bypass via registry"),
    ("eventvwr.exe",           0.85, "Event Viewer UAC bypass"),
    ("sdclt.exe",              0.85, "Backup and Restore UAC bypass"),
    ("computerdefaults.exe",   0.85, "ComputerDefaults UAC bypass"),
    ("slui.exe",               0.80, "Software Licensing UAC bypass"),
    ("wsreset.exe",            0.85, "WSReset UAC bypass"),
    ("cmstp.exe",              0.80, "CMSTP UAC bypass"),
    ("mmc.exe",                0.55, "MMC UAC bypass (context-dependent)"),
    ("diskcleanup",            0.70, "Disk Cleanup UAC bypass"),
    ("schtasks.exe",           0.65, "Scheduled Task UAC bypass"),
    ("silentcleanup",          0.80, "SilentCleanup UAC bypass"),
    ("dccw.exe",               0.75, "Display Color Calibration UAC bypass"),
];

/// Linux capability abuse indicators
const CAPABILITY_ABUSE: &[(&str, f64, &str)] = &[
    ("cap_setuid",         0.90, "CAP_SETUID — can change UID to root"),
    ("cap_setgid",         0.85, "CAP_SETGID — can change GID"),
    ("cap_dac_override",   0.85, "CAP_DAC_OVERRIDE — bypass file permissions"),
    ("cap_dac_read_search",0.75, "CAP_DAC_READ_SEARCH — bypass read checks"),
    ("cap_sys_admin",      0.95, "CAP_SYS_ADMIN — near-root capabilities"),
    ("cap_sys_ptrace",     0.85, "CAP_SYS_PTRACE — process injection"),
    ("cap_net_admin",      0.70, "CAP_NET_ADMIN — network manipulation"),
    ("cap_net_raw",        0.65, "CAP_NET_RAW — raw socket access"),
    ("cap_sys_module",     0.95, "CAP_SYS_MODULE — kernel module loading"),
    ("cap_chown",          0.70, "CAP_CHOWN — change file ownership"),
    ("cap_fowner",         0.75, "CAP_FOWNER — bypass ownership checks"),
    ("cap_sys_rawio",      0.80, "CAP_SYS_RAWIO — raw I/O port access"),
];

/// Cron/at job abuse for privilege persistence
const CRON_ABUSE_INDICATORS: &[(&str, f64, &str)] = &[
    ("crontab -e",         0.50, "Crontab edit (normal, but check context)"),
    ("/etc/cron.d/",       0.65, "System cron directory modification"),
    ("/etc/cron.daily/",   0.60, "Daily cron directory modification"),
    ("/etc/cron.hourly/",  0.65, "Hourly cron directory modification"),
    ("/var/spool/cron/",   0.70, "Direct spool directory manipulation"),
    ("at -f",              0.55, "AT job file execution"),
    ("systemd-run",        0.60, "Systemd transient service creation"),
    ("systemctl enable",   0.50, "Service enable (persistence indicator)"),
];

/// macOS-specific escalation techniques
const MACOS_ESCALATION: &[(&str, f64, &str)] = &[
    ("security authorizationdb", 0.85, "macOS AuthorizationDB manipulation"),
    ("launchctl load",     0.65, "LaunchDaemon/Agent loading"),
    ("osascript",          0.50, "AppleScript execution (context-dependent)"),
    ("TCC.db",             0.90, "TCC database manipulation — bypass permissions"),
    ("dscl . -create",     0.80, "Directory Service user creation"),
    ("dseditgroup",        0.75, "Group membership modification"),
    ("spctl --master-disable", 0.80, "Gatekeeper disable"),
    ("csrutil disable",    0.95, "SIP disable (requires recovery mode)"),
    ("defaults write",     0.40, "Defaults write (check for security prefs)"),
    ("kextload",           0.85, "Kernel extension loading"),
];

/// Writable service binary/config paths (Linux)
const WRITABLE_SERVICE_PATHS: &[(&str, f64, &str)] = &[
    ("/etc/systemd/system/",      0.75, "Systemd service directory"),
    ("/etc/init.d/",               0.70, "SysVinit script directory"),
    ("/usr/lib/systemd/system/",   0.80, "System service unit directory"),
    ("/etc/rc.local",              0.65, "RC local boot script"),
    ("/etc/profile.d/",            0.60, "Profile drop-in directory"),
    ("/etc/ld.so.conf.d/",         0.80, "Shared library config — preload abuse"),
    ("/etc/ld.so.preload",         0.90, "LD preload file — library injection"),
];

/// Windows token manipulation techniques
const TOKEN_TECHNIQUES: &[(&str, f64, &str)] = &[
    ("SeDebugPrivilege",       0.85, "Debug privilege — process injection"),
    ("SeImpersonatePrivilege", 0.80, "Impersonate privilege — Potato attacks"),
    ("SeAssignPrimaryToken",   0.80, "Assign primary token — token theft"),
    ("SeTcbPrivilege",         0.90, "TCB privilege — act as part of OS"),
    ("SeBackupPrivilege",      0.70, "Backup privilege — read any file"),
    ("SeRestorePrivilege",     0.70, "Restore privilege — write any file"),
    ("SeTakeOwnershipPrivilege",0.75,"Take ownership of objects"),
    ("SeLoadDriverPrivilege",  0.90, "Load kernel driver — kernel access"),
    ("JuicyPotato",            0.95, "JuicyPotato — DCOM token impersonation"),
    ("PrintSpoofer",           0.95, "PrintSpoofer — named pipe impersonation"),
    ("RoguePotato",            0.95, "RoguePotato — OXID resolver abuse"),
    ("SweetPotato",            0.95, "SweetPotato — combined Potato attack"),
    ("GodPotato",              0.95, "GodPotato — universal Potato"),
    ("EfsPotato",              0.90, "EfsPotato — EFS token impersonation"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum PrivEscTechnique {
    SUIDAbuse, SudoMisconfig, KernelExploit, TokenManipulation,
    DLLHijack, ServiceWeakness, UACBypass, ScheduledTaskAbuse,
    NamedPipeImpersonation, PATHManipulation, CapabilityAbuse,
    MacOSEntitlement, UnquotedServicePath,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PrivEscEvent {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub techniques: Vec<PrivEscTechnique>,
    pub process_name: String,
    pub process_id: u32,
    pub process_path: String,
    pub command_line: String,
    pub current_user: String,
    pub target_privilege: String,
    pub cve_match: Option<String>,
    pub suid_binary: Option<String>,
    pub uac_method: Option<String>,
    pub token_technique: Option<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct PrivEscStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub suid_abuses: u64,
    pub sudo_misconfigs: u64,
    pub kernel_exploits: u64,
    pub token_manipulations: u64,
    pub dll_hijacks: u64,
    pub service_weaknesses: u64,
    pub uac_bypasses: u64,
    pub capability_abuses: u64,
    pub path_manipulations: u64,
    pub named_pipe_impersonations: u64,
    pub blocked_escalations: u64,
    pub safe_processes: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PrivEscConfig {
    pub block_suid_abuse: bool,
    pub block_kernel_exploits: bool,
    pub block_uac_bypass: bool,
    pub block_token_manipulation: bool,
    pub scan_sudo: bool,
    pub scan_capabilities: bool,
    pub block_on_critical: bool,
}

impl PrivEscConfig {
    pub fn default_config() -> Self {
        Self {
            block_suid_abuse: true,
            block_kernel_exploits: true,
            block_uac_bypass: true,
            block_token_manipulation: true,
            scan_sudo: true,
            scan_capabilities: true,
            block_on_critical: true,
        }
    }
}

pub struct PrivilegeEscalationDetector {
    // Breakthrough #1: HierarchicalState — O(log n) escalation history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<PrivEscStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, PrivEscEvent>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, PrivEscStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — privilege diffs
    priv_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, PrivEscEvent>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — process × technique matrix
    process_technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<PrivEscConfig>,
    stats: RwLock<PrivEscStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl PrivilegeEscalationDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(PRIVESC_CACHE_MAX)
            .with_metrics(metrics.clone(), "privesc_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, PrivEscStats::default(),
            |acc: &mut PrivEscStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            priv_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(PRIVESC_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            process_technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(PrivEscConfig::default_config()),
            stats: RwLock::new(PrivEscStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("privesc", MEMORY_BUDGET / 2);
        info!("PrivilegeEscalationDetector started — {} SUID bins, {} kernel CVEs, {} UAC bypasses, {} token techniques",
            GTFOBINS_SUID.len(), KERNEL_EXPLOITS.len(),
            UAC_BYPASSES.len(), TOKEN_TECHNIQUES.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("PrivilegeEscalationDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Analyze a process execution for privilege escalation indicators.
    pub fn analyze_execution(
        &self, process_name: &str, pid: u32, process_path: &str,
        command_line: &str, user: &str, is_suid: bool,
        privileges: &[String],
    ) -> Option<PrivEscEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let cmd_lower = command_line.to_lowercase();
        let proc_lower = process_name.to_lowercase();
        let mut techniques = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut cve_match: Option<String> = None;
        let mut suid_bin: Option<String> = None;
        let mut uac_method: Option<String> = None;
        let mut token_tech: Option<String> = None;
        let mut max_risk: f64 = 0.0;

        // ── 1. SUID binary abuse ──
        if is_suid {
            for &(binary, risk, desc) in GTFOBINS_SUID {
                if proc_lower == binary || proc_lower.ends_with(&format!("/{}", binary)) {
                    suid_bin = Some(binary.to_string());
                    indicators.push(format!("SUID binary: {} — {}", binary, desc));
                    techniques.push(PrivEscTechnique::SUIDAbuse);
                    mitre_techniques.push("T1548.001".to_string());
                    self.stats.write().suid_abuses += 1;
                    max_risk = max_risk.max(risk);
                    break;
                }
            }
        }

        // ── 2. Sudo abuse ──
        if cmd_lower.starts_with("sudo ") {
            if cmd_lower.contains("sudo -u root") || cmd_lower.contains("sudo su") || cmd_lower.contains("sudo bash") {
                indicators.push(format!("Sudo escalation: {}", command_line));
                techniques.push(PrivEscTechnique::SudoMisconfig);
                mitre_techniques.push("T1548.003".to_string());
                self.stats.write().sudo_misconfigs += 1;
                max_risk = max_risk.max(0.70);
            }
        }

        // ── 3. Kernel exploit detection ──
        for &(cve, desc, risk, _affected) in KERNEL_EXPLOITS {
            if cmd_lower.contains(&cve.to_lowercase()) || cmd_lower.contains(&desc.split(' ').next().unwrap_or("").to_lowercase()) {
                cve_match = Some(cve.to_string());
                indicators.push(format!("{}: {}", cve, desc));
                techniques.push(PrivEscTechnique::KernelExploit);
                mitre_techniques.push("T1068".to_string());
                self.stats.write().kernel_exploits += 1;
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 4. UAC bypass detection ──
        for &(method, risk, desc) in UAC_BYPASSES {
            if proc_lower.contains(&method.to_lowercase()) || cmd_lower.contains(&method.to_lowercase()) {
                uac_method = Some(method.to_string());
                indicators.push(format!("UAC bypass: {} — {}", method, desc));
                techniques.push(PrivEscTechnique::UACBypass);
                mitre_techniques.push("T1548.002".to_string());
                self.stats.write().uac_bypasses += 1;
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 5. Token manipulation ──
        for &(tech, risk, desc) in TOKEN_TECHNIQUES {
            if privileges.iter().any(|p| p.contains(tech)) || cmd_lower.contains(&tech.to_lowercase()) {
                token_tech = Some(tech.to_string());
                indicators.push(format!("Token technique: {} — {}", tech, desc));
                techniques.push(PrivEscTechnique::TokenManipulation);
                mitre_techniques.push("T1134".to_string());
                self.stats.write().token_manipulations += 1;
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 6. PATH manipulation ──
        if cmd_lower.contains("path=") || cmd_lower.contains("export path") {
            let suspicious_paths = ["/tmp", "/dev/shm", "/var/tmp", "."];
            for sp in &suspicious_paths {
                if cmd_lower.contains(sp) {
                    indicators.push(format!("PATH manipulation: writable dir '{}' prepended", sp));
                    techniques.push(PrivEscTechnique::PATHManipulation);
                    self.stats.write().path_manipulations += 1;
                    mitre_techniques.push("T1574.007".to_string());
                    max_risk = max_risk.max(0.75);
                    break;
                }
            }
        }

        // ── 7. DLL hijacking / search order abuse ──
        if cmd_lower.contains("dll") && (cmd_lower.contains("hijack") || cmd_lower.contains("sideload") || cmd_lower.contains("phantom")) {
            indicators.push("DLL hijacking/sideloading detected".to_string());
            techniques.push(PrivEscTechnique::DLLHijack);
            self.stats.write().dll_hijacks += 1;
            mitre_techniques.push("T1574.001".to_string());
            max_risk = max_risk.max(0.80);
        }

        // ── 8. Named pipe impersonation ──
        if cmd_lower.contains("namedpipe") || cmd_lower.contains("impersonate") || cmd_lower.contains("potato") {
            if !techniques.contains(&PrivEscTechnique::TokenManipulation) {
                indicators.push("Named pipe impersonation technique".to_string());
                techniques.push(PrivEscTechnique::NamedPipeImpersonation);
                self.stats.write().named_pipe_impersonations += 1;
                mitre_techniques.push("T1134.001".to_string());
                max_risk = max_risk.max(0.90);
            }
        }

        // ── 9. Unquoted service path ──
        if cmd_lower.contains("unquoted") || (cmd_lower.contains("service") && cmd_lower.contains("path") && !cmd_lower.contains('"')) {
            indicators.push("Unquoted service path exploitation".to_string());
            techniques.push(PrivEscTechnique::UnquotedServicePath);
            self.stats.write().service_weaknesses += 1;
            mitre_techniques.push("T1574.009".to_string());
            max_risk = max_risk.max(0.70);
        }

        if techniques.is_empty() {
            self.stats.write().safe_processes += 1;
            return None;
        }

        // ── Finalize ──
        techniques.sort();
        techniques.dedup();
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let config = self.config.read().clone();
        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.60 + techniques.len() as f64 * 0.07
            + if cve_match.is_some() { 0.12 } else { 0.0 }).min(0.99);
        let blocked = config.block_on_critical && matches!(severity, Severity::Critical);

        self.stats.write().threats_detected += 1;
        if blocked { self.stats.write().blocked_escalations += 1; }

        // Breakthrough #627: SparseMatrix
        for t in &techniques {
            let c = *self.process_technique_matrix.read()
                .get(&process_name.to_string(), &format!("{:?}", t));
            self.process_technique_matrix.write()
                .set(process_name.to_string(), format!("{:?}", t), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let event = PrivEscEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, severity, confidence, techniques,
            process_name: process_name.to_string(), process_id: pid,
            process_path: process_path.to_string(),
            command_line: command_line.to_string(),
            current_user: user.to_string(),
            target_privilege: "root/SYSTEM".to_string(),
            cve_match, suid_binary: suid_bin, uac_method, token_technique: token_tech,
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.process_technique_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record privilege state diff
        self.priv_diffs.write().record_insert(
            event.id.clone(),
            format!("{}:{}:{}:{:?}", process_name, pid, user, event.techniques),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{}:{}:{:?}", process_name, pid, event.techniques).into_bytes(),
        );
        if blocked { warn!("PRIVESC BLOCKED: {} (PID {}) user={} — {:?}", process_name, pid, user, event.techniques); }
        Some(event)
    }

    /// Detect Linux capability abuse
    fn detect_capability_abuse(cmd: &str, privileges: &[String]) -> Vec<(String, f64)> {
        let cmd_lower = cmd.to_lowercase();
        let mut hits = Vec::new();
        for &(cap, risk, desc) in CAPABILITY_ABUSE {
            if cmd_lower.contains(cap) || privileges.iter().any(|p| p.to_lowercase().contains(cap)) {
                hits.push((format!("{}: {}", cap, desc), risk));
            }
        }
        hits
    }

    /// Detect cron/at job abuse
    fn detect_cron_abuse(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in CRON_ABUSE_INDICATORS {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                return Some((risk, desc.to_string()));
            }
        }
        None
    }

    /// Detect macOS-specific escalation
    fn detect_macos_escalation(cmd: &str) -> Vec<(String, f64)> {
        let cmd_lower = cmd.to_lowercase();
        let mut hits = Vec::new();
        for &(pattern, risk, desc) in MACOS_ESCALATION {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                hits.push((format!("{}: {}", pattern, desc), risk));
            }
        }
        hits
    }

    /// Detect writable service path manipulation
    fn detect_writable_service(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(path, risk, desc) in WRITABLE_SERVICE_PATHS {
            if cmd_lower.contains(path) {
                return Some((risk, desc.to_string()));
            }
        }
        None
    }

    /// Build a MalwareAlert from a PrivEscEvent
    fn build_alert(&self, event: &PrivEscEvent) -> MalwareAlert {
        MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: event.timestamp,
            severity: event.severity,
            module: "privilege_escalation_detector".to_string(),
            title: format!("Privilege escalation: {} (PID {})",
                event.process_name, event.process_id),
            details: format!(
                "Detected {} privesc technique(s) for process '{}' (PID {}) by user '{}'. \
                 Target: {}. CVE: {:?}. SUID: {:?}. UAC: {:?}. Token: {:?}. Confidence: {:.0}%. {}",
                event.techniques.len(),
                event.process_name, event.process_id,
                event.current_user, event.target_privilege,
                event.cve_match, event.suid_binary,
                event.uac_method, event.token_technique,
                event.confidence * 100.0,
                if event.blocked { "BLOCKED." } else { "" }
            ),
            path: Some(event.process_path.clone()),
            process_name: Some(event.process_name.clone()),
            process_pid: Some(event.process_id),
            verdict: None,
            mitre_ids: event.mitre_techniques.clone(),
            remediation: vec![format!("Kill process {} (PID {})", event.process_name, event.process_id)],
            confidence: event.confidence,
        }
    }

    /// Extended analysis that also checks capabilities, cron abuse,
    /// macOS techniques, and writable services.
    pub fn analyze_execution_extended(
        &self, process_name: &str, pid: u32, process_path: &str,
        command_line: &str, user: &str, is_suid: bool,
        privileges: &[String],
    ) -> Option<PrivEscEvent> {
        let mut event = self.analyze_execution(
            process_name, pid, process_path, command_line, user, is_suid, privileges,
        );

        // Enrich with capability abuse
        let cap_hits = Self::detect_capability_abuse(command_line, privileges);
        if !cap_hits.is_empty() {
            if let Some(ref mut ev) = event {
                for (desc, _risk) in &cap_hits {
                    ev.indicators.push(format!("Capability abuse: {}", desc));
                }
                if !ev.techniques.contains(&PrivEscTechnique::CapabilityAbuse) {
                    ev.techniques.push(PrivEscTechnique::CapabilityAbuse);
                    self.stats.write().capability_abuses += 1;
                }
                ev.mitre_techniques.push("T1548".to_string());
            }
        }

        // Enrich with cron abuse
        if let Some((risk, desc)) = Self::detect_cron_abuse(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Cron abuse: {}", desc));
                ev.techniques.push(PrivEscTechnique::ScheduledTaskAbuse);
                ev.mitre_techniques.push("T1053.003".to_string());
            }
        }

        // Enrich with macOS escalation
        let macos_hits = Self::detect_macos_escalation(command_line);
        if !macos_hits.is_empty() {
            if let Some(ref mut ev) = event {
                for (desc, _risk) in &macos_hits {
                    ev.indicators.push(format!("macOS escalation: {}", desc));
                }
                if !ev.techniques.contains(&PrivEscTechnique::MacOSEntitlement) {
                    ev.techniques.push(PrivEscTechnique::MacOSEntitlement);
                }
            }
        }

        // Enrich with writable service detection
        if let Some((risk, desc)) = Self::detect_writable_service(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Writable service: {}", desc));
                if !ev.techniques.contains(&PrivEscTechnique::ServiceWeakness) {
                    ev.techniques.push(PrivEscTechnique::ServiceWeakness);
                    self.stats.write().service_weaknesses += 1;
                }
                ev.mitre_techniques.push("T1574.010".to_string());
            }
        }

        // If we produced an event, build and queue the alert
        if let Some(ref ev) = event {
            let alert = self.build_alert(ev);
            let mut alerts = self.alerts.write();
            if alerts.len() >= MAX_EVENTS_QUEUE { alerts.pop_front(); }
            alerts.push_back(alert);
        }

        event
    }

    /// Drain all pending alerts.
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        let mut alerts = self.alerts.write();
        alerts.drain(..).collect()
    }

    pub fn update_config(&self, config: PrivEscConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> PrivEscStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
