//! Module 173: UnifiedAlertOrchestrator — Central Alert Pipeline with AI Remediation
//!
//! Bridges ALL 172 sentinel-malware module outputs into a unified `MalwareAlert`
//! stream with AI-generated remediation guidance. Solves the gap where the original
//! 1–100 modules return raw detection types (`ScanResult`, `SignatureMatch`,
//! `ScriptAnalysis`, etc.) without standardized alerts or remediation steps.
//!
//! ## Capabilities
//!
//! ### Input Adapters
//! - **ScanResult adapter** — converts file scan verdicts to alerts
//! - **ProcessSnapshot adapter** — converts process anomalies to alerts
//! - **LaunchItem adapter** — converts persistence findings to alerts
//! - **ScriptAnalysis adapter** — converts script deobfuscation findings to alerts
//! - **ArchiveAnalysis adapter** — converts archive bomb/nested threat findings
//! - **ReputationResult adapter** — converts hash reputation lookups
//! - **ProtectionStatus adapter** — converts missing protections to advisories
//! - **Raw MalwareAlert passthrough** — modules 110–172 already produce these
//!
//! ### AI Remediation Engine (Claude-Powered)
//! - **Claude LLM remediation** — Pro-tier users get Claude-generated step-by-step
//!   remediation via `sentinel-endpoint::RemediationEngine` → Beaver Warrior server
//!   → Anthropic Claude API, with caching and heuristic fallback
//! - **Threat-class remediation** — maps ScanVerdict variants to actionable steps
//! - **MITRE-guided remediation** — uses technique IDs to suggest defenses
//! - **Severity-scaled response** — Critical → auto-quarantine, Low → monitor
//! - **Context-aware actions** — file path, process tree, persistence type
//! - **Confidence-weighted priority** — high-confidence alerts get immediate action
//! - **Deduplication** — suppresses repeat alerts within configurable window
//! - **Escalation rules** — repeated medium alerts escalate to high
//!
//! ### Alert Routing
//! - Central priority queue (Critical → High → Medium → Low → Info)
//! - Per-module alert counters and rate limiting
//! - Configurable retention and auto-purge
//! - Bulk drain for SIEM/log forwarding
//!
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use crate::auto_remediator::{
    AutoRemediator, ActionType, RemediationTarget,
    RemediationRequest as AutoRemediationRequest, RemediationReport,
};
// Adapter imports for modules 16–45
use crate::memory_scanner::{MemoryScanResult, MemoryVerdict};
use crate::process_injection_detector::InjectionAlert;
use crate::process_tree_analyzer::TreeAnomaly;
use crate::lolbin_detector::LolBinDetection;
use crate::behavioral_ioc_engine::BehavioralMatch;
use crate::tcc_monitor::TccAlert;
use crate::gatekeeper_bypass_detector::GatekeeperAlert;
use crate::dylib_hijack_detector::DylibHijackAlert;
use crate::firmware_integrity_checker::{FirmwareScanResult, FirmwareStatus};
use crate::binary_provenance_verifier::BinaryVerification;
use crate::usb_device_controller::DeviceEvent;
use crate::bluetooth_guard::BtAlert;
use crate::packer_detector::PackerAnalysis;
use crate::polymorphic_analyzer::PolymorphicAnalysis;
use crate::time_bomb_detector::TimeBombAnalysis;
use crate::c2_beacon_detector::BeaconDetection;
use crate::ja3_fingerprinter::FingerprintMatch;
use crate::attack_chain_correlator::SecurityEvent;
use sentinel_endpoint::remediation::{RemediationEngine, RemediationRequest, RemediationResponse};
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, BTreeMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ──────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 100_000;
const STATS_WINDOW: usize = 1024;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 512;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

const DEDUP_WINDOW_SECS: i64 = 300;
const ESCALATION_THRESHOLD: u32 = 5;
const MAX_ALERTS_PER_MODULE_PER_MIN: u32 = 100;
const ALERT_RETENTION_MAX: usize = 50_000;

// ── Remediation Knowledge Base ─────────────────────────────────────────────────

const REMEDIATION_RANSOMWARE: &[&str] = &[
    "IMMEDIATE: Isolate endpoint from network to prevent lateral spread",
    "Terminate all processes associated with the ransomware family",
    "Snapshot current disk state for forensic preservation",
    "Check for Volume Shadow Copy availability (may allow file recovery)",
    "Restore affected files from latest verified clean backup",
    "Scan all mapped network drives and shared folders for encryption artifacts",
    "Reset credentials for all accounts that were active on this endpoint",
    "Submit sample hash to threat intel for campaign attribution",
    "Block associated C2 domains/IPs at network perimeter",
    "File incident report and engage IR team for full scope assessment",
];

const REMEDIATION_ROOTKIT: &[&str] = &[
    "CRITICAL: Assume full system compromise — do not trust local tools",
    "Boot from known-clean external media for forensic analysis",
    "Capture full memory dump before any remediation",
    "Compare running kernel modules against known-good baseline",
    "Check for modified system binaries (ls, ps, netstat, ss, top)",
    "Verify SIP status and boot chain integrity on macOS",
    "Re-image the endpoint from verified golden image",
    "Rotate ALL credentials that were accessible from this endpoint",
    "Audit all systems this endpoint communicated with in last 30 days",
    "Deploy EDR with kernel-level visibility on replacement system",
];

const REMEDIATION_EXPLOIT: &[&str] = &[
    "Quarantine the exploit payload immediately",
    "Check if the targeted vulnerability (CVE) is patched on this endpoint",
    "Apply emergency patch or virtual patch if available",
    "Scan for post-exploitation artifacts (webshells, backdoors, persistence)",
    "Review process tree for child processes spawned by exploited application",
    "Check for privilege escalation indicators",
    "Audit network connections made by the exploited process",
    "Update WAF/IDS signatures for this exploit technique",
    "Report to vendor if this is a zero-day exploit",
];

const REMEDIATION_MALICIOUS: &[&str] = &[
    "Quarantine the malicious file immediately",
    "Terminate any running processes from this binary",
    "Check for persistence mechanisms installed by this malware",
    "Scan for related IOCs (hashes, domains, IPs) across all endpoints",
    "Review recent file system changes for additional dropped payloads",
    "Check scheduled tasks, cron jobs, and launch agents for persistence",
    "Submit sample to sandbox for behavioral analysis if not already classified",
    "Block associated network IOCs at perimeter",
];

const REMEDIATION_SUSPICIOUS: &[&str] = &[
    "Flag file for analyst review within 24 hours",
    "Submit to cloud sandbox for dynamic analysis",
    "Monitor process behavior if currently executing",
    "Check VirusTotal and other multi-engine scanners for community detection",
    "Compare against known-good baseline for this application",
    "Review code signing status and certificate chain",
];

const REMEDIATION_PUP: &[&str] = &[
    "Prompt user for removal consent (PUP may have been intentionally installed)",
    "Remove associated browser extensions and toolbar entries",
    "Clean modified browser settings (homepage, search engine, DNS)",
    "Remove scheduled tasks and startup entries created by this PUP",
    "Scan for bundled additional PUPs often co-installed",
];

const REMEDIATION_PERSISTENCE: &[&str] = &[
    "Analyze the persistence mechanism for signs of malicious intent",
    "Compare against baseline of known-good persistence items",
    "If unauthorized: remove the persistence entry immediately",
    "Check the binary/script referenced by the persistence item",
    "Verify code signature and notarization status of the payload",
    "Audit who/what created this persistence item (process provenance)",
    "Monitor for re-creation after removal (indicates active threat)",
];

const REMEDIATION_PROTECTION_GAP: &[&str] = &[
    "Enable the missing protection feature via system configuration",
    "For SIP: reboot to recovery mode and re-enable with csrutil enable",
    "For ASLR/DEP: recompile affected binaries with security flags",
    "For Gatekeeper: re-enable via spctl --master-enable",
    "For FileVault: enable full-disk encryption immediately",
    "Document the gap and add to compliance exception register if intentional",
    "Schedule follow-up verification within 7 days",
];

const REMEDIATION_REPUTATION_BAD: &[&str] = &[
    "Quarantine the file based on negative reputation data",
    "Block the associated hash across all endpoints via EDR policy",
    "Check for additional files from same threat family",
    "Review download source and block if from known-malicious infrastructure",
    "Alert SOC for campaign-level triage",
];

const REMEDIATION_SCRIPT_OBFUSCATED: &[&str] = &[
    "Deobfuscate and review the script contents for malicious intent",
    "Check execution context: who ran it, from where, with what privileges",
    "If malicious: quarantine and check for persistence mechanisms",
    "Block the obfuscation technique at the script execution policy level",
    "Review osascript/python/bash execution logs for similar patterns",
    "Add YARA rule for the obfuscation pattern to prevent recurrence",
];

const REMEDIATION_ARCHIVE_BOMB: &[&str] = &[
    "Block the archive — likely a zip bomb or decompression attack",
    "Do NOT extract the archive on any production system",
    "Check if any extraction was already attempted (may have filled disk)",
    "Free disk space if extraction caused space exhaustion",
    "Report the archive hash to threat intel feeds",
    "Update archive scanning policy to enforce max decompression ratio",
];

// ── MITRE Technique to Remediation Mapping ─────────────────────────────────────

const MITRE_REMEDIATION: &[(&str, &str)] = &[
    ("T1059", "Restrict script execution via application allowlisting; enable PowerShell constrained language mode"),
    ("T1055", "Enable process integrity monitoring; deploy EMET/Exploit Guard; monitor for injection APIs"),
    ("T1053", "Audit scheduled tasks/cron; restrict task creation to administrators"),
    ("T1547", "Monitor boot/logon persistence locations; alert on new auto-start entries"),
    ("T1543", "Restrict service creation permissions; monitor for new LaunchDaemons/Agents"),
    ("T1068", "Apply latest security patches; enable kernel exploit mitigations"),
    ("T1071", "Deploy SSL/TLS inspection; monitor for beaconing patterns in network traffic"),
    ("T1486", "Maintain offline backups; deploy canary files for early ransomware detection"),
    ("T1027", "Deploy content inspection at email/web gateways; enable AMSI on Windows"),
    ("T1021", "Enforce MFA on all remote access; restrict lateral movement protocols"),
    ("T1048", "Monitor for unusual outbound data volumes; enforce DLP policies"),
    ("T1082", "Monitor for reconnaissance commands (whoami, systeminfo, ifconfig)"),
    ("T1005", "Deploy DLP; monitor clipboard and file access to sensitive paths"),
    ("T1566", "Enable email link/attachment scanning; deploy phishing-resistant MFA"),
    ("T1204", "Conduct user awareness training; enable protected view for documents"),
    ("T1562", "Monitor for security tool tampering; protect AV/EDR with tamper protection"),
    ("T1555", "Monitor keychain/credential store access; enforce credential guard"),
    ("T1036", "Verify binary signatures; alert on name-path mismatches"),
    ("T1497", "Detect sandbox evasion techniques; use bare-metal analysis for evasive samples"),
    ("T1014", "Boot from trusted media for rootkit detection; verify kernel integrity"),
    ("T1070", "Enable immutable logging; forward logs to remote SIEM in real-time"),
    ("T1112", "Monitor registry/plist changes; enforce configuration baselines"),
    ("T1078", "Enforce MFA; monitor for impossible-travel logins; rotate compromised credentials"),
    ("T1190", "Apply web application patches; deploy WAF; restrict service exposure"),
    ("T1110", "Enforce account lockout policies; deploy credential stuffing detection"),
    ("T1003", "Enable credential guard; monitor LSASS/keychain access"),
    ("T1569", "Restrict service execution permissions; monitor for suspicious service starts"),
    ("T1105", "Monitor and restrict file downloads; inspect transferred files at gateway"),
    ("T1095", "Monitor for non-standard protocol usage on common ports"),
    ("T1571", "Block known-bad ports; detect protocol-port mismatches"),
];

// ── Privacy Levels ──────────────────────────────────────────────────────────

/// Controls how much alert data leaves the device when requesting Claude remediation.
///
/// All levels still call the cloud — the difference is *what* Claude sees.
/// Even at `Maximum`, Claude receives enough threat semantics to generate
/// high-quality remediation steps.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum PrivacyLevel {
    /// **Maximum privacy.** Claude sees ONLY:
    ///   - Threat category (ransomware, rootkit, exploit, etc.)
    ///   - Severity level
    ///   - MITRE ATT&CK technique IDs
    ///   - File type (e.g. ".exe", ".sh") — NOT the filename or path
    ///   - Generic process category ("browser", "shell", "system") — NOT the name
    ///
    /// Zero paths, zero hostnames, zero IPs, zero PIDs, zero filenames.
    /// Claude can still give excellent remediation from threat semantics alone.
    Maximum,

    /// **Anonymized.** Scrubs PII (usernames, hostnames, private IPs, emails)
    /// but preserves alert structure, sanitized paths, and process details.
    /// Good balance of context and privacy.
    Anonymized,

    /// **Full.** Raw alert data sent as-is. Only use in air-gapped or trusted
    /// environments where data leaving the device is acceptable.
    Full,
}

impl Default for PrivacyLevel {
    fn default() -> Self { PrivacyLevel::Maximum }
}

// ── Remediation Sanitizer ───────────────────────────────────────────────────

/// Scrubs remediation requests based on the configured privacy level.
pub struct RemediationSanitizer {
    os_username: Option<String>,
    hostname: Option<String>,
    custom_redactions: Vec<String>,
}

impl RemediationSanitizer {
    pub fn new() -> Self {
        let os_username = std::env::var("HOME").ok().and_then(|home| {
            let parts: Vec<&str> = home.split('/').collect();
            parts.iter().rev().find(|p| !p.is_empty()).map(|s| s.to_string())
        });

        let hostname = std::env::var("HOSTNAME")
            .or_else(|_| std::env::var("COMPUTERNAME"))
            .ok()
            .or_else(|| {
                let _sys = sysinfo::System::new();
                sysinfo::System::host_name()
            });

        Self { os_username, hostname, custom_redactions: Vec::new() }
    }

    /// Add a custom string that should always be redacted (Anonymized & Maximum).
    pub fn add_custom_redaction(&mut self, value: String) {
        if !value.is_empty() { self.custom_redactions.push(value); }
    }

    /// Apply Anonymized-level scrubbing: replace usernames, hostnames,
    /// private IPs, and emails but keep alert structure.
    pub fn scrub_anonymized(&self, input: &str) -> String {
        let mut out = input.to_string();

        if let Some(ref user) = self.os_username {
            out = out.replace(&format!("/Users/{}", user), "/Users/[USER]");
            out = out.replace(&format!("/home/{}", user), "/home/[USER]");
            out = out.replace(user.as_str(), "[USER]");
        }
        if let Some(ref host) = self.hostname {
            if host.len() >= 3 { out = out.replace(host.as_str(), "[HOST]"); }
        }
        out = Self::redact_private_ips(&out);
        out = Self::redact_emails(&out);
        for custom in &self.custom_redactions {
            out = out.replace(custom.as_str(), "[REDACTED]");
        }
        out
    }

    /// Apply Anonymized-level scrubbing to a RemediationRequest in place.
    pub fn scrub_anonymized_request(&self, req: &mut RemediationRequest) {
        req.title = self.scrub_anonymized(&req.title);
        req.details = self.scrub_anonymized(&req.details);
        req.component = self.scrub_anonymized(&req.component);
    }

    /// Extract just the file extension from a path, e.g. "/foo/bar.exe" → ".exe"
    pub fn path_to_file_type(path: &str) -> &str {
        if let Some(dot_pos) = path.rfind('.') {
            let ext = &path[dot_pos..];
            // Only return if it looks like an extension (< 10 chars, no slashes)
            if ext.len() <= 10 && !ext.contains('/') { return ext; }
        }
        "unknown"
    }

    /// Classify a path into a generic location category.
    pub fn path_to_location(path: &str) -> &str {
        let p = path.to_lowercase();
        if p.contains("/downloads") { "user downloads directory" }
        else if p.contains("/documents") { "user documents directory" }
        else if p.contains("/desktop") { "user desktop" }
        else if p.contains("/applications") || p.contains("/app") { "applications directory" }
        else if p.contains("/library/launchagents") { "launch agents directory" }
        else if p.contains("/library/launchdaemons") { "launch daemons directory" }
        else if p.contains("/library") { "library directory" }
        else if p.contains("/tmp") || p.contains("/temp") { "temp directory" }
        else if p.contains("/bin") || p.contains("/sbin") { "system binaries directory" }
        else if p.contains("/etc") { "system config directory" }
        else if p.contains("/var") { "system var directory" }
        else if p.contains("/usr") { "system usr directory" }
        else if p.contains("/system") { "system directory" }
        else { "file system" }
    }

    /// Generalize a process name into a non-identifying category.
    pub fn generalize_process(name: &str) -> &str {
        let n = name.to_lowercase();
        // Browsers
        if n.contains("safari") || n.contains("chrome") || n.contains("firefox")
            || n.contains("brave") || n.contains("edge") || n.contains("opera") || n.contains("webkit") {
            return "browser process";
        }
        // Shells
        if n.contains("bash") || n.contains("zsh") || n.contains("sh") || n.contains("fish")
            || n.contains("terminal") || n.contains("iterm") || n.contains("powershell")
            || n.contains("cmd") { return "shell/terminal process"; }
        // Mail
        if n.contains("mail") || n.contains("outlook") || n.contains("thunderbird") {
            return "email client process";
        }
        // Editors / IDEs
        if n.contains("code") || n.contains("xcode") || n.contains("vim") || n.contains("emacs")
            || n.contains("sublime") || n.contains("intellij") || n.contains("cursor") {
            return "editor/IDE process";
        }
        // System
        if n.contains("launchd") || n.contains("kernel") || n.contains("syslog")
            || n.contains("cron") || n.contains("init") || n.contains("systemd") {
            return "system process";
        }
        // Scripting
        if n.contains("python") || n.contains("ruby") || n.contains("node")
            || n.contains("perl") || n.contains("osascript") || n.contains("java") {
            return "scripting runtime";
        }
        // Network daemons
        if n.contains("sshd") || n.contains("httpd") || n.contains("nginx")
            || n.contains("apache") || n.contains("postgres") || n.contains("mysql") {
            return "network service";
        }
        "process"
    }

    /// Build a Maximum-privacy request: only threat semantics, zero specifics.
    pub fn build_maximum_privacy_request(
        alert: &MalwareAlert,
    ) -> RemediationRequest {
        let severity = format!("{:?}", alert.severity);
        let component = alert.module.clone();

        // Title: keep the threat category but strip any specific identifiers
        let title = alert.title.clone();

        // Details: only threat semantics
        let file_type = alert.path.as_deref()
            .map(|p| Self::path_to_file_type(p))
            .unwrap_or("N/A");
        let location = alert.path.as_deref()
            .map(|p| Self::path_to_location(p))
            .unwrap_or("N/A");
        let process_category = alert.process_name.as_deref()
            .map(|p| Self::generalize_process(p))
            .unwrap_or("N/A");
        let mitre = if alert.mitre_ids.is_empty() {
            "N/A".to_string()
        } else {
            alert.mitre_ids.join(", ")
        };
        let verdict_str = alert.verdict.as_ref()
            .map(|v| format!("{:?}", v))
            .unwrap_or_else(|| "Unknown".to_string());

        let details = format!(
            "Verdict: {}\nFile type: {}\nLocation: {}\nOriginating process type: {}\n\
             MITRE ATT&CK: {}\nConfidence: {:.0}%",
            verdict_str, file_type, location, process_category,
            mitre, alert.confidence * 100.0,
        );

        RemediationRequest { severity, component, title, details }
    }

    fn redact_private_ips(input: &str) -> String {
        let mut output = String::with_capacity(input.len());
        let chars: Vec<char> = input.chars().collect();
        let mut i = 0;
        while i < chars.len() {
            if chars[i].is_ascii_digit() {
                let mut segments = Vec::new();
                let mut current = String::new();
                let mut j = i;
                while j < chars.len() && (chars[j].is_ascii_digit() || chars[j] == '.') {
                    if chars[j] == '.' {
                        segments.push(current.clone());
                        current.clear();
                    } else {
                        current.push(chars[j]);
                    }
                    j += 1;
                }
                if !current.is_empty() { segments.push(current); }
                if segments.len() == 4 {
                    let octets: Vec<Option<u16>> = segments.iter()
                        .map(|s| s.parse::<u16>().ok().filter(|&v| v <= 255))
                        .collect();
                    if octets.iter().all(|o| o.is_some()) {
                        let o: Vec<u16> = octets.into_iter().map(|o| o.unwrap()).collect();
                        let is_private = (o[0] == 10)
                            || (o[0] == 172 && o[1] >= 16 && o[1] <= 31)
                            || (o[0] == 192 && o[1] == 168)
                            || (o[0] == 127);
                        if is_private {
                            output.push_str("[PRIVATE_IP]");
                            i = j;
                            continue;
                        }
                    }
                }
            }
            output.push(chars[i]);
            i += 1;
        }
        output
    }

    fn redact_emails(input: &str) -> String {
        let mut output = input.to_string();
        let indicators = ["@gmail.", "@yahoo.", "@hotmail.", "@outlook.",
            "@protonmail.", "@icloud.", "@aol.", "@mail.", "@live.",
            "@company.", "@corp.", "@org.", "@edu."];
        for indicator in &indicators {
            while let Some(at_pos) = output.to_lowercase().find(indicator) {
                let start = output[..at_pos]
                    .rfind(|c: char| c.is_whitespace() || c == '<' || c == '(' || c == ',')
                    .map(|p| p + 1)
                    .unwrap_or(0);
                let after_at = at_pos + indicator.len();
                let end = output[after_at..]
                    .find(|c: char| c.is_whitespace() || c == '>' || c == ')' || c == ',')
                    .map(|p| after_at + p)
                    .unwrap_or(output.len());
                if end > start {
                    output.replace_range(start..end, "[EMAIL]");
                } else {
                    break;
                }
            }
        }
        output
    }
}

// ── Statistics ─────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct OrchestratorStats {
    pub total_alerts_generated: u64,
    pub total_scan_results_ingested: u64,
    pub total_process_alerts: u64,
    pub total_persistence_alerts: u64,
    pub total_script_alerts: u64,
    pub total_archive_alerts: u64,
    pub total_reputation_alerts: u64,
    pub total_protection_alerts: u64,
    pub total_passthrough_alerts: u64,
    pub total_deduplicated: u64,
    pub total_escalated: u64,
    pub total_rate_limited: u64,
    pub alerts_by_severity: [u64; 5],
    pub alerts_by_module: HashMap<String, u64>,
}

// ── Dedup Entry ────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct DedupKey {
    module: String,
    title_hash: u64,
    last_seen: i64,
    count: u32,
}

// ── Paged Signature Entry ──────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RemediationEntry {
    pub threat_class: String,
    pub steps: Vec<String>,
}

// ── Core Orchestrator ──────────────────────────────────────────────────────────

pub struct UnifiedAlertOrchestrator {
    running: Arc<AtomicBool>,
    // 13 breakthroughs
    state_history: RwLock<HierarchicalState<OrchestratorStats>>,
    alert_cache: TieredCache<String, MalwareAlert>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    alert_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, OrchestratorStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_alerts: RwLock<PruningMap<String, MalwareAlert>>,
    remediation_db: PagedMemory<RemediationEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    module_matrix: RwLock<SparseMatrix<String, String, u64>>,
    // Alert pipeline
    alert_queue: RwLock<VecDeque<MalwareAlert>>,
    dedup_window: RwLock<HashMap<u64, DedupKey>>,
    module_rate: RwLock<HashMap<String, (u32, i64)>>,
    stats: RwLock<OrchestratorStats>,
    total_alerts: AtomicU64,
    // MITRE remediation index
    mitre_remediation: HashMap<String, String>,
    compressed_archive: RwLock<HashMap<String, Vec<u8>>>,
    // Privacy
    sanitizer: RemediationSanitizer,
    privacy_level: RwLock<PrivacyLevel>,
}

impl UnifiedAlertOrchestrator {
    pub fn new() -> Self {
        let mut mitre_map = HashMap::new();
        for &(technique, remediation) in MITRE_REMEDIATION {
            mitre_map.insert(technique.to_string(), remediation.to_string());
        }

        Self {
            running: Arc::new(AtomicBool::new(true)),
            state_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            alert_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            alert_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, OrchestratorStats::default(),
                |acc: &mut OrchestratorStats, vals: &[f64]| { acc.total_alerts_generated += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(128 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_alerts: RwLock::new(PruningMap::new(CACHE_MAX)),
            remediation_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            module_matrix: RwLock::new(SparseMatrix::new(0u64)),
            alert_queue: RwLock::new(VecDeque::with_capacity(1024)),
            dedup_window: RwLock::new(HashMap::new()),
            module_rate: RwLock::new(HashMap::new()),
            stats: RwLock::new(OrchestratorStats::default()),
            total_alerts: AtomicU64::new(0),
            mitre_remediation: mitre_map,
            compressed_archive: RwLock::new(HashMap::new()),
            sanitizer: RemediationSanitizer::new(),
            privacy_level: RwLock::new(PrivacyLevel::Maximum),
        }
    }

    // ── Adapter: ScanResult → MalwareAlert ─────────────────────────────────

    pub fn ingest_scan_result(&self, result: &ScanResult, module: &str) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if matches!(result.verdict, ScanVerdict::Clean) { return None; }

        let severity = result.verdict.severity();
        let (title, remediation) = self.remediation_for_verdict(&result.verdict, &result.path);
        let confidence = self.confidence_for_verdict(&result.verdict);

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity: severity.clone(),
            module: module.to_string(),
            title,
            details: format!(
                "File: {} | SHA256: {} | BLAKE3: {} | Size: {} bytes | Entropy: {:.2} | Engines: {}",
                result.path, result.hash_sha256, result.hash_blake3,
                result.size_bytes, result.entropy,
                result.engines_matched.join(", ")
            ),
            path: Some(result.path.clone()),
            process_name: None,
            process_pid: None,
            verdict: Some(result.verdict.clone()),
            mitre_ids: result.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &result.mitre_ids),
            confidence,
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_scan_results_ingested += 1;
        Some(alert)
    }

    // ── Adapter: ProcessSnapshot → MalwareAlert ────────────────────────────

    pub fn ingest_process_anomaly(
        &self, process: &ProcessSnapshot, reason: &str, severity: Severity,
        mitre_ids: Vec<String>, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let remediation = vec![
            format!("Investigate process {} (PID {}) — {}", process.name, process.pid, reason),
            format!("Check parent process PID {} for signs of compromise", process.ppid),
            format!("Review command line: {}", process.cmdline),
            "Capture memory dump of the process for forensic analysis".into(),
            if process.hidden {
                "CRITICAL: Process is hidden — strong rootkit indicator. Boot from clean media.".into()
            } else {
                "Check loaded libraries for unsigned or injected modules".into()
            },
            "Review open files and network connections for data exfiltration".into(),
            "If malicious: terminate process tree and quarantine binary".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity: severity.clone(),
            module: module.to_string(),
            title: format!("Process anomaly: {} (PID {}) — {}", process.name, process.pid, reason),
            details: format!(
                "Exe: {} | User: {} | Signed: {:?} | Hidden: {} | Open ports: {:?} | Loaded libs: {}",
                process.exe_path, process.user, process.signed, process.hidden,
                process.open_ports, process.loaded_libs.len()
            ),
            path: Some(process.exe_path.clone()),
            process_name: Some(process.name.clone()),
            process_pid: Some(process.pid),
            verdict: None,
            mitre_ids: mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &mitre_ids),
            confidence: if process.hidden { 0.95 } else { 0.7 },
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_process_alerts += 1;
        Some(alert)
    }

    // ── Adapter: LaunchItem → MalwareAlert ─────────────────────────────────

    pub fn ingest_persistence_finding(
        &self, item: &LaunchItem, reason: &str, severity: Severity,
        mitre_ids: Vec<String>, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let mut remediation = REMEDIATION_PERSISTENCE.iter().map(|s| s.to_string()).collect::<Vec<_>>();
        remediation.insert(0, format!(
            "Investigate {:?} '{}' at path: {}", item.item_type, item.label, item.path
        ));
        if item.signed == Some(false) {
            remediation.push("WARNING: Binary is NOT code-signed — high risk".into());
        }
        if item.risk_score > 0.8 {
            remediation.push(format!("Risk score {:.2} exceeds threshold — recommend immediate removal", item.risk_score));
        }

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity: severity.clone(),
            module: module.to_string(),
            title: format!("Suspicious persistence: {:?} '{}' — {}", item.item_type, item.label, reason),
            details: format!(
                "Path: {} | Program: {:?} | Args: {:?} | RunAtLoad: {} | Signed: {:?} | Signer: {:?} | Risk: {:.2}",
                item.path, item.program, item.program_arguments,
                item.run_at_load, item.signed, item.signer, item.risk_score
            ),
            path: Some(item.path.clone()),
            process_name: item.program.clone(),
            process_pid: None,
            verdict: None,
            mitre_ids: mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &mitre_ids),
            confidence: item.risk_score.min(1.0),
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_persistence_alerts += 1;
        Some(alert)
    }

    // ── Adapter: ScriptAnalysis → MalwareAlert ─────────────────────────────

    pub fn ingest_script_analysis(
        &self, analysis: &ScriptAnalysis, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if matches!(analysis.verdict, ScanVerdict::Clean) { return None; }

        let severity = analysis.verdict.severity();
        let mut remediation = REMEDIATION_SCRIPT_OBFUSCATED.iter().map(|s| s.to_string()).collect::<Vec<_>>();
        remediation.insert(0, format!(
            "Analyze {:?} script at: {}", analysis.language, analysis.path
        ));
        if !analysis.urls_found.is_empty() {
            remediation.push(format!("Block extracted URLs: {}", analysis.urls_found.join(", ")));
        }
        if !analysis.ips_found.is_empty() {
            remediation.push(format!("Block extracted IPs: {}", analysis.ips_found.join(", ")));
        }

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity,
            module: module.to_string(),
            title: format!(
                "Suspicious {:?} script — obfuscation: {:.0}%, {} suspicious APIs",
                analysis.language, analysis.obfuscation_score * 100.0,
                analysis.suspicious_apis.len()
            ),
            details: format!(
                "Path: {} | Entropy: {:.2} | Obfuscation: {:.2} | Techniques: {} | URLs: {} | IPs: {} | Payloads: {}",
                analysis.path, analysis.entropy, analysis.obfuscation_score,
                analysis.obfuscation_techniques.join(", "),
                analysis.urls_found.len(), analysis.ips_found.len(),
                analysis.encoded_payloads.len()
            ),
            path: Some(analysis.path.clone()),
            process_name: None, process_pid: None,
            verdict: Some(analysis.verdict.clone()),
            mitre_ids: vec!["T1059".into(), "T1027".into()],
            remediation,
            confidence: analysis.obfuscation_score.max(0.5),
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_script_alerts += 1;
        Some(alert)
    }

    // ── Adapter: ArchiveAnalysis → MalwareAlert ────────────────────────────

    pub fn ingest_archive_analysis(
        &self, analysis: &ArchiveAnalysis, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if analysis.suspicious_entries.is_empty() && !analysis.zip_bomb_detected { return None; }

        let severity = if analysis.zip_bomb_detected { Severity::High }
            else if analysis.suspicious_entries.len() > 3 { Severity::High }
            else { Severity::Medium };

        let mut remediation = if analysis.zip_bomb_detected {
            REMEDIATION_ARCHIVE_BOMB.iter().map(|s| s.to_string()).collect::<Vec<_>>()
        } else {
            vec![
                format!("Review {} suspicious entries in {:?} archive", analysis.suspicious_entries.len(), analysis.format),
                "Extract and scan each suspicious entry in isolated sandbox".into(),
                "Check for path traversal (../) in entry names".into(),
                "Verify archive source and delivery mechanism".into(),
            ]
        };
        if analysis.nested_depth > 3 {
            remediation.push(format!("Deep nesting detected ({} levels) — possible evasion technique", analysis.nested_depth));
        }

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity,
            module: module.to_string(),
            title: format!(
                "{:?} archive threat: {} suspicious entries{}",
                analysis.format, analysis.suspicious_entries.len(),
                if analysis.zip_bomb_detected { " + ZIP BOMB" } else { "" }
            ),
            details: format!(
                "Path: {} | Entries: {} | Nested depth: {} | Password: {} | Ratio: {:.1}x | Uncompressed: {} bytes",
                analysis.path, analysis.total_entries, analysis.nested_depth,
                analysis.password_protected, analysis.compression_ratio,
                analysis.total_uncompressed_bytes
            ),
            path: Some(analysis.path.clone()),
            process_name: None, process_pid: None,
            verdict: None,
            mitre_ids: vec!["T1204.002".into(), "T1027".into()],
            remediation,
            confidence: if analysis.zip_bomb_detected { 0.95 } else { 0.7 },
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_archive_alerts += 1;
        Some(alert)
    }

    // ── Adapter: ReputationResult → MalwareAlert ───────────────────────────

    pub fn ingest_reputation_result(
        &self, rep: &ReputationResult, file_path: Option<&str>, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if !matches!(rep.verdict, ReputationVerdict::KnownMalicious | ReputationVerdict::Suspicious) {
            return None;
        }

        let severity = match rep.verdict {
            ReputationVerdict::KnownMalicious => Severity::Critical,
            ReputationVerdict::Suspicious => Severity::Medium,
            _ => Severity::Info,
        };
        let remediation = if matches!(rep.verdict, ReputationVerdict::KnownMalicious) {
            REMEDIATION_REPUTATION_BAD.iter().map(|s| s.to_string()).collect()
        } else {
            vec![
                "Submit file to multi-engine scanner for additional analysis".into(),
                "Monitor the file's behavior if it is currently executing".into(),
                "Flag for analyst review".into(),
            ]
        };

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity,
            module: module.to_string(),
            title: format!(
                "Reputation alert: {:?} — {} detections from {} submissions",
                rep.verdict, rep.detection_count, rep.total_submissions
            ),
            details: format!(
                "Hash: {} | Family: {:?} | Source: {} | Tags: {} | First seen: {:?}",
                rep.hash, rep.family, rep.source, rep.tags.join(", "), rep.first_seen
            ),
            path: file_path.map(|s| s.to_string()),
            process_name: None, process_pid: None,
            verdict: None,
            mitre_ids: vec![],
            remediation,
            confidence: (rep.detection_count as f64 / rep.total_submissions.max(1) as f64).min(1.0),
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_reputation_alerts += 1;
        Some(alert)
    }

    // ── Adapter: ProtectionStatus → MalwareAlert ───────────────────────────

    pub fn ingest_protection_gap(
        &self, status: &ProtectionStatus, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if status.enabled { return None; }

        let severity = match status.feature {
            ProtectionFeature::SIP => Severity::Critical,
            ProtectionFeature::DEP | ProtectionFeature::ASLR => Severity::High,
            ProtectionFeature::StackCanary | ProtectionFeature::Hardened => Severity::Medium,
            _ => Severity::Low,
        };

        let mut remediation = REMEDIATION_PROTECTION_GAP.iter().map(|s| s.to_string()).collect::<Vec<_>>();
        if let Some(ref rec) = status.recommendation {
            remediation.insert(0, format!("Vendor recommendation: {}", rec));
        }

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            severity,
            module: module.to_string(),
            title: format!("Protection gap: {:?} is DISABLED", status.feature),
            details: format!("Feature: {:?} | Status: disabled | Details: {}", status.feature, status.details),
            path: None, process_name: None, process_pid: None,
            verdict: None,
            mitre_ids: vec!["T1562".into()],
            remediation,
            confidence: 1.0,
        };

        self.emit_alert(alert.clone());
        self.stats.write().total_protection_alerts += 1;
        Some(alert)
    }

    // ── Adapter: MemoryScanResult → MalwareAlert (Module 16) ────────────────

    pub fn ingest_memory_scan(
        &self, result: &MemoryScanResult, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if matches!(result.verdict, MemoryVerdict::Clean) { return None; }

        let (severity, title) = match &result.verdict {
            MemoryVerdict::Malicious { technique, details } => (
                Severity::Critical,
                format!("In-memory threat: {} in {} (PID {}) — {}", technique, result.process_name, result.pid, details),
            ),
            MemoryVerdict::Suspicious { score, reasons } => (
                if *score > 0.8 { Severity::High } else { Severity::Medium },
                format!("Suspicious memory in {} (PID {}) — score {:.0}%: {}", result.process_name, result.pid, score * 100.0, reasons.join(", ")),
            ),
            MemoryVerdict::Clean => unreachable!(),
        };

        let details = format!(
            "PID: {} | Process: {} | Findings: {} | Risk: {:.2} | Duration: {}μs | MITRE: {}",
            result.pid, result.process_name, result.findings.len(), result.risk_score,
            result.scan_duration_us, result.mitre_ids.join(", ")
        );
        let remediation = vec![
            format!("Investigate process {} (PID {}) for fileless malware", result.process_name, result.pid),
            "Capture full memory dump for forensic analysis".into(),
            "Check for shellcode, RWX regions, and injected code".into(),
            "If confirmed: terminate process tree and quarantine binary".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
            severity, module: module.to_string(), title, details,
            path: None, process_name: Some(result.process_name.clone()), process_pid: Some(result.pid),
            verdict: None, mitre_ids: result.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &result.mitre_ids),
            confidence: result.risk_score.min(1.0),
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: InjectionAlert → MalwareAlert (Module 17) ────────────────

    pub fn ingest_injection_alert(
        &self, inj: &InjectionAlert, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!(
            "Process injection: {:?} into {} (PID {})",
            inj.technique, inj.target_name, inj.target_pid
        );
        let details = format!(
            "Target: {} (PID {}) | Source: {} (PID {:?}) | Technique: {:?} | Evidence: {} | Confidence: {:.0}%",
            inj.target_name, inj.target_pid,
            inj.source_name.as_deref().unwrap_or("unknown"),
            inj.source_pid, inj.technique, inj.evidence.join("; "), inj.confidence * 100.0,
        );
        let remediation = vec![
            format!("Terminate target process {} (PID {})", inj.target_name, inj.target_pid),
            format!("Investigate source process {:?} for compromise", inj.source_name),
            "Capture memory dump of injected process".into(),
            "Review loaded modules for unsigned or suspicious libraries".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: inj.timestamp,
            severity: inj.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: Some(inj.target_name.clone()), process_pid: Some(inj.target_pid),
            verdict: None, mitre_ids: inj.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &inj.mitre_ids),
            confidence: inj.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: TreeAnomaly → MalwareAlert (Module 18) ───────────────────

    pub fn ingest_tree_anomaly(
        &self, anomaly: &TreeAnomaly, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!(
            "Process tree anomaly: {:?} — {} (PID {})",
            anomaly.anomaly_type, anomaly.process_name, anomaly.pid
        );
        let details = format!(
            "PID: {} | Process: {} | Type: {:?} | Chain: {} | {}",
            anomaly.pid, anomaly.process_name, anomaly.anomaly_type,
            anomaly.chain.join(" → "), anomaly.details
        );
        let remediation = vec![
            format!("Investigate process {} (PID {}) — {}", anomaly.process_name, anomaly.pid, anomaly.details),
            "Review entire process spawn chain for anomalies".into(),
            "Check parent process legitimacy".into(),
            "If suspicious: terminate process tree and collect forensics".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
            severity: anomaly.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: Some(anomaly.process_name.clone()), process_pid: Some(anomaly.pid),
            verdict: None, mitre_ids: anomaly.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &anomaly.mitre_ids),
            confidence: anomaly.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: LolBinDetection → MalwareAlert (Module 19) ──────────────

    pub fn ingest_lolbin_detection(
        &self, det: &LolBinDetection, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if det.is_baseline { return None; }

        let title = format!(
            "LOLBin abuse: {} ({:?}) — {}",
            det.binary, det.category, det.description
        );
        let details = format!(
            "PID: {} | Binary: {} | Path: {} | Cmdline: {} | Parent: {} (PID {}) | Patterns: {}",
            det.pid, det.binary, det.full_path, det.cmdline,
            det.parent_name, det.parent_pid, det.matched_patterns.join(", ")
        );
        let remediation = vec![
            format!("Review command: {}", det.cmdline),
            format!("Check parent process {} (PID {}) for compromise", det.parent_name, det.parent_pid),
            "Block abusive command line patterns via application control".into(),
            "If unauthorized: terminate and investigate lateral movement".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: det.timestamp,
            severity: det.severity.clone(), module: module.to_string(), title, details,
            path: Some(det.full_path.clone()), process_name: Some(det.binary.clone()),
            process_pid: Some(det.pid),
            verdict: None, mitre_ids: det.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &det.mitre_ids),
            confidence: det.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: SecurityEvent → MalwareAlert (Module 20) ─────────────────

    pub fn ingest_attack_chain_event(
        &self, event: &SecurityEvent, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: event.timestamp,
            severity: event.severity.clone(), module: module.to_string(),
            title: format!("Attack chain event: {}", event.title),
            details: event.details.clone(),
            path: None, process_name: event.process_name.clone(),
            process_pid: event.pid,
            verdict: None, mitre_ids: event.mitre_ids.clone(),
            remediation: self.enrich_remediation(vec![
                format!("Correlate with other events for kill chain reconstruction"),
                "Check for lateral movement indicators".into(),
                "Review associated network connections".into(),
            ], &event.mitre_ids),
            confidence: event.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: BehavioralMatch → MalwareAlert (Module 21) ──────────────

    pub fn ingest_behavioral_match(
        &self, bmatch: &BehavioralMatch, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!("Behavioral IOC: {} (rule {})", bmatch.rule_name, bmatch.rule_id);
        let details = format!(
            "Rule: {} | Events matched: {} | Weight: {:.2} | {}",
            bmatch.rule_id, bmatch.matched_events.len(), bmatch.weight, bmatch.description
        );
        let remediation = vec![
            format!("Investigate behavioral pattern: {}", bmatch.description),
            format!("Review {} correlated events for full attack context", bmatch.matched_events.len()),
            "Check for persistence mechanisms associated with this behavior".into(),
            "Collect forensic evidence before remediation".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: bmatch.timestamp,
            severity: bmatch.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: None, process_pid: None,
            verdict: None, mitre_ids: bmatch.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &bmatch.mitre_ids),
            confidence: bmatch.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: TccAlert → MalwareAlert (Module 23) ─────────────────────

    pub fn ingest_tcc_alert(
        &self, tcc: &TccAlert, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!(
            "TCC violation: {:?} on {:?} by {}",
            tcc.alert_type, tcc.service, tcc.client
        );
        let details = format!(
            "Service: {:?} | Client: {} | Type: {:?} | {}",
            tcc.service, tcc.client, tcc.alert_type, tcc.details
        );
        let remediation = vec![
            format!("Review TCC access for client: {}", tcc.client),
            format!("Check {:?} permission legitimacy", tcc.service),
            "Audit TCC.db for unauthorized modifications".into(),
            "Revoke suspicious permissions via System Preferences".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: tcc.timestamp,
            severity: tcc.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: Some(tcc.client.clone()), process_pid: None,
            verdict: None, mitre_ids: tcc.mitre_ids.clone(),
            remediation: self.enrich_remediation(remediation, &tcc.mitre_ids),
            confidence: tcc.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: GatekeeperAlert → MalwareAlert (Module 24) ──────────────

    pub fn ingest_gatekeeper_alert(
        &self, gk: &GatekeeperAlert, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!(
            "Gatekeeper bypass: {:?} on {}",
            gk.bypass_type, gk.target_path
        );
        let details = format!(
            "Path: {} | Type: {:?} | Process: {:?} (PID {:?}) | CVE: {:?} | {}",
            gk.target_path, gk.bypass_type, gk.process_name, gk.process_pid,
            gk.cve, gk.details
        );

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: gk.timestamp,
            severity: gk.severity.clone(), module: module.to_string(), title, details,
            path: Some(gk.target_path.clone()), process_name: gk.process_name.clone(),
            process_pid: gk.process_pid,
            verdict: None, mitre_ids: gk.mitre_ids.clone(),
            remediation: self.enrich_remediation(vec![gk.remediation.clone()], &gk.mitre_ids),
            confidence: gk.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: DylibHijackAlert → MalwareAlert (Module 25) ─────────────

    pub fn ingest_dylib_hijack(
        &self, dh: &DylibHijackAlert, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!(
            "Dylib hijack: {:?} on {} via {}",
            dh.hijack_type, dh.target_binary, dh.dylib_path
        );
        let details = format!(
            "Binary: {} | Dylib: {} | Expected: {:?} | Type: {:?} | PID: {:?} | {}",
            dh.target_binary, dh.dylib_path, dh.expected_path,
            dh.hijack_type, dh.process_pid, dh.details
        );

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: dh.timestamp,
            severity: dh.severity.clone(), module: module.to_string(), title, details,
            path: Some(dh.dylib_path.clone()), process_name: Some(dh.target_binary.clone()),
            process_pid: dh.process_pid,
            verdict: None, mitre_ids: dh.mitre_ids.clone(),
            remediation: self.enrich_remediation(vec![dh.remediation.clone()], &dh.mitre_ids),
            confidence: dh.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: FirmwareScanResult → MalwareAlert (Module 37) ────────────

    pub fn ingest_firmware_scan(
        &self, fw: &FirmwareScanResult, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if matches!(fw.overall_status, FirmwareStatus::Verified) && fw.findings.is_empty() { return None; }

        let severity = match fw.overall_status {
            FirmwareStatus::Compromised => Severity::Critical,
            FirmwareStatus::Modified => Severity::High,
            FirmwareStatus::Unknown | FirmwareStatus::Unavailable | FirmwareStatus::BaselineMissing => Severity::Medium,
            FirmwareStatus::Verified => Severity::Info,
        };
        let title = format!(
            "Firmware integrity: {:?} — {} findings, {} components",
            fw.overall_status, fw.findings.len(), fw.components.len()
        );
        let details = format!(
            "Status: {:?} | SecureBoot: {:?} | Components: {} | Findings: {} | Drift: {} | Duration: {}ms",
            fw.overall_status, fw.secure_boot_state, fw.components.len(),
            fw.findings.len(), fw.baseline_drift.len(), fw.duration_ms
        );
        let remediation = vec![
            "Compare firmware hashes against manufacturer baselines".into(),
            "If modified: reflash firmware from trusted source".into(),
            "Check Secure Boot configuration".into(),
            "CRITICAL if compromised: boot from clean media, reflash all firmware".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: fw.scan_time,
            severity, module: module.to_string(), title, details,
            path: None, process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1542".into()],
            remediation: self.enrich_remediation(remediation, &["T1542".into()]),
            confidence: if matches!(fw.overall_status, FirmwareStatus::Compromised) { 0.95 } else { 0.7 },
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: BinaryVerification → MalwareAlert (Module 38) ────────────

    pub fn ingest_binary_verification(
        &self, bv: &BinaryVerification, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if bv.findings.is_empty() && bv.dangerous_entitlements.is_empty() { return None; }

        let severity = if bv.risk_score > 0.8 { Severity::High }
            else if bv.risk_score > 0.5 { Severity::Medium }
            else { Severity::Low };
        let title = format!(
            "Binary provenance: {} — {:?}, risk {:.0}%",
            bv.path, bv.signature_status, bv.risk_score * 100.0
        );
        let details = format!(
            "Path: {} | SHA256: {} | Sig: {:?} | Notarized: {} | Signer: {:?} | Entitlements: {} ({} dangerous) | Findings: {}",
            bv.path, bv.hash_sha256, bv.signature_status, bv.notarized,
            bv.signer, bv.entitlements.len(), bv.dangerous_entitlements.len(), bv.findings.len()
        );
        let remediation = vec![
            format!("Verify code signature for: {}", bv.path),
            if !bv.notarized { "Binary is NOT notarized — investigate source".into() }
            else { "Notarization verified".into() },
            if !bv.dangerous_entitlements.is_empty() {
                format!("Review dangerous entitlements: {}", bv.dangerous_entitlements.join(", "))
            } else { "No dangerous entitlements".into() },
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: bv.verified_at,
            severity, module: module.to_string(), title, details,
            path: Some(bv.path.clone()), process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1553".into()],
            remediation: self.enrich_remediation(remediation, &["T1553".into()]),
            confidence: bv.risk_score.min(1.0),
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: DeviceEvent → MalwareAlert (Module 39) ──────────────────

    pub fn ingest_usb_event(
        &self, event: &DeviceEvent, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let dev_alert = match &event.alert {
            Some(a) => a,
            None => return None,
        };

        let title = format!(
            "USB threat: {} — {:?} device {:04x}:{:04x}",
            dev_alert.title, event.event_type, event.device.vendor_id, event.device.product_id
        );
        let details = format!(
            "Device: {} | VID:PID: {:04x}:{:04x} | Event: {:?} | Policy: {:?} | {} | Evidence: {}",
            event.device.product_name.as_deref().unwrap_or("unknown"), event.device.vendor_id, event.device.product_id,
            event.event_type, event.policy_applied, event.details,
            dev_alert.evidence.join("; ")
        );
        let remediation = vec![
            format!("Disconnect USB device: {}", event.device.product_name.as_deref().unwrap_or("unknown")),
            "Scan device contents before allowing access".into(),
            "Check for BadUSB/rubber ducky indicators".into(),
            "Review USB device policy and whitelist".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: event.timestamp,
            severity: dev_alert.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1200".into()],
            remediation: self.enrich_remediation(remediation, &["T1200".into()]),
            confidence: 0.85,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: BtAlert → MalwareAlert (Module 40) ─────────────────────

    pub fn ingest_bluetooth_alert(
        &self, bt: &BtAlert, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let title = format!(
            "Bluetooth threat: {:?} — {} ({})",
            bt.threat_type, bt.title, bt.device.name.as_deref().unwrap_or("unknown")
        );
        let details = format!(
            "Device: {} ({}) | Threat: {:?} | {} | Evidence: {}",
            bt.device.name.as_deref().unwrap_or("unknown"), bt.device.address, bt.threat_type,
            bt.description, bt.evidence.join("; ")
        );

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: bt.timestamp,
            severity: bt.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: None, process_pid: None,
            verdict: None, mitre_ids: bt.mitre_id.clone().into_iter().collect(),
            remediation: self.enrich_remediation(bt.remediation.clone(), &bt.mitre_id.clone().into_iter().collect::<Vec<_>>()),
            confidence: bt.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: PackerAnalysis → MalwareAlert (Module 41) ───────────────

    pub fn ingest_packer_analysis(
        &self, pa: &PackerAnalysis, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if !pa.is_packed { return None; }

        let severity = if pa.risk_score > 0.8 { Severity::High }
            else if pa.risk_score > 0.5 { Severity::Medium }
            else { Severity::Low };
        let title = format!(
            "Packed binary: {:?} ({}) — entropy {:.2}, risk {:.0}%",
            pa.packer_type, pa.packer_name.as_deref().unwrap_or("unknown"),
            pa.overall_entropy, pa.risk_score * 100.0
        );
        let details = format!(
            "Path: {} | Format: {:?} | Packer: {:?} ({:?}) | Entropy: {:.2} | Sections: {} | Overlay: {} bytes | Indicators: {}",
            pa.path, pa.format, pa.packer_type, pa.packer_name,
            pa.overall_entropy, pa.sections.len(), pa.overlay_size, pa.indicators.len()
        );
        let remediation = vec![
            format!("Unpack and analyze: {}", pa.path),
            "Submit to sandbox for behavioral analysis".into(),
            "Check if packer is commonly used by malware families".into(),
            "Verify binary provenance and code signature".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
            severity, module: module.to_string(), title, details,
            path: Some(pa.path.clone()), process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1027.002".into()],
            remediation: self.enrich_remediation(remediation, &["T1027.002".into()]),
            confidence: pa.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: PolymorphicAnalysis → MalwareAlert (Module 42) ──────────

    pub fn ingest_polymorphic_analysis(
        &self, poly: &PolymorphicAnalysis, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if !poly.is_polymorphic && !poly.is_metamorphic { return None; }

        let severity = if poly.is_metamorphic { Severity::Critical }
            else if poly.risk_score > 0.8 { Severity::High }
            else { Severity::Medium };
        let kind = if poly.is_metamorphic { "Metamorphic" } else { "Polymorphic" };
        let title = format!(
            "{} malware: {} — {} mutations, {} variants",
            kind, poly.path, poly.mutations_detected.len(), poly.variant_count
        );
        let details = format!(
            "Path: {} | Hash: {} | Engine: {:?} | Mutations: {} | Variants: {} | Decryption loops: {} | Risk: {:.0}%",
            poly.path, poly.file_hash, poly.mutation_engine,
            poly.mutations_detected.len(), poly.variant_count,
            poly.decryption_loops.len(), poly.risk_score * 100.0
        );
        let remediation = vec![
            format!("Quarantine immediately: {}", poly.path),
            "Submit to AV vendor for signature generation".into(),
            format!("Search for {} known variants using structural hash: {}", poly.variant_count, poly.structural_hash),
            "Check for associated persistence mechanisms".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
            severity, module: module.to_string(), title, details,
            path: Some(poly.path.clone()), process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1027.001".into()],
            remediation: self.enrich_remediation(remediation, &["T1027.001".into()]),
            confidence: poly.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: TimeBombAnalysis → MalwareAlert (Module 43) ─────────────

    pub fn ingest_time_bomb_analysis(
        &self, tb: &TimeBombAnalysis, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if !tb.has_time_bomb { return None; }

        let severity = if tb.risk_score > 0.8 { Severity::High } else { Severity::Medium };
        let title = format!(
            "Time bomb detected: {} — {} triggers, {} hardcoded dates",
            tb.path, tb.bomb_types.len(), tb.hardcoded_dates.len()
        );
        let details = format!(
            "Path: {} | Hash: {} | Types: {} | Time APIs: {} | Sleep calls: {} | Dates: {} | Risk: {:.0}%",
            tb.path, tb.file_hash, tb.bomb_types.len(), tb.time_api_usage.len(),
            tb.sleep_calls.len(), tb.hardcoded_dates.len(), tb.risk_score * 100.0
        );
        let remediation = vec![
            format!("Quarantine and analyze: {}", tb.path),
            "Extract and review hardcoded dates/triggers".into(),
            "Run in sandbox with time manipulation to trigger payload".into(),
            "Check if binary is waiting to activate at a specific date".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
            severity, module: module.to_string(), title, details,
            path: Some(tb.path.clone()), process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1497.003".into()],
            remediation: self.enrich_remediation(remediation, &["T1497.003".into()]),
            confidence: tb.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: BeaconDetection → MalwareAlert (Module 44) ──────────────

    pub fn ingest_beacon_detection(
        &self, beacon: &BeaconDetection, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        let severity = if beacon.confidence > 0.85 { Severity::Critical }
            else if beacon.confidence > 0.6 { Severity::High }
            else { Severity::Medium };
        let title = format!(
            "C2 beacon: {:?} ({:?}) to {}:{} — interval {}ms, jitter {:.0}%",
            beacon.framework, beacon.protocol, beacon.destination,
            beacon.destination_port, beacon.beacon_interval_ms, beacon.jitter_percent
        );
        let details = format!(
            "Source: {}:{} → Dest: {}:{} | Protocol: {:?} | Framework: {:?} | Interval: {}ms | Jitter: {:.1}% | Samples: {} | Data: {} bytes",
            beacon.source_ip, beacon.source_port, beacon.destination, beacon.destination_port,
            beacon.protocol, beacon.framework, beacon.beacon_interval_ms,
            beacon.jitter_percent, beacon.samples_analyzed, beacon.data_volume_bytes
        );
        let remediation = vec![
            format!("Block outbound traffic to {}:{}", beacon.destination, beacon.destination_port),
            "Identify and terminate the beaconing process".into(),
            format!("Add {} to threat intelligence blocklist", beacon.destination),
            "Collect full PCAP for forensic analysis".into(),
            "Check for lateral movement from this endpoint".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: beacon.last_seen,
            severity, module: module.to_string(), title, details,
            path: None, process_name: None, process_pid: None,
            verdict: None, mitre_ids: vec!["T1071".into(), "T1573".into()],
            remediation: self.enrich_remediation(remediation, &["T1071".into(), "T1573".into()]),
            confidence: beacon.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Adapter: FingerprintMatch → MalwareAlert (Module 45) ─────────────

    pub fn ingest_ja3_match(
        &self, fp: &FingerprintMatch, module: &str,
    ) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        if !fp.is_malicious { return None; }

        let title = format!(
            "Malicious TLS fingerprint: {} — {:?}",
            fp.ja3_hash, fp.framework
        );
        let details = format!(
            "JA3: {} | Match: {:?} | Framework: {:?} | Source: {} → Dest: {} | Process: {:?} | {} | Findings: {}",
            fp.ja3_hash, fp.matched_entry, fp.framework,
            fp.source, fp.destination, fp.process,
            fp.description, fp.findings.len()
        );
        let remediation = vec![
            format!("Block TLS connections matching JA3 hash: {}", fp.ja3_hash),
            format!("Investigate process {:?} for malware", fp.process),
            format!("Add JA3 {} to network detection rules", fp.ja3_hash),
            "Review all connections from the source endpoint".into(),
        ];

        let alert = MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
            severity: fp.severity.clone(), module: module.to_string(), title, details,
            path: None, process_name: fp.process.clone(), process_pid: None,
            verdict: None, mitre_ids: vec!["T1071.001".into()],
            remediation: self.enrich_remediation(remediation, &["T1071.001".into()]),
            confidence: fp.confidence,
        };
        self.emit_alert(alert.clone()); Some(alert)
    }

    // ── Passthrough: MalwareAlert from modules 110–172 ─────────────────────

    pub fn ingest_alert(&self, mut alert: MalwareAlert) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }

        // Enrich remediation with MITRE-specific guidance if not already present
        if alert.remediation.len() < 3 {
            alert.remediation = self.enrich_remediation(alert.remediation.clone(), &alert.mitre_ids);
        }

        self.emit_alert(alert.clone());
        self.stats.write().total_passthrough_alerts += 1;
        Some(alert)
    }

    // ── Bulk ingest: drain alerts from any module that has drain_alerts() ───

    pub fn ingest_alert_batch(&self, alerts: Vec<MalwareAlert>) -> u32 {
        let mut count = 0u32;
        for alert in alerts {
            if self.ingest_alert(alert).is_some() {
                count += 1;
            }
        }
        count
    }

    // ── Core: emit an alert into the pipeline ──────────────────────────────

    fn emit_alert(&self, alert: MalwareAlert) {
        let now = chrono::Utc::now().timestamp();

        // Dedup check
        let title_hash = self.hash_string(&format!("{}:{}", alert.module, alert.title));
        {
            let mut dedup = self.dedup_window.write();
            if let Some(entry) = dedup.get_mut(&title_hash) {
                if now - entry.last_seen < DEDUP_WINDOW_SECS {
                    entry.count += 1;
                    entry.last_seen = now;
                    self.stats.write().total_deduplicated += 1;

                    // Escalation: if the same alert fires > threshold times, escalate
                    if entry.count >= ESCALATION_THRESHOLD {
                        self.stats.write().total_escalated += 1;
                        // Allow through as escalated alert
                    } else {
                        return;
                    }
                }
            }
            dedup.insert(title_hash, DedupKey {
                module: alert.module.clone(),
                title_hash,
                last_seen: now,
                count: 1,
            });
        }

        // Rate limiting per module
        {
            let mut rates = self.module_rate.write();
            let entry = rates.entry(alert.module.clone()).or_insert((0, now));
            if now - entry.1 > 60 {
                *entry = (1, now);
            } else {
                entry.0 += 1;
                if entry.0 > MAX_ALERTS_PER_MODULE_PER_MIN {
                    self.stats.write().total_rate_limited += 1;
                    return;
                }
            }
        }

        // Severity stats
        {
            let mut s = self.stats.write();
            let idx = match &alert.severity {
                Severity::Critical => 0,
                Severity::High => 1,
                Severity::Medium => 2,
                Severity::Low => 3,
                Severity::Info => 4,
            };
            s.alerts_by_severity[idx] += 1;
            *s.alerts_by_module.entry(alert.module.clone()).or_insert(0) += 1;
            s.total_alerts_generated += 1;
        }

        // Update module matrix
        {
            let mut matrix = self.module_matrix.write();
            let sev_str = format!("{:?}", alert.severity);
            let cur = *matrix.get(&alert.module, &sev_str);
            matrix.set(alert.module.clone(), sev_str, cur + 1);
        }

        // Cache and push
        self.alert_cache.insert(alert.id.clone(), alert.clone());
        self.recent_alerts.write().insert_with_priority(
            alert.id.clone(), alert.clone(),
            match &alert.severity {
                Severity::Critical => 1.0,
                Severity::High => 0.8,
                Severity::Medium => 0.5,
                Severity::Low => 0.2,
                Severity::Info => 0.1,
            },
        );
        self.risk_computer.write().push(alert.confidence);
        self.rate_accumulator.write().push(alert.confidence);
        self.event_diffs.write().record_insert(alert.id.clone(), alert.module.clone());

        // Push to queue (bounded)
        let mut queue = self.alert_queue.write();
        if queue.len() >= ALERT_RETENTION_MAX {
            queue.pop_front();
        }
        queue.push_back(alert);
        self.total_alerts.fetch_add(1, Ordering::Relaxed);
    }

    // ── Remediation enrichment ─────────────────────────────────────────────

    fn remediation_for_verdict(&self, verdict: &ScanVerdict, path: &str) -> (String, Vec<String>) {
        match verdict {
            ScanVerdict::Ransomware { family, .. } => (
                format!("Ransomware detected: {} in {}", family, path),
                REMEDIATION_RANSOMWARE.iter().map(|s| s.to_string()).collect(),
            ),
            ScanVerdict::Rootkit { technique, .. } => (
                format!("Rootkit detected: {} in {}", technique, path),
                REMEDIATION_ROOTKIT.iter().map(|s| s.to_string()).collect(),
            ),
            ScanVerdict::Exploit { cve, technique } => (
                format!("Exploit detected: {} ({:?}) in {}", technique, cve, path),
                REMEDIATION_EXPLOIT.iter().map(|s| s.to_string()).collect(),
            ),
            ScanVerdict::Malicious { rule_name, .. } => (
                format!("Malware detected: {} in {}", rule_name, path),
                REMEDIATION_MALICIOUS.iter().map(|s| s.to_string()).collect(),
            ),
            ScanVerdict::HashMatch { family, .. } => (
                format!("Known malware hash: {} in {}", family, path),
                REMEDIATION_MALICIOUS.iter().map(|s| s.to_string()).collect(),
            ),
            ScanVerdict::Suspicious { score, .. } => (
                format!("Suspicious file (score {:.0}%) in {}", score * 100.0, path),
                REMEDIATION_SUSPICIOUS.iter().map(|s| s.to_string()).collect(),
            ),
            ScanVerdict::Pup { name, .. } => (
                format!("PUP detected: {} in {}", name, path),
                REMEDIATION_PUP.iter().map(|s| s.to_string()).collect(),
            ),
            _ => (
                format!("Detection in {}", path),
                vec!["Review the flagged item and determine appropriate action".into()],
            ),
        }
    }

    fn confidence_for_verdict(&self, verdict: &ScanVerdict) -> f64 {
        match verdict {
            ScanVerdict::HashMatch { .. } => 0.99,
            ScanVerdict::Ransomware { .. } => 0.95,
            ScanVerdict::Rootkit { .. } => 0.90,
            ScanVerdict::Malicious { .. } => 0.85,
            ScanVerdict::Exploit { .. } => 0.80,
            ScanVerdict::Pup { .. } => 0.70,
            ScanVerdict::Suspicious { score, .. } => *score,
            _ => 0.5,
        }
    }

    fn enrich_remediation(&self, mut steps: Vec<String>, mitre_ids: &[String]) -> Vec<String> {
        for id in mitre_ids {
            // Match on technique prefix (T1059 matches T1059.005)
            let prefix = if id.contains('.') {
                id.split('.').next().unwrap_or(id)
            } else {
                id.as_str()
            };
            if let Some(mitre_step) = self.mitre_remediation.get(prefix) {
                steps.push(format!("[MITRE {}] {}", id, mitre_step));
            }
        }
        steps
    }

    fn hash_string(&self, s: &str) -> u64 {
        use std::hash::{Hash, Hasher};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        s.hash(&mut hasher);
        hasher.finish()
    }

    // ── Public API ─────────────────────────────────────────────────────────

    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        self.alert_queue.write().drain(..).collect()
    }

    pub fn drain_critical_alerts(&self) -> Vec<MalwareAlert> {
        let mut queue = self.alert_queue.write();
        let (critical, rest): (VecDeque<_>, VecDeque<_>) = queue.drain(..)
            .partition(|a| matches!(a.severity, Severity::Critical));
        *queue = rest;
        critical.into_iter().collect()
    }

    pub fn peek_alerts(&self, count: usize) -> Vec<MalwareAlert> {
        self.alert_queue.read().iter().rev().take(count).cloned().collect()
    }

    pub fn alert_count(&self) -> usize { self.alert_queue.read().len() }

    pub fn stats(&self) -> OrchestratorStats { self.stats.read().clone() }

    pub fn checkpoint(&self) {
        self.state_history.write().checkpoint(self.stats.read().clone());
    }

    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }

    /// Set the privacy level for outbound Claude remediation requests.
    ///
    /// - `Maximum` (default): Only threat semantics leave the device.
    ///   Claude sees: severity, threat category, MITRE IDs, file type, process
    ///   category. Zero paths, hostnames, IPs, PIDs, or filenames.
    /// - `Anonymized`: Scrubs PII (usernames, hostnames, private IPs, emails)
    ///   but preserves sanitized alert structure for richer Claude context.
    /// - `Full`: Raw alert data. Only for air-gapped / trusted environments.
    pub fn set_privacy_level(&self, level: PrivacyLevel) {
        *self.privacy_level.write() = level;
    }

    /// Get the current privacy level.
    pub fn privacy_level(&self) -> PrivacyLevel {
        *self.privacy_level.read()
    }

    /// Get a mutable reference to the sanitizer for adding custom redactions.
    pub fn sanitizer_mut(&mut self) -> &mut RemediationSanitizer {
        &mut self.sanitizer
    }

    // ── Claude-Powered Remediation (via sentinel-endpoint::RemediationEngine) ──

    /// Convert a MalwareAlert into a RemediationRequest for the Claude API,
    /// applying the current privacy level to control what data leaves the device.
    ///
    /// - `Maximum`: Claude sees only threat semantics (category, MITRE, file type)
    /// - `Anonymized`: PII scrubbed, alert structure preserved
    /// - `Full`: Raw data (air-gapped / trusted only)
    fn alert_to_remediation_request(&self, alert: &MalwareAlert) -> RemediationRequest {
        let level = *self.privacy_level.read();

        match level {
            PrivacyLevel::Maximum => {
                // Zero specific data leaves the device.
                // Claude gets only threat semantics — enough for great remediation.
                RemediationSanitizer::build_maximum_privacy_request(alert)
            }
            PrivacyLevel::Anonymized => {
                // Scrub PII but keep alert structure for richer context.
                let component = alert.module.clone();
                let severity = format!("{:?}", alert.severity);
                let title = alert.title.clone();
                let details = format!(
                    "{}\n\nMITRE ATT&CK: {}\nConfidence: {:.0}%\nPath: {}\nProcess: {}",
                    alert.details,
                    if alert.mitre_ids.is_empty() { "N/A".to_string() } else { alert.mitre_ids.join(", ") },
                    alert.confidence * 100.0,
                    alert.path.as_deref().unwrap_or("N/A"),
                    alert.process_name.as_deref().unwrap_or("N/A"),
                );
                let mut req = RemediationRequest { severity, component, title, details };
                self.sanitizer.scrub_anonymized_request(&mut req);
                req
            }
            PrivacyLevel::Full => {
                // Raw data — trusted / air-gapped environments only.
                let component = alert.module.clone();
                let severity = format!("{:?}", alert.severity);
                let title = alert.title.clone();
                let details = format!(
                    "{}\n\nMITRE ATT&CK: {}\nConfidence: {:.0}%\nPath: {}\nProcess: {}",
                    alert.details,
                    if alert.mitre_ids.is_empty() { "N/A".to_string() } else { alert.mitre_ids.join(", ") },
                    alert.confidence * 100.0,
                    alert.path.as_deref().unwrap_or("N/A"),
                    alert.process_name.as_deref().unwrap_or("N/A"),
                );
                RemediationRequest { severity, component, title, details }
            }
        }
    }

    /// Get Claude-powered remediation for a single alert.
    ///
    /// Calls the Beaver Warrior production server → Anthropic Claude API.
    /// Falls back to built-in heuristic advice if the server is unavailable.
    /// Results are cached by (module, title) in the RemediationEngine.
    ///
    /// Requires a Pro/Enterprise subscription (validated server-side via Stripe).
    pub async fn get_claude_remediation(
        &self,
        alert: &MalwareAlert,
        engine: &RemediationEngine,
        user_email: &str,
    ) -> RemediationResponse {
        let req = self.alert_to_remediation_request(alert);
        engine.generate(&req, user_email).await
    }

    /// Enrich an alert's remediation field with Claude-generated advice.
    ///
    /// Replaces the static remediation steps with Claude's context-aware response.
    /// If Claude is unavailable, the built-in heuristic fallback is used instead.
    pub async fn enrich_alert_with_claude(
        &self,
        alert: &mut MalwareAlert,
        engine: &RemediationEngine,
        user_email: &str,
    ) {
        let resp = self.get_claude_remediation(alert, engine, user_email).await;
        // Replace static remediation with Claude's response, split into steps
        let claude_steps: Vec<String> = resp.advice
            .lines()
            .filter(|l| !l.trim().is_empty())
            .map(|l| l.to_string())
            .collect();
        if !claude_steps.is_empty() {
            alert.remediation = claude_steps;
        }
    }

    /// Batch-enrich all pending alerts with Claude remediation.
    ///
    /// Processes each alert in the queue, calling Claude for each unique
    /// (module, title) pair. The RemediationEngine's built-in cache ensures
    /// duplicate alert types only trigger one API call.
    pub async fn enrich_all_alerts_with_claude(
        &self,
        engine: &RemediationEngine,
        user_email: &str,
    ) -> u32 {
        let mut alerts: Vec<MalwareAlert> = self.alert_queue.write().drain(..).collect();
        let mut enriched = 0u32;
        for alert in alerts.iter_mut() {
            self.enrich_alert_with_claude(alert, engine, user_email).await;
            enriched += 1;
        }
        // Push enriched alerts back
        let mut queue = self.alert_queue.write();
        for alert in alerts {
            queue.push_back(alert);
        }
        enriched
    }

    /// Ingest a scan result AND immediately get Claude remediation.
    ///
    /// Combines `ingest_scan_result` + `enrich_alert_with_claude` in one call.
    pub async fn ingest_scan_result_with_claude(
        &self,
        result: &ScanResult,
        module: &str,
        engine: &RemediationEngine,
        user_email: &str,
    ) -> Option<MalwareAlert> {
        let mut alert = self.ingest_scan_result(result, module)?;
        self.enrich_alert_with_claude(&mut alert, engine, user_email).await;
        Some(alert)
    }

    /// Ingest a process anomaly AND immediately get Claude remediation.
    pub async fn ingest_process_anomaly_with_claude(
        &self,
        process: &ProcessSnapshot,
        reason: &str,
        severity: Severity,
        mitre_ids: Vec<String>,
        module: &str,
        engine: &RemediationEngine,
        user_email: &str,
    ) -> Option<MalwareAlert> {
        let mut alert = self.ingest_process_anomaly(process, reason, severity, mitre_ids, module)?;
        self.enrich_alert_with_claude(&mut alert, engine, user_email).await;
        Some(alert)
    }

    /// Ingest any MalwareAlert (from modules 110-172) AND enrich with Claude.
    pub async fn ingest_alert_with_claude(
        &self,
        mut alert: MalwareAlert,
        engine: &RemediationEngine,
        user_email: &str,
    ) -> Option<MalwareAlert> {
        self.enrich_alert_with_claude(&mut alert, engine, user_email).await;
        self.ingest_alert(alert)
    }

    // ── One-Click Remediation (Claude → Parse → AutoRemediator) ─────────

    /// Parse Claude's text remediation advice into concrete ActionTypes
    /// that the AutoRemediator can execute.
    ///
    /// This is the bridge between "Claude says do X" and "the system does X".
    /// Uses keyword matching against Claude's natural language response to
    /// identify which actions are recommended.
    pub fn parse_claude_actions(advice: &str) -> Vec<ActionType> {
        let lower = advice.to_lowercase();
        let mut actions = Vec::new();

        // Order matters: check most specific patterns first

        // Network isolation (Critical — requires manual approval)
        if lower.contains("isolate") && (lower.contains("network") || lower.contains("endpoint") || lower.contains("disconnect")) {
            actions.push(ActionType::IsolateEndpoint);
        }

        // Process termination
        if lower.contains("kill") || lower.contains("terminate") || lower.contains("stop the process")
            || lower.contains("end the process") || lower.contains("force quit") {
            actions.push(ActionType::KillProcess);
        }

        // File quarantine
        if lower.contains("quarantine") || lower.contains("move to vault")
            || lower.contains("isolate the file") || lower.contains("isolate the .") {
            actions.push(ActionType::QuarantineFile);
        }

        // File deletion (Critical — requires manual approval)
        if lower.contains("delete the file") || lower.contains("remove the file")
            || lower.contains("permanently remove") || lower.contains("securely delete") {
            actions.push(ActionType::DeleteFile);
        }

        // IP/network blocking
        if lower.contains("block") && (lower.contains("ip") || lower.contains("address")
            || lower.contains("c2") || lower.contains("command and control")
            || lower.contains("domain")) {
            actions.push(ActionType::BlockIp);
        }

        // Connection killing
        if lower.contains("kill") && lower.contains("connection") {
            actions.push(ActionType::KillConnection);
        }

        // Hash blocking
        if lower.contains("block") && (lower.contains("hash") || lower.contains("sha")
            || lower.contains("md5") || lower.contains("signature")) {
            actions.push(ActionType::BlockHash);
        }

        // Persistence removal
        if lower.contains("remove") && (lower.contains("persistence") || lower.contains("launch")
            || lower.contains("daemon") || lower.contains("agent") || lower.contains("cron")
            || lower.contains("startup") || lower.contains("login item")
            || lower.contains("scheduled task")) {
            actions.push(ActionType::RemovePersistence);
        }

        // Credential rotation
        if lower.contains("password") && (lower.contains("reset") || lower.contains("change") || lower.contains("rotate")) {
            actions.push(ActionType::ForcePasswordReset);
        }
        if lower.contains("revoke") && (lower.contains("token") || lower.contains("key") || lower.contains("session")) {
            actions.push(ActionType::RevokeToken);
        }

        // Account disable
        if lower.contains("disable") && lower.contains("account") {
            actions.push(ActionType::DisableAccount);
        }

        // Firewall
        if lower.contains("firewall") && (lower.contains("update") || lower.contains("rule") || lower.contains("block")) {
            actions.push(ActionType::UpdateFirewallRule);
        }

        // Sandboxing
        if lower.contains("sandbox") {
            actions.push(ActionType::SandboxProcess);
        }

        // Forensics
        if lower.contains("forensic") || lower.contains("evidence") || lower.contains("capture")
            || lower.contains("memory dump") || lower.contains("preserve") {
            actions.push(ActionType::CollectForensics);
        }

        // Escalation
        if lower.contains("soc") || lower.contains("security team") || lower.contains("incident response team") {
            actions.push(ActionType::EscalateToSOC);
        }
        if lower.contains("notify") && (lower.contains("admin") || lower.contains("administrator")) {
            actions.push(ActionType::NotifyAdmin);
        }

        // Dedup
        actions.dedup();

        // Always collect forensics and escalate for critical threats if not already present
        if !actions.contains(&ActionType::CollectForensics) && actions.len() >= 3 {
            actions.push(ActionType::CollectForensics);
        }

        actions
    }

    /// Build an AutoRemediator-compatible request from a MalwareAlert.
    fn alert_to_auto_remediation_request(
        alert: &MalwareAlert,
        suggested_actions: Vec<ActionType>,
    ) -> AutoRemediationRequest {
        // Build the target from the alert's available data
        let target = if let Some(ref path) = alert.path {
            RemediationTarget::File {
                path: path.clone(),
                hash: None,
            }
        } else if let (Some(ref name), Some(pid)) = (&alert.process_name, alert.process_pid) {
            RemediationTarget::Process {
                pid,
                name: name.clone(),
                path: alert.path.clone(),
            }
        } else {
            RemediationTarget::Custom {
                description: alert.title.clone(),
                parameters: HashMap::new(),
            }
        };

        AutoRemediationRequest {
            alert_id: alert.id.clone(),
            source_module: alert.module.clone(),
            severity: alert.severity.clone(),
            confidence: alert.confidence,
            description: alert.details.clone(),
            target,
            mitre_technique: alert.mitre_ids.first().cloned(),
            suggested_actions,
            evidence: alert.remediation.clone(),
        }
    }

    /// **One-click remediation.** The user clicks "Fix It" and this method:
    ///
    /// 1. Gets Claude's remediation advice (privacy-scrubbed)
    /// 2. Parses Claude's text into concrete ActionTypes
    /// 3. Feeds them to the AutoRemediator for execution
    /// 4. Returns a full audit report of what was done
    ///
    /// Safety: The AutoRemediator's three-tier approval system still applies.
    /// - Low-risk actions (collect forensics, notify) → auto-execute
    /// - Medium-risk (block IP, quarantine) → auto if confidence ≥ 75%
    /// - High-risk (kill process, remove persistence) → confirm if confidence ≥ 90%
    /// - Critical (delete file, isolate endpoint, disable account) → always manual
    ///
    /// The user always sees the plan before critical actions execute.
    pub async fn one_click_remediate(
        &self,
        alert: &MalwareAlert,
        claude_engine: &RemediationEngine,
        remediator: &AutoRemediator,
        user_email: &str,
    ) -> OneClickResult {
        // Step 1: Get Claude advice (privacy-scrubbed per current PrivacyLevel)
        let claude_resp = self.get_claude_remediation(alert, claude_engine, user_email).await;

        // Step 2: Parse Claude's text into ActionTypes
        let actions = Self::parse_claude_actions(&claude_resp.advice);

        if actions.is_empty() {
            return OneClickResult {
                claude_advice: claude_resp.advice,
                parsed_actions: vec![],
                validation: None,
                report: None,
                summary: "Claude provided advice but no automatable actions were identified. \
                          Please follow the manual steps above.".to_string(),
            };
        }

        // Step 3: Validate Claude's advice before executing anything
        let validation = RemediationValidator::validate(&claude_resp.advice, &actions, alert);
        info!(
            "Remediation validation for alert {}: passed={}, confidence={:.0}%, findings={}, approved={}/{}",
            alert.id, validation.passed, validation.confidence * 100.0,
            validation.findings.len(), validation.approved_actions.len(), actions.len()
        );

        if !validation.passed {
            let reason = validation.findings.iter()
                .filter(|f| f.severity == "Critical")
                .map(|f| f.message.as_str())
                .collect::<Vec<_>>()
                .join("; ");
            let summary = format!(
                "Validation BLOCKED execution (confidence {:.0}%). {}. Review Claude's advice manually.",
                validation.confidence * 100.0,
                if reason.is_empty() { "Insufficient confidence to proceed safely" } else { &reason }
            );
            warn!("One-click remediation blocked for alert {}: {}", alert.id, summary);
            return OneClickResult {
                claude_advice: claude_resp.advice,
                parsed_actions: actions.iter().map(|a| format!("{:?}", a)).collect(),
                validation: Some(validation),
                report: None,
                summary,
            };
        }

        // Step 4: Execute only the validated/approved actions
        let approved = validation.approved_actions.clone();
        let request = Self::alert_to_auto_remediation_request(alert, approved);
        let report = remediator.remediate(request);

        // Step 5: Build result summary
        let executed = report.actions_taken.iter()
            .filter(|a| a.status == crate::auto_remediator::ActionStatus::Completed)
            .count();
        let skipped = report.actions_taken.iter()
            .filter(|a| a.status == crate::auto_remediator::ActionStatus::Skipped)
            .count();
        let failed = report.actions_taken.iter()
            .filter(|a| a.status == crate::auto_remediator::ActionStatus::Failed)
            .count();

        let summary = format!(
            "Validated ({:.0}% confidence). {} actions executed, {} awaiting approval, {} failed. {}",
            validation.confidence * 100.0, executed, skipped, failed,
            if report.overall_success { "Remediation successful." }
            else { "Some actions require manual approval — check the report." }
        );

        info!("One-click remediation for alert {}: {}", alert.id, summary);

        OneClickResult {
            claude_advice: claude_resp.advice,
            parsed_actions: actions.iter().map(|a| format!("{:?}", a)).collect(),
            validation: Some(validation),
            report: Some(report),
            summary,
        }
    }
}

// ── Remediation Validator ─────────────────────────────────────────────────
//
// Validates Claude's remediation advice BEFORE execution.
// Five checks run in sequence; any Critical finding blocks execution entirely.

/// Dangerous patterns that should NEVER appear in remediation advice.
/// If Claude suggests these, the advice has been poisoned or hallucinated.
const DANGEROUS_ADVICE_PATTERNS: &[(&str, &str)] = &[
    ("rm -rf /", "Destructive wipe of entire filesystem"),
    ("rm -rf /*", "Destructive wipe of entire filesystem"),
    ("dd if=/dev/zero", "Disk overwrite"),
    ("mkfs.", "Filesystem format"),
    (":(){ :|:& };:", "Fork bomb"),
    ("chmod -R 777 /", "Recursive permission strip on root"),
    ("> /dev/sda", "Direct disk write"),
    ("curl | bash", "Pipe remote code to shell"),
    ("curl | sh", "Pipe remote code to shell"),
    ("wget | bash", "Pipe remote code to shell"),
    ("wget | sh", "Pipe remote code to shell"),
    ("bash -i >& /dev/tcp/", "Reverse shell"),
    ("nc -e /bin/", "Netcat reverse shell"),
    ("python -c 'import socket", "Python reverse shell"),
    ("eval(base64", "Obfuscated code execution"),
    ("exec(base64", "Obfuscated code execution"),
    ("stratum+tcp://", "Crypto miner connection"),
    ("xmrig", "Crypto miner binary"),
    ("/etc/shadow", "Password file access"),
    ("/etc/passwd", "User database access"),
    ("iptables -F", "Flush all firewall rules"),
    ("ufw disable", "Disable firewall entirely"),
    ("disable sip", "Disable System Integrity Protection"),
    ("csrutil disable", "Disable SIP via csrutil"),
    ("--privileged", "Privileged container escape vector"),
    ("-v /:/", "Mount host root into container"),
    ("ngrok", "Tunnel to external network"),
    (".burpcollaborator.net", "DNS exfiltration domain"),
    ("oastify.com", "DNS exfiltration domain"),
];

/// Action types that are reasonable for each broad alert category.
const COHERENT_ACTIONS: &[(&str, &[ActionType])] = &[
    ("malware", &[ActionType::KillProcess, ActionType::QuarantineFile, ActionType::DeleteFile,
                  ActionType::BlockHash, ActionType::RemovePersistence, ActionType::CollectForensics,
                  ActionType::SandboxProcess, ActionType::EscalateToSOC, ActionType::NotifyAdmin]),
    ("network", &[ActionType::BlockIp, ActionType::KillConnection, ActionType::UpdateFirewallRule,
                  ActionType::IsolateEndpoint, ActionType::CollectForensics, ActionType::EscalateToSOC,
                  ActionType::NotifyAdmin]),
    ("credential", &[ActionType::ForcePasswordReset, ActionType::RevokeToken, ActionType::DisableAccount,
                     ActionType::KillProcess, ActionType::CollectForensics, ActionType::EscalateToSOC,
                     ActionType::NotifyAdmin]),
    ("persistence", &[ActionType::RemovePersistence, ActionType::KillProcess, ActionType::QuarantineFile,
                      ActionType::DeleteFile, ActionType::CollectForensics, ActionType::EscalateToSOC,
                      ActionType::NotifyAdmin]),
    ("exfiltration", &[ActionType::BlockIp, ActionType::KillConnection, ActionType::KillProcess,
                       ActionType::IsolateEndpoint, ActionType::UpdateFirewallRule,
                       ActionType::CollectForensics, ActionType::EscalateToSOC, ActionType::NotifyAdmin]),
];

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ValidationFinding {
    pub check: String,
    pub severity: String,
    pub message: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ValidationResult {
    /// true if advice passed all checks and is safe to execute
    pub passed: bool,
    /// 0.0–1.0 confidence that the advice is correct and safe
    pub confidence: f64,
    /// Individual check results
    pub findings: Vec<ValidationFinding>,
    /// Actions that were filtered out as unsafe or incoherent
    pub filtered_actions: Vec<String>,
    /// Actions that survived validation
    pub approved_actions: Vec<ActionType>,
}

pub struct RemediationValidator;

impl RemediationValidator {
    /// Run all 5 validation checks on Claude's advice and parsed actions.
    ///
    /// Returns a ValidationResult that either approves execution (with
    /// possibly filtered actions) or blocks it entirely.
    pub fn validate(
        advice: &str,
        parsed_actions: &[ActionType],
        alert: &MalwareAlert,
    ) -> ValidationResult {
        let mut findings = Vec::new();
        let mut confidence: f64 = 1.0;
        let mut blocked = false;
        let mut filtered_out: Vec<String> = Vec::new();
        let mut approved: Vec<ActionType> = parsed_actions.to_vec();

        // ── Check 1: Malicious Content Scan ──────────────────────────────
        // Reject advice that contains dangerous shell commands, reverse
        // shells, or destructive operations Claude should never suggest.
        let advice_lower = advice.to_lowercase();
        for &(pattern, description) in DANGEROUS_ADVICE_PATTERNS {
            if advice_lower.contains(&pattern.to_lowercase()) {
                findings.push(ValidationFinding {
                    check: "malicious_content".into(),
                    severity: "Critical".into(),
                    message: format!("Dangerous pattern detected: {} — {}", pattern, description),
                });
                confidence = 0.0;
                blocked = true;
            }
        }

        // ── Check 2: Target Existence Verification ───────────────────────
        // Verify that file paths mentioned in the alert actually exist on
        // the system. If Claude references a path, it should be real.
        if let Some(ref path) = alert.path {
            if !std::path::Path::new(path).exists() {
                findings.push(ValidationFinding {
                    check: "target_existence".into(),
                    severity: "Warning".into(),
                    message: format!("Alert file path does not exist: {} — may have been removed already", path),
                });
                // Remove file-targeted actions if the file doesn't exist
                let before = approved.len();
                approved.retain(|a| !matches!(a, ActionType::QuarantineFile | ActionType::DeleteFile));
                if approved.len() < before {
                    filtered_out.push("QuarantineFile/DeleteFile (target missing)".into());
                }
                confidence *= 0.85;
            }
        }

        // Check PID existence
        if let Some(pid) = alert.process_pid {
            // On macOS/Linux, check /proc or use kill -0
            let pid_alive = std::path::Path::new(&format!("/proc/{}", pid)).exists()
                || std::process::Command::new("kill")
                    .args(["-0", &pid.to_string()])
                    .output()
                    .map(|o| o.status.success())
                    .unwrap_or(false);
            if !pid_alive {
                findings.push(ValidationFinding {
                    check: "target_existence".into(),
                    severity: "Warning".into(),
                    message: format!("Process PID {} is not running — may have exited", pid),
                });
                let before = approved.len();
                approved.retain(|a| !matches!(a, ActionType::KillProcess | ActionType::SuspendProcess));
                if approved.len() < before {
                    filtered_out.push("KillProcess/SuspendProcess (PID not running)".into());
                }
                confidence *= 0.85;
            }
        }

        // ── Check 3: Alert-Action Coherence ──────────────────────────────
        // Verify the parsed actions make sense for the alert category.
        // E.g., "ForcePasswordReset" for a malware alert is suspicious.
        let alert_category = Self::categorize_alert(alert);
        let coherent_set: Vec<ActionType> = COHERENT_ACTIONS.iter()
            .filter(|(cat, _)| alert_category.contains(cat))
            .flat_map(|(_, actions)| actions.iter().copied())
            .collect();

        if !coherent_set.is_empty() {
            let before = approved.len();
            let mut incoherent = Vec::new();
            approved.retain(|a| {
                // Always allow forensics/escalation/notify regardless
                if matches!(a, ActionType::CollectForensics | ActionType::EscalateToSOC | ActionType::NotifyAdmin) {
                    return true;
                }
                if coherent_set.contains(a) {
                    true
                } else {
                    incoherent.push(format!("{:?}", a));
                    false
                }
            });
            if approved.len() < before {
                findings.push(ValidationFinding {
                    check: "coherence".into(),
                    severity: "Warning".into(),
                    message: format!(
                        "Removed {} incoherent action(s) for {} alert: {}",
                        incoherent.len(), alert_category, incoherent.join(", ")
                    ),
                });
                filtered_out.extend(incoherent.iter().map(|a| format!("{} (incoherent)", a)));
                confidence *= 0.9;
            }
        }

        // ── Check 4: Hallucination Detection ─────────────────────────────
        // Check if Claude's advice references specific targets (IPs, paths,
        // PIDs) that don't appear in the original alert data.
        let ip_regex_simple = |text: &str| -> Vec<String> {
            let mut ips = Vec::new();
            for word in text.split_whitespace() {
                let clean = word.trim_matches(|c: char| !c.is_ascii_digit() && c != '.');
                let parts: Vec<&str> = clean.split('.').collect();
                if parts.len() == 4 && parts.iter().all(|p| p.parse::<u8>().is_ok()) {
                    ips.push(clean.to_string());
                }
            }
            ips
        };

        let advice_ips = ip_regex_simple(advice);
        let alert_text = format!("{} {} {}", alert.title, alert.details, alert.remediation.join(" "));
        let alert_ips = ip_regex_simple(&alert_text);

        for ip in &advice_ips {
            if !alert_ips.contains(ip) && !ip.starts_with("127.") && !ip.starts_with("0.") {
                findings.push(ValidationFinding {
                    check: "hallucination".into(),
                    severity: "Warning".into(),
                    message: format!("Claude referenced IP {} not present in original alert — possible hallucination", ip),
                });
                confidence *= 0.8;
            }
        }

        // Check for fabricated file paths in advice that aren't in the alert
        let suspicious_paths: Vec<&str> = advice.split_whitespace()
            .filter(|w| w.starts_with('/') && w.len() > 3 && w.contains('/'))
            .filter(|w| !alert_text.contains(*w))
            .collect();
        if suspicious_paths.len() > 2 {
            findings.push(ValidationFinding {
                check: "hallucination".into(),
                severity: "Warning".into(),
                message: format!(
                    "Claude referenced {} file paths not in the alert: {} ...",
                    suspicious_paths.len(),
                    suspicious_paths.iter().take(3).cloned().collect::<Vec<_>>().join(", ")
                ),
            });
            confidence *= 0.75;
        }

        // ── Check 5: Confidence Scoring ──────────────────────────────────
        // Penalize empty or very short advice (likely failed API call).
        if advice.len() < 50 {
            findings.push(ValidationFinding {
                check: "confidence".into(),
                severity: "Warning".into(),
                message: "Claude's advice is unusually short — may be incomplete".into(),
            });
            confidence *= 0.5;
        }

        // Penalize if no actions were parseable
        if parsed_actions.is_empty() {
            confidence *= 0.3;
        }

        // Penalize if we filtered out more than half the actions
        if !parsed_actions.is_empty() && approved.len() < parsed_actions.len() / 2 {
            findings.push(ValidationFinding {
                check: "confidence".into(),
                severity: "Warning".into(),
                message: format!(
                    "More than half of parsed actions were filtered ({}/{})",
                    parsed_actions.len() - approved.len(), parsed_actions.len()
                ),
            });
            confidence *= 0.7;
        }

        // Add passing note if nothing was flagged
        if findings.is_empty() {
            findings.push(ValidationFinding {
                check: "all_checks".into(),
                severity: "Info".into(),
                message: "All 5 validation checks passed".into(),
            });
        }

        confidence = confidence.clamp(0.0, 1.0);

        ValidationResult {
            passed: !blocked && confidence >= 0.3 && !approved.is_empty(),
            confidence,
            findings,
            filtered_actions: filtered_out,
            approved_actions: approved,
        }
    }

    /// Classify the alert into a broad category for coherence checking.
    fn categorize_alert(alert: &MalwareAlert) -> String {
        let text = format!("{} {} {}", alert.module, alert.title, alert.details).to_lowercase();
        if text.contains("credential") || text.contains("password") || text.contains("token")
            || text.contains("keychain") || text.contains("login") || text.contains("auth") {
            return "credential".into();
        }
        if text.contains("exfil") || text.contains("data leak") || text.contains("dns tunnel")
            || text.contains("covert channel") || text.contains("c2") || text.contains("beacon") {
            return "exfiltration".into();
        }
        if text.contains("persist") || text.contains("launch") || text.contains("daemon")
            || text.contains("cron") || text.contains("startup") || text.contains("login item") {
            return "persistence".into();
        }
        if text.contains("network") || text.contains("connection") || text.contains("firewall")
            || text.contains("ip") || text.contains("port") || text.contains("traffic") {
            return "network".into();
        }
        "malware".into() // default
    }
}

// ── One-Click Result ──────────────────────────────────────────────────────

/// The result of a one-click remediation: Claude's advice + what was actually done.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct OneClickResult {
    /// Claude's original text remediation advice
    pub claude_advice: String,
    /// Actions parsed from Claude's text (human-readable names)
    pub parsed_actions: Vec<String>,
    /// Validation results — what checks passed/failed before execution
    pub validation: Option<ValidationResult>,
    /// Full audit report from the AutoRemediator (None if no actions were automatable)
    pub report: Option<RemediationReport>,
    /// Human-readable summary of what happened
    pub summary: String,
}
