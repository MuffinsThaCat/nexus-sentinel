//! Module 64: DockPluginMonitor — Dock Tile Plugin & UI Persistence Detection
//!
//! Monitors macOS Dock tile plugins, persistent Dock items, and related UI-layer
//! persistence mechanisms. Dock tile plugins execute code whenever the Dock process
//! renders an application tile, providing a stealthy persistence vector.
//!
//! ## Features
//!
//! - **Dock tile plugin detection**: Monitors NSDockTilePlugin bundles embedded in apps
//! - **Dock plist persistence**: Watches ~/Library/Preferences/com.apple.dock.plist for injected items
//! - **Persistent Dock item injection**: Detects apps/URLs added to Dock for social engineering
//! - **Dock tile plugin code analysis**: Inspects plugin binaries for suspicious behavior
//! - **DockTilePlugIn protocol abuse**: Detects plugins that execute payloads on render
//! - **Login item via Dock**: Catches items that auto-launch via Dock integration
//! - **Dock restart monitoring**: Detects killall Dock / Dock crash-respawn abuse
//! - **Finder sync extensions**: Monitors Finder extensions that persist via Dock association
//! - **App bundle DockTile.plugin inspection**: Scans app bundles for embedded Dock plugins
//! - **Dock pref modification by non-Dock process**: Flags unauthorized plist writes
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) Dock event history
//! - **#2  TieredCache** — Hot cache for recently analyzed plugins
//! - **#3  ReversibleComputation** — Recompute risk on Dock changes
//! - **#5  StreamAccumulator** — Streaming event rate for Dock modifications
//! - **#6  MemoryMetrics** — Bounded memory for plugin analysis
//! - **#461 DifferentialStore** — Track Dock plist diffs between scans
//! - **#569 PruningMap** — Auto-expire old Dock events
//! - **#592 DedupStore** — Deduplicate identical plugin bundles
//! - **#627 SparseMatrix** — Plugin type × action frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1547 — Boot or Logon Autostart Execution
//! - T1547.015 — Login Items (Dock-associated login items)
//! - T1036 — Masquerading (fake Dock items mimicking legitimate apps)
//! - T1204.001 — User Execution: Malicious Link (Dock URL items)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const DOCK_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 12 * 1024 * 1024;

/// Dock preference plist path (per-user)
const DOCK_PLIST_NAME: &str = "com.apple.dock.plist";

/// System-level Dock-related paths
const DOCK_SYSTEM_PATHS: &[&str] = &[
    "/System/Library/CoreServices/Dock.app",
    "/System/Library/PrivateFrameworks/DockKit.framework",
];

/// Known Dock tile plugin locations within app bundles
const DOCK_TILE_PLUGIN_SUBPATH: &str = "Contents/PlugIns/DockTile.plugin";
const DOCK_TILE_PLUGIN_ALT: &str = "Contents/PlugIns/DockTilePlugIn.plugin";

/// Finder Sync extension subpath
const FINDER_SYNC_SUBPATH: &str = "Contents/PlugIns/FinderSync.appex";

/// Common application directories to scan for Dock tile plugins
const APP_SCAN_DIRS: &[&str] = &[
    "/Applications",
    "/Applications/Utilities",
    "/System/Applications",
    "/usr/local/Cellar",
];

/// Known legitimate Dock tile plugins (by bundle ID prefix)
const KNOWN_LEGITIMATE_DOCK_PLUGINS: &[&str] = &[
    "com.apple.", "com.microsoft.", "com.google.",
    "com.adobe.", "com.slack.", "com.spotify.",
    "com.dropbox.", "com.1password.", "com.agilebits.",
    "com.jetbrains.", "com.sublimetext.", "com.visualstudio.",
    "com.github.", "com.brave.", "com.mozilla.",
    "org.mozilla.", "com.operasoftware.",
];

/// Suspicious indicators in Dock tile plugin binaries
const SUSPICIOUS_PLUGIN_INDICATORS: &[&str] = &[
    "NSTask", "launchApplication",        // Process launching
    "NSAppleScript", "osascript",          // AppleScript execution
    "URLWithString", "NSURLSession",       // Network access
    "NSPipe", "/bin/sh", "/bin/bash",      // Shell execution
    "IORegistryEntry", "IOServiceMatching",// Hardware access
    "SecKeychain", "SecItem",              // Keychain access
    "NSFileManager", "moveItemAtPath",     // File manipulation
    "dlopen", "dlsym", "objc_msgSend",     // Dynamic loading
    "kextload", "kmutil",                  // Kernel extension loading
    "ptrace", "task_for_pid",              // Process debugging
];

/// Suspicious Dock plist modifications
const SUSPICIOUS_DOCK_KEYS: &[&str] = &[
    "persistent-apps",   // Persistent app tiles
    "persistent-others", // Persistent folder/URL tiles
    "recent-apps",       // Recent app list
    "autohide",          // Hiding Dock (stealth)
    "minimize-to-application", // UI manipulation
    "show-recents",      // Disabling recent apps (hiding tracks)
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DockItemType {
    /// NSDockTilePlugin embedded in an app bundle
    DockTilePlugin,
    /// Persistent app item in Dock plist
    PersistentApp,
    /// Persistent URL/folder item in Dock plist
    PersistentOther,
    /// Finder Sync extension (Dock-associated)
    FinderSyncExtension,
    /// Dock plist configuration change
    DockConfig,
    /// Dock process manipulation (restart/crash)
    DockProcess,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DockAction {
    PluginDiscovered,
    PluginModified,
    ItemAdded,
    ItemRemoved,
    ItemReplaced,
    ConfigChanged,
    DockRestarted,
    PlistModified,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DockRisk {
    Trusted,
    KnownApp,
    Unknown,
    Suspicious,
    Malicious,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DockPluginEvent {
    pub id: String,
    pub timestamp: i64,
    pub item_type: DockItemType,
    pub action: DockAction,
    pub risk: DockRisk,
    pub severity: Severity,
    pub confidence: f64,
    pub file_path: String,
    pub bundle_id: String,
    pub app_name: String,
    pub plugin_path: Option<String>,
    pub content_hash: String,
    pub modifying_process: String,
    pub modifying_pid: u32,
    pub indicators: Vec<String>,
    pub suspicious_symbols: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
    pub is_known_legitimate: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct DockPluginStats {
    pub events_analyzed: u64,
    pub plugins_scanned: u64,
    pub threats_detected: u64,
    pub threats_blocked: u64,
    pub dock_tile_plugins_found: u64,
    pub unknown_plugins_found: u64,
    pub plist_modifications: u64,
    pub dock_restarts: u64,
    pub suspicious_symbols_total: u64,
    pub items_added: u64,
    pub items_removed: u64,
    pub item_types: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// DockPluginMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct DockPluginMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical Dock event history ──
    monitor_history: RwLock<HierarchicalState<DockPluginStats>>,
    // ── Breakthrough #2: Tiered event cache ──
    event_cache: TieredCache<String, DockPluginEvent>,
    // ── Breakthrough #3: Reversible risk computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming event rate ──
    event_rate: RwLock<StreamAccumulator<f64, DockPluginStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Dock plist diff tracking ──
    dock_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old events ──
    recent_events: RwLock<PruningMap<String, DockPluginEvent>>,
    // ── Breakthrough #592: Deduplicate identical plugins ──
    plugin_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Item type × action frequency ──
    type_action_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Known plugin hashes — maps plugin_path → content hash
    known_plugins: RwLock<HashMap<String, String>>,
    stats: RwLock<DockPluginStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl DockPluginMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(DOCK_CACHE_MAX)
            .with_metrics(metrics.clone(), "dock_plugin_events");
        let risk_computer = ReversibleComputation::new(512,
            |risks: &[f64]| if risks.is_empty() { 0.0 } else { risks.iter().sum::<f64>() / risks.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, DockPluginStats::default(),
            |acc: &mut DockPluginStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            dock_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(DOCK_CACHE_MAX)),
            plugin_dedup: RwLock::new(DedupStore::new()),
            type_action_matrix: RwLock::new(SparseMatrix::new(0u64)),
            known_plugins: RwLock::new(HashMap::new()),
            stats: RwLock::new(DockPluginStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("dock_plugin", MEMORY_BUDGET / 2);
        info!("DockPluginMonitor started — scanning {} app dirs for Dock tile plugins",
            APP_SCAN_DIRS.len());
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("DockPluginMonitor stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    // ── Classification ─────────────────────────────────────────────────────

    fn is_known_legitimate(bundle_id: &str) -> bool {
        KNOWN_LEGITIMATE_DOCK_PLUGINS.iter().any(|prefix| bundle_id.starts_with(prefix))
    }

    fn classify_risk(bundle_id: &str, has_suspicious_symbols: bool, is_signed: bool) -> DockRisk {
        if has_suspicious_symbols && !is_signed {
            return DockRisk::Malicious;
        }
        if has_suspicious_symbols {
            return DockRisk::Suspicious;
        }
        if Self::is_known_legitimate(bundle_id) {
            return DockRisk::KnownApp;
        }
        if !is_signed {
            return DockRisk::Suspicious;
        }
        DockRisk::Unknown
    }

    fn scan_for_suspicious_symbols(binary_strings: &[String]) -> Vec<String> {
        let mut found = Vec::new();
        for s in binary_strings {
            for &indicator in SUSPICIOUS_PLUGIN_INDICATORS {
                if s.contains(indicator) && !found.contains(&indicator.to_string()) {
                    found.push(indicator.to_string());
                }
            }
        }
        found
    }

    // ── Primary Analysis ───────────────────────────────────────────────────

    /// Analyze a Dock tile plugin discovery or modification.
    pub fn analyze_plugin(
        &self,
        plugin_path: &str,
        app_path: &str,
        bundle_id: &str,
        app_name: &str,
        action: DockAction,
        content_hash: &str,
        binary_strings: &[String],
        is_signed: bool,
        process_name: &str,
        pid: u32,
    ) -> Option<DockPluginEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;
        self.stats.write().plugins_scanned += 1;

        let suspicious_symbols = Self::scan_for_suspicious_symbols(binary_strings);
        let is_legitimate = Self::is_known_legitimate(bundle_id);
        let risk = Self::classify_risk(bundle_id, !suspicious_symbols.is_empty(), is_signed);

        // Skip known legitimate with no suspicious activity
        if is_legitimate && suspicious_symbols.is_empty()
            && matches!(action, DockAction::PluginDiscovered) { return None; }

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();

        // ── New/unknown Dock tile plugin ──
        if !is_legitimate {
            indicators.push(format!("Unknown Dock tile plugin in app: {}", app_name));
            mitre_techniques.push("T1547".to_string());
            self.stats.write().unknown_plugins_found += 1;
        }

        // ── Suspicious symbols in plugin binary ──
        if !suspicious_symbols.is_empty() {
            indicators.push(format!("Suspicious symbols in Dock plugin: {:?}",
                &suspicious_symbols[..suspicious_symbols.len().min(5)]));
            self.stats.write().suspicious_symbols_total += suspicious_symbols.len() as u64;
        }

        // ── Unsigned plugin ──
        if !is_signed {
            indicators.push(format!("Unsigned Dock tile plugin: {}", bundle_id));
        }

        // ── Plugin modification ──
        if action == DockAction::PluginModified {
            let previous = self.known_plugins.read().get(plugin_path).cloned();
            if let Some(ref prev) = previous {
                if prev != content_hash {
                    indicators.push(format!("Dock plugin content changed: {} → {}",
                        &prev[..8.min(prev.len())],
                        &content_hash[..8.min(content_hash.len())]));
                }
            }
        }

        if indicators.is_empty() { return None; }

        let severity = match risk {
            DockRisk::Malicious => Severity::Critical,
            DockRisk::Suspicious => Severity::High,
            DockRisk::Unknown => Severity::Medium,
            DockRisk::KnownApp => Severity::Low,
            DockRisk::Trusted => Severity::Info,
        };

        let confidence = match risk {
            DockRisk::Malicious => 0.92,
            DockRisk::Suspicious => 0.78,
            DockRisk::Unknown => 0.60,
            _ => (0.4 + indicators.len() as f64 * 0.12).min(0.90),
        };

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1547".to_string());
        }

        self.stats.write().dock_tile_plugins_found += 1;

        let event = DockPluginEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            item_type: DockItemType::DockTilePlugin,
            action, risk, severity, confidence,
            file_path: app_path.to_string(),
            bundle_id: bundle_id.to_string(),
            app_name: app_name.to_string(),
            plugin_path: Some(plugin_path.to_string()),
            content_hash: content_hash.to_string(),
            modifying_process: process_name.to_string(),
            modifying_pid: pid,
            indicators,
            suspicious_symbols,
            mitre_techniques,
            blocked: risk == DockRisk::Malicious,
            is_known_legitimate: is_legitimate,
        };

        // Update stores
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.dock_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.plugin_dedup.write().insert(
            format!("{}:{}", plugin_path, content_hash), vec![]);
        self.known_plugins.write().insert(plugin_path.to_string(), content_hash.to_string());

        let type_str = format!("{:?}", DockItemType::DockTilePlugin);
        let action_str = format!("{:?}", action);
        let current = *self.type_action_matrix.read().get(&type_str, &action_str);
        self.type_action_matrix.write().set(type_str, action_str, current + 1);

        self.stats.write().threats_detected += 1;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.dock_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.plugin_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(confidence);

        warn!("Dock tile plugin: {:?} {:?} {} in {} (pid {})",
            action, risk, bundle_id, app_name, pid);

        Some(event)
    }

    /// Analyze a Dock plist modification (item added/removed/changed).
    pub fn analyze_dock_plist_change(
        &self,
        action: DockAction,
        changed_key: &str,
        item_label: &str,
        item_path: &str,
        content_hash: &str,
        process_name: &str,
        pid: u32,
    ) -> Option<DockPluginEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;
        self.stats.write().plist_modifications += 1;

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();

        // Non-Dock process modifying Dock plist
        if process_name != "Dock" && process_name != "cfprefsd" && process_name != "defaults" {
            indicators.push(format!("Dock plist modified by unexpected process: {}", process_name));
        }

        // Track specific changes
        match action {
            DockAction::ItemAdded => {
                indicators.push(format!("Item added to Dock: '{}' → {}", item_label, item_path));
                mitre_techniques.push("T1547.015".to_string());
                self.stats.write().items_added += 1;
            }
            DockAction::ItemRemoved => {
                indicators.push(format!("Item removed from Dock: '{}'", item_label));
                self.stats.write().items_removed += 1;
            }
            DockAction::ItemReplaced => {
                indicators.push(format!("Dock item replaced: '{}' → {}", item_label, item_path));
                mitre_techniques.push("T1036".to_string());
            }
            DockAction::ConfigChanged => {
                if SUSPICIOUS_DOCK_KEYS.contains(&changed_key) {
                    indicators.push(format!("Suspicious Dock config change: {}", changed_key));
                }
            }
            DockAction::DockRestarted => {
                indicators.push(format!("Dock process restarted by: {}", process_name));
                self.stats.write().dock_restarts += 1;
            }
            _ => {}
        }

        // URL items in Dock (potential phishing)
        if item_path.starts_with("http://") || item_path.starts_with("https://") {
            indicators.push(format!("URL item in Dock: {}", item_path));
            mitre_techniques.push("T1204.001".to_string());
        }

        if indicators.is_empty() { return None; }

        let item_type = if changed_key == "persistent-apps" {
            DockItemType::PersistentApp
        } else if changed_key == "persistent-others" {
            DockItemType::PersistentOther
        } else {
            DockItemType::DockConfig
        };

        let severity = if process_name != "Dock" && process_name != "cfprefsd" {
            Severity::High
        } else {
            Severity::Medium
        };

        let confidence = (0.5 + indicators.len() as f64 * 0.12).min(0.90);

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1547".to_string());
        }

        let event = DockPluginEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            item_type, action,
            risk: DockRisk::Unknown,
            severity, confidence,
            file_path: DOCK_PLIST_NAME.to_string(),
            bundle_id: String::new(),
            app_name: item_label.to_string(),
            plugin_path: None,
            content_hash: content_hash.to_string(),
            modifying_process: process_name.to_string(),
            modifying_pid: pid,
            indicators,
            suspicious_symbols: vec![],
            mitre_techniques,
            blocked: false,
            is_known_legitimate: false,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.dock_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());

        let type_str = format!("{:?}", item_type);
        let action_str = format!("{:?}", action);
        let current = *self.type_action_matrix.read().get(&type_str, &action_str);
        self.type_action_matrix.write().set(type_str.clone(), action_str, current + 1);

        self.stats.write().threats_detected += 1;
        *self.stats.write().item_types.entry(type_str).or_insert(0) += 1;
        self.event_rate.write().push(1.0);

        warn!("Dock persistence: {:?} '{}' by {} (pid {})",
            action, item_label, process_name, pid);

        Some(event)
    }

    pub fn stats(&self) -> DockPluginStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }
}
