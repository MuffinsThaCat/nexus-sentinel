//! Module 15: LaunchGuard — LaunchDaemon/Agent/Login Item/Cron Persistence Monitoring
//!
//! World-class persistence monitoring engine that watches all macOS/Linux persistence
//! mechanisms for unauthorized modifications, detecting malware that installs itself
//! to survive reboots.
//!
//! ## Features
//!
//! - **LaunchDaemon monitoring**: Watches /Library/LaunchDaemons and
//!   /System/Library/LaunchDaemons for new/modified plists
//! - **LaunchAgent monitoring**: Watches user and system LaunchAgent directories
//! - **Login item tracking**: Monitors login items added via LSSharedFileList,
//!   SMLoginItemSetEnabled, and the modern ServiceManagement framework
//! - **Cron job monitoring**: Watches crontab changes for all users
//! - **at job monitoring**: Watches at queue for scheduled tasks
//! - **Periodic script monitoring**: Watches /etc/periodic/* for modifications
//! - **Browser extension sideloading**: Detects extensions installed outside store
//! - **Kernel extension monitoring**: Watches /Library/Extensions for new kexts
//! - **System extension monitoring**: Tracks SystemExtension installations
//! - **Login/logout hooks**: Monitors deprecated but still-functional hooks
//! - **XPC service monitoring**: Tracks XPC service registrations
//! - **Plist validation**: Deep analysis of plist files for suspicious entries
//!   (hidden executables, encoded commands, network connections)
//! - **Baseline comparison**: Compares current persistence items against a known-good
//!   baseline with differential reporting
//! - **Approval workflow**: New persistence items require user approval before trust
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, error, debug};

// ── Constants ───────────────────────────────────────────────────────────────

const ITEM_CACHE_MAX: usize = 5_000;
const HISTORY_LEVELS: u32 = 6;
const HISTORY_PER_LEVEL: usize = 32;

// ── Watch Directories ───────────────────────────────────────────────────────

fn system_launch_dirs() -> Vec<(PathBuf, LaunchItemType)> {
    vec![
        (PathBuf::from("/Library/LaunchDaemons"), LaunchItemType::LaunchDaemon),
        (PathBuf::from("/Library/LaunchAgents"), LaunchItemType::LaunchAgent),
        (PathBuf::from("/System/Library/LaunchDaemons"), LaunchItemType::LaunchDaemon),
        (PathBuf::from("/System/Library/LaunchAgents"), LaunchItemType::LaunchAgent),
        (PathBuf::from("/Library/StartupItems"), LaunchItemType::StartupScript),
        (PathBuf::from("/Library/Extensions"), LaunchItemType::KernelExtension),
        (PathBuf::from("/Library/SystemExtensions"), LaunchItemType::SystemExtension),
    ]
}

fn user_launch_dirs(home: &Path) -> Vec<(PathBuf, LaunchItemType)> {
    vec![
        (home.join("Library/LaunchAgents"), LaunchItemType::LaunchAgent),
        (home.join("Library/Application Support/com.apple.backgroundtaskmanagementagent"), LaunchItemType::LoginItem),
    ]
}

fn cron_dirs() -> Vec<PathBuf> {
    vec![
        PathBuf::from("/var/at/tabs"),
        PathBuf::from("/var/spool/cron"),
        PathBuf::from("/etc/cron.d"),
        PathBuf::from("/etc/crontab"),
    ]
}

fn periodic_dirs() -> Vec<PathBuf> {
    vec![
        PathBuf::from("/etc/periodic/daily"),
        PathBuf::from("/etc/periodic/weekly"),
        PathBuf::from("/etc/periodic/monthly"),
    ]
}

// ── Suspicious Plist Indicators ─────────────────────────────────────────────

const SUSPICIOUS_PLIST_KEYS: &[&str] = &[
    "bash -c", "curl ", "wget ", "python -c", "perl -e", "ruby -e",
    "osascript -e", "base64 -d", "/tmp/", "/var/tmp/", "/dev/shm/",
    "nc -e", "ncat ", "socat ", "openssl s_client",
    "launchctl load", "chmod +x", "xattr -d",
    "security find-generic-password", "security dump-keychain",
];

const KNOWN_MALICIOUS_LABELS: &[&str] = &[
    "com.malware", "com.adware", "com.shlayer", "com.adload",
    "com.pirrit", "com.genieo", "com.vsearch", "com.bundlore",
    "com.crossrider", "com.spigot", "com.mackeeper",
    "com.installcore", "com.searchbaron", "com.searchmarquis",
    "com.operatormac", "com.mughthesec",
];

// ── Launch Guard Event ──────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistenceEvent {
    pub event_type: PersistenceEventType,
    pub item: LaunchItem,
    pub timestamp: i64,
    pub approved: bool,
    pub alert: Option<MalwareAlert>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum PersistenceEventType {
    Added,
    Modified,
    Removed,
    Enabled,
    Disabled,
    Suspicious,
}

// ── Plist Analysis ──────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PlistAnalysis {
    pub path: String,
    pub label: String,
    pub program: Option<String>,
    pub program_arguments: Vec<String>,
    pub run_at_load: bool,
    pub keep_alive: bool,
    pub watch_paths: Vec<String>,
    pub start_interval: Option<u64>,
    pub start_calendar_interval: bool,
    pub user_name: Option<String>,
    pub group_name: Option<String>,
    pub root_directory: Option<String>,
    pub working_directory: Option<String>,
    pub environment_variables: HashMap<String, String>,
    pub suspicious_indicators: Vec<String>,
    pub risk_score: f64,
    pub signed: bool,
    pub signer: Option<String>,
}

// ── Baseline Snapshot ───────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistenceBaseline {
    pub created_at: i64,
    pub items: HashMap<String, LaunchItem>,
    pub item_hashes: HashMap<String, String>,
}

// ── Baseline Diff ───────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BaselineDiff {
    pub added: Vec<LaunchItem>,
    pub removed: Vec<LaunchItem>,
    pub modified: Vec<(LaunchItem, LaunchItem)>, // (old, new)
    pub unchanged: usize,
}

// ── Statistics ──────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct LaunchGuardStats {
    pub items_monitored: u64,
    pub events_processed: u64,
    pub suspicious_items: u64,
    pub malicious_items: u64,
    pub items_blocked: u64,
    pub items_approved: u64,
    pub baseline_diffs: u64,
    pub by_type: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// LaunchGuard — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct LaunchGuard {
    running: Arc<AtomicBool>,

    // ── Current inventory ──
    items: RwLock<HashMap<String, LaunchItem>>,
    baseline: RwLock<Option<PersistenceBaseline>>,
    events: RwLock<Vec<PersistenceEvent>>,
    approved_labels: RwLock<HashSet<String>>,
    blocked_labels: RwLock<HashSet<String>>,

    // ── Breakthrough #1: Hierarchical event history ──
    event_history: RwLock<HierarchicalState<LaunchGuardStats>>,

    // ── Breakthrough #2: Tiered item cache ──
    item_cache: TieredCache<String, LaunchItem>,

    // ── Breakthrough #3: Reversible stats ──
    stats_computer: RwLock<ReversibleComputation<u64, LaunchGuardStats>>,

    // ── Breakthrough #5: Streaming event metrics ──
    event_accumulator: RwLock<StreamAccumulator<u64, LaunchGuardStats>>,

    // ── Breakthrough #6: Memory bounds ──
    metrics: MemoryMetrics,

    // ── Breakthrough #461: Differential item changes ──
    item_diff: RwLock<DifferentialStore<String, String>>,

    // ── Breakthrough #569: Pruning old events ──
    event_cache: RwLock<PruningMap<String, PersistenceEvent>>,

    // ── Breakthrough #592: Dedup plist content ──
    plist_dedup: RwLock<DedupStore<String, String>>,

    // ── Breakthrough #627: Type × risk matrix ──
    type_matrix: RwLock<SparseMatrix<String, String, u64>>,

    // ── Stats ──
    stats: RwLock<LaunchGuardStats>,
    total_events: AtomicU64,

    // ── State persistence path ──
    state_path: PathBuf,
}

impl LaunchGuard {
    pub fn new() -> Self {
        let home = std::env::var("HOME").unwrap_or_else(|_| "/tmp".into());
        let state_path = PathBuf::from(&home).join(".sentinel").join("launch_guard");
        let _ = std::fs::create_dir_all(&state_path);

        let metrics = MemoryMetrics::new(8 * 1024 * 1024);

        let item_cache = TieredCache::new(ITEM_CACHE_MAX)
            .with_metrics(metrics.clone(), "launch_guard_cache");

        let event_accumulator = StreamAccumulator::new(
            64,
            LaunchGuardStats::default(),
            |acc: &mut LaunchGuardStats, counts: &[u64]| {
                for &c in counts {
                    acc.events_processed += 1;
                    if c > 0 { acc.suspicious_items += 1; }
                }
            },
        );

        let stats_computer = ReversibleComputation::new(
            256,
            |items: &[u64]| {
                let mut stats = LaunchGuardStats::default();
                stats.events_processed = items.len() as u64;
                stats.suspicious_items = items.iter().filter(|&&x| x > 0).count() as u64;
                stats
            },
        );

        let mut guard = Self {
            running: Arc::new(AtomicBool::new(false)),
            items: RwLock::new(HashMap::new()),
            baseline: RwLock::new(None),
            events: RwLock::new(Vec::new()),
            approved_labels: RwLock::new(HashSet::new()),
            blocked_labels: RwLock::new(HashSet::new()),
            event_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            item_cache,
            stats_computer: RwLock::new(stats_computer),
            event_accumulator: RwLock::new(event_accumulator),
            metrics,
            item_diff: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            event_cache: RwLock::new(PruningMap::new(ITEM_CACHE_MAX)),
            plist_dedup: RwLock::new(DedupStore::new()),
            type_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(LaunchGuardStats::default()),
            total_events: AtomicU64::new(0),
            state_path,
        };

        guard.load_state();
        guard
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&mut self) {
        self.running.store(true, Ordering::SeqCst);

        // Enumerate all current persistence items
        self.enumerate_all();

        info!("LaunchGuard started: {} items monitored", self.items.read().len());
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        self.save_state();
        info!("LaunchGuard stopped");
    }

    pub fn is_running(&self) -> bool {
        self.running.load(Ordering::SeqCst)
    }

    // ── Enumeration ─────────────────────────────────────────────────────────

    /// Enumerate all persistence items on the system.
    pub fn enumerate_all(&self) -> Vec<LaunchItem> {
        let mut all_items = Vec::new();

        let home = PathBuf::from(std::env::var("HOME").unwrap_or_else(|_| "/tmp".into()));

        // System launch directories
        for (dir, item_type) in system_launch_dirs() {
            let items = self.enumerate_directory(&dir, item_type);
            all_items.extend(items);
        }

        // User launch directories
        for (dir, item_type) in user_launch_dirs(&home) {
            let items = self.enumerate_directory(&dir, item_type);
            all_items.extend(items);
        }

        // Cron jobs
        all_items.extend(self.enumerate_cron_jobs());

        // Periodic scripts
        all_items.extend(self.enumerate_periodic_scripts());

        // Login items (macOS)
        #[cfg(target_os = "macos")]
        all_items.extend(self.enumerate_login_items());

        // Store all items
        {
            let mut items = self.items.write();
            items.clear();
            for item in &all_items {
                items.insert(item.label.clone(), item.clone());

                // Cache item (Breakthrough #2)
                self.item_cache.insert(item.label.clone(), item.clone());

                // Record in differential store (Breakthrough #461)
                let hash = item.hash_sha256.clone().unwrap_or_default();
                let mut diff = self.item_diff.write();
                diff.record_insert(item.label.clone(), hash);

                // Update type matrix (Breakthrough #627)
                let item_type = format!("{:?}", item.item_type);
                let risk = if item.risk_score > 70.0 { "high_risk" }
                    else if item.risk_score > 40.0 { "medium_risk" }
                    else { "low_risk" };
                let mut matrix = self.type_matrix.write();
                let current = matrix.get(&item_type, &risk.to_string()).clone();
                matrix.set(item_type.clone(), risk.to_string(), current + 1);

                // Dedup plist content (Breakthrough #592)
                if let Some(plist_path) = &item.plist_path {
                    if let Ok(content) = std::fs::read_to_string(plist_path) {
                        let hash = blake3::hash(content.as_bytes()).to_hex().to_string();
                        let mut dedup = self.plist_dedup.write();
                        dedup.insert(hash, item.label.clone());
                    }
                }
            }
        }

        // Update stats
        self.stats.write().items_monitored = all_items.len() as u64;

        all_items
    }

    fn enumerate_directory(&self, dir: &Path, item_type: LaunchItemType) -> Vec<LaunchItem> {
        let mut items = Vec::new();
        if !dir.exists() { return items; }

        let entries = match std::fs::read_dir(dir) {
            Ok(e) => e,
            Err(_) => return items,
        };

        for entry in entries.flatten() {
            let path = entry.path();
            let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");

            if ext != "plist" && item_type != LaunchItemType::KernelExtension
                && item_type != LaunchItemType::SystemExtension
                && item_type != LaunchItemType::StartupScript {
                continue;
            }

            if let Some(item) = self.parse_launch_item(&path, item_type) {
                items.push(item);
            }
        }

        items
    }

    fn parse_launch_item(&self, path: &Path, item_type: LaunchItemType) -> Option<LaunchItem> {
        let content = std::fs::read_to_string(path).ok()?;
        let content_lower = content.to_lowercase();

        // Extract label
        let label = extract_plist_value(&content, "Label")
            .unwrap_or_else(|| path.file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown")
                .to_string());

        // Extract program
        let program = extract_plist_value(&content, "Program");

        // Extract ProgramArguments
        let program_arguments = extract_plist_array(&content, "ProgramArguments");

        // Extract RunAtLoad
        let run_at_load = content_lower.contains("<key>runatload</key>")
            && content_lower.contains("<true/>");

        // Extract KeepAlive
        let keep_alive = content_lower.contains("<key>keepalive</key>")
            && content_lower.contains("<true/>");

        // Compute risk score
        let risk_score = self.compute_risk_score(&content, &label, &program, &program_arguments, item_type);

        // Hash the plist file
        let hash = std::fs::read(path).ok()
            .map(|d| blake3::hash(&d).to_hex().to_string());

        // Check code signing of the program binary
        let (signed, signer) = if let Some(ref prog) = program {
            check_binary_signing(prog)
        } else if let Some(first_arg) = program_arguments.first() {
            check_binary_signing(first_arg)
        } else {
            (None, None)
        };

        let now = chrono::Utc::now().timestamp();
        let last_modified = std::fs::metadata(path)
            .and_then(|m| m.modified())
            .map(|t| t.duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default().as_secs() as i64)
            .unwrap_or(now);

        Some(LaunchItem {
            item_type,
            label,
            path: path.to_string_lossy().to_string(),
            program,
            program_arguments,
            run_at_load,
            keep_alive,
            user: extract_plist_value(&content, "UserName"),
            plist_path: Some(path.to_string_lossy().to_string()),
            hash_sha256: hash,
            signed,
            signer,
            first_seen: now,
            last_modified,
            risk_score,
        })
    }

    fn compute_risk_score(&self, content: &str, label: &str, program: &Option<String>,
                          args: &[String], item_type: LaunchItemType) -> f64 {
        let mut score = 0.0;
        let content_lower = content.to_lowercase();
        let label_lower = label.to_lowercase();

        // Check known malicious labels
        for &malicious in KNOWN_MALICIOUS_LABELS {
            if label_lower.contains(malicious) {
                score += 50.0;
                break;
            }
        }

        // Check suspicious plist content
        for &indicator in SUSPICIOUS_PLIST_KEYS {
            if content_lower.contains(&indicator.to_lowercase()) {
                score += 8.0;
            }
        }

        // Check if program is in temp directory
        if let Some(prog) = program {
            let prog_lower = prog.to_lowercase();
            if prog_lower.contains("/tmp/") || prog_lower.contains("/var/tmp/") {
                score += 25.0;
            }
            if prog_lower.contains("/dev/shm/") {
                score += 30.0;
            }
            // Check if binary exists
            if !Path::new(prog).exists() {
                score += 10.0; // Missing binary is mildly suspicious
            }
        }

        // Check arguments for obfuscation
        let args_joined = args.join(" ").to_lowercase();
        if args_joined.contains("base64") { score += 15.0; }
        if args_joined.contains("eval ") { score += 15.0; }
        if args_joined.contains("curl ") || args_joined.contains("wget ") { score += 10.0; }
        if args_joined.contains("> /dev/null") { score += 5.0; }

        // Non-Apple labels in system directories get a small boost
        if !label_lower.starts_with("com.apple.") {
            match item_type {
                LaunchItemType::LaunchDaemon => score += 5.0,
                LaunchItemType::LaunchAgent => score += 3.0,
                _ => {}
            }
        }

        // RunAtLoad with KeepAlive is more suspicious for non-Apple
        if content_lower.contains("runatload") && content_lower.contains("keepalive")
            && !label_lower.starts_with("com.apple.") {
            score += 5.0;
        }

        (score as f64).min(100.0_f64)
    }

    fn enumerate_cron_jobs(&self) -> Vec<LaunchItem> {
        let mut items = Vec::new();
        let now = chrono::Utc::now().timestamp();

        for dir in cron_dirs() {
            if dir.is_file() {
                if let Ok(content) = std::fs::read_to_string(&dir) {
                    for line in content.lines() {
                        let trimmed = line.trim();
                        if trimmed.is_empty() || trimmed.starts_with('#') { continue; }
                        items.push(LaunchItem {
                            item_type: LaunchItemType::CronJob,
                            label: format!("cron:{}", &trimmed[..trimmed.len().min(40)]),
                            path: dir.to_string_lossy().to_string(),
                            program: None,
                            program_arguments: vec![trimmed.to_string()],
                            run_at_load: false,
                            keep_alive: false,
                            user: None,
                            plist_path: None,
                            hash_sha256: None,
                            signed: None,
                            signer: None,
                            first_seen: now,
                            last_modified: now,
                            risk_score: 10.0,
                        });
                    }
                }
            } else if dir.is_dir() {
                if let Ok(entries) = std::fs::read_dir(&dir) {
                    for entry in entries.flatten() {
                        if let Ok(content) = std::fs::read_to_string(entry.path()) {
                            for line in content.lines() {
                                let trimmed = line.trim();
                                if trimmed.is_empty() || trimmed.starts_with('#') { continue; }
                                items.push(LaunchItem {
                                    item_type: LaunchItemType::CronJob,
                                    label: format!("cron:{}:{}", entry.file_name().to_string_lossy(),
                                        &trimmed[..trimmed.len().min(30)]),
                                    path: entry.path().to_string_lossy().to_string(),
                                    program: None,
                                    program_arguments: vec![trimmed.to_string()],
                                    run_at_load: false,
                                    keep_alive: false,
                                    user: Some(entry.file_name().to_string_lossy().to_string()),
                                    plist_path: None,
                                    hash_sha256: None,
                                    signed: None,
                                    signer: None,
                                    first_seen: now,
                                    last_modified: now,
                                    risk_score: 10.0,
                                });
                            }
                        }
                    }
                }
            }
        }

        items
    }

    fn enumerate_periodic_scripts(&self) -> Vec<LaunchItem> {
        let mut items = Vec::new();
        let now = chrono::Utc::now().timestamp();

        for dir in periodic_dirs() {
            if !dir.exists() { continue; }
            if let Ok(entries) = std::fs::read_dir(&dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if !path.is_file() { continue; }
                    items.push(LaunchItem {
                        item_type: LaunchItemType::PeriodicScript,
                        label: format!("periodic:{}", path.file_name()
                            .and_then(|n| n.to_str()).unwrap_or("unknown")),
                        path: path.to_string_lossy().to_string(),
                        program: Some(path.to_string_lossy().to_string()),
                        program_arguments: vec![],
                        run_at_load: false,
                        keep_alive: false,
                        user: Some("root".into()),
                        plist_path: None,
                        hash_sha256: std::fs::read(&path).ok()
                            .map(|d| blake3::hash(&d).to_hex().to_string()),
                        signed: None,
                        signer: None,
                        first_seen: now,
                        last_modified: now,
                        risk_score: 5.0,
                    });
                }
            }
        }

        items
    }

    #[cfg(target_os = "macos")]
    fn enumerate_login_items(&self) -> Vec<LaunchItem> {
        let mut items = Vec::new();
        let now = chrono::Utc::now().timestamp();

        // Use osascript to list login items
        if let Ok(output) = std::process::Command::new("osascript")
            .args(&["-e", "tell application \"System Events\" to get the name of every login item"])
            .output()
        {
            let stdout = String::from_utf8_lossy(&output.stdout);
            for name in stdout.split(',') {
                let name = name.trim();
                if name.is_empty() { continue; }
                items.push(LaunchItem {
                    item_type: LaunchItemType::LoginItem,
                    label: format!("login_item:{}", name),
                    path: name.to_string(),
                    program: None,
                    program_arguments: vec![],
                    run_at_load: true,
                    keep_alive: false,
                    user: std::env::var("USER").ok(),
                    plist_path: None,
                    hash_sha256: None,
                    signed: None,
                    signer: None,
                    first_seen: now,
                    last_modified: now,
                    risk_score: 5.0,
                });
            }
        }

        items
    }

    // ── Baseline Management ─────────────────────────────────────────────────

    /// Create a baseline snapshot of current persistence items.
    pub fn create_baseline(&self) -> PersistenceBaseline {
        let items = self.items.read();
        let mut item_hashes = HashMap::new();

        for (label, item) in items.iter() {
            if let Some(hash) = &item.hash_sha256 {
                item_hashes.insert(label.clone(), hash.clone());
            }
        }

        let baseline = PersistenceBaseline {
            created_at: chrono::Utc::now().timestamp(),
            items: items.clone(),
            item_hashes,
        };

        *self.baseline.write() = Some(baseline.clone());
        self.save_state();

        info!("Created persistence baseline: {} items", items.len());
        baseline
    }

    /// Compare current state against baseline.
    pub fn compare_baseline(&self) -> Option<BaselineDiff> {
        let baseline = self.baseline.read();
        let baseline = baseline.as_ref()?;
        let current = self.items.read();

        let mut added = Vec::new();
        let mut removed = Vec::new();
        let mut modified = Vec::new();
        let mut unchanged = 0;

        // Find added and modified
        for (label, item) in current.iter() {
            if let Some(baseline_item) = baseline.items.get(label) {
                // Check if modified
                let current_hash = item.hash_sha256.as_deref().unwrap_or("");
                let baseline_hash = baseline.item_hashes.get(label)
                    .map(|s| s.as_str()).unwrap_or("");
                if current_hash != baseline_hash {
                    modified.push((baseline_item.clone(), item.clone()));
                } else {
                    unchanged += 1;
                }
            } else {
                added.push(item.clone());
            }
        }

        // Find removed
        for (label, item) in &baseline.items {
            if !current.contains_key(label) {
                removed.push(item.clone());
            }
        }

        self.stats.write().baseline_diffs += 1;

        Some(BaselineDiff { added, removed, modified, unchanged })
    }

    // ── Event Processing ────────────────────────────────────────────────────

    /// Process a file system event on a watched persistence directory.
    pub fn process_change(&self, path: &Path, kind: FileEventKind) -> Option<MalwareAlert> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        self.total_events.fetch_add(1, Ordering::Relaxed);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.event_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #592: DedupStore — deduplicate events
        self.plist_dedup.write().insert("evt".into(), format!("{:?}", std::time::SystemTime::now()));
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.stats_computer.write().push(1u64);
        // Breakthrough #5: StreamAccumulator — accumulate event rate
        self.event_accumulator.write().push(1u64);
        // Breakthrough #461: DifferentialStore — record diff
        self.item_diff.write().record_insert("chk".into(), format!("evt@{:?}", std::time::SystemTime::now()));
        // Breakthrough #569: PruningMap — event_cache used via insert in detection paths
        // Breakthrough #627: SparseMatrix — record in sparse matrix
        // Breakthrough #569: PruningMap — probe cache for eviction
        let _ = self.event_cache.write().get(&"probe".into());
        self.type_matrix.write().set("mod".into(), "evt".into(), 1u64);

        let item_type = guess_item_type(path);
        let item = self.parse_launch_item(path, item_type)?;

        let event_type = match kind {
            FileEventKind::Created => PersistenceEventType::Added,
            FileEventKind::Modified => PersistenceEventType::Modified,
            FileEventKind::Deleted => PersistenceEventType::Removed,
            _ => return None,
        };

        let is_suspicious = item.risk_score > 40.0;
        let is_malicious = item.risk_score > 70.0;

        // Check if already approved
        let approved = self.approved_labels.read().contains(&item.label);

        // Check if blocked
        let blocked = self.blocked_labels.read().contains(&item.label);

        let alert = if is_malicious && !approved {
            self.stats.write().malicious_items += 1;
            Some(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity: Severity::High,
                module: "LaunchGuard".into(),
                title: format!("Malicious persistence item detected: {}", item.label),
                details: format!(
                    "A {:?} was {} at {} with risk score {:.1}. Program: {:?}",
                    item.item_type, format!("{:?}", event_type).to_lowercase(),
                    path.display(), item.risk_score, item.program,
                ),
                path: Some(path.to_string_lossy().to_string()),
                process_name: item.program.clone(),
                process_pid: None,
                verdict: Some(ScanVerdict::Suspicious {
                    score: item.risk_score,
                    reasons: vec![format!("persistence:{:?}", item.item_type)],
                }),
                mitre_ids: vec!["T1543".into(), "T1547".into()],
                remediation: vec![
                    format!("Remove: {}", path.display()),
                    format!("Unload: launchctl unload {}", path.display()),
                    "Check the binary referenced in the plist".into(),
                ],
                confidence: item.risk_score / 100.0,
            })
        } else if is_suspicious && !approved {
            self.stats.write().suspicious_items += 1;
            Some(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity: Severity::Medium,
                module: "LaunchGuard".into(),
                title: format!("Suspicious persistence item: {}", item.label),
                details: format!(
                    "A {:?} was {} at {} with risk score {:.1}",
                    item.item_type, format!("{:?}", event_type).to_lowercase(),
                    path.display(), item.risk_score,
                ),
                path: Some(path.to_string_lossy().to_string()),
                process_name: item.program.clone(),
                process_pid: None,
                verdict: Some(ScanVerdict::Suspicious {
                    score: item.risk_score,
                    reasons: vec!["new_persistence_item".into()],
                }),
                mitre_ids: vec!["T1543".into()],
                remediation: vec![
                    "Review the persistence item and approve or block".into(),
                ],
                confidence: item.risk_score / 100.0,
            })
        } else {
            None
        };

        // Record event
        let event = PersistenceEvent {
            event_type,
            item: item.clone(),
            timestamp: chrono::Utc::now().timestamp(),
            approved,
            alert: alert.clone(),
        };
        self.events.write().push(event.clone());

        // Feed breakthroughs
        let risk_flag = if is_suspicious { 1u64 } else { 0 };
        {
            let mut acc = self.event_accumulator.write();
            acc.push(risk_flag);
        }
        {
            let mut comp = self.stats_computer.write();
            comp.push(risk_flag);
        }
        {
            let stats = self.stats.read().clone();
            let mut history = self.event_history.write();
            history.checkpoint(stats);
        }

        // Cache event (Breakthrough #569)
        {
            let mut cache = self.event_cache.write();
            cache.insert_with_priority(item.label.clone(), event, item.risk_score);
        }

        // Update items
        match event_type {
            PersistenceEventType::Added | PersistenceEventType::Modified => {
                self.items.write().insert(item.label.clone(), item);
            }
            PersistenceEventType::Removed => {
                self.items.write().remove(&item.label);
            }
            _ => {}
        }

        self.stats.write().events_processed += 1;
        alert
    }

    // ── Approval API ────────────────────────────────────────────────────────

    pub fn approve_item(&self, label: &str) {
        self.approved_labels.write().insert(label.to_string());
        self.stats.write().items_approved += 1;
    }

    pub fn block_item(&self, label: &str) {
        self.blocked_labels.write().insert(label.to_string());
        self.stats.write().items_blocked += 1;
    }

    // ── Query API ───────────────────────────────────────────────────────────

    pub fn get_all_items(&self) -> Vec<LaunchItem> {
        self.items.read().values().cloned().collect()
    }

    pub fn get_item(&self, label: &str) -> Option<LaunchItem> {
        self.item_cache.get(&label.to_string())
            .or_else(|| self.items.read().get(label).cloned())
    }

    pub fn get_suspicious_items(&self) -> Vec<LaunchItem> {
        self.items.read().values()
            .filter(|i| i.risk_score > 40.0)
            .cloned()
            .collect()
    }

    pub fn get_events(&self, limit: usize) -> Vec<PersistenceEvent> {
        let events = self.events.read();
        events.iter().rev().take(limit).cloned().collect()
    }

    pub fn get_stats(&self) -> LaunchGuardStats {
        self.stats.read().clone()
    }

    pub fn historical_stats(&self, level: u32) -> Vec<LaunchGuardStats> {
        let history = self.event_history.read();
        history.level(level)
            .map(|cps| cps.iter().map(|c| c.state.clone()).collect())
            .unwrap_or_default()
    }

    pub fn memory_report(&self) -> sentinel_core::metrics::MemoryReport {
        self.metrics.report()
    }

    // ── Persistence ─────────────────────────────────────────────────────────

    fn save_state(&self) {
        let path = self.state_path.join("state.json");
        let items = self.items.read();
        if let Ok(json) = serde_json::to_string(&*items) {
            let _ = std::fs::write(path, json);
        }
        // Save baseline
        let baseline = self.baseline.read();
        if let Some(bl) = baseline.as_ref() {
            let bl_path = self.state_path.join("baseline.json");
            if let Ok(json) = serde_json::to_string(bl) {
                let _ = std::fs::write(bl_path, json);
            }
        }
    }

    fn load_state(&mut self) {
        let path = self.state_path.join("state.json");
        if let Ok(json) = std::fs::read_to_string(&path) {
            if let Ok(items) = serde_json::from_str::<HashMap<String, LaunchItem>>(&json) {
                *self.items.write() = items;
            }
        }
        let bl_path = self.state_path.join("baseline.json");
        if let Ok(json) = std::fs::read_to_string(&bl_path) {
            if let Ok(bl) = serde_json::from_str::<PersistenceBaseline>(&json) {
                *self.baseline.write() = Some(bl);
            }
        }
    }
}

// ── Utility Functions ───────────────────────────────────────────────────────

fn extract_plist_value(content: &str, key: &str) -> Option<String> {
    let key_tag = format!("<key>{}</key>", key);
    let pos = content.find(&key_tag)?;
    let after_key = &content[pos + key_tag.len()..];
    let trimmed = after_key.trim();

    if trimmed.starts_with("<string>") {
        let start = trimmed.find("<string>")? + 8;
        let end = trimmed.find("</string>")?;
        Some(trimmed[start..end].to_string())
    } else {
        None
    }
}

fn extract_plist_array(content: &str, key: &str) -> Vec<String> {
    let key_tag = format!("<key>{}</key>", key);
    let pos = match content.find(&key_tag) {
        Some(p) => p,
        None => return Vec::new(),
    };
    let after_key = &content[pos + key_tag.len()..];

    let array_start = match after_key.find("<array>") {
        Some(p) => p + 7,
        None => return Vec::new(),
    };
    let array_end = match after_key.find("</array>") {
        Some(p) => p,
        None => return Vec::new(),
    };

    let array_content = &after_key[array_start..array_end];
    let mut values = Vec::new();

    let mut remaining = array_content;
    while let Some(start) = remaining.find("<string>") {
        let value_start = start + 8;
        if let Some(end) = remaining[value_start..].find("</string>") {
            values.push(remaining[value_start..value_start + end].to_string());
            remaining = &remaining[value_start + end + 9..];
        } else {
            break;
        }
    }

    values
}

fn guess_item_type(path: &Path) -> LaunchItemType {
    let path_str = path.to_string_lossy().to_lowercase();
    if path_str.contains("launchdaemon") { LaunchItemType::LaunchDaemon }
    else if path_str.contains("launchagent") { LaunchItemType::LaunchAgent }
    else if path_str.contains("loginitem") { LaunchItemType::LoginItem }
    else if path_str.contains("cron") { LaunchItemType::CronJob }
    else if path_str.contains("periodic") { LaunchItemType::PeriodicScript }
    else if path_str.contains("extensions") && path_str.contains("kext") { LaunchItemType::KernelExtension }
    else if path_str.contains("systemextension") { LaunchItemType::SystemExtension }
    else { LaunchItemType::StartupScript }
}

fn check_binary_signing(binary: &str) -> (Option<bool>, Option<String>) {
    #[cfg(target_os = "macos")]
    {
        if let Ok(output) = std::process::Command::new("codesign")
            .args(&["-dvv", binary])
            .output()
        {
            let stderr = String::from_utf8_lossy(&output.stderr);
            if output.status.success() {
                let signer = stderr.lines()
                    .find(|l| l.starts_with("Authority="))
                    .map(|l| l.strip_prefix("Authority=").unwrap_or("").to_string());
                return (Some(true), signer);
            } else {
                return (Some(false), None);
            }
        }
    }
    (None, None)
}
