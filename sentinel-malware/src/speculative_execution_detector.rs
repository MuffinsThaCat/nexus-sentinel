//! Module 148: SpeculativeExecutionDetector — CPU Side-Channel & Speculative Execution Attack Detection
//!
//! Detects Spectre, Meltdown, MDS, LVI, and other microarchitectural attacks
//! that exploit speculative execution, branch prediction, and CPU cache
//! behavior on both Intel and Apple Silicon Macs. Monitors for both active
//! exploitation and vulnerability exposure.
//!
//! ## Detection Capabilities
//!
//! ### Spectre Variants
//! - **Spectre v1 (Bounds Check Bypass)**: Detection of gadgets that
//!   speculatively bypass array bounds checks to leak data through cache
//!   timing side channels (CVE-2017-5753)
//! - **Spectre v2 (Branch Target Injection)**: BTI/BHI attacks that poison
//!   indirect branch predictors to redirect speculative execution
//!   (CVE-2017-5715, CVE-2022-0001/0002)
//! - **Spectre-BHB (Branch History Buffer)**: Exploits branch history to
//!   perform cross-privilege speculative execution
//! - **Spectre-RSB (Return Stack Buffer)**: RSB poisoning/underflow to
//!   hijack speculative returns
//! - **Spectre-STL (Speculative Store Bypass)**: Store-to-load forwarding
//!   bypass for data leakage (CVE-2018-3639)
//! - **SpectreRSB/ret2spec**: Return address speculation attacks
//!
//! ### Meltdown Variants
//! - **Meltdown (Rogue Data Cache Load)**: Reading kernel memory from
//!   userspace via speculative execution (CVE-2017-5754)
//! - **Meltdown-GP (Bounds Check Bypass Store)**: Speculative store after
//!   faulting load
//! - **L1TF (L1 Terminal Fault/Foreshadow)**: Reading L1 cache via terminal
//!   page fault (CVE-2018-3615/3620/3646)
//! - **RIDL/Fallout/ZombieLoad (MDS)**: Microarchitectural Data Sampling
//!   from fill buffers, store buffers, load ports (CVE-2018-12126/12127/12130)
//! - **TAA (TSX Asynchronous Abort)**: Data leak via TSX abort handling
//!   (CVE-2019-11135)
//! - **CacheOut/L1DES**: L1 Data Eviction Sampling (CVE-2020-0549)
//!
//! ### Advanced Microarchitectural Attacks
//! - **LVI (Load Value Injection)**: Injecting values into speculative
//!   execution via microarchitectural buffers (CVE-2020-0551)
//! - **PACMAN**: Speculative execution attack to bypass ARM64 PAC on
//!   Apple Silicon (M1/M2)
//! - **Augury**: Data Memory-Dependent Prefetcher (DMP) side channel on
//!   Apple Silicon
//! - **GoFetch**: DMP-based cryptographic key extraction on Apple M-series
//! - **iLeakage**: Safari-based speculative execution attack on Apple Silicon
//! - **Downfall/GDS (Gather Data Sampling)**: AVX data leak on Intel
//!   (CVE-2022-40982)
//! - **Inception/SRSO (Speculative Return Stack Overflow)**: AMD phantom
//!   speculation (relevant for Hackintosh)
//!
//! ### Cache Timing Attacks
//! - **Prime+Probe**: Filling cache sets then measuring eviction timing
//! - **Flush+Reload**: Using clflush + timing to detect shared memory access
//! - **Evict+Time**: Cache eviction timing measurements
//! - **Cache occupancy attacks**: Monitoring total cache occupancy changes
//! - **TLB side channels**: Translation Lookaside Buffer timing attacks
//! - **ASLR bypass via cache**: Cache-based ASLR defeat
//!
//! ### Detection Indicators
//! - **High-resolution timer abuse**: rdtsc/mach_absolute_time used for
//!   sub-nanosecond timing measurements
//! - **Cache manipulation instructions**: clflush, clflushopt, clwb usage
//!   from non-system processes
//! - **TSX instruction usage**: xbegin/xend/xabort for transactional memory
//!   side channels
//! - **Speculative gadget patterns**: Code patterns matching known Spectre
//!   gadgets in loaded binaries
//! - **Performance counter anomalies**: Branch misprediction spikes, cache
//!   miss patterns indicating side-channel probing
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1082 — System Information Discovery
//! - T1003 — OS Credential Dumping
//! - T1552 — Unsecured Credentials
//! - T1190 — Exploit Public-Facing Application
//!
//! ## Memory Breakthroughs: All 13 integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const TIMER_ACCESS_SPIKE_THRESHOLD: u64 = 10_000;
const BRANCH_MISPREDICT_SPIKE_RATIO: f64 = 0.15;
const CACHE_MISS_SPIKE_RATIO: f64 = 0.25;

// ── Known Speculative Execution CVEs ─────────────────────────────────────────

const SPECULATIVE_EXEC_CVES: &[(&str, &str, &str, &str, f64)] = &[
    // Spectre family
    ("CVE-2017-5753", "Spectre v1 (Bounds Check Bypass)", "spectre_v1", "Intel/ARM/Apple", 0.85),
    ("CVE-2017-5715", "Spectre v2 (Branch Target Injection)", "spectre_v2", "Intel/ARM", 0.85),
    ("CVE-2018-3639", "Spectre v4 (Speculative Store Bypass)", "spectre_stl", "Intel/ARM", 0.8),
    ("CVE-2022-0001", "Spectre-BHI (Branch History Injection)", "spectre_bhi", "Intel", 0.85),
    ("CVE-2022-0002", "Spectre-BHB (Branch History Buffer)", "spectre_bhb", "Intel/ARM", 0.85),
    ("CVE-2022-29901", "RetBleed (Return-based Spectre v2)", "retbleed", "Intel/AMD", 0.85),
    // Meltdown family
    ("CVE-2017-5754", "Meltdown (Rogue Data Cache Load)", "meltdown", "Intel", 0.9),
    ("CVE-2018-3615", "L1TF/Foreshadow (L1 Terminal Fault)", "l1tf", "Intel", 0.85),
    ("CVE-2018-3620", "L1TF OS/SMM variant", "l1tf_os", "Intel", 0.85),
    // MDS family
    ("CVE-2018-12126", "MSBDS (Microarch Store Buffer Data Sampling)", "mds_msbds", "Intel", 0.85),
    ("CVE-2018-12127", "MLPDS (Microarch Load Port Data Sampling)", "mds_mlpds", "Intel", 0.85),
    ("CVE-2018-12130", "MFBDS (Microarch Fill Buffer Data Sampling / ZombieLoad)", "mds_zombieload", "Intel", 0.9),
    ("CVE-2019-11091", "MDSUM (Microarch Data Sampling Uncacheable Memory)", "mds_mdsum", "Intel", 0.8),
    ("CVE-2019-11135", "TAA (TSX Asynchronous Abort)", "taa", "Intel", 0.85),
    ("CVE-2020-0549", "CacheOut / L1DES (L1 Data Eviction Sampling)", "cacheout", "Intel", 0.85),
    // Advanced
    ("CVE-2020-0551", "LVI (Load Value Injection)", "lvi", "Intel", 0.85),
    ("CVE-2022-40982", "Downfall / GDS (Gather Data Sampling)", "downfall", "Intel", 0.85),
    ("CVE-2023-20569", "Inception / SRSO (Speculative Return Stack Overflow)", "inception", "AMD", 0.8),
    // Apple Silicon specific
    ("PACMAN-2022", "PACMAN (PAC bypass via speculative execution)", "pacman", "Apple_M1/M2", 0.85),
    ("Augury-2022", "Augury (DMP side channel on Apple Silicon)", "augury", "Apple_M1/M2", 0.8),
    ("GoFetch-2024", "GoFetch (DMP crypto key extraction)", "gofetch", "Apple_M1/M2/M3", 0.9),
    ("iLeakage-2023", "iLeakage (Safari speculative execution)", "ileakage", "Apple_M1/M2/M3", 0.85),
];

// ── Attack Pattern Indicators ────────────────────────────────────────────────

const ATTACK_PATTERNS: &[(&str, &str, &str, f64)] = &[
    // Timer abuse
    ("rdtsc_high_rate", "High-rate rdtsc/rdtscp usage (timing side channel)", "T1082", 0.7),
    ("mach_absolute_time_spam", "Excessive mach_absolute_time calls (cache timing)", "T1082", 0.6),
    ("clock_gettime_monotonic_spam", "High-rate CLOCK_MONOTONIC queries", "T1082", 0.5),
    ("performance_counter_access", "Direct performance counter access (PMC)", "T1082", 0.6),
    // Cache manipulation
    ("clflush_usage", "clflush instruction from userspace (Flush+Reload)", "T1003", 0.7),
    ("clflushopt_usage", "clflushopt instruction (optimized cache flush)", "T1003", 0.7),
    ("cache_line_probe", "Systematic cache line probing pattern (Prime+Probe)", "T1003", 0.8),
    ("cache_set_eviction", "Targeted cache set eviction pattern", "T1003", 0.75),
    ("shared_memory_probe", "Shared memory region timing probes (Flush+Reload)", "T1003", 0.75),
    ("tlb_probe_pattern", "TLB probing pattern detected", "T1003", 0.7),
    // TSX abuse
    ("tsx_abort_pattern", "Repeated TSX abort pattern (TAA/MDS exploit)", "T1003", 0.8),
    ("xbegin_xabort_loop", "xbegin/xabort loop (transactional side channel)", "T1003", 0.8),
    // Branch predictor
    ("branch_mispredict_spike", "Branch misprediction rate spike (BTI training)", "T1003", 0.7),
    ("indirect_branch_training", "Indirect branch predictor training pattern", "T1003", 0.75),
    ("rsb_stuffing_detected", "Return Stack Buffer stuffing pattern", "T1003", 0.75),
    ("branch_history_manipulation", "Branch history buffer manipulation", "T1003", 0.75),
    // Speculative gadgets
    ("spectre_v1_gadget", "Spectre v1 gadget pattern in loaded code", "T1203", 0.7),
    ("spectre_v2_gadget", "Spectre v2 indirect branch gadget", "T1203", 0.7),
    ("rop_speculative_chain", "ROP chain with speculative execution window", "T1203", 0.8),
    // Apple Silicon specific
    ("dmp_probe_pattern", "Data Memory-Dependent Prefetcher probe (Augury/GoFetch)", "T1003", 0.85),
    ("pac_oracle", "PAC oracle: speculative PAC verification bypass", "T1003", 0.85),
    ("ileakage_pattern", "iLeakage: speculative type confusion in WebKit", "T1003", 0.85),
    // Memory access patterns
    ("kernel_address_probe", "Probing kernel address space via timing", "T1003", 0.8),
    ("aslr_defeat_timing", "ASLR defeat via cache timing", "T1082", 0.75),
    ("cross_vm_leakage", "Cross-VM data leakage pattern", "T1003", 0.8),
    ("cross_process_leakage", "Cross-process speculative data leakage", "T1003", 0.85),
    ("crypto_key_extraction", "Cryptographic key extraction via side channel", "T1552", 0.9),
];

// ── Mitigation Status Indicators ─────────────────────────────────────────────

const MITIGATION_STATUS: &[(&str, &str, f64)] = &[
    ("kpti_disabled", "KPTI (Kernel Page Table Isolation) disabled — Meltdown vulnerable", 0.85),
    ("ibrs_disabled", "IBRS (Indirect Branch Restricted Speculation) disabled", 0.7),
    ("ibpb_disabled", "IBPB (Indirect Branch Prediction Barrier) disabled", 0.6),
    ("stibp_disabled", "STIBP (Single Thread Indirect Branch Predictors) disabled", 0.5),
    ("ssbd_disabled", "SSBD (Speculative Store Bypass Disable) disabled", 0.6),
    ("mds_mitigation_off", "MDS mitigation (md_clear/verw) disabled", 0.7),
    ("tsx_enabled", "TSX (Transactional Synchronization Extensions) enabled", 0.4),
    ("l1d_flush_disabled", "L1D cache flush on VM entry disabled", 0.6),
    ("retpoline_absent", "Retpoline not in use (Spectre v2 mitigation)", 0.6),
    ("dit_disabled", "DIT (Data Independent Timing) not enabled on Apple Silicon", 0.5),
    ("ssbs_disabled", "SSBS (Speculative Store Bypass Safe) not enabled on ARM", 0.5),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SideChannelThreatType {
    SpectreV1,
    SpectreV2,
    SpectreSTL,
    SpectreBHI,
    SpectreBHB,
    SpectreRSB,
    RetBleed,
    Meltdown,
    L1TerminalFault,
    MDS_ZombieLoad,
    MDS_RIDL,
    MDS_Fallout,
    TSXAsyncAbort,
    CacheOut,
    LoadValueInjection,
    Downfall,
    Inception,
    PACMAN,
    Augury,
    GoFetch,
    ILeakage,
    FlushReload,
    PrimeProbe,
    EvictTime,
    TimerAbuse,
    CacheManipulation,
    TSXAbuse,
    BranchPredictorTraining,
    RSBStuffing,
    SpeculativeGadget,
    KernelAddressProbe,
    ASLRDefeat,
    CrossProcessLeak,
    CryptoKeyExtraction,
    MitigationDisabled,
    KnownCVEExploit,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SideChannelFinding {
    pub threat_type: SideChannelThreatType,
    pub confidence: f64,
    pub description: String,
    pub attack_variant: Option<String>,
    pub cve_id: Option<String>,
    pub affected_cpu: Option<String>,
    pub mitigation_status: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timer_rate: Option<u64>,
    pub cache_miss_ratio: Option<f64>,
    pub branch_mispredict_ratio: Option<f64>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SideChannelEvent {
    pub event_type: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub cpu_type: Option<String>,          // "intel", "apple_m1", "apple_m2", "apple_m3"
    pub timer_access_rate: Option<u64>,
    pub cache_miss_ratio: Option<f64>,
    pub branch_mispredict_ratio: Option<f64>,
    pub tsx_abort_count: Option<u64>,
    pub performance_counters: HashMap<String, u64>,
    pub instructions_detected: Vec<String>, // "clflush", "rdtsc", "xbegin", etc.
    pub integrity_check: Option<String>,
    pub mitigation_status: Vec<String>,
    pub loaded_modules: Vec<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SideChannelAnalysisResult {
    pub is_attack: bool,
    pub events_analyzed: u32,
    pub findings: Vec<SideChannelFinding>,
    pub attack_families: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SideChannelScanStats {
    pub total_events: u64,
    pub attack_detections: u64,
    pub spectre_detections: u64,
    pub meltdown_detections: u64,
    pub mds_detections: u64,
    pub apple_silicon_detections: u64,
    pub cache_attack_detections: u64,
    pub mitigation_gaps: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SideChannelSigEntry { pub pattern: String, pub variant: String, pub severity: f64 }

pub struct SpeculativeExecutionDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SideChannelScanStats>>,
    result_cache: TieredCache<String, SideChannelAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    sc_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SideChannelScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, SideChannelAnalysisResult>>,
    sig_db: PagedMemory<SideChannelSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<SideChannelScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SpeculativeExecutionDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            sc_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SideChannelScanStats::default(),
                |acc: &mut SideChannelScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(SideChannelScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &SideChannelEvent) -> Option<SideChannelAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("sidechan:{}:{}:{}", event.event_type, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut families = HashSet::new();

        let ind_text = format!("{} {}",
            event.event_type,
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. CVE-specific detection ───────────────────────────────────
        for &(cve, desc, variant, cpus, conf) in SPECULATIVE_EXEC_CVES {
            if ind_lower.contains(&variant.to_lowercase()) || ind_lower.contains(&cve.to_lowercase()) {
                let cpu_match = event.cpu_type.as_ref().map_or(true, |cpu| {
                    cpus.to_lowercase().contains(&cpu.to_lowercase()) || cpus.contains("Intel") || cpus.contains("ARM")
                });
                if cpu_match {
                    let tt = match variant {
                        "spectre_v1" => SideChannelThreatType::SpectreV1,
                        "spectre_v2" | "retbleed" => SideChannelThreatType::SpectreV2,
                        "spectre_stl" => SideChannelThreatType::SpectreSTL,
                        "spectre_bhi" => SideChannelThreatType::SpectreBHI,
                        "spectre_bhb" => SideChannelThreatType::SpectreBHB,
                        "meltdown" => SideChannelThreatType::Meltdown,
                        "l1tf" | "l1tf_os" => SideChannelThreatType::L1TerminalFault,
                        "mds_zombieload" | "mds_mfbds" => SideChannelThreatType::MDS_ZombieLoad,
                        "mds_mlpds" => SideChannelThreatType::MDS_RIDL,
                        "mds_msbds" | "mds_mdsum" => SideChannelThreatType::MDS_Fallout,
                        "taa" => SideChannelThreatType::TSXAsyncAbort,
                        "cacheout" => SideChannelThreatType::CacheOut,
                        "lvi" => SideChannelThreatType::LoadValueInjection,
                        "downfall" => SideChannelThreatType::Downfall,
                        "inception" => SideChannelThreatType::Inception,
                        "pacman" => SideChannelThreatType::PACMAN,
                        "augury" => SideChannelThreatType::Augury,
                        "gofetch" => SideChannelThreatType::GoFetch,
                        "ileakage" => SideChannelThreatType::ILeakage,
                        _ => SideChannelThreatType::KnownCVEExploit,
                    };
                    let family = if variant.starts_with("spectre") || variant == "retbleed" { "Spectre" }
                        else if variant == "meltdown" || variant.starts_with("l1tf") { "Meltdown" }
                        else if variant.starts_with("mds") || variant == "taa" || variant == "cacheout" { "MDS" }
                        else if variant == "pacman" || variant == "augury" || variant == "gofetch" || variant == "ileakage" { "AppleSilicon" }
                        else { "Other" };
                    findings.push(SideChannelFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("{}: {}", cve, desc),
                        attack_variant: Some(variant.to_string()),
                        cve_id: Some(cve.to_string()),
                        affected_cpu: Some(cpus.to_string()),
                        mitigation_status: None,
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid,
                        timer_rate: event.timer_access_rate,
                        cache_miss_ratio: event.cache_miss_ratio,
                        branch_mispredict_ratio: event.branch_mispredict_ratio,
                        mitre_id: "T1003".into(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1003".into());
                    families.insert(family.to_string());
                }
            }
        }

        // ── 2. Attack pattern matching ──────────────────────────────────
        for &(pattern, desc, mitre, conf) in ATTACK_PATTERNS {
            if ind_lower.contains(&pattern.to_lowercase()) ||
               event.instructions_detected.iter().any(|i| i.to_lowercase().contains(&pattern.to_lowercase())) {
                let tt = match pattern {
                    p if p.contains("rdtsc") || p.contains("mach_absolute") || p.contains("clock_gettime") || p.contains("performance_counter") => SideChannelThreatType::TimerAbuse,
                    p if p.contains("clflush") || p.contains("cache_line") || p.contains("cache_set") => SideChannelThreatType::CacheManipulation,
                    p if p.contains("shared_memory_probe") => SideChannelThreatType::FlushReload,
                    p if p.contains("tlb") => SideChannelThreatType::CacheManipulation,
                    p if p.contains("tsx") || p.contains("xbegin") => SideChannelThreatType::TSXAbuse,
                    p if p.contains("branch_mispredict") || p.contains("indirect_branch") || p.contains("branch_history") => SideChannelThreatType::BranchPredictorTraining,
                    p if p.contains("rsb") => SideChannelThreatType::RSBStuffing,
                    p if p.contains("gadget") || p.contains("rop_speculative") => SideChannelThreatType::SpeculativeGadget,
                    p if p.contains("dmp") => SideChannelThreatType::Augury,
                    p if p.contains("pac_oracle") => SideChannelThreatType::PACMAN,
                    p if p.contains("ileakage") => SideChannelThreatType::ILeakage,
                    p if p.contains("kernel_address") => SideChannelThreatType::KernelAddressProbe,
                    p if p.contains("aslr") => SideChannelThreatType::ASLRDefeat,
                    p if p.contains("cross_process") || p.contains("cross_vm") => SideChannelThreatType::CrossProcessLeak,
                    p if p.contains("crypto_key") => SideChannelThreatType::CryptoKeyExtraction,
                    _ => SideChannelThreatType::CacheManipulation,
                };
                findings.push(SideChannelFinding {
                    threat_type: tt, confidence: conf,
                    description: desc.to_string(),
                    attack_variant: Some(pattern.to_string()),
                    cve_id: None, affected_cpu: event.cpu_type.clone(),
                    mitigation_status: None,
                    process_name: event.process_name.clone(),
                    process_pid: event.process_pid,
                    timer_rate: event.timer_access_rate,
                    cache_miss_ratio: event.cache_miss_ratio,
                    branch_mispredict_ratio: event.branch_mispredict_ratio,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                families.insert("SideChannel".to_string());
            }
        }

        // ── 3. Statistical anomaly detection ────────────────────────────
        if let Some(rate) = event.timer_access_rate {
            if rate > TIMER_ACCESS_SPIKE_THRESHOLD {
                findings.push(SideChannelFinding {
                    threat_type: SideChannelThreatType::TimerAbuse,
                    confidence: (0.5 + (rate as f64 / 100_000.0).min(0.4)),
                    description: format!("Timer access rate: {} calls/sec (threshold: {})", rate, TIMER_ACCESS_SPIKE_THRESHOLD),
                    attack_variant: Some("timer_abuse".into()),
                    cve_id: None, affected_cpu: event.cpu_type.clone(),
                    mitigation_status: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    timer_rate: Some(rate), cache_miss_ratio: None, branch_mispredict_ratio: None,
                    mitre_id: "T1082".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1082".into());
                families.insert("TimingAttack".to_string());
            }
        }

        if let Some(ratio) = event.branch_mispredict_ratio {
            if ratio > BRANCH_MISPREDICT_SPIKE_RATIO {
                findings.push(SideChannelFinding {
                    threat_type: SideChannelThreatType::BranchPredictorTraining,
                    confidence: (0.5 + (ratio * 2.0).min(0.4)),
                    description: format!("Branch misprediction rate: {:.1}% (threshold: {:.1}%)", ratio * 100.0, BRANCH_MISPREDICT_SPIKE_RATIO * 100.0),
                    attack_variant: Some("branch_training".into()),
                    cve_id: None, affected_cpu: event.cpu_type.clone(),
                    mitigation_status: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    timer_rate: None, cache_miss_ratio: None, branch_mispredict_ratio: Some(ratio),
                    mitre_id: "T1003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1003".into());
                families.insert("BranchPredictor".to_string());
            }
        }

        if let Some(ratio) = event.cache_miss_ratio {
            if ratio > CACHE_MISS_SPIKE_RATIO {
                findings.push(SideChannelFinding {
                    threat_type: SideChannelThreatType::PrimeProbe,
                    confidence: (0.4 + (ratio * 1.5).min(0.4)),
                    description: format!("Cache miss ratio: {:.1}% (threshold: {:.1}%)", ratio * 100.0, CACHE_MISS_SPIKE_RATIO * 100.0),
                    attack_variant: Some("cache_probing".into()),
                    cve_id: None, affected_cpu: event.cpu_type.clone(),
                    mitigation_status: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    timer_rate: None, cache_miss_ratio: Some(ratio), branch_mispredict_ratio: None,
                    mitre_id: "T1003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1003".into());
                families.insert("CacheAttack".to_string());
            }
        }

        // ── 4. Mitigation gap detection ─────────────────────────────────
        for &(pattern, desc, conf) in MITIGATION_STATUS {
            if event.mitigation_status.iter().any(|s| s.to_lowercase().contains(&pattern.to_lowercase())) {
                findings.push(SideChannelFinding {
                    threat_type: SideChannelThreatType::MitigationDisabled,
                    confidence: conf,
                    description: desc.to_string(),
                    attack_variant: None, cve_id: None,
                    affected_cpu: event.cpu_type.clone(),
                    mitigation_status: Some(pattern.to_string()),
                    process_name: None, process_pid: None,
                    timer_rate: None, cache_miss_ratio: None, branch_mispredict_ratio: None,
                    mitre_id: "T1082".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1082".into());
                families.insert("MitigationGap".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},pid={},findings={}", event.event_type, pid, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_attack = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let fam_vec: Vec<String> = families.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = SideChannelAnalysisResult {
            is_attack, events_analyzed: 1, findings,
            attack_families: fam_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_attack {
                s.attack_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        SideChannelThreatType::SpectreV1 | SideChannelThreatType::SpectreV2 |
                        SideChannelThreatType::SpectreSTL | SideChannelThreatType::SpectreBHI |
                        SideChannelThreatType::SpectreBHB | SideChannelThreatType::SpectreRSB |
                        SideChannelThreatType::RetBleed => s.spectre_detections += 1,
                        SideChannelThreatType::Meltdown | SideChannelThreatType::L1TerminalFault =>
                            s.meltdown_detections += 1,
                        SideChannelThreatType::MDS_ZombieLoad | SideChannelThreatType::MDS_RIDL |
                        SideChannelThreatType::MDS_Fallout | SideChannelThreatType::TSXAsyncAbort |
                        SideChannelThreatType::CacheOut => s.mds_detections += 1,
                        SideChannelThreatType::PACMAN | SideChannelThreatType::Augury |
                        SideChannelThreatType::GoFetch | SideChannelThreatType::ILeakage =>
                            s.apple_silicon_detections += 1,
                        SideChannelThreatType::FlushReload | SideChannelThreatType::PrimeProbe |
                        SideChannelThreatType::EvictTime | SideChannelThreatType::CacheManipulation =>
                            s.cache_attack_detections += 1,
                        SideChannelThreatType::MitigationDisabled => s.mitigation_gaps += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_attack {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "speculative_execution_detector".into(),
                title: format!("SIDE-CHANNEL ATTACK: {} ({})",
                    result.attack_families.join(", "),
                    event.process_name.as_deref().unwrap_or("unknown")),
                details: format!("Risk {:.1}%, {} findings, families: {}, CPU: {:?}",
                    risk_score * 100.0, result.findings.len(),
                    result.attack_families.join(", "), event.cpu_type),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Update macOS to latest security patches".into(),
                    "Kill the suspicious process: kill -9 <pid>".into(),
                    "Intel: Verify mitigations: sysctl -a | grep spec".into(),
                    "Apple Silicon: GoFetch has no software mitigation — use constant-time crypto".into(),
                    "Disable Hyper-Threading if MDS attacks suspected".into(),
                    "Use site isolation in browsers (enabled by default in Safari)".into(),
                    "Consider process isolation for sensitive workloads".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[SideChannelFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                SideChannelThreatType::CryptoKeyExtraction => 1.8,
                SideChannelThreatType::GoFetch => 1.7,
                SideChannelThreatType::CrossProcessLeak => 1.6,
                SideChannelThreatType::KernelAddressProbe => 1.5,
                SideChannelThreatType::Meltdown => 1.5,
                SideChannelThreatType::MDS_ZombieLoad => 1.5,
                SideChannelThreatType::LoadValueInjection => 1.5,
                SideChannelThreatType::SpectreV2 | SideChannelThreatType::SpectreV1 => 1.4,
                SideChannelThreatType::PACMAN | SideChannelThreatType::ILeakage => 1.4,
                SideChannelThreatType::SpeculativeGadget => 1.3,
                SideChannelThreatType::FlushReload | SideChannelThreatType::PrimeProbe => 1.3,
                SideChannelThreatType::ASLRDefeat => 1.2,
                SideChannelThreatType::TimerAbuse => 0.8,
                SideChannelThreatType::MitigationDisabled => 0.9,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> SideChannelScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
