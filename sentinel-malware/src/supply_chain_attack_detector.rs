//! Module 162: SupplyChainAttackDetector â€” Software Supply Chain Integrity Monitor
//!
//! Comprehensive detection of software supply chain attacks targeting macOS,
//! including compromised updates, hijacked build pipelines, tampered binaries,
//! and trojanized dependencies across the entire software delivery lifecycle.
//!
//! ## Detection Capabilities
//!
//! ### Update Mechanism Attacks
//! - **Sparkle framework hijacking**: Detecting compromised Sparkle update
//!   feeds (HTTP downgrade, XML injection, signature bypass)
//! - **App Store update tampering**: Monitoring for MitM on App Store updates
//! - **Auto-update hijacking**: Detecting redirected or tampered auto-update
//!   mechanisms in third-party applications
//! - **Update server compromise**: Indicators of compromised update servers
//!   (certificate changes, domain changes, new signing keys)
//! - **Rollback attacks**: Forcing installation of older vulnerable versions
//!
//! ### Binary Integrity
//! - **Code signing anomalies**: Detecting unsigned, ad-hoc signed, or
//!   recently re-signed binaries in unexpected locations
//! - **Notarization verification**: Apple notarization status changes
//! - **Binary modification post-install**: Detecting modifications to
//!   installed application binaries
//! - **Dylib injection in app bundles**: Unauthorized dylibs inside
//!   application bundles
//! - **Resource tampering**: Modified resources (NIBs, plists, scripts)
//!   within application bundles
//!
//! ### Build Pipeline Attacks
//! - **Xcode build phase injection**: Malicious build phases added to
//!   Xcode projects (XCSSET-style)
//! - **Compiler trojan**: Detecting compromised compiler toolchains
//! - **Build artifact tampering**: Differences between expected and actual
//!   build outputs
//! - **Reproducible build verification**: Comparing builds against
//!   reproducible build attestations
//!
//! ### Dependency Attacks
//! - **Homebrew formula tampering**: Modified Homebrew formulae or taps
//! - **MacPorts poisoning**: Compromised MacPorts portfiles
//! - **pip/npm/gem supply chain**: Package manager dependency confusion
//!   and typosquatting targeting macOS developers
//! - **CocoaPods/SPM poisoning**: iOS/macOS dependency manager attacks
//!
//! ### Known Supply Chain Campaigns
//! - **SolarWinds/Sunburst patterns**: Nation-state supply chain TTPs
//! - **Codecov-style attacks**: CI/CD tool compromise patterns
//! - **3CX-style attacks**: Desktop app supply chain compromise
//! - **XcodeGhost patterns**: IDE-level supply chain attacks
//!
//! ## MITRE ATT&CK: T1195.001, T1195.002, T1195.003, T1553.002
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

const UPDATE_ATTACK_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("sparkle_http_feed", "Sparkle update feed over HTTP (downgrade attack)", "T1195.002", 0.8),
    ("sparkle_sig_bypass", "Sparkle update signature verification bypassed", "T1195.002", 0.9),
    ("sparkle_xml_inject", "XML injection in Sparkle appcast feed", "T1195.002", 0.85),
    ("update_server_cert_change", "Update server certificate unexpectedly changed", "T1195.002", 0.7),
    ("update_server_domain_change", "Update server domain changed without notice", "T1195.002", 0.75),
    ("update_signing_key_change", "Update signing key changed (possible compromise)", "T1195.002", 0.8),
    ("update_http_downgrade", "HTTPS update forced to HTTP (MitM opportunity)", "T1195.002", 0.85),
    ("update_redirect_suspicious", "Update download redirected to suspicious host", "T1195.002", 0.8),
    ("rollback_to_vulnerable", "Update rollback to known vulnerable version", "T1195.002", 0.7),
    ("app_store_mitm", "App Store update MitM indicators", "T1195.002", 0.8),
];

const BINARY_INTEGRITY_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("unsigned_app_bundle", "Unsigned application bundle in /Applications", "T1553.002", 0.7),
    ("adhoc_signed_system", "Ad-hoc signed binary in system location", "T1553.002", 0.8),
    ("notarization_revoked", "Apple notarization ticket revoked", "T1553.002", 0.9),
    ("recently_resigned", "Application recently re-signed with different cert", "T1553.002", 0.75),
    ("binary_modified_post_install", "Binary modified after installation", "T1195.002", 0.85),
    ("dylib_injected_in_bundle", "Unauthorized dylib inside app bundle", "T1195.001", 0.85),
    ("resource_tampered", "Application resource files tampered", "T1195.002", 0.7),
    ("info_plist_modified", "Info.plist modified post-installation", "T1195.002", 0.7),
    ("entitlements_escalated", "Entitlements escalated in app bundle", "T1195.002", 0.8),
    ("team_id_mismatch", "Code signing Team ID differs from expected", "T1553.002", 0.85),
];

const BUILD_PIPELINE_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("xcode_build_phase_inject", "Malicious Xcode build phase (XCSSET-style)", "T1195.001", 0.9),
    ("compiler_trojan", "Compromised compiler toolchain detected", "T1195.001", 0.95),
    ("build_artifact_mismatch", "Build artifact differs from expected output", "T1195.001", 0.8),
    ("reproducible_build_fail", "Reproducible build verification failed", "T1195.001", 0.7),
    ("ci_config_tampered", "CI/CD configuration tampered", "T1195.001", 0.8),
    ("build_script_injection", "Malicious code in build scripts", "T1195.001", 0.85),
];

const DEPENDENCY_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("homebrew_formula_tampered", "Homebrew formula hash mismatch", "T1195.001", 0.8),
    ("homebrew_tap_suspicious", "Suspicious Homebrew tap source", "T1195.001", 0.6),
    ("cocoapods_repo_hijack", "CocoaPods repo hijack indicators", "T1195.001", 0.8),
    ("spm_dependency_confusion", "Swift Package Manager dependency confusion", "T1195.001", 0.75),
    ("pip_typosquat", "pip typosquatting package detected", "T1195.001", 0.8),
    ("npm_install_script_abuse", "npm postinstall script abuse", "T1195.001", 0.75),
    ("gem_supply_chain", "RubyGem supply chain attack indicators", "T1195.001", 0.7),
];

const KNOWN_CAMPAIGNS: &[(&str, &str, &str, f64)] = &[
    ("sunburst_pattern", "SolarWinds/Sunburst-style supply chain TTP", "T1195.002", 0.9),
    ("codecov_pattern", "Codecov-style CI tool compromise pattern", "T1195.001", 0.85),
    ("3cx_pattern", "3CX-style desktop app supply chain compromise", "T1195.002", 0.9),
    ("xcodeghost_pattern", "XcodeGhost-style IDE compromise", "T1195.001", 0.9),
    ("solarmarker_pattern", "SolarMarker SEO poisoning supply chain", "T1195.002", 0.7),
    ("kaseya_pattern", "Kaseya-style MSP supply chain attack", "T1195.002", 0.85),
    ("event_stream_pattern", "event-stream-style npm hijack", "T1195.001", 0.8),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SupplyChainThreatType {
    UpdateMechanismAttack, SparkleHijack, UpdateServerCompromise,
    RollbackAttack, UnsignedBinary, NotarizationRevoked,
    BinaryModifiedPostInstall, DylibInjectedInBundle, ResourceTampered,
    TeamIDMismatch, XcodeBuildPhaseInject, CompilerTrojan,
    BuildArtifactMismatch, CIConfigTampered, HomebrewTampered,
    CocoaPodHijack, SPMConfusion, PipTyposquat, NpmInstallAbuse,
    KnownCampaignPattern,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SupplyChainFinding {
    pub threat_type: SupplyChainThreatType,
    pub confidence: f64,
    pub description: String,
    pub affected_software: Option<String>,
    pub expected_hash: Option<String>,
    pub actual_hash: Option<String>,
    pub update_source: Option<String>,
    pub campaign_name: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SupplyChainEvent {
    pub event_type: String,
    pub software_name: Option<String>,
    pub software_path: Option<String>,
    pub update_url: Option<String>,
    pub expected_hash: Option<String>,
    pub actual_hash: Option<String>,
    pub code_signed: Option<bool>,
    pub notarized: Option<bool>,
    pub team_id: Option<String>,
    pub expected_team_id: Option<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SupplyChainAnalysisResult {
    pub has_threats: bool,
    pub findings: Vec<SupplyChainFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SupplyChainStats {
    pub total_events: u64,
    pub update_attacks: u64,
    pub binary_integrity_violations: u64,
    pub build_pipeline_attacks: u64,
    pub dependency_attacks: u64,
    pub campaign_matches: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SupplyChainSigEntry { pub pattern: String, pub severity: f64 }

pub struct SupplyChainAttackDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SupplyChainStats>>,
    result_cache: TieredCache<String, SupplyChainAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    sc_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SupplyChainStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, SupplyChainAnalysisResult>>,
    sig_db: PagedMemory<SupplyChainSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<SupplyChainStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SupplyChainAttackDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            sc_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SupplyChainStats::default(),
                |acc: &mut SupplyChainStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(SupplyChainStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(128)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &SupplyChainEvent) -> Option<SupplyChainAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("sc:{}:{}", event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        let ind_text = format!("{} {} {}",
            event.event_type, event.update_url.as_deref().unwrap_or(""),
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // 1. Update attacks
        for &(pattern, desc, mitre, conf) in UPDATE_ATTACK_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("sparkle") { SupplyChainThreatType::SparkleHijack }
                    else if pattern.contains("rollback") { SupplyChainThreatType::RollbackAttack }
                    else if pattern.contains("server") { SupplyChainThreatType::UpdateServerCompromise }
                    else { SupplyChainThreatType::UpdateMechanismAttack };
                findings.push(SupplyChainFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    affected_software: event.software_name.clone(),
                    expected_hash: event.expected_hash.clone(), actual_hash: event.actual_hash.clone(),
                    update_source: event.update_url.clone(), campaign_name: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 2. Binary integrity
        for &(pattern, desc, mitre, conf) in BINARY_INTEGRITY_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "unsigned_app_bundle" | "adhoc_signed_system" => SupplyChainThreatType::UnsignedBinary,
                    "notarization_revoked" => SupplyChainThreatType::NotarizationRevoked,
                    "binary_modified_post_install" => SupplyChainThreatType::BinaryModifiedPostInstall,
                    "dylib_injected_in_bundle" => SupplyChainThreatType::DylibInjectedInBundle,
                    "resource_tampered" | "info_plist_modified" => SupplyChainThreatType::ResourceTampered,
                    "team_id_mismatch" => SupplyChainThreatType::TeamIDMismatch,
                    _ => SupplyChainThreatType::BinaryModifiedPostInstall,
                };
                findings.push(SupplyChainFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    affected_software: event.software_name.clone(),
                    expected_hash: event.expected_hash.clone(), actual_hash: event.actual_hash.clone(),
                    update_source: None, campaign_name: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // Team ID check
        if let (Some(ref expected), Some(ref actual)) = (&event.expected_team_id, &event.team_id) {
            if expected != actual {
                findings.push(SupplyChainFinding {
                    threat_type: SupplyChainThreatType::TeamIDMismatch, confidence: 0.85,
                    description: format!("Team ID mismatch: expected {} got {}", expected, actual),
                    affected_software: event.software_name.clone(),
                    expected_hash: None, actual_hash: None, update_source: None, campaign_name: None,
                    mitre_id: "T1553.002".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1553.002".into());
            }
        }

        // 3. Build pipeline
        for &(pattern, desc, mitre, conf) in BUILD_PIPELINE_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "xcode_build_phase_inject" => SupplyChainThreatType::XcodeBuildPhaseInject,
                    "compiler_trojan" => SupplyChainThreatType::CompilerTrojan,
                    "build_artifact_mismatch" | "reproducible_build_fail" => SupplyChainThreatType::BuildArtifactMismatch,
                    "ci_config_tampered" | "build_script_injection" => SupplyChainThreatType::CIConfigTampered,
                    _ => SupplyChainThreatType::BuildArtifactMismatch,
                };
                findings.push(SupplyChainFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    affected_software: event.software_name.clone(),
                    expected_hash: None, actual_hash: None, update_source: None, campaign_name: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 4. Dependency attacks
        for &(pattern, desc, mitre, conf) in DEPENDENCY_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("homebrew") => SupplyChainThreatType::HomebrewTampered,
                    p if p.contains("cocoapods") => SupplyChainThreatType::CocoaPodHijack,
                    p if p.contains("spm") => SupplyChainThreatType::SPMConfusion,
                    p if p.contains("pip") => SupplyChainThreatType::PipTyposquat,
                    p if p.contains("npm") => SupplyChainThreatType::NpmInstallAbuse,
                    _ => SupplyChainThreatType::PipTyposquat,
                };
                findings.push(SupplyChainFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    affected_software: event.software_name.clone(),
                    expected_hash: None, actual_hash: None, update_source: None, campaign_name: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 5. Known campaigns
        for &(pattern, desc, mitre, conf) in KNOWN_CAMPAIGNS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                findings.push(SupplyChainFinding {
                    threat_type: SupplyChainThreatType::KnownCampaignPattern, confidence: conf,
                    description: desc.to_string(),
                    affected_software: event.software_name.clone(),
                    expected_hash: None, actual_hash: None, update_source: None,
                    campaign_name: Some(pattern.to_string()),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        let risk_score = if findings.is_empty() { 0.0 } else {
            let s: f64 = findings.iter().map(|f| f.confidence * match f.threat_type {
                SupplyChainThreatType::CompilerTrojan | SupplyChainThreatType::KnownCampaignPattern => 1.6,
                SupplyChainThreatType::NotarizationRevoked | SupplyChainThreatType::XcodeBuildPhaseInject => 1.5,
                SupplyChainThreatType::SparkleHijack | SupplyChainThreatType::DylibInjectedInBundle => 1.4,
                _ => 1.0,
            }).sum();
            (s / (findings.len() as f64 * 1.5)).min(1.0)
        };
        self.risk_computer.write().push(risk_score);
        let severity = if risk_score >= 0.85 { Severity::Critical } else if risk_score >= 0.65 { Severity::High }
            else if risk_score >= 0.45 { Severity::Medium } else if risk_score >= 0.25 { Severity::Low }
            else { Severity::Info };
        let has_threats = risk_score > 0.5;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = SupplyChainAnalysisResult {
            has_threats, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
          if has_threats { for f in &result.findings { match f.threat_type {
              SupplyChainThreatType::UpdateMechanismAttack | SupplyChainThreatType::SparkleHijack |
              SupplyChainThreatType::UpdateServerCompromise | SupplyChainThreatType::RollbackAttack => s.update_attacks += 1,
              SupplyChainThreatType::UnsignedBinary | SupplyChainThreatType::NotarizationRevoked |
              SupplyChainThreatType::BinaryModifiedPostInstall | SupplyChainThreatType::DylibInjectedInBundle |
              SupplyChainThreatType::ResourceTampered | SupplyChainThreatType::TeamIDMismatch => s.binary_integrity_violations += 1,
              SupplyChainThreatType::XcodeBuildPhaseInject | SupplyChainThreatType::CompilerTrojan |
              SupplyChainThreatType::BuildArtifactMismatch | SupplyChainThreatType::CIConfigTampered => s.build_pipeline_attacks += 1,
              SupplyChainThreatType::HomebrewTampered | SupplyChainThreatType::CocoaPodHijack |
              SupplyChainThreatType::SPMConfusion | SupplyChainThreatType::PipTyposquat |
              SupplyChainThreatType::NpmInstallAbuse => s.dependency_attacks += 1,
              SupplyChainThreatType::KnownCampaignPattern => s.campaign_matches += 1,
          } } }
          let n = s.total_events as f64;
          s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if has_threats {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "supply_chain_attack_detector".into(),
                title: format!("SUPPLY CHAIN: {} findings for {:?}", result.findings.len(), event.software_name),
                details: format!("Risk {:.1}%, path: {:?}", risk_score*100.0, event.software_path),
                path: event.file_path.clone(), process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None, mitre_ids: mitre_vec,
                remediation: vec![
                    "Verify software against known-good hashes".into(),
                    "Check code signing: codesign -dvvv <path>".into(),
                    "Verify notarization: spctl -a -vvv <path>".into(),
                    "Re-download from official source and compare".into(),
                    "Check update mechanism for tampering".into(),
                ], confidence: risk_score,
            });
        }
        Some(result)
    }

    pub fn stats(&self) -> SupplyChainStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
