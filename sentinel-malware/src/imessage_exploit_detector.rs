//! Module 132: iMessageExploitDetector — iMessage/MMS Zero-Click Exploit Detection
//!
//! Detects zero-click and one-click exploits targeting Apple's iMessage framework,
//! including NSO Group Pegasus (FORCEDENTRY/FINDMYPWN), Operation Triangulation,
//! and other sophisticated iMessage-based attack chains. These are among the most
//! dangerous exploits as they require no user interaction.
//!
//! ## Detection Capabilities
//!
//! - **Zero-click attachment analysis**: Malformed PDFs, GIFs, PNGs, WebP images
//!   sent via iMessage that trigger parser vulnerabilities (ImageIO, CoreGraphics,
//!   PDFKit, libwebp exploits)
//! - **JBIG2 bitmap abuse**: NSO FORCEDENTRY-style JBIG2 Turing-complete exploit
//!   chains hidden in PDF attachments
//! - **BlastDoor bypass detection**: Techniques to escape iMessage's BlastDoor
//!   sandbox (introduced iOS 14 / macOS 11)
//! - **IMTransferAgent monitoring**: Suspicious behavior from IMTransferAgent
//!   process that handles iMessage attachments
//! - **Shared cache injection**: Exploits targeting dyld shared cache via iMessage
//! - **HomeKit exploitation**: iMessage → HomeKit pivot (Operation Triangulation)
//! - **iMessage extension abuse**: Malicious iMessage app extensions
//! - **Invisible message detection**: Zero-width characters, empty messages with
//!   hidden payloads, messages that auto-delete
//! - **Attachment type anomaly**: Unusual MIME types, polyglot files, oversized
//!   attachments, rapid attachment delivery
//! - **Process chain analysis**: imagent → IMTransferAgent → exploit chain
//!   process spawning patterns
//! - **Known CVE detection**: CVE-2021-30860 (FORCEDENTRY), CVE-2023-41064
//!   (BLASTPASS), CVE-2023-32434/32435 (Triangulation), CVE-2023-41061
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1203 — Exploitation for Client Execution
//! - T1204.001 — User Execution: Malicious Link
//! - T1566.001 — Phishing: Spearphishing Attachment
//! - T1071.003 — Application Layer Protocol: Mail Protocols
//! - T1055 — Process Injection
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const HIGH_ENTROPY_THRESHOLD: f64 = 7.2;
const OVERSIZED_ATTACHMENT_MB: u64 = 100;
const RAPID_ATTACHMENT_THRESHOLD: u32 = 10;
const RAPID_ATTACHMENT_WINDOW_SECS: u64 = 5;

// ── iMessage Process Chain ───────────────────────────────────────────────────

const IMESSAGE_PROCESSES: &[(&str, &str, f64)] = &[
    ("imagent", "iMessage agent daemon", 0.3),
    ("IMTransferAgent", "iMessage attachment handler", 0.3),
    ("IMDPersistenceAgent", "iMessage persistence", 0.2),
    ("MessagesBlastDoorService", "BlastDoor sandbox service", 0.2),
    ("com.apple.messages", "Messages app process", 0.2),
    ("apsd", "Apple Push Notification Service daemon", 0.2),
    ("identityservicesd", "Identity Services daemon", 0.2),
];

// ── Suspicious Attachment Types ──────────────────────────────────────────────

const SUSPICIOUS_MIME_TYPES: &[(&str, &str, f64)] = &[
    ("application/pdf", "PDF (JBIG2/FORCEDENTRY vector)", 0.4),
    ("image/gif", "GIF (parser exploit vector)", 0.3),
    ("image/tiff", "TIFF (ImageIO exploit vector)", 0.5),
    ("image/webp", "WebP (libwebp CVE-2023-4863)", 0.6),
    ("image/heic", "HEIC (ImageIO exploit vector)", 0.4),
    ("image/jp2", "JPEG 2000 (parser exploit)", 0.6),
    ("application/x-plist", "Property list (config exploit)", 0.5),
    ("application/octet-stream", "Binary data (unknown type)", 0.6),
    ("text/vcard", "vCard (contact parser exploit)", 0.5),
    ("text/x-vcalendar", "vCalendar (calendar parser exploit)", 0.5),
    ("application/pkpass", "Wallet pass (pkpass exploit)", 0.5),
    ("model/usd", "3D model (SceneKit exploit)", 0.6),
    ("audio/mp4", "Audio (CoreAudio exploit)", 0.4),
    ("video/mp4", "Video (AVFoundation exploit)", 0.4),
];

// ── Known CVEs ───────────────────────────────────────────────────────────────

const IMESSAGE_CVES: &[(&str, &str, &str, f64)] = &[
    ("CVE-2021-30860", "FORCEDENTRY: JBIG2 integer overflow in CoreGraphics (NSO Pegasus)", "pdf,jbig2", 0.98),
    ("CVE-2021-30858", "WebKit use-after-free via iMessage link preview", "webkit,link", 0.9),
    ("CVE-2023-41064", "BLASTPASS: ImageIO buffer overflow via PassKit", "image,webp", 0.97),
    ("CVE-2023-41061", "BLASTPASS: Wallet validation issue", "pkpass,wallet", 0.95),
    ("CVE-2023-32434", "Operation Triangulation: kernel integer overflow", "font,imessage", 0.98),
    ("CVE-2023-32435", "Operation Triangulation: WebKit memory corruption", "webkit,imessage", 0.98),
    ("CVE-2023-38606", "Operation Triangulation: kernel MMIO exploit", "kernel,imessage", 0.98),
    ("CVE-2023-4863", "libwebp heap buffer overflow (via iMessage WebP)", "webp,image", 0.95),
    ("CVE-2022-22620", "WebKit use-after-free (zombie object)", "webkit,link", 0.9),
    ("CVE-2022-32893", "WebKit out-of-bounds write", "webkit,link", 0.9),
    ("CVE-2020-9956", "ImageIO heap buffer overflow via TIFF", "tiff,image", 0.9),
    ("CVE-2019-8641", "iMessage deserialization vulnerability", "nscoding,plist", 0.95),
    ("CVE-2019-8646", "iMessage data leak via NSKeyedUnarchiver", "nscoding,plist", 0.9),
];

// ── Exploit Chain Indicators ─────────────────────────────────────────────────

const EXPLOIT_CHAIN_INDICATORS: &[(&str, &str, f64)] = &[
    // Process spawning patterns
    ("IMTransferAgent.*fork", "IMTransferAgent spawning child process", 0.9),
    ("imagent.*posix_spawn", "imagent spawning new process", 0.85),
    ("BlastDoor.*crash", "BlastDoor crash (potential bypass attempt)", 0.8),
    ("IMTransferAgent.*crash", "IMTransferAgent crash (potential exploit)", 0.85),
    // File system artifacts
    ("/tmp/com.apple.messages", "Temp file from Messages processing", 0.4),
    ("com.apple.iChat", "iChat legacy framework access", 0.3),
    ("/var/mobile/Library/SMS/Attachments", "SMS/iMessage attachment directory", 0.3),
    ("~/Library/Messages/Attachments", "macOS Messages attachment directory", 0.3),
    // Suspicious behaviors
    ("NSKeyedUnarchiver.*iMessage", "NSKeyedUnarchiver deserialization from iMessage", 0.8),
    ("ImageIO.*overflow", "ImageIO buffer overflow indicator", 0.9),
    ("CoreGraphics.*JBIG2", "JBIG2 processing in CoreGraphics", 0.85),
    ("libwebp.*heap", "libwebp heap corruption", 0.9),
    ("dyld_shared_cache.*IMTransferAgent", "Shared cache manipulation via iMessage", 0.9),
    // HomeKit pivot (Operation Triangulation)
    ("homed.*IMTransferAgent", "HomeKit daemon triggered by iMessage", 0.85),
    ("com.apple.homed", "HomeKit service (potential pivot target)", 0.5),
];

// ── Attachment Anomaly Patterns ──────────────────────────────────────────────

const ATTACHMENT_ANOMALIES: &[(&str, &str, f64)] = &[
    ("polyglot", "File valid as multiple formats (polyglot)", 0.85),
    ("pdf_with_jbig2", "PDF containing JBIG2 streams", 0.8),
    ("gif_with_lzw_overflow", "GIF with oversized LZW stream", 0.8),
    ("tiff_with_tiles", "TIFF with excessive tile count", 0.7),
    ("webp_vp8l_overflow", "WebP VP8L with oversized transform", 0.85),
    ("plist_with_nscoding", "Plist with NSCoding objects (deserialization)", 0.75),
    ("heic_with_exif_overflow", "HEIC with oversized EXIF data", 0.7),
    ("zero_display_content", "Attachment with no visible content (invisible message)", 0.7),
    ("auto_delete_flag", "Message with auto-delete/expiry flag", 0.5),
    ("empty_body_with_attachment", "Empty message body with attachment only", 0.4),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum iMessageThreatType {
    ZeroClickExploit,
    MalformedAttachment,
    JBIG2Exploit,
    ImageIOExploit,
    WebPExploit,
    BlastDoorBypass,
    ProcessChainAnomaly,
    SharedCacheInjection,
    HomeKitPivot,
    DeserializationExploit,
    PolyglotAttachment,
    InvisibleMessage,
    OversizedAttachment,
    RapidAttachmentDelivery,
    HighEntropyAttachment,
    SuspiciousMIMEType,
    KnownCVEExploit,
    iMessageExtensionAbuse,
    LinkPreviewExploit,
    ProcessCrash,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct iMessageThreatFinding {
    pub threat_type: iMessageThreatType,
    pub confidence: f64,
    pub description: String,
    pub sender: Option<String>,
    pub attachment_type: Option<String>,
    pub attachment_size: Option<u64>,
    pub attachment_hash: Option<String>,
    pub cve_id: Option<String>,
    pub exploit_chain: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct iMessageEvent {
    pub event_type: String,              // "attachment_received", "process_spawn", "crash", "file_write"
    pub process_name: String,
    pub process_pid: u32,
    pub parent_process: Option<String>,
    pub sender_id: Option<String>,       // Phone/email of sender
    pub attachment_mime: Option<String>,
    pub attachment_size: Option<u64>,
    pub attachment_hash: Option<String>,
    pub attachment_entropy: Option<f64>,
    pub attachment_path: Option<String>,
    pub message_body: Option<String>,
    pub is_group_chat: bool,
    pub crash_report: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct iMessageAnalysisResult {
    pub is_exploit: bool,
    pub events_analyzed: u32,
    pub findings: Vec<iMessageThreatFinding>,
    pub suspected_cves: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct iMessageScanStats {
    pub total_events: u64,
    pub exploit_detections: u64,
    pub zero_click_detections: u64,
    pub attachment_detections: u64,
    pub cve_detections: u64,
    pub crash_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct iMsgSigEntry { pub pattern: String, pub cve: String, pub severity: f64 }

#[derive(Debug, Clone, Default)]
struct SenderTracker {
    attachment_count: u64,
    attachment_timestamps: Vec<u64>,
    mime_types: HashSet<String>,
    total_bytes: u64,
    crash_count: u32,
    first_seen: u64,
    last_seen: u64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct IMessageExploitDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<iMessageScanStats>>,
    result_cache: TieredCache<String, iMessageAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, iMessageScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, iMessageAnalysisResult>>,
    sig_db: PagedMemory<iMsgSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<iMessageScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    sender_tracker: RwLock<HashMap<String, SenderTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl IMessageExploitDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, iMessageScanStats::default(),
                |acc: &mut iMessageScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(iMessageScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            sender_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &iMessageEvent) -> Option<iMessageAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.process_name, event.process_pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut suspected_cves = HashSet::new();

        let sender = event.sender_id.as_deref().unwrap_or("unknown");

        // ── 1. Update sender tracker ────────────────────────────────────
        {
            let mut tracker = self.sender_tracker.write();
            let st = tracker.entry(sender.to_string()).or_default();
            if event.attachment_mime.is_some() {
                st.attachment_count += 1;
                st.attachment_timestamps.push(event.timestamp);
                if let Some(ref mime) = event.attachment_mime { st.mime_types.insert(mime.clone()); }
                if let Some(size) = event.attachment_size { st.total_bytes += size; }
            }
            if event.event_type == "crash" { st.crash_count += 1; }
            if st.first_seen == 0 { st.first_seen = event.timestamp; }
            st.last_seen = event.timestamp;
            if st.attachment_timestamps.len() > 500 { st.attachment_timestamps.drain(..250); }
        }

        // ── 2. Attachment MIME type analysis ─────────────────────────────
        if let Some(ref mime) = event.attachment_mime {
            for &(mime_pattern, desc, conf) in SUSPICIOUS_MIME_TYPES {
                if mime.to_lowercase().contains(&mime_pattern.to_lowercase()) {
                    // Higher confidence for known exploit vectors
                    let boosted = if mime_pattern.contains("webp") || mime_pattern.contains("tiff")
                        || mime_pattern.contains("jp2") || mime_pattern.contains("usd") {
                        (conf + 0.15).min(0.9)
                    } else { conf };

                    findings.push(iMessageThreatFinding {
                        threat_type: iMessageThreatType::SuspiciousMIMEType,
                        confidence: boosted,
                        description: format!("iMessage attachment: {} — {}", mime, desc),
                        sender: event.sender_id.clone(),
                        attachment_type: Some(mime.clone()),
                        attachment_size: event.attachment_size,
                        attachment_hash: event.attachment_hash.clone(),
                        cve_id: None, exploit_chain: None,
                        mitre_id: "T1566.001".into(),
                        process_name: Some(event.process_name.clone()),
                        process_pid: Some(event.process_pid),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1566.001".into());
                    break;
                }
            }
        }

        // ── 3. High entropy attachment detection ────────────────────────
        if let Some(entropy) = event.attachment_entropy {
            if entropy > HIGH_ENTROPY_THRESHOLD {
                findings.push(iMessageThreatFinding {
                    threat_type: iMessageThreatType::HighEntropyAttachment,
                    confidence: (0.5 + (entropy - HIGH_ENTROPY_THRESHOLD) * 0.5).min(0.9),
                    description: format!("High entropy iMessage attachment: {:.2} bits/byte", entropy),
                    sender: event.sender_id.clone(),
                    attachment_type: event.attachment_mime.clone(),
                    attachment_size: event.attachment_size,
                    attachment_hash: event.attachment_hash.clone(),
                    cve_id: None, exploit_chain: None,
                    mitre_id: "T1203".into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
            }
        }

        // ── 4. Oversized attachment ─────────────────────────────────────
        if let Some(size) = event.attachment_size {
            if size > OVERSIZED_ATTACHMENT_MB * 1024 * 1024 {
                findings.push(iMessageThreatFinding {
                    threat_type: iMessageThreatType::OversizedAttachment,
                    confidence: 0.6,
                    description: format!("Oversized iMessage attachment: {:.1}MB", size as f64 / (1024.0 * 1024.0)),
                    sender: event.sender_id.clone(),
                    attachment_type: event.attachment_mime.clone(),
                    attachment_size: Some(size),
                    attachment_hash: event.attachment_hash.clone(),
                    cve_id: None, exploit_chain: None,
                    mitre_id: "T1203".into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
            }
        }

        // ── 5. Rapid attachment delivery (flooding) ─────────────────────
        {
            let tracker = self.sender_tracker.read();
            if let Some(st) = tracker.get(sender) {
                let recent = st.attachment_timestamps.iter()
                    .filter(|&&t| event.timestamp.saturating_sub(RAPID_ATTACHMENT_WINDOW_SECS) <= t)
                    .count() as u32;
                if recent >= RAPID_ATTACHMENT_THRESHOLD {
                    findings.push(iMessageThreatFinding {
                        threat_type: iMessageThreatType::RapidAttachmentDelivery,
                        confidence: (0.7 + (recent as f64 / 30.0).min(0.25)),
                        description: format!("{} attachments in {}s from {}", recent, RAPID_ATTACHMENT_WINDOW_SECS, sender),
                        sender: event.sender_id.clone(),
                        attachment_type: None, attachment_size: None, attachment_hash: None,
                        cve_id: None, exploit_chain: None,
                        mitre_id: "T1499".into(),
                        process_name: Some(event.process_name.clone()),
                        process_pid: Some(event.process_pid),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1499".into());
                }

                // Crash correlation: if sender's attachments coincide with crashes
                if st.crash_count >= 2 && st.attachment_count > 0 {
                    findings.push(iMessageThreatFinding {
                        threat_type: iMessageThreatType::ZeroClickExploit,
                        confidence: (0.8 + (st.crash_count as f64 * 0.05).min(0.15)),
                        description: format!("{} crashes correlated with {} attachments from {}",
                            st.crash_count, st.attachment_count, sender),
                        sender: event.sender_id.clone(),
                        attachment_type: None, attachment_size: None, attachment_hash: None,
                        cve_id: None,
                        exploit_chain: Some("attachment → crash → potential code execution".into()),
                        mitre_id: "T1203".into(),
                        process_name: Some(event.process_name.clone()),
                        process_pid: Some(event.process_pid),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1203".into());
                }
            }
        }

        // ── 6. Process crash analysis ───────────────────────────────────
        if event.event_type == "crash" {
            let is_imessage_proc = IMESSAGE_PROCESSES.iter()
                .any(|&(p, _, _)| event.process_name.to_lowercase().contains(&p.to_lowercase()));
            if is_imessage_proc {
                let conf = if event.process_name.contains("BlastDoor") { 0.8 }
                    else if event.process_name.contains("IMTransferAgent") { 0.85 }
                    else { 0.6 };

                let tt = if event.process_name.contains("BlastDoor") {
                    iMessageThreatType::BlastDoorBypass
                } else {
                    iMessageThreatType::ProcessCrash
                };

                findings.push(iMessageThreatFinding {
                    threat_type: tt, confidence: conf,
                    description: format!("{} crash — potential exploit attempt", event.process_name),
                    sender: event.sender_id.clone(),
                    attachment_type: event.attachment_mime.clone(),
                    attachment_size: event.attachment_size,
                    attachment_hash: event.attachment_hash.clone(),
                    cve_id: None, exploit_chain: None,
                    mitre_id: "T1203".into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
            }
        }

        // ── 7. Exploit chain indicator matching ─────────────────────────
        let event_text = format!("{} {} {} {}",
            event.process_name,
            event.crash_report.as_deref().unwrap_or(""),
            event.file_path.as_deref().unwrap_or(""),
            event.event_type);

        for &(pattern, desc, conf) in EXPLOIT_CHAIN_INDICATORS {
            if event_text.to_lowercase().contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("JBIG2") { iMessageThreatType::JBIG2Exploit }
                    else if pattern.contains("ImageIO") { iMessageThreatType::ImageIOExploit }
                    else if pattern.contains("webp") { iMessageThreatType::WebPExploit }
                    else if pattern.contains("BlastDoor") { iMessageThreatType::BlastDoorBypass }
                    else if pattern.contains("shared_cache") { iMessageThreatType::SharedCacheInjection }
                    else if pattern.contains("home") { iMessageThreatType::HomeKitPivot }
                    else if pattern.contains("NSKeyedUnarchiver") { iMessageThreatType::DeserializationExploit }
                    else { iMessageThreatType::ProcessChainAnomaly };

                findings.push(iMessageThreatFinding {
                    threat_type: tt, confidence: conf,
                    description: desc.to_string(),
                    sender: event.sender_id.clone(),
                    attachment_type: event.attachment_mime.clone(),
                    attachment_size: event.attachment_size,
                    attachment_hash: event.attachment_hash.clone(),
                    cve_id: None, exploit_chain: Some(desc.to_string()),
                    mitre_id: "T1203".into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
            }
        }

        // ── 8. Known CVE matching ───────────────────────────────────────
        for &(cve, desc, _triggers, conf) in IMESSAGE_CVES {
            if event_text.contains(cve) {
                findings.push(iMessageThreatFinding {
                    threat_type: iMessageThreatType::KnownCVEExploit,
                    confidence: conf,
                    description: format!("{}: {}", cve, desc),
                    sender: event.sender_id.clone(),
                    attachment_type: event.attachment_mime.clone(),
                    attachment_size: event.attachment_size,
                    attachment_hash: event.attachment_hash.clone(),
                    cve_id: Some(cve.to_string()),
                    exploit_chain: Some(desc.to_string()),
                    mitre_id: "T1203".into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                suspected_cves.insert(cve.to_string());
            }
        }

        // ── Store state & build result ──────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("proc={},type={},sender={}", event.process_name, event.event_type, sender));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_exploit = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cves_vec: Vec<String> = suspected_cves.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = iMessageAnalysisResult {
            is_exploit, events_analyzed: 1, findings, suspected_cves: cves_vec,
            risk_score, severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_exploit {
                s.exploit_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        iMessageThreatType::ZeroClickExploit => s.zero_click_detections += 1,
                        iMessageThreatType::KnownCVEExploit => s.cve_detections += 1,
                        iMessageThreatType::ProcessCrash | iMessageThreatType::BlastDoorBypass => s.crash_detections += 1,
                        _ => s.attachment_detections += 1,
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_exploit {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "imessage_exploit_detector".into(),
                title: format!("iMessage exploit: {} from {}", event.process_name, sender),
                details: format!("Risk: {:.1}%, {} findings, CVEs: {}",
                    risk_score * 100.0, result.findings.len(),
                    if result.suspected_cves.is_empty() { "none".into() } else { result.suspected_cves.join(", ") }),
                path: event.attachment_path.clone(),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid), verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Enable Lockdown Mode (Settings → Privacy & Security)".into(),
                    "Block the sender immediately".into(),
                    "Update macOS/iOS to latest version".into(),
                    "Check for indicators of compromise (IOCs)".into(),
                    "Report to Apple security: product-security@apple.com".into(),
                    "Consider forensic analysis with MVT (Mobile Verification Toolkit)".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[iMessageThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                iMessageThreatType::KnownCVEExploit => 1.6,
                iMessageThreatType::ZeroClickExploit => 1.6,
                iMessageThreatType::JBIG2Exploit => 1.5,
                iMessageThreatType::BlastDoorBypass => 1.5,
                iMessageThreatType::SharedCacheInjection => 1.4,
                iMessageThreatType::DeserializationExploit => 1.4,
                iMessageThreatType::ImageIOExploit | iMessageThreatType::WebPExploit => 1.3,
                iMessageThreatType::HomeKitPivot => 1.3,
                iMessageThreatType::ProcessChainAnomaly => 1.2,
                iMessageThreatType::ProcessCrash => 1.1,
                iMessageThreatType::HighEntropyAttachment => 1.0,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> iMessageScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
