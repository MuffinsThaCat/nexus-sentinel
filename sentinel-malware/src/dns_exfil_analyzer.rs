//! Module 121: DNSExfilAnalyzer — DNS-Based Data Exfiltration Detection
//!
//! Detects data exfiltration encoded in DNS queries. Attackers encode stolen
//! data as subdomains in DNS lookups to exfiltrate through firewalls that
//! allow DNS traffic. This module goes beyond basic DNS tunnel detection
//! to analyze encoding patterns, data volume, and exfiltration campaigns.
//!
//! ## Detection Capabilities
//!
//! - **Subdomain encoding**: Base32/Base64/hex-encoded data in subdomain labels
//! - **DNS query volume**: Excessive unique subdomain queries to single domains
//! - **Label length analysis**: Unusually long DNS labels (>30 chars)
//! - **Query type abuse**: TXT/NULL/CNAME/MX records used as data channels
//! - **Entropy analysis**: High entropy in subdomain portions of queries
//! - **Tool detection**: iodine, dnscat2, dns2tcp, DNSExfiltrator, Cobalt Strike
//!   DNS beacon, OzymanDNS, Heyoka signatures
//! - **Frequency analysis**: Rapid sequential queries to same domain
//! - **Response size anomaly**: Large TXT records in responses (download channel)
//! - **Domain generation algorithm**: DGA-like patterns in queried domains
//! - **Chunked transfer detection**: Sequential numbered subdomains
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const LABEL_LENGTH_THRESHOLD: usize = 30;
const SUBDOMAIN_ENTROPY_THRESHOLD: f64 = 3.8;
const QUERY_RATE_THRESHOLD: u32 = 50;
const QUERY_RATE_WINDOW_SECS: u64 = 60;
const UNIQUE_SUBDOMAIN_THRESHOLD: u32 = 100;
const TXT_RESPONSE_SIZE_THRESHOLD: usize = 200;

const DNS_EXFIL_TOOLS: &[(&str, &str, &str, f64)] = &[
    ("iodine", "Iodine — IP over DNS tunnel", "T1048.003", 0.95),
    ("dnscat2", "DNScat2 — encrypted DNS C2/exfil", "T1071.004", 0.95),
    ("dns2tcp", "DNS2TCP — TCP over DNS tunnel", "T1048.003", 0.9),
    ("dnsexfiltrator", "DNSExfiltrator — PowerShell DNS exfil", "T1048.003", 0.9),
    ("cobalt_dns", "Cobalt Strike DNS beacon", "T1071.004", 0.95),
    ("ozymandns", "OzymanDNS — SSH over DNS", "T1048.003", 0.85),
    ("heyoka", "Heyoka — bidirectional DNS tunnel", "T1048.003", 0.85),
    ("dnsfilexfer", "DNSFileXfer — file transfer over DNS", "T1048.003", 0.85),
    ("godoh", "GoDoh — Go DNS-over-HTTPS C2", "T1071.004", 0.9),
    ("sliver_dns", "Sliver DNS implant", "T1071.004", 0.9),
];

const ENCODING_PATTERNS: &[(&str, &str, f64)] = &[
    ("base32", "Base32-encoded subdomain labels (A-Z2-7)", 0.7),
    ("base64", "Base64-encoded subdomain labels", 0.75),
    ("hex", "Hex-encoded subdomain labels (0-9a-f)", 0.65),
    ("base16", "Base16/hex-encoded data in labels", 0.65),
    ("custom", "Custom alphabet encoding detected", 0.6),
];

const SUSPICIOUS_QUERY_TYPES: &[(u16, &str, f64)] = &[
    (16, "TXT record — large data channel", 0.5),
    (10, "NULL record — raw data channel", 0.8),
    (5, "CNAME record — encoded response", 0.4),
    (15, "MX record — encoded data", 0.5),
    (6, "SOA record — data in SOA fields", 0.6),
    (99, "SPF/TXT — data in SPF records", 0.5),
    (255, "ANY record — maximum response", 0.6),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DNSExfilThreatType {
    EncodedSubdomain,
    HighEntropyQuery,
    LongLabel,
    ExcessiveUniqueSubdomains,
    HighQueryRate,
    SuspiciousQueryType,
    LargeTXTResponse,
    ToolSignature,
    ChunkedTransfer,
    DGAPattern,
    BidirectionalTunnel,
    EncryptedPayload,
    SequentialNumbering,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSExfilFinding {
    pub threat_type: DNSExfilThreatType,
    pub source_ip: String,
    pub query_domain: String,
    pub query_type: u16,
    pub subdomain_entropy: f64,
    pub label_length: usize,
    pub confidence: f64,
    pub description: String,
    pub encoding_type: Option<String>,
    pub tool_name: Option<String>,
    pub mitre_id: String,
    pub estimated_data_bytes: u64,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSQuery {
    pub source_ip: String,
    pub query_name: String,
    pub query_type: u16,
    pub response_size: Option<usize>,
    pub response_data: Option<String>,
    pub timestamp: u64,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSExfilResult {
    pub is_exfiltration: bool,
    pub queries_analyzed: u32,
    pub findings: Vec<DNSExfilFinding>,
    pub exfil_domains: Vec<String>,
    pub estimated_exfil_bytes: u64,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct DNSExfilStats {
    pub total_queries: u64,
    pub exfil_detections: u64,
    pub tunnel_detections: u64,
    pub tool_detections: u64,
    pub estimated_exfil_bytes: u64,
    pub unique_exfil_domains: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSExfilConfig {
    pub enabled: bool,
    pub label_length_threshold: usize,
    pub entropy_threshold: f64,
    pub query_rate_threshold: u32,
    pub unique_subdomain_threshold: u32,
    pub txt_response_threshold: usize,
    pub detect_encoding: bool,
    pub detect_tools: bool,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for DNSExfilConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            label_length_threshold: LABEL_LENGTH_THRESHOLD,
            entropy_threshold: SUBDOMAIN_ENTROPY_THRESHOLD,
            query_rate_threshold: QUERY_RATE_THRESHOLD,
            unique_subdomain_threshold: UNIQUE_SUBDOMAIN_THRESHOLD,
            txt_response_threshold: TXT_RESPONSE_SIZE_THRESHOLD,
            detect_encoding: true,
            detect_tools: true,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSToolSig {
    pub name: String,
    pub pattern: String,
    pub severity: f64,
}

#[derive(Debug, Clone, Default)]
struct DomainTracker {
    unique_subdomains: HashSet<String>,
    query_count: u64,
    total_subdomain_bytes: u64,
    timestamps: Vec<u64>,
    query_types: HashMap<u16, u32>,
    first_seen: u64,
    last_seen: u64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct DNSExfilAnalyzer {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<DNSExfilStats>>,
    result_cache: TieredCache<String, DNSExfilResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    query_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, DNSExfilStats>>,
    metrics: MemoryMetrics,
    domain_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, DNSExfilResult>>,
    tool_sig_db: PagedMemory<DNSToolSig>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<DNSExfilConfig>,
    stats: RwLock<DNSExfilStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_queries: AtomicU64,
    domain_tracker: RwLock<HashMap<String, DomainTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl DNSExfilAnalyzer {
    pub fn new() -> Self {
        let cfg = DNSExfilConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            query_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, DNSExfilStats::default(),
                |acc: &mut DNSExfilStats, vals: &[f64]| { acc.total_queries += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            domain_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            tool_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(DNSExfilStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_queries: AtomicU64::new(0),
            domain_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_query(&self, query: &DNSQuery) -> Option<DNSExfilResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_queries.fetch_add(1, Ordering::Relaxed);

        let parts: Vec<&str> = query.query_name.split('.').collect();
        let base_domain = if parts.len() >= 2 {
            format!("{}.{}", parts[parts.len() - 2], parts[parts.len() - 1])
        } else { query.query_name.clone() };

        let subdomain = if parts.len() > 2 {
            parts[..parts.len() - 2].join(".")
        } else { String::new() };

        // Update domain tracker
        {
            let mut tracker = self.domain_tracker.write();
            let dt = tracker.entry(base_domain.clone()).or_default();
            if !subdomain.is_empty() {
                dt.unique_subdomains.insert(subdomain.clone());
                dt.total_subdomain_bytes += subdomain.len() as u64;
            }
            dt.query_count += 1;
            dt.timestamps.push(query.timestamp);
            *dt.query_types.entry(query.query_type).or_insert(0) += 1;
            if dt.first_seen == 0 { dt.first_seen = query.timestamp; }
            dt.last_seen = query.timestamp;
            if dt.timestamps.len() > 1000 { dt.timestamps.drain(..500); }
        }

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut estimated_bytes = 0u64;

        if !subdomain.is_empty() {
            // Label length check
            let max_label = parts[..parts.len() - 2].iter().map(|l| l.len()).max().unwrap_or(0);
            if max_label > cfg.label_length_threshold {
                findings.push(DNSExfilFinding {
                    threat_type: DNSExfilThreatType::LongLabel,
                    source_ip: query.source_ip.clone(),
                    query_domain: query.query_name.clone(),
                    query_type: query.query_type,
                    subdomain_entropy: 0.0, label_length: max_label,
                    confidence: (0.5 + (max_label as f64 - cfg.label_length_threshold as f64) / 30.0).min(0.9),
                    description: format!("Long DNS label: {} chars (threshold: {})", max_label, cfg.label_length_threshold),
                    encoding_type: None, tool_name: None,
                    mitre_id: "T1048.003".into(),
                    estimated_data_bytes: subdomain.len() as u64,
                    timestamp: query.timestamp,
                });
                mitre_ids.insert("T1048.003".into());
                estimated_bytes += subdomain.len() as u64;
            }

            // Entropy check
            let ent = Self::shannon_entropy(subdomain.as_bytes());
            if ent > cfg.entropy_threshold {
                findings.push(DNSExfilFinding {
                    threat_type: DNSExfilThreatType::HighEntropyQuery,
                    source_ip: query.source_ip.clone(),
                    query_domain: query.query_name.clone(),
                    query_type: query.query_type,
                    subdomain_entropy: ent, label_length: subdomain.len(),
                    confidence: (0.5 + (ent - cfg.entropy_threshold) * 0.2).min(0.9),
                    description: format!("High entropy subdomain: {:.2} bits/char", ent),
                    encoding_type: None, tool_name: None,
                    mitre_id: "T1048.003".into(),
                    estimated_data_bytes: subdomain.len() as u64,
                    timestamp: query.timestamp,
                });
                mitre_ids.insert("T1048.003".into());
            }

            // Encoding detection
            if cfg.detect_encoding && subdomain.len() > 16 {
                let encoding = Self::detect_encoding(&subdomain);
                if let Some((enc_type, conf)) = encoding {
                    findings.push(DNSExfilFinding {
                        threat_type: DNSExfilThreatType::EncodedSubdomain,
                        source_ip: query.source_ip.clone(),
                        query_domain: query.query_name.clone(),
                        query_type: query.query_type,
                        subdomain_entropy: ent, label_length: subdomain.len(),
                        confidence: conf,
                        description: format!("{} encoding in subdomain ({} chars)", enc_type, subdomain.len()),
                        encoding_type: Some(enc_type.to_string()),
                        tool_name: None,
                        mitre_id: "T1048.003".into(),
                        estimated_data_bytes: (subdomain.len() as f64 * 0.75) as u64,
                        timestamp: query.timestamp,
                    });
                    mitre_ids.insert("T1048.003".into());
                    estimated_bytes += (subdomain.len() as f64 * 0.75) as u64;
                }
            }

            // Chunked transfer detection (sequential numbering)
            if subdomain.len() > 4 {
                let prefix_digits: String = subdomain.chars().take_while(|c| c.is_ascii_digit()).collect();
                if prefix_digits.len() >= 2 && prefix_digits.len() <= 6 {
                    findings.push(DNSExfilFinding {
                        threat_type: DNSExfilThreatType::SequentialNumbering,
                        source_ip: query.source_ip.clone(),
                        query_domain: query.query_name.clone(),
                        query_type: query.query_type,
                        subdomain_entropy: ent, label_length: subdomain.len(),
                        confidence: 0.6,
                        description: format!("Sequential numbering prefix: {}", prefix_digits),
                        encoding_type: None, tool_name: None,
                        mitre_id: "T1048.003".into(),
                        estimated_data_bytes: subdomain.len() as u64,
                        timestamp: query.timestamp,
                    });
                    mitre_ids.insert("T1048.003".into());
                }
            }
        }

        // Suspicious query type
        for &(qtype, desc, conf) in SUSPICIOUS_QUERY_TYPES {
            if query.query_type == qtype {
                if let Some(resp_size) = query.response_size {
                    if resp_size > cfg.txt_response_threshold {
                        findings.push(DNSExfilFinding {
                            threat_type: DNSExfilThreatType::LargeTXTResponse,
                            source_ip: query.source_ip.clone(),
                            query_domain: query.query_name.clone(),
                            query_type: query.query_type,
                            subdomain_entropy: 0.0, label_length: 0,
                            confidence: (conf + 0.2).min(0.9),
                            description: format!("{}: {} byte response", desc, resp_size),
                            encoding_type: None, tool_name: None,
                            mitre_id: "T1071.004".into(),
                            estimated_data_bytes: resp_size as u64,
                            timestamp: query.timestamp,
                        });
                        mitre_ids.insert("T1071.004".into());
                        estimated_bytes += resp_size as u64;
                    }
                }
                break;
            }
        }

        // Domain-level anomalies
        {
            let tracker = self.domain_tracker.read();
            if let Some(dt) = tracker.get(&base_domain) {
                if dt.unique_subdomains.len() as u32 > cfg.unique_subdomain_threshold {
                    findings.push(DNSExfilFinding {
                        threat_type: DNSExfilThreatType::ExcessiveUniqueSubdomains,
                        source_ip: query.source_ip.clone(),
                        query_domain: base_domain.clone(),
                        query_type: query.query_type,
                        subdomain_entropy: 0.0, label_length: 0,
                        confidence: (0.7 + (dt.unique_subdomains.len() as f64 / 500.0).min(0.25)),
                        description: format!("{} unique subdomains for {} ({} total bytes)",
                            dt.unique_subdomains.len(), base_domain, dt.total_subdomain_bytes),
                        encoding_type: None, tool_name: None,
                        mitre_id: "T1048.003".into(),
                        estimated_data_bytes: dt.total_subdomain_bytes,
                        timestamp: query.timestamp,
                    });
                    mitre_ids.insert("T1048.003".into());
                    estimated_bytes += dt.total_subdomain_bytes;
                }

                // Query rate check
                if dt.timestamps.len() >= 10 {
                    let recent: Vec<&u64> = dt.timestamps.iter()
                        .filter(|&&t| query.timestamp - t < QUERY_RATE_WINDOW_SECS)
                        .collect();
                    if recent.len() as u32 > cfg.query_rate_threshold {
                        findings.push(DNSExfilFinding {
                            threat_type: DNSExfilThreatType::HighQueryRate,
                            source_ip: query.source_ip.clone(),
                            query_domain: base_domain.clone(),
                            query_type: query.query_type,
                            subdomain_entropy: 0.0, label_length: 0,
                            confidence: (0.6 + (recent.len() as f64 / 200.0).min(0.3)),
                            description: format!("{} queries/min to {}", recent.len(), base_domain),
                            encoding_type: None, tool_name: None,
                            mitre_id: "T1048.003".into(),
                            estimated_data_bytes: 0,
                            timestamp: query.timestamp,
                        });
                        mitre_ids.insert("T1048.003".into());
                    }
                }
            }
        }

        self.domain_diffs.write().record_insert(
            format!("{}:{}", query.source_ip, base_domain),
            format!("qtype={},sub_len={}", query.query_type, subdomain.len()),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_exfiltration = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let exfil_domains = if is_exfiltration { vec![base_domain.clone()] } else { Vec::new() };

        let result = DNSExfilResult {
            is_exfiltration,
            queries_analyzed: 1,
            findings,
            exfil_domains,
            estimated_exfil_bytes: estimated_bytes,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        let cache_key = format!("{}:{}:{}", query.source_ip, base_domain, query.timestamp);
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &base_domain);
                m.set(k, base_domain.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_queries += 1;
            if is_exfiltration {
                stats.exfil_detections += 1;
                stats.estimated_exfil_bytes += estimated_bytes;
            }
            let n = stats.total_queries as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_exfiltration {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "dns_exfil_analyzer".into(),
                title: format!("DNS exfiltration: {} → {}", query.source_ip, base_domain),
                details: format!("Risk: {:.1}%, {} findings, est. {} bytes exfiltrated",
                    risk_score * 100.0, result.findings.len(), estimated_bytes),
                path: None,
                process_name: query.process_name.clone(),
                process_pid: query.process_pid,
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Block DNS to external resolvers (force internal DNS)".into(),
                    "Monitor DNS query lengths and entropy".into(),
                    "Restrict DNS query types (block TXT/NULL)".into(),
                    "Deploy DNS inspection at egress".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn detect_encoding(s: &str) -> Option<(&'static str, f64)> {
        let chars: Vec<char> = s.chars().collect();
        let total = chars.len() as f64;
        if total < 8.0 { return None; }

        // Check hex encoding (0-9a-f only, ignoring dots)
        let hex_chars = chars.iter().filter(|c| c.is_ascii_hexdigit() || **c == '.').count() as f64;
        if hex_chars / total > 0.95 {
            return Some(("hex", 0.7));
        }

        // Check base32 (A-Z2-7=)
        let b32_chars = chars.iter()
            .filter(|c| c.is_ascii_uppercase() || (**c >= '2' && **c <= '7') || **c == '=' || **c == '.')
            .count() as f64;
        if b32_chars / total > 0.95 {
            return Some(("base32", 0.75));
        }

        // Check base64 (A-Za-z0-9+/=)
        let b64_chars = chars.iter()
            .filter(|c| c.is_ascii_alphanumeric() || **c == '+' || **c == '/' || **c == '=' || **c == '.' || **c == '-')
            .count() as f64;
        if b64_chars / total > 0.95 && chars.iter().any(|c| c.is_ascii_uppercase()) && chars.iter().any(|c| c.is_ascii_lowercase()) {
            return Some(("base64", 0.7));
        }

        None
    }

    fn shannon_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        freq.iter().filter(|&&f| f > 0).map(|&f| {
            let p = f as f64 / len;
            -p * p.log2()
        }).sum()
    }

    fn calculate_risk_score(&self, findings: &[DNSExfilFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                DNSExfilThreatType::ToolSignature => 1.5,
                DNSExfilThreatType::BidirectionalTunnel => 1.4,
                DNSExfilThreatType::EncryptedPayload => 1.3,
                DNSExfilThreatType::ExcessiveUniqueSubdomains => 1.3,
                DNSExfilThreatType::EncodedSubdomain => 1.2,
                DNSExfilThreatType::ChunkedTransfer => 1.2,
                DNSExfilThreatType::HighEntropyQuery => 1.1,
                DNSExfilThreatType::HighQueryRate => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> DNSExfilStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
