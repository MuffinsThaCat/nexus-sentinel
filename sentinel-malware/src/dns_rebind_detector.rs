//! Module 83: DNSRebindDetector — DNS Rebinding Attack Detection
//!
//! World-class detection engine for DNS rebinding attacks that exploit the
//! same-origin policy by manipulating DNS responses to redirect browser requests
//! from public to private IP addresses, enabling attackers to access internal
//! services, IoT devices, cloud metadata endpoints, and localhost applications.
//!
//! ## Features
//!
//! - **TTL anomaly detection**: Flags DNS responses with ultra-low TTLs (< 5s)
//!   that indicate active rebinding preparation
//! - **IP address oscillation tracking**: Detects domains alternating between
//!   public and private IP addresses across consecutive resolutions
//! - **Private IP targeting**: Monitors for DNS responses resolving to RFC1918
//!   (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16), link-local, and loopback
//! - **Cloud metadata protection**: Detects rebinding to 169.254.169.254 (AWS/GCP
//!   metadata), 100.100.100.200 (Alibaba), and Azure IMDS endpoints
//! - **Localhost rebinding**: Detects domains resolving to 127.0.0.0/8 targeting
//!   local development servers, databases, and admin panels
//! - **Multi-answer detection**: Flags DNS responses with both public and private
//!   IPs in the same answer section (classic rebinding setup)
//! - **Rapid re-resolution tracking**: Monitors for JavaScript-triggered rapid
//!   DNS lookups that indicate rebinding exploitation phase
//! - **Whitelisted domain bypass**: Detects rebinding attempts using subdomains
//!   of trusted domains (e.g., attacker.example.com → 192.168.1.1)
//! - **Browser-based rebinding**: Detects WebSocket and WebRTC-based rebinding
//!   that bypasses traditional DNS rebinding defenses
//! - **Service fingerprinting**: Identifies targeted internal services based on
//!   port patterns (8080, 8443, 3000, 5432, 6379, 27017)
//! - **DNS pinning bypass detection**: Monitors for techniques that circumvent
//!   browser DNS pinning (multiple A records, CNAME chains)
//! - **Singularity of Origin detection**: Identifies patterns from known rebinding
//!   frameworks (Singularity, DNSrebinder, Rebind.network)
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) DNS resolution history
//! - **#2  TieredCache** — Hot cache for recent DNS resolutions
//! - **#3  ReversibleComputation** — Recompute rebinding risk scores
//! - **#5  StreamAccumulator** — Streaming DNS event rate
//! - **#6  MemoryMetrics** — Bounded memory for DNS tracking data
//! - **#461 DifferentialStore** — Track DNS response diffs per domain
//! - **#569 PruningMap** — Auto-expire old DNS events
//! - **#592 DedupStore** — Deduplicate identical DNS alerts
//! - **#627 SparseMatrix** — Domain × IP frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1557 — Adversary-in-the-Middle
//! - T1071.004 — Application Layer Protocol: DNS
//! - T1572 — Protocol Tunneling
//! - T1190 — Exploit Public-Facing Application

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const DNS_CACHE_MAX: usize = 20_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 16 * 1024 * 1024;

/// TTL below this value (seconds) is suspicious for rebinding
const SUSPICIOUS_TTL_THRESHOLD: u32 = 5;
/// Low TTL threshold (still flagged but lower confidence)
const LOW_TTL_THRESHOLD: u32 = 60;
/// Maximum resolution history per domain
const MAX_RESOLUTION_HISTORY: usize = 64;
/// Rapid resolution threshold — lookups per minute
const RAPID_RESOLUTION_THRESHOLD: u32 = 20;
/// Maximum CNAME chain depth before flagging
const MAX_CNAME_DEPTH: u32 = 8;

/// Private/reserved IP ranges that should never appear in public DNS
const PRIVATE_IP_RANGES: &[(&str, &str, &str)] = &[
    ("10.0.0.0/8",       "RFC1918 Class A private",    "Internal network access"),
    ("172.16.0.0/12",    "RFC1918 Class B private",    "Internal network access"),
    ("192.168.0.0/16",   "RFC1918 Class C private",    "Internal/home network access"),
    ("127.0.0.0/8",      "Loopback",                   "Localhost service access"),
    ("169.254.0.0/16",   "Link-local",                 "APIPA / cloud metadata"),
    ("0.0.0.0/8",        "Current network",            "Bind-all interface"),
    ("100.64.0.0/10",    "Carrier-grade NAT",          "CGNAT private range"),
    ("198.18.0.0/15",    "Benchmark testing",          "Reserved range"),
    ("240.0.0.0/4",      "Reserved",                   "Reserved/future use"),
    ("fc00::/7",         "IPv6 unique local",          "IPv6 private"),
    ("fe80::/10",        "IPv6 link-local",            "IPv6 link-local"),
    ("::1/128",          "IPv6 loopback",              "IPv6 localhost"),
];

/// Cloud metadata endpoints targeted by rebinding attacks
const CLOUD_METADATA_IPS: &[(&str, &str, f64)] = &[
    ("169.254.169.254",  "AWS/GCP/Azure Instance Metadata Service",  1.0),
    ("100.100.100.200",  "Alibaba Cloud Metadata Service",           1.0),
    ("169.254.170.2",    "AWS ECS Container Credentials",            0.95),
    ("fd00:ec2::254",    "AWS IPv6 IMDS",                            0.95),
    ("metadata.google.internal", "GCP Metadata hostname",            0.90),
];

/// Known rebinding tool signatures
const REBINDING_TOOL_SIGNATURES: &[(&str, &str, f64)] = &[
    ("rebind.network",      "Rebind.network — public rebinding service",     0.95),
    ("rbndr.us",            "RBNDr — DNS rebinding tool",                    0.95),
    ("1u.ms",               "1u.ms — DNS rebinding as a service",            0.90),
    ("nip.io",              "nip.io — wildcard DNS (can facilitate rebind)",  0.60),
    ("xip.io",              "xip.io — wildcard DNS",                         0.60),
    ("sslip.io",            "sslip.io — wildcard DNS with TLS",              0.55),
    ("singularity",         "Singularity of Origin framework",               0.90),
    ("dnsrebinder",         "DNSRebinder tool",                              0.90),
    ("whonow",              "Whonow — DNS rebinding server",                 0.90),
    ("tavis-rebinding",     "Tavis Ormandy rebinding PoC",                   0.85),
];

/// Common internal service ports targeted by rebinding
const TARGET_PORTS: &[(u16, &str, f64)] = &[
    (80,    "HTTP",                   0.3),
    (443,   "HTTPS",                  0.3),
    (3000,  "Node.js / Grafana",      0.6),
    (4200,  "Angular dev server",     0.5),
    (5000,  "Flask / Docker Registry", 0.6),
    (5432,  "PostgreSQL",             0.8),
    (5900,  "VNC",                    0.8),
    (6379,  "Redis",                  0.9),
    (8080,  "HTTP alt / proxy",       0.5),
    (8443,  "HTTPS alt",              0.4),
    (8888,  "Jupyter Notebook",       0.7),
    (9090,  "Prometheus",             0.7),
    (9200,  "Elasticsearch",          0.8),
    (27017, "MongoDB",                0.9),
    (11211, "Memcached",              0.8),
    (2375,  "Docker API (unencrypted)", 1.0),
    (2376,  "Docker API (TLS)",       0.8),
    (10250, "Kubelet API",            0.9),
    (10255, "Kubelet read-only",      0.7),
    (25,    "SMTP",                   0.6),
    (22,    "SSH",                    0.5),
    (3306,  "MySQL",                  0.8),
    (1433,  "MSSQL",                  0.8),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum RebindThreatType {
    LowTTL, IPOscillation, PrivateIPResolution, CloudMetadataTarget,
    LocalhostTarget, MultiAnswerMixed, RapidReresolution, CNAMEChain,
    KnownRebindTool, ServiceTargeting, DNSPinningBypass,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSResolution {
    pub domain: String,
    pub resolved_ips: Vec<String>,
    pub ttl: u32,
    pub cname_chain: Vec<String>,
    pub query_timestamp: i64,
    pub response_time_ms: u32,
    pub record_type: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RebindEvent {
    pub id: String,
    pub timestamp: i64,
    pub threat_types: Vec<RebindThreatType>,
    pub severity: Severity,
    pub confidence: f64,
    pub domain: String,
    pub current_ips: Vec<String>,
    pub previous_ips: Vec<String>,
    pub ttl: u32,
    pub resolution_count: u32,
    pub private_ips_targeted: Vec<String>,
    pub cloud_metadata_targeted: bool,
    pub cname_depth: u32,
    pub target_port: Option<u16>,
    pub target_service: Option<String>,
    pub rebind_tool_match: Option<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct RebindStats {
    pub resolutions_analyzed: u64,
    pub threats_detected: u64,
    pub low_ttl_detected: u64,
    pub ip_oscillations: u64,
    pub private_ip_resolutions: u64,
    pub cloud_metadata_targets: u64,
    pub localhost_targets: u64,
    pub mixed_answers: u64,
    pub rapid_reresolutions: u64,
    pub cname_chains: u64,
    pub known_tools: u64,
    pub service_targets: u64,
    pub blocked_domains: u64,
    pub unique_domains_tracked: u64,
}

pub struct DNSRebindDetector {
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<RebindStats>>,
    event_cache: TieredCache<String, RebindEvent>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_rate: RwLock<StreamAccumulator<f64, RebindStats>>,
    metrics: MemoryMetrics,
    dns_diffs: RwLock<DifferentialStore<String, String>>,
    recent_events: RwLock<PruningMap<String, RebindEvent>>,
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    domain_ip_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Per-domain resolution history: domain → vec of (timestamp, ips, ttl)
    resolution_history: RwLock<HashMap<String, VecDeque<(i64, Vec<String>, u32)>>>,
    /// Per-domain resolution rate: domain → count in current window
    resolution_rate: RwLock<HashMap<String, u32>>,
    stats: RwLock<RebindStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl DNSRebindDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(DNS_CACHE_MAX)
            .with_metrics(metrics.clone(), "dns_rebind_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, RebindStats::default(),
            |acc: &mut RebindStats, rates: &[f64]| {
                for &r in rates { acc.resolutions_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            dns_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(DNS_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            domain_ip_matrix: RwLock::new(SparseMatrix::new(0u64)),
            resolution_history: RwLock::new(HashMap::new()),
            resolution_rate: RwLock::new(HashMap::new()),
            stats: RwLock::new(RebindStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("dns_rebind", MEMORY_BUDGET / 2);
        info!("DNSRebindDetector started — {} private ranges, {} metadata IPs, {} target ports",
            PRIVATE_IP_RANGES.len(), CLOUD_METADATA_IPS.len(), TARGET_PORTS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("DNSRebindDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn is_private_ip(ip: &str) -> bool {
        ip.starts_with("10.") || ip.starts_with("192.168.")
            || ip.starts_with("172.") && {
                ip.split('.').nth(1).and_then(|s| s.parse::<u8>().ok())
                    .map(|n| (16..=31).contains(&n)).unwrap_or(false)
            }
            || ip.starts_with("127.") || ip.starts_with("0.")
            || ip.starts_with("169.254.") || ip.starts_with("100.64.")
            || ip == "::1" || ip.starts_with("fc") || ip.starts_with("fe80:")
    }

    fn is_cloud_metadata(ip: &str) -> Option<(&'static str, f64)> {
        CLOUD_METADATA_IPS.iter()
            .find(|(addr, _, _)| ip == *addr)
            .map(|(_, desc, risk)| (*desc, *risk))
    }

    fn check_rebind_tool(domain: &str) -> Option<(&'static str, f64)> {
        let domain_lower = domain.to_lowercase();
        REBINDING_TOOL_SIGNATURES.iter()
            .find(|(sig, _, _)| domain_lower.contains(sig))
            .map(|(_, desc, risk)| (*desc, *risk))
    }

    /// Analyze a DNS resolution for rebinding indicators.
    pub fn analyze_resolution(&self, resolution: &DNSResolution) -> Option<RebindEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().resolutions_analyzed += 1;

        let mut threat_types = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut private_ips = Vec::new();
        let mut cloud_metadata = false;
        let mut max_risk: f64 = 0.0;

        // ── 1. TTL analysis ──
        if resolution.ttl <= SUSPICIOUS_TTL_THRESHOLD {
            indicators.push(format!("Ultra-low TTL: {} seconds for '{}'",
                resolution.ttl, resolution.domain));
            threat_types.push(RebindThreatType::LowTTL);
            self.stats.write().low_ttl_detected += 1;
            max_risk = max_risk.max(0.7);
        } else if resolution.ttl <= LOW_TTL_THRESHOLD {
            indicators.push(format!("Low TTL: {} seconds for '{}'",
                resolution.ttl, resolution.domain));
            max_risk = max_risk.max(0.3);
        }

        // ── 2. Private IP detection ──
        for ip in &resolution.resolved_ips {
            if Self::is_private_ip(ip) {
                private_ips.push(ip.clone());
                indicators.push(format!("Private IP resolved: '{}' → {}", resolution.domain, ip));
                threat_types.push(RebindThreatType::PrivateIPResolution);
                self.stats.write().private_ip_resolutions += 1;
                max_risk = max_risk.max(0.85);

                if ip.starts_with("127.") || ip == "::1" {
                    threat_types.push(RebindThreatType::LocalhostTarget);
                    self.stats.write().localhost_targets += 1;
                    max_risk = max_risk.max(0.9);
                }
            }

            // Cloud metadata
            if let Some((desc, risk)) = Self::is_cloud_metadata(ip) {
                indicators.push(format!("CLOUD METADATA target: '{}' → {} ({})",
                    resolution.domain, ip, desc));
                threat_types.push(RebindThreatType::CloudMetadataTarget);
                mitre_techniques.push("T1552.005".to_string());
                self.stats.write().cloud_metadata_targets += 1;
                cloud_metadata = true;
                max_risk = max_risk.max(risk);
            }
        }

        // ── 3. Mixed answer detection ──
        let has_public = resolution.resolved_ips.iter().any(|ip| !Self::is_private_ip(ip));
        let has_private = !private_ips.is_empty();
        if has_public && has_private {
            indicators.push(format!("Mixed DNS answer: '{}' resolves to both public and private IPs",
                resolution.domain));
            threat_types.push(RebindThreatType::MultiAnswerMixed);
            self.stats.write().mixed_answers += 1;
            max_risk = max_risk.max(0.9);
        }

        // ── 4. IP oscillation — compare with history ──
        let previous_ips;
        {
            let mut history = self.resolution_history.write();
            let entry = history.entry(resolution.domain.clone())
                .or_insert_with(|| VecDeque::with_capacity(MAX_RESOLUTION_HISTORY));

            previous_ips = entry.back().map(|(_, ips, _)| ips.clone()).unwrap_or_default();

            if !previous_ips.is_empty() && previous_ips != resolution.resolved_ips {
                let prev_has_private = previous_ips.iter().any(|ip| Self::is_private_ip(ip));
                let curr_has_private = resolution.resolved_ips.iter().any(|ip| Self::is_private_ip(ip));
                if prev_has_private != curr_has_private {
                    indicators.push(format!(
                        "IP oscillation: '{}' switched between public/private: {:?} → {:?}",
                        resolution.domain, &previous_ips[..previous_ips.len().min(3)],
                        &resolution.resolved_ips[..resolution.resolved_ips.len().min(3)]));
                    threat_types.push(RebindThreatType::IPOscillation);
                    self.stats.write().ip_oscillations += 1;
                    max_risk = max_risk.max(0.95);
                }
            }

            entry.push_back((now, resolution.resolved_ips.clone(), resolution.ttl));
            if entry.len() > MAX_RESOLUTION_HISTORY { entry.pop_front(); }

            self.stats.write().unique_domains_tracked = history.len() as u64;
        }

        // ── 5. Rapid re-resolution ──
        {
            let mut rates = self.resolution_rate.write();
            let count = rates.entry(resolution.domain.clone()).or_insert(0);
            *count += 1;
            if *count > RAPID_RESOLUTION_THRESHOLD {
                indicators.push(format!("Rapid re-resolution: '{}' resolved {} times in window",
                    resolution.domain, count));
                threat_types.push(RebindThreatType::RapidReresolution);
                self.stats.write().rapid_reresolutions += 1;
                max_risk = max_risk.max(0.75);
            }
        }

        // ── 6. CNAME chain depth ──
        if resolution.cname_chain.len() as u32 > MAX_CNAME_DEPTH {
            indicators.push(format!("Deep CNAME chain: '{}' has {} levels",
                resolution.domain, resolution.cname_chain.len()));
            threat_types.push(RebindThreatType::CNAMEChain);
            self.stats.write().cname_chains += 1;
            max_risk = max_risk.max(0.6);
        }

        // ── 7. Known rebinding tool ──
        if let Some((desc, risk)) = Self::check_rebind_tool(&resolution.domain) {
            indicators.push(format!("Known rebinding tool: '{}' — {}", resolution.domain, desc));
            threat_types.push(RebindThreatType::KnownRebindTool);
            self.stats.write().known_tools += 1;
            max_risk = max_risk.max(risk);
        }

        // Update matrix
        for ip in &resolution.resolved_ips {
            let c = *self.domain_ip_matrix.read()
                .get(&resolution.domain, ip);
            self.domain_ip_matrix.write()
                .set(resolution.domain.clone(), ip.clone(), c + 1);
        }

        if threat_types.is_empty() { return None; }

        threat_types.sort();
        threat_types.dedup();
        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1557".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.7 + indicators.len() as f64 * 0.05).min(0.99);
        let blocked = matches!(severity, Severity::Critical);

        self.stats.write().threats_detected += 1;
        if blocked { self.stats.write().blocked_domains += 1; }

        let event = RebindEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, threat_types, severity, confidence,
            domain: resolution.domain.clone(),
            current_ips: resolution.resolved_ips.clone(),
            previous_ips, ttl: resolution.ttl,
            resolution_count: *self.resolution_rate.read()
                .get(&resolution.domain).unwrap_or(&1),
            private_ips_targeted: private_ips,
            cloud_metadata_targeted: cloud_metadata,
            cname_depth: resolution.cname_chain.len() as u32,
            target_port: None, target_service: None,
            rebind_tool_match: Self::check_rebind_tool(&resolution.domain)
                .map(|(desc, _)| desc.to_string()),
            indicators, mitre_techniques, blocked,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(
            event.id.clone(), event.clone(), confidence);
        self.risk_computer.write().push(confidence);
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.domain_ip_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.dns_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );

        if blocked {
            warn!("DNS REBINDING: '{}' → {:?}", resolution.domain, event.current_ips);
        }
        Some(event)
    }

    pub fn stats(&self) -> RebindStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
