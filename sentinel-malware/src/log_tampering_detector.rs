//! Module 96: LogTamperingDetector — Log Manipulation & Anti-Forensics Detection
//!
//! World-class detection engine for log tampering, evidence destruction, and
//! anti-forensics techniques. Monitors system logs, application logs, audit trails,
//! and event stores for unauthorized deletion, modification, rotation abuse, and
//! timestomping designed to cover attacker tracks.
//!
//! ## Features
//!
//! - **Log deletion detection**: Monitors for unauthorized deletion of syslog,
//!   auth.log, secure, wtmp, btmp, lastlog, and application log files
//! - **Event log clearing**: Detects Windows Event Log clearing (wevtutil cl,
//!   Clear-EventLog), Security/System/Application log wipes
//! - **Selective log editing**: Identifies surgical removal of specific log entries
//!   (sed/awk on logs, journal vacuum with time ranges)
//! - **Timestomping detection**: Detects modification of file timestamps (touch,
//!   SetFileTime, timestomp) to alter forensic timelines
//! - **Audit trail manipulation**: Monitors auditd configuration changes, audit
//!   rule deletion, and audit daemon stopping
//! - **Log rotation abuse**: Identifies forced log rotation (logrotate --force),
//!   rotation config modification, and max size reduction
//! - **Syslog manipulation**: Detects syslog daemon reconfiguration, rsyslog/
//!   syslog-ng rule changes, and log forwarding disruption
//! - **macOS Unified Log**: Monitors for log stream manipulation, log show
//!   filtering abuse, and log erase commands
//! - **Journal manipulation**: Detects systemd journal vacuum, rotation, and
//!   journalctl configuration changes
//! - **History file tampering**: Monitors bash_history, zsh_history, PowerShell
//!   history clearing, HISTCONTROL manipulation
//! - **Shadow log detection**: Identifies attacker-created shadow copies of logs
//!   to maintain access while deleting originals
//! - **USB forensic artifact cleanup**: Detects removal of USB connection logs,
//!   setupapi logs, and device history
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) tampering event history
//! - **#2  TieredCache** — Hot cache for recent tampering detections
//! - **#3  ReversibleComputation** — Recompute tampering risk scores
//! - **#5  StreamAccumulator** — Streaming detection rate
//! - **#6  MemoryMetrics** — Bounded memory for detection data
//! - **#461 DifferentialStore** — Track log file size/hash diffs
//! - **#569 PruningMap** — Auto-expire old tampering events
//! - **#592 DedupStore** — Deduplicate identical detections
//! - **#627 SparseMatrix** — Log-source × tampering-type matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1070.001 — Indicator Removal: Clear Windows Event Logs
//! - T1070.002 — Indicator Removal: Clear Linux or Mac System Logs
//! - T1070.003 — Indicator Removal: Clear Command History
//! - T1070.004 — Indicator Removal: File Deletion
//! - T1070.006 — Indicator Removal: Timestomp
//! - T1562.001 — Impair Defenses: Disable or Modify Tools
//! - T1562.002 — Impair Defenses: Disable Windows Event Logging

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const TAMPER_CACHE_MAX: usize = 8_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 20 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────
const LOG_SHRINKAGE_THRESHOLD_PERCENT: f64 = 20.0;
const RAPID_CLEAR_WINDOW_SECS: i64 = 300;
const MIN_LOG_SIZE_FOR_SHRINKAGE: u64 = 1024;
const SELECTIVE_EDIT_RISK: f64 = 0.85;

/// Critical log files to monitor for tampering: (path, name, platform, risk_if_deleted)
const CRITICAL_LOG_FILES: &[(&str, &str, &str, f64)] = &[
    ("/var/log/syslog",        "Syslog",             "Linux",  0.90),
    ("/var/log/auth.log",      "Auth Log",           "Linux",  0.95),
    ("/var/log/secure",        "Secure Log",         "Linux",  0.95),
    ("/var/log/messages",      "Messages",           "Linux",  0.85),
    ("/var/log/kern.log",      "Kernel Log",         "Linux",  0.85),
    ("/var/log/daemon.log",    "Daemon Log",         "Linux",  0.75),
    ("/var/log/cron",          "Cron Log",           "Linux",  0.70),
    ("/var/log/faillog",       "Failed Login Log",   "Linux",  0.80),
    ("/var/log/wtmp",          "Login Records",      "Linux",  0.90),
    ("/var/log/btmp",          "Bad Login Records",  "Linux",  0.85),
    ("/var/log/lastlog",       "Last Login Records", "Linux",  0.80),
    ("/var/log/utmp",          "Current Logins",     "Linux",  0.85),
    ("/var/log/audit/audit.log","Audit Log",         "Linux",  0.95),
    ("/var/log/apache2/access.log", "Apache Access", "Linux",  0.70),
    ("/var/log/apache2/error.log",  "Apache Error",  "Linux",  0.70),
    ("/var/log/nginx/access.log",   "Nginx Access",  "Linux",  0.70),
    ("/var/log/nginx/error.log",    "Nginx Error",   "Linux",  0.70),
    ("/var/log/install.log",   "macOS Install Log",  "macOS",  0.65),
    ("/var/log/system.log",    "macOS System Log",   "macOS",  0.85),
    ("/var/log/asl/",          "macOS ASL Logs",     "macOS",  0.80),
];

/// Log clearing commands: (command_pattern, description, risk, mitre)
const LOG_CLEARING_COMMANDS: &[(&str, &str, f64, &str)] = &[
    ("wevtutil cl Security",     "Clear Windows Security Event Log",    0.98, "T1070.001"),
    ("wevtutil cl System",       "Clear Windows System Event Log",      0.95, "T1070.001"),
    ("wevtutil cl Application",  "Clear Windows Application Log",       0.90, "T1070.001"),
    ("wevtutil cl",              "Clear Windows Event Log (any)",       0.90, "T1070.001"),
    ("Clear-EventLog",           "PowerShell Clear-EventLog",           0.95, "T1070.001"),
    ("Remove-EventLog",          "PowerShell Remove-EventLog",          0.95, "T1070.001"),
    ("for /F %x in ('wevtutil el')", "Batch clear all event logs",     0.98, "T1070.001"),
    ("rm -rf /var/log",          "Delete all Linux logs",               0.98, "T1070.002"),
    ("shred /var/log",           "Secure delete Linux logs",            0.95, "T1070.002"),
    ("truncate -s 0 /var/log",   "Truncate Linux log files",           0.90, "T1070.002"),
    ("> /var/log/",              "Redirect empty to log file",          0.85, "T1070.002"),
    ("cat /dev/null > /var/log", "Null redirect to log file",          0.90, "T1070.002"),
    ("journalctl --vacuum-time", "Systemd journal vacuum by time",     0.75, "T1070.002"),
    ("journalctl --vacuum-size", "Systemd journal vacuum by size",     0.70, "T1070.002"),
    ("log erase",                "macOS log erase command",             0.90, "T1070.002"),
    ("log erase --all",          "macOS erase all logs",                0.95, "T1070.002"),
    ("osascript -e 'do shell script \"rm", "macOS AppleScript log deletion", 0.85, "T1070.002"),
];

/// History file tampering commands
const HISTORY_TAMPERING: &[(&str, &str, f64, &str)] = &[
    ("history -c",              "Clear bash history",                   0.80, "T1070.003"),
    ("history -w /dev/null",    "Write empty history",                  0.85, "T1070.003"),
    ("unset HISTFILE",          "Disable history file",                 0.80, "T1070.003"),
    ("HISTSIZE=0",              "Set history size to 0",                0.80, "T1070.003"),
    ("HISTCONTROL=ignoreboth",  "Ignore duplicates and spaces",         0.50, "T1070.003"),
    ("export HISTFILESIZE=0",   "Set history file size to 0",           0.80, "T1070.003"),
    ("rm ~/.bash_history",      "Delete bash history file",             0.90, "T1070.003"),
    ("rm ~/.zsh_history",       "Delete zsh history file",              0.90, "T1070.003"),
    ("shred ~/.bash_history",   "Secure delete bash history",           0.95, "T1070.003"),
    ("Clear-History",           "PowerShell Clear-History",             0.85, "T1070.003"),
    ("Remove-Item (Get-PSReadlineOption).HistorySavePath", "Delete PSReadLine history", 0.90, "T1070.003"),
    ("Set-PSReadlineOption -HistorySaveStyle SaveNothing", "Disable PS history save", 0.80, "T1070.003"),
    ("ln -sf /dev/null ~/.bash_history", "Symlink history to null",    0.90, "T1070.003"),
];

/// Timestomping indicators
const TIMESTOMP_PATTERNS: &[(&str, f64, &str)] = &[
    ("touch -t",            0.65, "Touch with specific timestamp"),
    ("touch -r",            0.55, "Touch reference file timestamp"),
    ("touch -d",            0.60, "Touch with date string"),
    ("SetFileTime",         0.80, "Windows SetFileTime API"),
    ("timestomp",           0.95, "Metasploit timestomp"),
    ("NtSetInformationFile",0.85, "NT API file time manipulation"),
    ("SetFileInformationByHandle", 0.80, "Win32 file info manipulation"),
    ("New-ItemProperty -Name LastWriteTime", 0.85, "PowerShell timestamp change"),
    ("xattr -w",            0.50, "macOS extended attribute modification"),
];

/// Audit system tampering
const AUDIT_TAMPERING: &[(&str, f64, &str)] = &[
    ("auditctl -D",         0.95, "Delete all audit rules"),
    ("auditctl -e 0",       0.95, "Disable auditing"),
    ("service auditd stop", 0.90, "Stop audit daemon"),
    ("systemctl stop auditd",0.90,"Stop audit daemon via systemctl"),
    ("systemctl disable auditd",0.85,"Disable audit daemon"),
    ("rm /etc/audit/rules.d",0.90,"Delete audit rule files"),
    ("auditpol /clear",     0.95, "Clear Windows audit policy"),
    ("auditpol /set /subcategory:",0.70,"Modify audit subcategory"),
    ("setenforce 0",        0.75, "Disable SELinux enforcement"),
    ("echo 0 > /proc/sys/kernel/sysrq", 0.60, "Disable SysRq"),
];

/// Syslog reconfiguration indicators
const SYSLOG_RECONFIG: &[(&str, f64, &str)] = &[
    ("rsyslog.conf",              0.60, "Rsyslog configuration modification"),
    ("syslog-ng.conf",            0.60, "Syslog-NG configuration modification"),
    ("/etc/logrotate",            0.40, "Log rotation configuration change"),
    ("logger -p",                 0.35, "Manual syslog injection"),
    ("systemctl restart rsyslog", 0.55, "Rsyslog service restart"),
    ("kill -HUP",                 0.45, "Signal-based config reload"),
    ("@@127.0.0.1",               0.70, "Syslog redirect to localhost"),
    ("/dev/null",                 0.80, "Output redirect to /dev/null"),
];

/// Windows Event Log manipulation via PowerShell/WMI
const WINDOWS_EVENTLOG_MANIPULATION: &[(&str, f64, &str)] = &[
    ("Limit-EventLog",            0.70, "Limit event log size"),
    ("Set-ItemProperty.*MaxSize", 0.65, "Set max log size via registry"),
    ("Get-WinEvent | Remove",     0.90, "Remove specific events"),
    ("Stop-Service EventLog",     0.95, "Stop Windows Event Log service"),
    ("sc stop eventlog",          0.95, "Stop Event Log via sc"),
    ("reg delete.*EventLog",      0.85, "Delete Event Log registry keys"),
    ("wmic nteventlog",           0.70, "WMI Event Log manipulation"),
];

/// Selective log editing tools and techniques
const SELECTIVE_EDITING: &[(&str, f64, &str)] = &[
    ("sed -i",                    0.70, "In-place stream editing of log files"),
    ("awk '{print}'",             0.50, "AWK selective line printing"),
    ("grep -v",                   0.60, "Inverse grep — remove matching lines"),
    ("perl -pi -e",               0.70, "Perl in-place editing"),
    ("python -c.*open.*write",    0.65, "Python file modification"),
    ("tail -n +",                 0.50, "Tail skip — remove head of file"),
    ("head -n",                   0.45, "Head truncation"),
    ("dd if=/dev/zero",           0.75, "DD zero-fill — overwrite file sections"),
];

/// Shadow log / decoy log indicators
const SHADOW_LOG_INDICATORS: &[(&str, f64, &str)] = &[
    ("tee -a",                    0.40, "Tee append — may duplicate logs"),
    ("mkfifo",                    0.55, "Named pipe — log interception"),
    ("socat",                     0.50, "Socat relay — log redirect"),
    ("ncat -l",                   0.55, "Ncat listener — log capture"),
    ("syslog-ng.*destination",    0.60, "Syslog-NG destination change"),
    ("rsyslog.*action",           0.60, "Rsyslog action modification"),
];

/// Log rotation abuse patterns
const LOG_ROTATION_ABUSE: &[(&str, f64, &str)] = &[
    ("logrotate -f",              0.65, "Forced log rotation"),
    ("logrotate --force",         0.65, "Forced log rotation (long flag)"),
    ("rotate 0",                  0.80, "Set rotation count to 0 — immediate deletion"),
    ("maxage 1",                  0.70, "Set max age to 1 day — rapid expiry"),
    ("size 1",                    0.75, "Set rotation size to 1 byte — rapid rotation"),
    ("compress",                  0.25, "Compression (normal, low risk alone)"),
    ("sharedscripts",            0.30, "Shared scripts (normal, low risk alone)"),
];

/// USB/removable media log cleanup
const USB_LOG_CLEANUP: &[(&str, f64, &str)] = &[
    ("setupapi.dev.log",          0.75, "Windows USB device setup log"),
    ("USBSTOR",                   0.70, "USB storage registry key"),
    ("usb-devices",               0.50, "Linux USB device listing"),
    ("/var/log/kern.log.*usb",    0.65, "Kernel USB log entries"),
    ("MountedDevices",            0.70, "Windows mounted devices registry"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum TamperTechnique {
    LogDeletion, EventLogClearing, SelectiveEditing, Timestomping,
    AuditManipulation, LogRotationAbuse, HistoryClearing, JournalManipulation,
    SyslogReconfiguration, USBLogCleanup, ShadowLogCreation, LogTruncation,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TamperEvent {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub techniques: Vec<TamperTechnique>,
    pub process_name: String,
    pub process_id: u32,
    pub command_line: String,
    pub user: String,
    pub affected_logs: Vec<String>,
    pub command_matched: String,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TamperStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub log_deletions: u64,
    pub event_log_clears: u64,
    pub timestomps: u64,
    pub audit_manipulations: u64,
    pub history_clears: u64,
    pub journal_manipulations: u64,
    pub syslog_reconfigs: u64,
    pub log_truncations: u64,
    pub log_shrinkage_detected: u64,
    pub blocked_tampering: u64,
    pub safe_operations: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TamperDetectorConfig {
    pub block_log_clearing: bool,
    pub block_history_tampering: bool,
    pub block_audit_manipulation: bool,
    pub detect_syslog_reconfig: bool,
    pub detect_log_shrinkage: bool,
    pub block_on_high: bool,
}

impl TamperDetectorConfig {
    pub fn default_config() -> Self {
        Self {
            block_log_clearing: true,
            block_history_tampering: true,
            block_audit_manipulation: true,
            detect_syslog_reconfig: true,
            detect_log_shrinkage: true,
            block_on_high: true,
        }
    }
}

pub struct LogTamperingDetector {
    // Breakthrough #1: HierarchicalState — O(log n) tamper history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<TamperStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, TamperEvent>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, TamperStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — log size diffs
    log_size_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, TamperEvent>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — user × technique matrix
    log_tamper_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<TamperDetectorConfig>,
    /// Track log file sizes for shrinkage detection
    log_file_sizes: RwLock<HashMap<String, u64>>,
    stats: RwLock<TamperStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl LogTamperingDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(TAMPER_CACHE_MAX)
            .with_metrics(metrics.clone(), "tamper_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, TamperStats::default(),
            |acc: &mut TamperStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            log_size_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(TAMPER_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            log_tamper_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(TamperDetectorConfig::default_config()),
            log_file_sizes: RwLock::new(HashMap::new()),
            stats: RwLock::new(TamperStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("log_tampering", MEMORY_BUDGET / 2);
        info!("LogTamperingDetector started — {} critical logs, {} clearing cmds, {} history cmds, {} timestomp patterns",
            CRITICAL_LOG_FILES.len(), LOG_CLEARING_COMMANDS.len(),
            HISTORY_TAMPERING.len(), TIMESTOMP_PATTERNS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("LogTamperingDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Analyze a command execution for log tampering indicators.
    pub fn analyze_command(
        &self, process_name: &str, pid: u32, command_line: &str, user: &str,
    ) -> Option<TamperEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let cmd_lower = command_line.to_lowercase();
        let mut techniques = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut affected_logs = Vec::new();
        let mut matched_cmd = String::new();
        let mut max_risk: f64 = 0.0;

        // ── 1. Log clearing commands ──
        for &(pattern, desc, risk, mitre) in LOG_CLEARING_COMMANDS {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                matched_cmd = pattern.to_string();
                indicators.push(format!("Log clearing: {} — {}", pattern, desc));
                techniques.push(TamperTechnique::EventLogClearing);
                mitre_techniques.push(mitre.to_string());
                max_risk = max_risk.max(risk);
                self.stats.write().event_log_clears += 1;
                break;
            }
        }

        // ── 2. History tampering ──
        for &(pattern, desc, risk, mitre) in HISTORY_TAMPERING {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                if matched_cmd.is_empty() { matched_cmd = pattern.to_string(); }
                indicators.push(format!("History tampering: {} — {}", pattern, desc));
                techniques.push(TamperTechnique::HistoryClearing);
                mitre_techniques.push(mitre.to_string());
                max_risk = max_risk.max(risk);
                self.stats.write().history_clears += 1;
                break;
            }
        }

        // ── 3. Timestomping ──
        for &(pattern, risk, desc) in TIMESTOMP_PATTERNS {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                if matched_cmd.is_empty() { matched_cmd = pattern.to_string(); }
                indicators.push(format!("Timestomping: {} — {}", pattern, desc));
                techniques.push(TamperTechnique::Timestomping);
                mitre_techniques.push("T1070.006".to_string());
                max_risk = max_risk.max(risk);
                self.stats.write().timestomps += 1;
                break;
            }
        }

        // ── 4. Audit tampering ──
        for &(pattern, risk, desc) in AUDIT_TAMPERING {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                if matched_cmd.is_empty() { matched_cmd = pattern.to_string(); }
                indicators.push(format!("Audit tampering: {} — {}", pattern, desc));
                techniques.push(TamperTechnique::AuditManipulation);
                mitre_techniques.push("T1562.002".to_string());
                max_risk = max_risk.max(risk);
                self.stats.write().audit_manipulations += 1;
                break;
            }
        }

        // ── 5. Critical log file access ──
        for &(path, name, _platform, risk) in CRITICAL_LOG_FILES {
            if cmd_lower.contains(path) && (cmd_lower.contains("rm ") || cmd_lower.contains("shred ")
                || cmd_lower.contains("truncate ") || cmd_lower.contains("> ")) {
                affected_logs.push(format!("{} ({})", name, path));
                techniques.push(TamperTechnique::LogDeletion);
                mitre_techniques.push("T1070.004".to_string());
                max_risk = max_risk.max(risk);
                self.stats.write().log_deletions += 1;
            }
        }

        let config = self.config.read().clone();

        // ── 6. Syslog reconfiguration ──
        if config.detect_syslog_reconfig {
            for &(pattern, risk, desc) in SYSLOG_RECONFIG {
                if cmd_lower.contains(&pattern.to_lowercase()) {
                    if matched_cmd.is_empty() { matched_cmd = pattern.to_string(); }
                    indicators.push(format!("Syslog reconfig: {} — {}", pattern, desc));
                    techniques.push(TamperTechnique::SyslogReconfiguration);
                    mitre_techniques.push("T1562.006".to_string());
                    max_risk = max_risk.max(risk);
                    self.stats.write().syslog_reconfigs += 1;
                    break;
                }
            }
        }

        // ── 7. Windows Event Log manipulation ──
        for &(pattern, risk, desc) in WINDOWS_EVENTLOG_MANIPULATION {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                if matched_cmd.is_empty() { matched_cmd = pattern.to_string(); }
                indicators.push(format!("EventLog manipulation: {} — {}", pattern, desc));
                techniques.push(TamperTechnique::EventLogClearing);
                mitre_techniques.push("T1070.001".to_string());
                max_risk = max_risk.max(risk);
                self.stats.write().event_log_clears += 1;
                break;
            }
        }

        // ── 8. Log truncation detection ──
        if cmd_lower.contains("truncate") || cmd_lower.contains("> /var/log") || cmd_lower.contains("cat /dev/null") {
            if !techniques.contains(&TamperTechnique::LogTruncation) {
                indicators.push("Log truncation detected".to_string());
                techniques.push(TamperTechnique::LogTruncation);
                self.stats.write().log_truncations += 1;
                max_risk = max_risk.max(0.85);
            }
        }

        if techniques.is_empty() {
            self.stats.write().safe_operations += 1;
            return None;
        }

        // ── Finalize ──
        techniques.sort();
        techniques.dedup();
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.60 + techniques.len() as f64 * 0.07
            + if affected_logs.len() > 1 { 0.10 } else { 0.0 }).min(0.99);
        let blocked = config.block_on_high && matches!(severity, Severity::Critical | Severity::High);

        self.stats.write().threats_detected += 1;
        if blocked { self.stats.write().blocked_tampering += 1; }

        // Breakthrough #627: SparseMatrix
        for t in &techniques {
            let c = *self.log_tamper_matrix.read()
                .get(&user.to_string(), &format!("{:?}", t));
            self.log_tamper_matrix.write()
                .set(user.to_string(), format!("{:?}", t), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let event = TamperEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, severity, confidence, techniques,
            process_name: process_name.to_string(), process_id: pid,
            command_line: command_line.to_string(), user: user.to_string(),
            affected_logs, command_matched: matched_cmd,
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.log_tamper_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record log state diff
        self.log_size_diffs.write().record_insert(
            event.id.clone(),
            format!("{}:{}:{:?}", command_line, user, event.techniques),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{}:{}:{:?}", command_line, user, event.techniques).into_bytes(),
        );
        if blocked { warn!("LOG TAMPERING BLOCKED: {} by user={} — {:?}", command_line, user, event.techniques); }
        Some(event)
    }

    /// Detect selective log editing
    fn detect_selective_editing(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in SELECTIVE_EDITING {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                // Only flag if targeting a log file
                if cmd_lower.contains("/var/log") || cmd_lower.contains(".log")
                    || cmd_lower.contains("event") || cmd_lower.contains("audit") {
                    return Some((risk, desc.to_string()));
                }
            }
        }
        None
    }

    /// Detect shadow log / log interception
    fn detect_shadow_log(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in SHADOW_LOG_INDICATORS {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                return Some((risk, desc.to_string()));
            }
        }
        None
    }

    /// Detect log rotation abuse
    fn detect_rotation_abuse(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in LOG_ROTATION_ABUSE {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                return Some((risk, desc.to_string()));
            }
        }
        None
    }

    /// Detect USB log cleanup
    fn detect_usb_log_cleanup(cmd: &str) -> Option<(f64, String)> {
        let cmd_lower = cmd.to_lowercase();
        for &(pattern, risk, desc) in USB_LOG_CLEANUP {
            if cmd_lower.contains(&pattern.to_lowercase()) {
                if cmd_lower.contains("rm ") || cmd_lower.contains("del ")
                    || cmd_lower.contains("shred") || cmd_lower.contains("wipe")
                    || cmd_lower.contains("reg delete") {
                    return Some((risk, desc.to_string()));
                }
            }
        }
        None
    }

    /// Report a log file size change for shrinkage detection.
    pub fn report_log_size(&self, log_path: &str, current_size: u64) {
        let mut sizes = self.log_file_sizes.write();
        if let Some(&prev_size) = sizes.get(log_path) {
            if prev_size > MIN_LOG_SIZE_FOR_SHRINKAGE && current_size < prev_size {
                let shrinkage_pct = ((prev_size - current_size) as f64 / prev_size as f64) * 100.0;
                if shrinkage_pct >= LOG_SHRINKAGE_THRESHOLD_PERCENT {
                    self.stats.write().log_shrinkage_detected += 1;
                    warn!("LOG SHRINKAGE: {} shrank by {:.1}% ({} → {} bytes)",
                        log_path, shrinkage_pct, prev_size, current_size);
                }
            }
        }
        sizes.insert(log_path.to_string(), current_size);
    }

    /// Build a MalwareAlert from a TamperEvent
    fn build_alert(&self, event: &TamperEvent) -> MalwareAlert {
        MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: event.timestamp,
            severity: event.severity,
            module: "log_tampering_detector".to_string(),
            title: format!("Log tampering: {} by user={}",
                event.command_matched, event.user),
            details: format!(
                "Detected {} log tampering technique(s) by user '{}' via process '{}' (PID {}). \
                 Affected logs: {:?}. Command: '{}'. Confidence: {:.0}%. {}",
                event.techniques.len(),
                event.user, event.process_name, event.process_id,
                event.affected_logs, event.command_line,
                event.confidence * 100.0,
                if event.blocked { "BLOCKED." } else { "" }
            ),
            path: None,
            process_name: Some(event.process_name.clone()),
            process_pid: Some(event.process_id),
            verdict: None,
            mitre_ids: event.mitre_techniques.clone(),
            remediation: vec![format!("Investigate user '{}' activity", event.user)],
            confidence: event.confidence,
        }
    }

    /// Extended analysis that also checks selective editing, shadow logs,
    /// rotation abuse, and USB log cleanup.
    pub fn analyze_command_extended(
        &self, process_name: &str, pid: u32, command_line: &str, user: &str,
    ) -> Option<TamperEvent> {
        let mut event = self.analyze_command(process_name, pid, command_line, user);

        // Enrich with selective editing
        if let Some((risk, desc)) = Self::detect_selective_editing(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Selective editing: {}", desc));
                if !ev.techniques.contains(&TamperTechnique::SelectiveEditing) {
                    ev.techniques.push(TamperTechnique::SelectiveEditing);
                }
            }
        }

        // Enrich with shadow log detection
        if let Some((risk, desc)) = Self::detect_shadow_log(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Shadow log: {}", desc));
                ev.techniques.push(TamperTechnique::ShadowLogCreation);
            }
        }

        // Enrich with rotation abuse
        if let Some((risk, desc)) = Self::detect_rotation_abuse(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("Rotation abuse: {}", desc));
                ev.techniques.push(TamperTechnique::LogRotationAbuse);
            }
        }

        // Enrich with USB log cleanup
        if let Some((risk, desc)) = Self::detect_usb_log_cleanup(command_line) {
            if let Some(ref mut ev) = event {
                ev.indicators.push(format!("USB log cleanup: {}", desc));
                ev.techniques.push(TamperTechnique::USBLogCleanup);
            }
        }

        // If we produced an event, build and queue the alert
        if let Some(ref ev) = event {
            let alert = self.build_alert(ev);
            let mut alerts = self.alerts.write();
            if alerts.len() >= MAX_EVENTS_QUEUE { alerts.pop_front(); }
            alerts.push_back(alert);
        }

        event
    }

    /// Drain all pending alerts.
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        let mut alerts = self.alerts.write();
        alerts.drain(..).collect()
    }

    pub fn update_config(&self, config: TamperDetectorConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> TamperStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
