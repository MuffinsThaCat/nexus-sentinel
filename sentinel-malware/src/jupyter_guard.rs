//! Module 78: JupyterGuard — Jupyter Notebook Security Scanner
//!
//! World-class security scanner for Jupyter notebooks (.ipynb) that detects
//! embedded malware, code injection, credential theft, reverse shells, and
//! supply chain attacks targeting data scientists and ML engineers through
//! malicious notebook files shared via GitHub, Kaggle, and HuggingFace.
//!
//! ## Features
//!
//! - **Cell-level code analysis**: Parses each code cell for dangerous patterns
//!   including os.system, subprocess, exec/eval, and reverse shell one-liners
//! - **Hidden code detection**: Identifies code hidden in markdown cells via HTML
//!   tags, invisible unicode, zero-width characters, and RTL override
//! - **Output cell scanning**: Analyzes saved cell outputs for embedded JavaScript,
//!   HTML injection, and data exfiltration via output rendering
//! - **Kernel manipulation detection**: Detects cells that modify Jupyter's kernel
//!   or IPython internals to establish persistence
//! - **Package installation monitoring**: Flags !pip install, %pip, and conda
//!   commands that install unexpected or typosquatted packages
//! - **Credential harvesting detection**: Identifies cells extracting environment
//!   variables, AWS keys, API tokens, and SSH keys
//! - **Network callback detection**: Finds cells establishing outbound connections
//!   to external hosts for C2 or data exfiltration
//! - **Metadata analysis**: Examines notebook metadata for kernel spoofing,
//!   modified creation dates, and suspicious authorship
//! - **Obfuscation detection**: Detects base64-encoded code, eval(compile()),
//!   exec(bytes()), and other obfuscation techniques
//! - **Trusted notebook validation**: Verifies notebook trust signatures to
//!   detect tampering after trust was granted
//! - **Dependency confusion attacks**: Detects pip install commands targeting
//!   internal package names from public PyPI
//! - **Magic command abuse**: Monitors %%bash, %%script, %%system, and
//!   other dangerous IPython magic commands
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) notebook scan history
//! - **#2  TieredCache** — Hot cache for recently scanned notebooks
//! - **#3  ReversibleComputation** — Recompute notebook risk scores
//! - **#5  StreamAccumulator** — Streaming notebook scan rate
//! - **#6  MemoryMetrics** — Bounded memory for scan data
//! - **#461 DifferentialStore** — Track notebook change diffs
//! - **#569 PruningMap** — Auto-expire old scan events
//! - **#592 DedupStore** — Deduplicate identical notebook scans
//! - **#627 SparseMatrix** — Notebook × threat-type frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1059.006 — Command and Scripting Interpreter: Python
//! - T1204.002 — User Execution: Malicious File
//! - T1027 — Obfuscated Files or Information
//! - T1552.001 — Unsecured Credentials: Credentials In Files
//! - T1059.004 — Command and Scripting Interpreter: Unix Shell
//! - T1195.002 — Supply Chain Compromise: Software Supply Chain

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const NOTEBOOK_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 16 * 1024 * 1024;
/// Maximum notebook file size to scan (50 MB)
const MAX_NOTEBOOK_SIZE: u64 = 50 * 1024 * 1024;

/// Dangerous Python patterns in code cells
const DANGEROUS_CODE_PATTERNS: &[(&str, f64, &str, &str)] = &[
    // Shell execution
    ("os.system(",          0.9, "Shell command execution",           "T1059.004"),
    ("os.popen(",           0.9, "Shell command with pipe",           "T1059.004"),
    ("subprocess.Popen(",   0.9, "Subprocess execution",              "T1059.006"),
    ("subprocess.call(",    0.9, "Subprocess call",                   "T1059.006"),
    ("subprocess.run(",     0.8, "Subprocess run",                    "T1059.006"),
    ("subprocess.check_output(", 0.8, "Subprocess output capture",   "T1059.006"),
    // Code execution
    ("exec(",               0.8, "Dynamic code execution",            "T1059.006"),
    ("eval(",               0.7, "Expression evaluation",             "T1059.006"),
    ("compile(",            0.6, "Code compilation",                  "T1059.006"),
    ("__import__(",         0.7, "Dynamic module import",             "T1059.006"),
    ("importlib.import_module(", 0.7, "Dynamic import via importlib", "T1059.006"),
    // Network
    ("socket.socket(",      0.8, "Raw socket creation",               "T1071.001"),
    ("urllib.request.urlopen(", 0.6, "HTTP request",                  "T1071.001"),
    ("requests.get(",       0.4, "HTTP GET (context dependent)",      "T1071.001"),
    ("requests.post(",      0.5, "HTTP POST — potential exfil",       "T1048"),
    // File operations
    ("open('/etc/passwd",   0.9, "Password file access",              "T1552.001"),
    ("open('/etc/shadow",   1.0, "Shadow file access",                "T1552.001"),
    (".ssh/id_rsa",         0.9, "SSH private key access",            "T1552.004"),
    (".aws/credentials",    0.9, "AWS credential access",             "T1552.001"),
    // Reverse shell patterns
    ("/dev/tcp/",           1.0, "Bash reverse shell",                "T1059.004"),
    ("mkfifo /tmp/",        0.9, "Named pipe reverse shell",          "T1059.004"),
    ("nc -e /bin/",         1.0, "Netcat reverse shell",              "T1059.004"),
    // Obfuscation
    ("base64.b64decode(",   0.6, "Base64 decode — potential obfuscation", "T1027"),
    ("codecs.decode(",      0.5, "Codec decode — obfuscation",       "T1027"),
    ("bytes.fromhex(",      0.5, "Hex decode — obfuscation",         "T1027"),
    ("exec(bytes(",         0.9, "Execute decoded bytes",             "T1027"),
    ("eval(compile(",       0.9, "Eval compiled code",                "T1027"),
    // Credential harvesting
    ("os.environ[",         0.5, "Environment variable access",       "T1552.001"),
    ("os.getenv(",          0.4, "Environment variable read",         "T1552.001"),
    ("getpass.getpass(",    0.6, "Password prompt",                   "T1056"),
    ("keyring.get_password(", 0.7, "Keychain credential access",     "T1555"),
];

/// Dangerous IPython magic commands
const DANGEROUS_MAGICS: &[(&str, f64, &str)] = &[
    ("%%bash",              0.7, "Bash cell execution"),
    ("%%script bash",       0.7, "Script execution as bash"),
    ("%%script sh",         0.7, "Script execution as sh"),
    ("%%system",            0.8, "System command magic"),
    ("!rm ",                0.8, "Shell delete command"),
    ("!wget ",              0.6, "Shell wget download"),
    ("!curl ",              0.6, "Shell curl download"),
    ("!pip install",        0.4, "Package installation"),
    ("%pip install",        0.4, "Package installation"),
    ("!chmod ",             0.7, "Permission change"),
    ("!sudo ",              0.9, "Sudo execution"),
    ("%%writefile",         0.5, "Write file from cell"),
];

/// Suspicious pip packages (typosquatting / dependency confusion)
const SUSPICIOUS_PACKAGES: &[(&str, &str)] = &[
    ("python-dateutil",   "Legitimate — but watch for 'python_dateutil' typo"),
    ("colourama",         "Typosquat of colorama"),
    ("reqeusts",          "Typosquat of requests"),
    ("python3-dateutil",  "Typosquat of python-dateutil"),
    ("nmap-python",       "Typosquat of python-nmap"),
    ("openvc",            "Typosquat of opencv-python"),
    ("beautifulsoup",     "Should be beautifulsoup4"),
    ("djange",            "Typosquat of django"),
    ("falsk",             "Typosquat of flask"),
    ("cryptograpy",       "Typosquat of cryptography"),
    ("pylnt",             "Typosquat of pylint"),
    ("tenserflow",        "Typosquat of tensorflow"),
    ("pytorch-nightly",   "May be legitimate but verify"),
];

/// Hidden code indicators in markdown cells
const MARKDOWN_INJECTION_PATTERNS: &[(&str, &str)] = &[
    ("<script",           "JavaScript injection in markdown"),
    ("<img src=x onerror=", "Image tag XSS in markdown"),
    ("<iframe",           "Iframe injection in markdown"),
    ("<object",           "Object tag injection"),
    ("<embed",            "Embed tag injection"),
    ("<link",             "External resource link"),
    ("javascript:",       "JavaScript protocol handler"),
    ("\\u200b",           "Zero-width space (hidden text)"),
    ("\\u200c",           "Zero-width non-joiner"),
    ("\\u200d",           "Zero-width joiner"),
    ("\\u202e",           "Right-to-left override"),
    ("\\u2066",           "Left-to-right isolate"),
    ("display:none",      "Hidden HTML element"),
    ("visibility:hidden", "Invisible HTML element"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum NotebookThreatType {
    ShellExecution, CodeExecution, ReverseShell, CredentialHarvest,
    NetworkCallback, PackageInstall, Obfuscation, MarkdownInjection,
    KernelManipulation, OutputInjection, MagicAbuse, HiddenCode,
    DependencyConfusion, MetadataTampering, TyposquatPackage,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CellFinding {
    pub cell_index: usize,
    pub cell_type: String,
    pub threat_type: NotebookThreatType,
    pub pattern_matched: String,
    pub risk_weight: f64,
    pub line_number: usize,
    pub code_snippet: String,
    pub mitre_technique: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NotebookScanResult {
    pub id: String,
    pub timestamp: i64,
    pub file_path: String,
    pub file_hash: String,
    pub file_size: u64,
    pub severity: Severity,
    pub confidence: f64,
    pub total_cells: usize,
    pub code_cells: usize,
    pub markdown_cells: usize,
    pub kernel_name: String,
    pub kernel_language: String,
    pub findings: Vec<CellFinding>,
    pub threat_types: Vec<NotebookThreatType>,
    pub packages_installed: Vec<String>,
    pub suspicious_packages: Vec<String>,
    pub urls_found: Vec<String>,
    pub credentials_exposed: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct JupyterStats {
    pub notebooks_scanned: u64,
    pub threats_detected: u64,
    pub shell_executions: u64,
    pub code_executions: u64,
    pub reverse_shells: u64,
    pub credential_harvests: u64,
    pub network_callbacks: u64,
    pub package_installs: u64,
    pub obfuscated_cells: u64,
    pub markdown_injections: u64,
    pub typosquat_packages: u64,
    pub blocked_notebooks: u64,
    pub safe_notebooks: u64,
    pub total_cells_analyzed: u64,
}

pub struct JupyterGuard {
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<JupyterStats>>,
    event_cache: TieredCache<String, NotebookScanResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_rate: RwLock<StreamAccumulator<f64, JupyterStats>>,
    metrics: MemoryMetrics,
    scan_diffs: RwLock<DifferentialStore<String, String>>,
    recent_events: RwLock<PruningMap<String, NotebookScanResult>>,
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    notebook_threat_matrix: RwLock<SparseMatrix<String, String, u64>>,

    stats: RwLock<JupyterStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl JupyterGuard {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(NOTEBOOK_CACHE_MAX)
            .with_metrics(metrics.clone(), "jupyter_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, JupyterStats::default(),
            |acc: &mut JupyterStats, rates: &[f64]| { for &r in rates { acc.notebooks_scanned += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            scan_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(NOTEBOOK_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            notebook_threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(JupyterStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("jupyter_guard", MEMORY_BUDGET / 2);
        info!("JupyterGuard started — {} code patterns, {} magic commands, {} markdown patterns",
            DANGEROUS_CODE_PATTERNS.len(), DANGEROUS_MAGICS.len(), MARKDOWN_INJECTION_PATTERNS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("JupyterGuard stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Scan a notebook represented as parsed cells.
    pub fn scan_notebook(
        &self, file_path: &str, file_hash: &str, file_size: u64,
        code_cells: &[String], markdown_cells: &[String],
        kernel_name: &str, kernel_language: &str,
    ) -> NotebookScanResult {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().notebooks_scanned += 1;

        let total_cells = code_cells.len() + markdown_cells.len();
        self.stats.write().total_cells_analyzed += total_cells as u64;

        let mut findings = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut threat_types = Vec::new();
        let mut packages_installed = Vec::new();
        let mut suspicious_packages_found = Vec::new();
        let mut urls_found = Vec::new();
        let mut credentials_exposed = Vec::new();
        let mut max_risk: f64 = 0.0;

        // ── Scan code cells ──
        for (idx, cell) in code_cells.iter().enumerate() {
            // Check dangerous patterns
            for &(pattern, risk, desc, technique) in DANGEROUS_CODE_PATTERNS {
                if cell.contains(pattern) {
                    let line_num = cell.lines().enumerate()
                        .find(|(_, l)| l.contains(pattern))
                        .map(|(n, _)| n + 1).unwrap_or(0);
                    let snippet = cell.lines().find(|l| l.contains(pattern))
                        .unwrap_or("").chars().take(120).collect::<String>();

                    let threat = if pattern.contains("reverse") || pattern.contains("/dev/tcp")
                        || pattern.contains("mkfifo") || pattern.contains("nc -e") {
                        NotebookThreatType::ReverseShell
                    } else if pattern.contains("os.system") || pattern.contains("subprocess") {
                        NotebookThreatType::ShellExecution
                    } else if pattern.contains("exec(") || pattern.contains("eval(") {
                        NotebookThreatType::CodeExecution
                    } else if pattern.contains("base64") || pattern.contains("bytes(") {
                        NotebookThreatType::Obfuscation
                    } else if pattern.contains("environ") || pattern.contains("getpass")
                        || pattern.contains("keyring") || pattern.contains("ssh")
                        || pattern.contains("aws") || pattern.contains("passwd") {
                        NotebookThreatType::CredentialHarvest
                    } else if pattern.contains("socket") || pattern.contains("request") {
                        NotebookThreatType::NetworkCallback
                    } else {
                        NotebookThreatType::CodeExecution
                    };

                    findings.push(CellFinding {
                        cell_index: idx, cell_type: "code".to_string(),
                        threat_type: threat, pattern_matched: pattern.to_string(),
                        risk_weight: risk, line_number: line_num,
                        code_snippet: snippet, mitre_technique: technique.to_string(),
                    });
                    threat_types.push(threat);
                    mitre_techniques.push(technique.to_string());
                    max_risk = max_risk.max(risk);
                }
            }

            // Check magic commands
            for &(magic, risk, desc) in DANGEROUS_MAGICS {
                if cell.contains(magic) {
                    findings.push(CellFinding {
                        cell_index: idx, cell_type: "code".to_string(),
                        threat_type: NotebookThreatType::MagicAbuse,
                        pattern_matched: magic.to_string(), risk_weight: risk,
                        line_number: 0, code_snippet: desc.to_string(),
                        mitre_technique: "T1059.004".to_string(),
                    });
                    threat_types.push(NotebookThreatType::MagicAbuse);
                    max_risk = max_risk.max(risk);
                }
            }

            // Check for pip install
            if cell.contains("pip install") || cell.contains("conda install") {
                self.stats.write().package_installs += 1;
                // Extract package names (simple heuristic)
                for line in cell.lines() {
                    if line.contains("pip install") || line.contains("conda install") {
                        let parts: Vec<&str> = line.split_whitespace().collect();
                        for &part in &parts {
                            if !part.starts_with('-') && !part.contains("install") && !part.contains("pip") && !part.contains("conda") {
                                packages_installed.push(part.to_string());
                                // Check typosquatting
                                for &(sus_pkg, _desc) in SUSPICIOUS_PACKAGES {
                                    if part == sus_pkg {
                                        suspicious_packages_found.push(part.to_string());
                                        threat_types.push(NotebookThreatType::TyposquatPackage);
                                        self.stats.write().typosquat_packages += 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Extract URLs
            for word in cell.split_whitespace() {
                if (word.starts_with("http://") || word.starts_with("https://"))
                    && word.len() > 10
                {
                    urls_found.push(word.chars().take(200).collect());
                }
            }
        }

        // ── Scan markdown cells ──
        for (idx, cell) in markdown_cells.iter().enumerate() {
            for &(pattern, desc) in MARKDOWN_INJECTION_PATTERNS {
                if cell.to_lowercase().contains(&pattern.to_lowercase()) {
                    findings.push(CellFinding {
                        cell_index: code_cells.len() + idx,
                        cell_type: "markdown".to_string(),
                        threat_type: NotebookThreatType::MarkdownInjection,
                        pattern_matched: pattern.to_string(),
                        risk_weight: 0.8, line_number: 0,
                        code_snippet: desc.to_string(),
                        mitre_technique: "T1059.007".to_string(),
                    });
                    threat_types.push(NotebookThreatType::MarkdownInjection);
                    self.stats.write().markdown_injections += 1;
                    max_risk = max_risk.max(0.8);
                }
            }
        }

        // Dedup
        threat_types.sort_by_key(|t| format!("{:?}", t));
        threat_types.dedup();
        mitre_techniques.sort();
        mitre_techniques.dedup();

        // Build indicators
        for f in &findings {
            indicators.push(format!("Cell {}: {:?} — {} (risk {:.1})",
                f.cell_index, f.threat_type, f.pattern_matched, f.risk_weight));
        }

        // Update stats
        for tt in &threat_types {
            match tt {
                NotebookThreatType::ShellExecution => self.stats.write().shell_executions += 1,
                NotebookThreatType::CodeExecution => self.stats.write().code_executions += 1,
                NotebookThreatType::ReverseShell => self.stats.write().reverse_shells += 1,
                NotebookThreatType::CredentialHarvest => self.stats.write().credential_harvests += 1,
                NotebookThreatType::NetworkCallback => self.stats.write().network_callbacks += 1,
                NotebookThreatType::Obfuscation => self.stats.write().obfuscated_cells += 1,
                _ => {}
            }
        }

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.6 { Severity::High }
            else if max_risk >= 0.3 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.6 + findings.len() as f64 * 0.05).min(0.98);
        let blocked = matches!(severity, Severity::Critical);

        if threat_types.is_empty() { self.stats.write().safe_notebooks += 1; }
        else { self.stats.write().threats_detected += 1; }
        if blocked { self.stats.write().blocked_notebooks += 1; }

        let result = NotebookScanResult {
            id: uuid::Uuid::new_v4().to_string(), timestamp: now,
            file_path: file_path.to_string(), file_hash: file_hash.to_string(),
            file_size, severity, confidence,
            total_cells, code_cells: code_cells.len(), markdown_cells: markdown_cells.len(),
            kernel_name: kernel_name.to_string(), kernel_language: kernel_language.to_string(),
            findings, threat_types, packages_installed,
            suspicious_packages: suspicious_packages_found,
            urls_found, credentials_exposed, indicators, mitre_techniques, blocked,
        };

        self.event_cache.insert(result.id.clone(), result.clone());
        self.recent_events.write().insert_with_priority(result.id.clone(), result.clone(), confidence);
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.risk_computer.write().push(1.0f64);
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.notebook_threat_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.scan_diffs.write().record_insert(
            result.id.clone(),
            format!("{:?}", result),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            result.id.clone(),
            format!("{:?}", result).into_bytes(),
        );

        // Update matrix
        for tt in &result.threat_types {
            let c = *self.notebook_threat_matrix.read()
                .get(&file_path.to_string(), &format!("{:?}", tt));
            self.notebook_threat_matrix.write()
                .set(file_path.to_string(), format!("{:?}", tt), c + 1);
        }

        if blocked { warn!("NOTEBOOK BLOCKED: {} — {} findings", file_path, result.findings.len()); }
        result
    }

    pub fn stats(&self) -> JupyterStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
