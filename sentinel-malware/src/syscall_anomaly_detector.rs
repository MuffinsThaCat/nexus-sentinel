//! Module 145: SyscallAnomalyDetector — System Call Behavioral Anomaly Detection
//!
//! Monitors and analyzes system call patterns to detect exploitation, privilege
//! escalation, sandbox escape, and evasion techniques at the syscall boundary.
//! Uses statistical profiling, sequence analysis, and known-bad pattern matching
//! to identify anomalous syscall behavior on macOS XNU.
//!
//! ## Detection Capabilities
//!
//! ### Syscall Sequence Analysis
//! - **Exploit chain detection**: Sequences like mmap→mprotect→write→jmp that
//!   indicate shellcode injection and execution
//! - **Privilege escalation sequences**: setuid/seteuid/setgid after fork,
//!   credential manipulation via syscall chains
//! - **Sandbox escape patterns**: Syscall sequences that probe or bypass
//!   sandbox restrictions (profile violations, exception abuse)
//! - **Anti-analysis sequences**: ptrace(PT_DENY_ATTACH), sysctl probes for
//!   debuggers, timing-based evasion
//!
//! ### Rate & Volume Anomalies
//! - **Syscall flooding**: Abnormally high syscall rates indicating DoS,
//!   brute force, or race condition exploitation
//! - **Unusual syscall distribution**: Processes using rare or deprecated
//!   syscalls that legitimate software never touches
//! - **Burst patterns**: Sudden spikes in specific syscall categories
//!
//! ### Specific Syscall Abuse
//! - **fork bomb detection**: Exponential process creation
//! - **File descriptor exhaustion**: Massive open() calls to exhaust fd table
//! - **Signal abuse**: Unusual signal delivery patterns (SIGKILL storms, etc.)
//! - **Process tracing abuse**: ptrace for process injection or anti-debug
//! - **Namespace manipulation**: chroot escape, pivot_root abuse
//! - **Time manipulation**: settimeofday/clock_settime for log evasion
//! - **Resource limit manipulation**: setrlimit to remove restrictions
//!
//! ### macOS-Specific Syscall Monitoring
//! - **Mach trap monitoring**: mach_msg, task_for_pid, thread_create_running,
//!   host_get_special_port abuse
//! - **BSD syscall anomalies**: proc_info, csops, memorystatus_control,
//!   persona manipulation
//! - **SIP-protected syscalls**: Attempts to call restricted operations that
//!   should be blocked by System Integrity Protection
//! - **Entitlement-gated syscalls**: Calls requiring specific entitlements
//!   from processes that lack them
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1106 — Native API
//! - T1068 — Exploitation for Privilege Escalation
//! - T1055 — Process Injection
//! - T1497 — Virtualization/Sandbox Evasion
//! - T1562.001 — Disable or Modify Tools
//! - T1499.001 — OS Exhaustion Flood
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs integrated with elevated parameters.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const FORK_BOMB_THRESHOLD: u32 = 50;
const FORK_BOMB_WINDOW_SECS: u64 = 5;
const SYSCALL_FLOOD_THRESHOLD: u64 = 100_000;
const SYSCALL_FLOOD_WINDOW_SECS: u64 = 1;
const FD_EXHAUSTION_THRESHOLD: u32 = 1000;

// ── Exploit Syscall Sequences ────────────────────────────────────────────────

const EXPLOIT_SEQUENCES: &[(&[&str], &str, &str, f64)] = &[
    (&["mmap", "mprotect", "write", "jmp"], "Shellcode injection: mmap→mprotect(RWX)→write→execute", "T1055", 0.95),
    (&["mmap", "memcpy", "mprotect"], "Code injection: mmap→memcpy→mprotect(RX)", "T1055", 0.9),
    (&["fork", "ptrace", "execve"], "Process injection via fork+ptrace+execve", "T1055", 0.8),
    (&["fork", "setsid", "dup2", "execve"], "Daemon creation (potential backdoor)", "T1543", 0.5),
    (&["socket", "connect", "dup2", "execve"], "Reverse shell: socket→connect→dup2→execve", "T1059", 0.95),
    (&["socket", "bind", "listen", "accept", "execve"], "Bind shell: socket→bind→listen→accept→exec", "T1059", 0.95),
    (&["open", "mmap", "close", "munmap"], "Memory-mapped file processing (may be benign, flag if rapid)", "T1106", 0.3),
    (&["getuid", "setuid", "execve"], "Privilege check then setuid+exec", "T1068", 0.6),
    (&["fork", "setuid", "setgid", "execve"], "Fork+setuid privesc chain", "T1068", 0.7),
    (&["ptrace", "wait4", "ptrace", "detach"], "Process debugging/injection via ptrace", "T1055", 0.6),
    (&["unlink", "rename", "link"], "Atomic file replacement (rootkit technique)", "T1014", 0.5),
    (&["chdir", "chroot", "chdir"], "Chroot escape attempt (chdir before/after chroot)", "T1068", 0.85),
    (&["settimeofday"], "System time manipulation (log evasion)", "T1070.006", 0.7),
    (&["clock_settime"], "Clock manipulation", "T1070.006", 0.7),
];

// ── Dangerous Individual Syscalls ────────────────────────────────────────────

const DANGEROUS_SYSCALLS: &[(&str, &str, &str, f64)] = &[
    ("ptrace_deny_attach", "PT_DENY_ATTACH anti-debugging", "T1497", 0.6),
    ("ptrace_attach", "ptrace(ATTACH) — process injection/debugging", "T1055", 0.5),
    ("task_for_pid", "task_for_pid — cross-process manipulation", "T1055", 0.7),
    ("processor_set_tasks", "processor_set_tasks — enumerate all tasks", "T1057", 0.6),
    ("host_get_special_port", "host_get_special_port — privileged port access", "T1068", 0.5),
    ("thread_create_running", "thread_create_running in remote task", "T1055", 0.8),
    ("mach_vm_write", "mach_vm_write to remote process", "T1055", 0.8),
    ("mach_vm_remap", "mach_vm_remap — memory remapping", "T1055", 0.7),
    ("memorystatus_control", "memorystatus_control — jetsam manipulation", "T1562", 0.6),
    ("csops", "csops — code signing status query/manipulation", "T1553", 0.5),
    ("persona_modify", "persona syscall — identity manipulation", "T1134", 0.7),
    ("proc_info", "proc_info — detailed process information query", "T1057", 0.3),
    ("kas_info", "kas_info — kernel address space info (KASLR leak)", "T1068", 0.8),
    ("shared_region_check_np", "shared_region_check — ASLR info leak", "T1068", 0.6),
    ("__mac_syscall", "__mac_syscall — MAC framework syscall", "T1556", 0.5),
    ("nfsclnt", "NFS client syscall (unusual for non-NFS system)", "T1106", 0.4),
    ("reboot", "Reboot syscall from non-root process", "T1529", 0.7),
    ("mount", "Mount syscall from unexpected process", "T1006", 0.5),
    ("unmount", "Unmount syscall (evidence destruction risk)", "T1070", 0.5),
    ("kqueue_workloop_ctl", "Workloop control (kernel exploitation vector)", "T1068", 0.4),
    ("io_uring_setup", "io_uring setup (Linux compat, unusual on macOS)", "T1106", 0.6),
];

// ── Anti-Analysis Syscall Patterns ───────────────────────────────────────────

const ANTI_ANALYSIS_PATTERNS: &[(&str, &str, f64)] = &[
    ("sysctl_kern_proc_all", "sysctl: enumerating all processes (recon)", 0.4),
    ("sysctl_debug", "sysctl: debug MIB query (debugger detection)", 0.6),
    ("sysctl_hw_model", "sysctl: hardware model check (VM detection)", 0.4),
    ("sysctl_hw_machine", "sysctl: machine architecture check", 0.3),
    ("sysctl_kern_boottime", "sysctl: boot time query (sandbox detection)", 0.4),
    ("sysctl_kern_hostname", "sysctl: hostname query (environment fingerprinting)", 0.3),
    ("isatty_check", "isatty check (terminal detection for evasion)", 0.3),
    ("getenv_DYLD", "getenv(DYLD_*) check (injection detection)", 0.5),
    ("getenv_HOME", "getenv(HOME) for user identification", 0.2),
    ("access_debugserver", "access() check for debugserver", 0.7),
    ("stat_debugger_ports", "stat() on debug-related paths", 0.6),
    ("nanosleep_timing", "Precise nanosleep (timing-based evasion)", 0.4),
    ("mach_absolute_time_loop", "Repeated mach_absolute_time (timing check)", 0.5),
];

// ── Sandbox Escape Syscall Patterns ──────────────────────────────────────────

const SANDBOX_ESCAPE_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("sandbox_check_fail", "sandbox_check returned violation — probing boundaries", "T1497", 0.5),
    ("open_outside_container", "open() attempted path outside sandbox container", "T1497", 0.7),
    ("symlink_escape", "Symlink creation pointing outside sandbox", "T1497", 0.8),
    ("exec_unsandboxed", "execve of binary not in sandbox profile", "T1497", 0.7),
    ("xpc_connection_privileged", "XPC connection to privileged service from sandbox", "T1068", 0.5),
    ("mach_lookup_privileged", "Mach bootstrap lookup for privileged service", "T1068", 0.5),
    ("iokit_connect_from_sandbox", "IOKit user client from sandboxed process", "T1068", 0.6),
    ("shared_memory_escape", "Shared memory access outside sandbox", "T1497", 0.7),
    ("file_provenance_bypass", "File provenance/quarantine bypass from sandbox", "T1553", 0.7),
    ("hardlink_escape", "Hard link creation to escape sandbox file restrictions", "T1497", 0.8),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SyscallThreatType {
    // Exploit sequences
    ShellcodeInjection,
    ReverseShell,
    BindShell,
    ProcessInjection,
    PrivilegeEscalation,
    ChromeEscape,
    // Individual dangerous syscalls
    AntiDebugging,
    TaskPortAbuse,
    RemoteThreadCreate,
    RemoteMemoryWrite,
    PersonaManipulation,
    KASLRLeak,
    MACFrameworkAbuse,
    // Rate/volume
    ForkBomb,
    SyscallFlood,
    FDExhaustion,
    SignalAbuse,
    // Sandbox escape
    SandboxProbe,
    SandboxEscape,
    SymlinkEscape,
    SharedMemoryEscape,
    XPCEscape,
    IOKitEscape,
    // Anti-analysis
    DebuggerDetection,
    VMDetection,
    EnvironmentFingerprint,
    TimingEvasion,
    // System manipulation
    TimeManipulation,
    RebootAttempt,
    MountManipulation,
    AtomicFileReplace,
    ResourceLimitAbuse,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SyscallFinding {
    pub threat_type: SyscallThreatType,
    pub confidence: f64,
    pub description: String,
    pub syscall_name: Option<String>,
    pub syscall_sequence: Option<Vec<String>>,
    pub syscall_count: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub target_pid: Option<u32>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SyscallEvent {
    pub event_type: String,
    pub syscall_name: String,
    pub syscall_number: Option<u32>,
    pub syscall_args: Vec<u64>,
    pub syscall_return: Option<i64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub parent_pid: Option<u32>,
    pub target_pid: Option<u32>,
    pub recent_syscalls: Vec<String>,   // Last N syscalls for sequence analysis
    pub syscall_rate: Option<u64>,      // Syscalls per second
    pub fork_count_recent: Option<u32>, // Recent fork count
    pub open_fd_count: Option<u32>,
    pub is_sandboxed: bool,
    pub sandbox_violation: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SyscallAnalysisResult {
    pub is_anomalous: bool,
    pub events_analyzed: u32,
    pub findings: Vec<SyscallFinding>,
    pub anomaly_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SyscallScanStats {
    pub total_events: u64,
    pub anomaly_detections: u64,
    pub exploit_sequence_detections: u64,
    pub sandbox_escape_detections: u64,
    pub anti_analysis_detections: u64,
    pub flood_detections: u64,
    pub fork_bomb_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SyscallSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

pub struct SyscallAnomalyDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SyscallScanStats>>,
    result_cache: TieredCache<String, SyscallAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    syscall_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SyscallScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, SyscallAnalysisResult>>,
    sig_db: PagedMemory<SyscallSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<SyscallScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    process_syscall_history: RwLock<HashMap<u32, Vec<String>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SyscallAnomalyDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            syscall_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SyscallScanStats::default(),
                |acc: &mut SyscallScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(SyscallScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(512)),
            total_events: AtomicU64::new(0),
            process_syscall_history: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &SyscallEvent) -> Option<SyscallAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("syscall:{}:{}:{}", pid, event.syscall_name, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        // Update process history
        {
            let mut hist = self.process_syscall_history.write();
            let entry = hist.entry(pid).or_insert_with(Vec::new);
            entry.push(event.syscall_name.clone());
            if entry.len() > 200 { entry.drain(..100); }
        }

        // Build recent syscall list for sequence matching
        let recent: Vec<String> = if !event.recent_syscalls.is_empty() {
            event.recent_syscalls.clone()
        } else {
            self.process_syscall_history.read()
                .get(&pid).cloned().unwrap_or_default()
        };

        // ── 1. Exploit sequence detection ───────────────────────────────
        for &(seq, desc, mitre, conf) in EXPLOIT_SEQUENCES {
            if Self::sequence_match(&recent, seq) {
                let tt = if desc.contains("Shellcode") { SyscallThreatType::ShellcodeInjection }
                    else if desc.contains("Reverse shell") { SyscallThreatType::ReverseShell }
                    else if desc.contains("Bind shell") { SyscallThreatType::BindShell }
                    else if desc.contains("injection") { SyscallThreatType::ProcessInjection }
                    else if desc.contains("privesc") || desc.contains("setuid") { SyscallThreatType::PrivilegeEscalation }
                    else if desc.contains("Chroot") { SyscallThreatType::ChromeEscape }
                    else if desc.contains("time") { SyscallThreatType::TimeManipulation }
                    else if desc.contains("rootkit") || desc.contains("file replacement") { SyscallThreatType::AtomicFileReplace }
                    else { SyscallThreatType::ProcessInjection };
                findings.push(SyscallFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    syscall_name: Some(event.syscall_name.clone()),
                    syscall_sequence: Some(seq.iter().map(|s| s.to_string()).collect()),
                    syscall_count: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_pid: event.target_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("ExploitSequence".to_string());
            }
        }

        // ── 2. Dangerous individual syscall matching ────────────────────
        let sc_lower = event.syscall_name.to_lowercase();
        for &(pattern, desc, mitre, conf) in DANGEROUS_SYSCALLS {
            if sc_lower.contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("ptrace_deny") { SyscallThreatType::AntiDebugging }
                    else if pattern.contains("task_for_pid") { SyscallThreatType::TaskPortAbuse }
                    else if pattern.contains("thread_create") { SyscallThreatType::RemoteThreadCreate }
                    else if pattern.contains("mach_vm_write") { SyscallThreatType::RemoteMemoryWrite }
                    else if pattern.contains("persona") { SyscallThreatType::PersonaManipulation }
                    else if pattern.contains("kas_info") || pattern.contains("shared_region") { SyscallThreatType::KASLRLeak }
                    else if pattern.contains("mac_syscall") { SyscallThreatType::MACFrameworkAbuse }
                    else if pattern.contains("reboot") { SyscallThreatType::RebootAttempt }
                    else if pattern.contains("mount") || pattern.contains("unmount") { SyscallThreatType::MountManipulation }
                    else { SyscallThreatType::ProcessInjection };
                findings.push(SyscallFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    syscall_name: Some(event.syscall_name.clone()),
                    syscall_sequence: None, syscall_count: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_pid: event.target_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("DangerousSyscall".to_string());
            }
        }

        // ── 3. Anti-analysis pattern detection ──────────────────────────
        for &(pattern, desc, conf) in ANTI_ANALYSIS_PATTERNS {
            if sc_lower.contains(&pattern.to_lowercase()) || 
               recent.iter().any(|s| s.to_lowercase().contains(&pattern.to_lowercase())) {
                let tt = if pattern.contains("debug") || pattern.contains("debugger") { SyscallThreatType::DebuggerDetection }
                    else if pattern.contains("hw_model") || pattern.contains("hw_machine") { SyscallThreatType::VMDetection }
                    else if pattern.contains("timing") || pattern.contains("nanosleep") || pattern.contains("mach_absolute") { SyscallThreatType::TimingEvasion }
                    else { SyscallThreatType::EnvironmentFingerprint };
                findings.push(SyscallFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    syscall_name: Some(event.syscall_name.clone()),
                    syscall_sequence: None, syscall_count: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_pid: None,
                    mitre_id: "T1497".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1497".into());
                categories.insert("AntiAnalysis".to_string());
            }
        }

        // ── 4. Sandbox escape detection ─────────────────────────────────
        if event.is_sandboxed {
            if let Some(ref violation) = event.sandbox_violation {
                let viol_lower = violation.to_lowercase();
                for &(pattern, desc, mitre, conf) in SANDBOX_ESCAPE_PATTERNS {
                    if viol_lower.contains(&pattern.to_lowercase()) {
                        let tt = if pattern.contains("symlink") { SyscallThreatType::SymlinkEscape }
                            else if pattern.contains("shared_memory") { SyscallThreatType::SharedMemoryEscape }
                            else if pattern.contains("xpc") || pattern.contains("mach_lookup") { SyscallThreatType::XPCEscape }
                            else if pattern.contains("iokit") { SyscallThreatType::IOKitEscape }
                            else if pattern.contains("probe") || pattern.contains("check_fail") { SyscallThreatType::SandboxProbe }
                            else { SyscallThreatType::SandboxEscape };
                        findings.push(SyscallFinding {
                            threat_type: tt, confidence: conf, description: desc.to_string(),
                            syscall_name: Some(event.syscall_name.clone()),
                            syscall_sequence: None, syscall_count: None,
                            process_name: event.process_name.clone(), process_pid: event.process_pid,
                            target_pid: None,
                            mitre_id: mitre.into(), timestamp: event.timestamp,
                        });
                        mitre_ids.insert(mitre.into());
                        categories.insert("SandboxEscape".to_string());
                    }
                }
            }
        }

        // ── 5. Rate anomaly detection ───────────────────────────────────
        if let Some(rate) = event.syscall_rate {
            if rate > SYSCALL_FLOOD_THRESHOLD {
                findings.push(SyscallFinding {
                    threat_type: SyscallThreatType::SyscallFlood,
                    confidence: (0.6 + (rate as f64 / 1_000_000.0).min(0.3)),
                    description: format!("Syscall flood: {} calls/sec from pid {}", rate, pid),
                    syscall_name: Some(event.syscall_name.clone()),
                    syscall_sequence: None, syscall_count: Some(rate),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_pid: None,
                    mitre_id: "T1499.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1499.001".into());
                categories.insert("RateAnomaly".to_string());
            }
        }

        // Fork bomb detection
        if let Some(fork_count) = event.fork_count_recent {
            if fork_count > FORK_BOMB_THRESHOLD {
                findings.push(SyscallFinding {
                    threat_type: SyscallThreatType::ForkBomb,
                    confidence: (0.8 + (fork_count as f64 / 500.0).min(0.15)),
                    description: format!("Fork bomb: {} forks in {}s from pid {}",
                        fork_count, FORK_BOMB_WINDOW_SECS, pid),
                    syscall_name: Some("fork".into()),
                    syscall_sequence: None, syscall_count: Some(fork_count as u64),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_pid: None,
                    mitre_id: "T1499.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1499.001".into());
                categories.insert("ForkBomb".to_string());
            }
        }

        // FD exhaustion
        if let Some(fd_count) = event.open_fd_count {
            if fd_count > FD_EXHAUSTION_THRESHOLD {
                findings.push(SyscallFinding {
                    threat_type: SyscallThreatType::FDExhaustion,
                    confidence: 0.6,
                    description: format!("{} open file descriptors (potential exhaustion attack)", fd_count),
                    syscall_name: Some("open".into()),
                    syscall_sequence: None, syscall_count: Some(fd_count as u64),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_pid: None,
                    mitre_id: "T1499.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1499.001".into());
                categories.insert("ResourceExhaustion".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("syscall={},pid={},findings={}", event.syscall_name, pid, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_anomalous = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = SyscallAnalysisResult {
            is_anomalous, events_analyzed: 1, findings,
            anomaly_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_anomalous {
                s.anomaly_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        SyscallThreatType::ShellcodeInjection | SyscallThreatType::ReverseShell |
                        SyscallThreatType::BindShell | SyscallThreatType::ProcessInjection |
                        SyscallThreatType::PrivilegeEscalation => s.exploit_sequence_detections += 1,
                        SyscallThreatType::SandboxProbe | SyscallThreatType::SandboxEscape |
                        SyscallThreatType::SymlinkEscape | SyscallThreatType::XPCEscape |
                        SyscallThreatType::IOKitEscape | SyscallThreatType::SharedMemoryEscape =>
                            s.sandbox_escape_detections += 1,
                        SyscallThreatType::AntiDebugging | SyscallThreatType::DebuggerDetection |
                        SyscallThreatType::VMDetection | SyscallThreatType::TimingEvasion |
                        SyscallThreatType::EnvironmentFingerprint =>
                            s.anti_analysis_detections += 1,
                        SyscallThreatType::SyscallFlood | SyscallThreatType::FDExhaustion =>
                            s.flood_detections += 1,
                        SyscallThreatType::ForkBomb => s.fork_bomb_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_anomalous {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "syscall_anomaly_detector".into(),
                title: format!("Syscall anomaly: {} (pid {})",
                    result.anomaly_categories.join(", "), pid),
                details: format!("Risk {:.1}%, {} findings, syscall: {}, process: {:?}",
                    risk_score * 100.0, result.findings.len(),
                    event.syscall_name, event.process_name),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the suspicious process: kill -9 <pid>".into(),
                    "Check process tree: pstree -p <pid>".into(),
                    "Inspect open files: lsof -p <pid>".into(),
                    "Check network connections: lsof -i -P -n -p <pid>".into(),
                    "Review system logs: log show --predicate 'process == \"<name>\"'".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn sequence_match(recent: &[String], pattern: &[&str]) -> bool {
        if pattern.is_empty() || recent.len() < pattern.len() { return false; }
        let mut pi = 0;
        for sc in recent {
            if sc.to_lowercase().contains(&pattern[pi].to_lowercase()) {
                pi += 1;
                if pi == pattern.len() { return true; }
            }
        }
        false
    }

    fn calculate_risk_score(&self, findings: &[SyscallFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                SyscallThreatType::ShellcodeInjection => 1.8,
                SyscallThreatType::ReverseShell | SyscallThreatType::BindShell => 1.7,
                SyscallThreatType::PrivilegeEscalation => 1.6,
                SyscallThreatType::RemoteMemoryWrite | SyscallThreatType::RemoteThreadCreate => 1.6,
                SyscallThreatType::SandboxEscape | SyscallThreatType::SymlinkEscape => 1.5,
                SyscallThreatType::ProcessInjection => 1.4,
                SyscallThreatType::KASLRLeak => 1.4,
                SyscallThreatType::TaskPortAbuse => 1.3,
                SyscallThreatType::ForkBomb => 1.3,
                SyscallThreatType::SyscallFlood => 1.1,
                SyscallThreatType::AntiDebugging => 0.8,
                SyscallThreatType::EnvironmentFingerprint => 0.7,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> SyscallScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
