//! Module 118: SSHPivotDetector — SSH Tunneling & Pivot Detection Engine
//!
//! Detects SSH-based lateral movement, tunneling, port forwarding, and pivoting.
//! On macOS, SSH is natively available and commonly abused for covert channels
//! and lateral movement in enterprise environments.
//!
//! ## Detection Capabilities
//!
//! - **SSH tunneling**: Local (-L), remote (-R), and dynamic (-D) port forwarding
//! - **SSH pivot chains**: Multi-hop SSH via ProxyJump/ProxyCommand
//! - **Reverse tunnels**: Outbound SSH creating inbound access paths
//! - **SOCKS proxy**: Dynamic SOCKS5 proxy via SSH (-D flag)
//! - **SSH key abuse**: Unauthorized key deployment, agent forwarding hijack
//! - **Brute force**: Rapid failed SSH authentication attempts
//! - **Unusual SSH patterns**: Non-standard ports, unusual ciphers, unexpected
//!   connections from non-admin users, SSH from unusual processes
//! - **SSH config tampering**: Modifications to ~/.ssh/config, authorized_keys,
//!   known_hosts for persistence or pivoting
//! - **Multiplexed sessions**: ControlMaster/ControlPath abuse
//! - **SSH over non-standard transport**: SSH over HTTP/DNS tunnels
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const BRUTE_FORCE_THRESHOLD: u32 = 10;
const BRUTE_FORCE_WINDOW_SECS: u64 = 120;

// ── SSH Threat Patterns ──────────────────────────────────────────────────────

const SSH_TUNNEL_FLAGS: &[(&str, &str, f64)] = &[
    ("-L ", "Local port forwarding", 0.6),
    ("-R ", "Remote port forwarding (reverse tunnel)", 0.8),
    ("-D ", "Dynamic SOCKS proxy", 0.75),
    ("-N", "No remote command (tunnel-only session)", 0.5),
    ("-f", "Background SSH (daemon mode)", 0.6),
    ("-g", "Gateway ports (allow remote bind)", 0.7),
    ("-w", "TUN/TAP tunneling (VPN mode)", 0.85),
    ("ProxyJump", "SSH proxy jump (multi-hop pivot)", 0.7),
    ("ProxyCommand", "SSH proxy command (custom tunnel)", 0.75),
    ("ControlMaster", "SSH multiplexing master", 0.5),
    ("ControlPath", "SSH multiplexing socket", 0.5),
    ("ControlPersist", "Persistent SSH multiplexing", 0.55),
    ("StrictHostKeyChecking=no", "Disabled host key checking", 0.7),
    ("UserKnownHostsFile=/dev/null", "Discarded known hosts", 0.75),
    ("ServerAliveInterval", "Keepalive (persistent tunnel)", 0.3),
    ("ExitOnForwardFailure", "Forward failure handling", 0.4),
];

const SSH_CONFIG_TAMPERING: &[(&str, &str, f64)] = &[
    ("authorized_keys", "SSH authorized keys modification", 0.7),
    ("id_rsa", "SSH private key access/creation", 0.6),
    ("id_ed25519", "SSH ED25519 key access/creation", 0.6),
    ("known_hosts", "Known hosts modification", 0.4),
    (".ssh/config", "SSH client config modification", 0.5),
    ("sshd_config", "SSH daemon config modification", 0.8),
    ("PermitRootLogin", "Root login configuration change", 0.85),
    ("PasswordAuthentication", "Password auth configuration change", 0.6),
    ("AllowAgentForwarding", "Agent forwarding configuration", 0.5),
    ("GatewayPorts", "Gateway ports configuration", 0.7),
    ("PermitTunnel", "Tunnel permission configuration", 0.75),
];

const SSH_SUSPICIOUS_COMMANDS: &[(&str, &str, f64)] = &[
    ("ssh -o StrictHostKeyChecking=no", "SSH with disabled host verification", 0.7),
    ("sshpass", "Automated SSH password tool", 0.85),
    ("expect.*ssh", "Expect-based SSH automation", 0.7),
    ("ssh-copy-id", "SSH key deployment", 0.5),
    ("ssh-keygen", "SSH key generation", 0.4),
    ("ssh-agent", "SSH agent start", 0.3),
    ("ssh-add", "SSH key addition to agent", 0.35),
    ("autossh", "Automatic SSH reconnection (persistent tunnel)", 0.8),
    ("sshuttle", "SSH-based VPN tool", 0.85),
    ("chisel", "HTTP tunnel tool via SSH", 0.9),
    ("bore", "Bore tunnel (Rust-based SSH alternative)", 0.8),
    ("ngrok", "Ngrok tunnel (reverse proxy)", 0.7),
];

const SSH_LATERAL_TOOLS: &[(&str, &str, &str, f64)] = &[
    ("paramiko", "Python SSH library (used by many attack tools)", "T1021.004", 0.6),
    ("fabric", "Python SSH automation framework", "T1021.004", 0.5),
    ("ansible", "Ansible SSH-based automation", "T1021.004", 0.3),
    ("pssh", "Parallel SSH execution", "T1021.004", 0.65),
    ("clusterssh", "Cluster SSH (multi-host)", "T1021.004", 0.5),
    ("mosh", "Mobile shell (SSH alternative)", "T1021.004", 0.3),
    ("plink", "PuTTY Link (SSH client)", "T1021.004", 0.6),
    ("dbclient", "Dropbear SSH client", "T1021.004", 0.5),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SSHThreatType {
    LocalPortForward,
    RemotePortForward,
    DynamicSOCKSProxy,
    TUNTAPTunnel,
    ProxyJumpPivot,
    ReverseTunnel,
    BruteForce,
    KeyDeployment,
    AgentForwardingHijack,
    ConfigTampering,
    MultiplexedSession,
    PersistentTunnel,
    NonStandardPort,
    UnusualCipher,
    UnusualSourceProcess,
    PivotChain,
    AutomatedSSH,
    SSHOverHTTP,
    RootLoginAttempt,
    DisabledHostVerification,
    LateralToolUsage,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SSHThreatFinding {
    pub threat_type: SSHThreatType,
    pub source_ip: String,
    pub dest_ip: String,
    pub dest_port: u16,
    pub confidence: f64,
    pub description: String,
    pub username: Option<String>,
    pub command_line: Option<String>,
    pub forwarded_port: Option<u16>,
    pub tunnel_type: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SSHConnection {
    pub session_id: String,
    pub source_ip: String,
    pub dest_ip: String,
    pub dest_port: u16,
    pub username: String,
    pub auth_method: String,
    pub cipher: String,
    pub kex_algorithm: String,
    pub command_line: Option<String>,
    pub process_name: String,
    pub process_pid: u32,
    pub parent_pid: Option<u32>,
    pub start_time: u64,
    pub is_outbound: bool,
    pub has_pty: bool,
    pub forwarded_ports: Vec<(String, u16)>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SSHAnalysisResult {
    pub is_malicious: bool,
    pub connections_analyzed: u32,
    pub findings: Vec<SSHThreatFinding>,
    pub pivot_chains: Vec<Vec<String>>,
    pub active_tunnels: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SSHScanStats {
    pub total_connections: u64,
    pub tunnel_detections: u64,
    pub pivot_detections: u64,
    pub brute_force_detections: u64,
    pub config_tampering_detections: u64,
    pub tool_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SSHPivotConfig {
    pub enabled: bool,
    pub detect_tunnels: bool,
    pub detect_pivots: bool,
    pub detect_brute_force: bool,
    pub detect_config_tampering: bool,
    pub brute_force_threshold: u32,
    pub brute_force_window_secs: u64,
    pub standard_ssh_ports: Vec<u16>,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for SSHPivotConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            detect_tunnels: true,
            detect_pivots: true,
            detect_brute_force: true,
            detect_config_tampering: true,
            brute_force_threshold: BRUTE_FORCE_THRESHOLD,
            brute_force_window_secs: BRUTE_FORCE_WINDOW_SECS,
            standard_ssh_ports: vec![22, 2222],
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SSHToolSigEntry {
    pub name: String,
    pub pattern: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct SSHPivotDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SSHScanStats>>,
    result_cache: TieredCache<String, SSHAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    conn_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SSHScanStats>>,
    metrics: MemoryMetrics,
    conn_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, SSHAnalysisResult>>,
    tool_sig_db: PagedMemory<SSHToolSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<SSHPivotConfig>,
    stats: RwLock<SSHScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_analyses: AtomicU64,
    ssh_graph: RwLock<HashMap<String, HashSet<String>>>,
    auth_failures: RwLock<HashMap<String, Vec<u64>>>,
    active_tunnels: RwLock<HashMap<String, Vec<(String, u16)>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SSHPivotDetector {
    pub fn new() -> Self {
        let cfg = SSHPivotConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            conn_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SSHScanStats::default(),
                |acc: &mut SSHScanStats, vals: &[f64]| { acc.total_connections += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            conn_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            tool_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(SSHScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_analyses: AtomicU64::new(0),
            ssh_graph: RwLock::new(HashMap::new()),
            auth_failures: RwLock::new(HashMap::new()),
            active_tunnels: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_connection(&self, conn: &SSHConnection) -> Option<SSHAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_analyses.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", conn.source_ip, conn.dest_ip, conn.session_id);

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut active_tunnels = Vec::new();

        // Check tunnel flags in command line
        if cfg.detect_tunnels {
            if let Some(ref cmd) = conn.command_line {
                for &(flag, desc, conf) in SSH_TUNNEL_FLAGS {
                    if cmd.contains(flag) {
                        let tt = if flag.starts_with("-R") { SSHThreatType::RemotePortForward }
                            else if flag.starts_with("-L") { SSHThreatType::LocalPortForward }
                            else if flag.starts_with("-D") { SSHThreatType::DynamicSOCKSProxy }
                            else if flag.starts_with("-w") { SSHThreatType::TUNTAPTunnel }
                            else if flag.contains("ProxyJump") { SSHThreatType::ProxyJumpPivot }
                            else if flag.contains("ProxyCommand") { SSHThreatType::ProxyJumpPivot }
                            else if flag.contains("ControlMaster") { SSHThreatType::MultiplexedSession }
                            else if flag.contains("StrictHostKey") { SSHThreatType::DisabledHostVerification }
                            else { SSHThreatType::PersistentTunnel };
                        findings.push(SSHThreatFinding {
                            threat_type: tt,
                            source_ip: conn.source_ip.clone(),
                            dest_ip: conn.dest_ip.clone(),
                            dest_port: conn.dest_port,
                            confidence: conf,
                            description: format!("{}: {} → {}:{}", desc, conn.source_ip, conn.dest_ip, conn.dest_port),
                            username: Some(conn.username.clone()),
                            command_line: Some(cmd.clone()),
                            forwarded_port: None,
                            tunnel_type: Some(flag.trim().to_string()),
                            mitre_id: "T1572".into(),
                            process_name: Some(conn.process_name.clone()),
                            process_pid: Some(conn.process_pid),
                            timestamp: conn.start_time,
                        });
                        mitre_ids.insert("T1572".into());
                        active_tunnels.push(format!("{} {} → {}:{}", flag.trim(), conn.source_ip, conn.dest_ip, conn.dest_port));
                    }
                }

                // Check for lateral movement tools
                for &(tool, desc, mitre, conf) in SSH_LATERAL_TOOLS {
                    if cmd.to_lowercase().contains(tool) {
                        findings.push(SSHThreatFinding {
                            threat_type: SSHThreatType::LateralToolUsage,
                            source_ip: conn.source_ip.clone(),
                            dest_ip: conn.dest_ip.clone(),
                            dest_port: conn.dest_port,
                            confidence: conf,
                            description: desc.to_string(),
                            username: Some(conn.username.clone()),
                            command_line: Some(cmd.clone()),
                            forwarded_port: None, tunnel_type: None,
                            mitre_id: mitre.into(),
                            process_name: Some(conn.process_name.clone()),
                            process_pid: Some(conn.process_pid),
                            timestamp: conn.start_time,
                        });
                        mitre_ids.insert(mitre.into());
                    }
                }

                // Check suspicious SSH commands
                let cmd_lower = cmd.to_lowercase();
                for &(pattern, desc, conf) in SSH_SUSPICIOUS_COMMANDS {
                    if cmd_lower.contains(&pattern.to_lowercase()) {
                        findings.push(SSHThreatFinding {
                            threat_type: SSHThreatType::AutomatedSSH,
                            source_ip: conn.source_ip.clone(),
                            dest_ip: conn.dest_ip.clone(),
                            dest_port: conn.dest_port,
                            confidence: conf,
                            description: desc.to_string(),
                            username: Some(conn.username.clone()),
                            command_line: Some(cmd.clone()),
                            forwarded_port: None, tunnel_type: None,
                            mitre_id: "T1021.004".into(),
                            process_name: Some(conn.process_name.clone()),
                            process_pid: Some(conn.process_pid),
                            timestamp: conn.start_time,
                        });
                        mitre_ids.insert("T1021.004".into());
                    }
                }
            }
        }

        // Check non-standard port
        if !cfg.standard_ssh_ports.contains(&conn.dest_port) {
            findings.push(SSHThreatFinding {
                threat_type: SSHThreatType::NonStandardPort,
                source_ip: conn.source_ip.clone(),
                dest_ip: conn.dest_ip.clone(),
                dest_port: conn.dest_port,
                confidence: 0.5,
                description: format!("SSH on non-standard port {}", conn.dest_port),
                username: Some(conn.username.clone()),
                command_line: conn.command_line.clone(),
                forwarded_port: None, tunnel_type: None,
                mitre_id: "T1571".into(),
                process_name: Some(conn.process_name.clone()),
                process_pid: Some(conn.process_pid),
                timestamp: conn.start_time,
            });
            mitre_ids.insert("T1571".into());
        }

        // Track SSH graph for pivot detection
        if cfg.detect_pivots {
            self.ssh_graph.write()
                .entry(conn.source_ip.clone())
                .or_default()
                .insert(conn.dest_ip.clone());
        }

        let pivot_chains = if cfg.detect_pivots {
            self.find_pivot_chains(&conn.source_ip, 5)
        } else { Vec::new() };

        if pivot_chains.iter().any(|c| c.len() >= 3) {
            findings.push(SSHThreatFinding {
                threat_type: SSHThreatType::PivotChain,
                source_ip: conn.source_ip.clone(),
                dest_ip: conn.dest_ip.clone(),
                dest_port: conn.dest_port,
                confidence: 0.85,
                description: format!("SSH pivot chain: {} hops from {}",
                    pivot_chains.iter().map(|c| c.len()).max().unwrap_or(0), conn.source_ip),
                username: Some(conn.username.clone()),
                command_line: conn.command_line.clone(),
                forwarded_port: None, tunnel_type: None,
                mitre_id: "T1021.004".into(),
                process_name: Some(conn.process_name.clone()),
                process_pid: Some(conn.process_pid),
                timestamp: conn.start_time,
            });
            mitre_ids.insert("T1021.004".into());
        }

        self.conn_diffs.write().record_insert(
            cache_key.clone(),
            format!("src={},dst={}:{},user={},auth={}",
                conn.source_ip, conn.dest_ip, conn.dest_port, conn.username, conn.auth_method),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = SSHAnalysisResult {
            is_malicious,
            connections_analyzed: 1,
            findings,
            pivot_chains,
            active_tunnels,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_connections += 1;
            let n = stats.total_connections as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "ssh_pivot_detector".into(),
                title: format!("SSH pivot: {} → {}:{}", conn.source_ip, conn.dest_ip, conn.dest_port),
                details: format!("Risk: {:.1}%, {} findings, user: {}",
                    risk_score * 100.0, result.findings.len(), conn.username),
                path: None,
                process_name: Some(conn.process_name.clone()),
                process_pid: Some(conn.process_pid),
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Restrict SSH access with AllowUsers/AllowGroups".into(),
                    "Disable SSH agent forwarding".into(),
                    "Monitor SSH port forwarding with auditd".into(),
                    "Implement SSH certificate authentication".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn find_pivot_chains(&self, start: &str, max_depth: usize) -> Vec<Vec<String>> {
        let graph = self.ssh_graph.read();
        let mut chains = Vec::new();
        let mut visited = HashSet::new();
        let mut stack = vec![(start.to_string(), vec![start.to_string()])];
        while let Some((node, path)) = stack.pop() {
            if path.len() > max_depth { continue; }
            if path.len() >= 3 { chains.push(path.clone()); }
            visited.insert(node.clone());
            if let Some(neighbors) = graph.get(&node) {
                for next in neighbors {
                    if !visited.contains(next) {
                        let mut np = path.clone();
                        np.push(next.clone());
                        stack.push((next.clone(), np));
                    }
                }
            }
        }
        chains
    }

    fn calculate_risk_score(&self, findings: &[SSHThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                SSHThreatType::PivotChain => 1.5,
                SSHThreatType::ReverseTunnel => 1.4,
                SSHThreatType::TUNTAPTunnel => 1.4,
                SSHThreatType::RemotePortForward => 1.3,
                SSHThreatType::AgentForwardingHijack => 1.3,
                SSHThreatType::DynamicSOCKSProxy => 1.2,
                SSHThreatType::AutomatedSSH => 1.2,
                SSHThreatType::LateralToolUsage => 1.1,
                SSHThreatType::BruteForce => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> SSHScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
