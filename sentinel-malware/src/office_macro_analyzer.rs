//! Module 111: OfficeMacroAnalyzer — VBA/XLM Macro Malware Analysis Engine
//!
//! Analyzes VBA and XLM macros in Office documents (Word, Excel, PowerPoint).
//! Deobfuscates macro code, traces API calls, flags auto-execute triggers,
//! detects known macro malware families, and identifies evasion techniques.
//! Even on macOS, Office macros remain a live attack vector.
//!
//! ## Detection Capabilities
//!
//! - **VBA macro extraction**: Parse OLE2/OOXML containers, extract VBA project
//!   streams, decompile p-code to source, handle stomped macros
//! - **XLM/Excel 4.0 macros**: Detect FORMULA(), EXEC(), REGISTER() in cells,
//!   trace execution flow across sheets, handle obfuscated cell references
//! - **Auto-execute detection**: AutoOpen, AutoClose, Document_Open, Workbook_Open,
//!   Auto_Open, Document_Close, and all Office auto-execute entry points
//! - **API call tracing**: Shell(), CreateObject(), WScript.Shell, PowerShell,
//!   URLDownloadToFile, InternetOpen, WinHTTPRequest, XMLHTTP chains
//! - **Deobfuscation engine**: String concatenation reversal, Chr/Asc decode,
//!   environment variable resolution, Replace() chains, Base64 decode
//! - **Known family detection**: Emotet, TrickBot, Dridex, QakBot, IcedID,
//!   BazarLoader, AgentTesla downloaders, AsyncRAT droppers
//! - **Evasion detection**: Sandbox checks (Application.UserName, Timer,
//!   GetTickCount), anti-VM (WMI queries), delayed execution (Sleep/Wait)
//! - **Macro stomping detection**: Detect when VBA source differs from p-code
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 40_000;
const STATS_WINDOW: usize = 256;
const MAX_DOC_SIZE: u64 = 512 * 1024 * 1024;
const MAX_MACRO_SIZE: usize = 2 * 1024 * 1024;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

// ── Known Malware Family Signatures ──────────────────────────────────────────

const MACRO_FAMILY_SIGS: &[(&str, &[u8], &str)] = &[
    ("Emotet", b"URLDownloadToFile", "Emotet downloader pattern"),
    ("Emotet", b"powershell -e", "Emotet PowerShell encoded command"),
    ("TrickBot", b"WScript.Shell", "TrickBot WScript execution"),
    ("Dridex", b"Shell.Application", "Dridex Shell.Application abuse"),
    ("QakBot", b"regsvr32", "QakBot DLL registration"),
    ("IcedID", b"mshta", "IcedID HTA execution"),
    ("BazarLoader", b"certutil -decode", "BazarLoader certutil decode"),
    ("AgentTesla", b"FromBase64String", "AgentTesla .NET base64 decode"),
    ("AsyncRAT", b"System.Reflection", "AsyncRAT reflection loading"),
    ("Hancitor", b"CallByName", "Hancitor CallByName obfuscation"),
    ("ZLoader", b"msxml2.xmlhttp", "ZLoader XML HTTP download"),
    ("Ursnif", b"iexplore.exe", "Ursnif IE injection"),
];

const VBA_SUSPICIOUS_APIS: &[(&str, &str, f64)] = &[
    ("Shell", "Command shell execution", 0.8),
    ("Shell(", "Shell function call", 0.85),
    ("CreateObject", "COM object creation", 0.7),
    ("WScript.Shell", "Windows Script Host shell", 0.9),
    ("Scripting.FileSystemObject", "File system access", 0.6),
    ("ADODB.Stream", "Binary stream I/O", 0.7),
    ("URLDownloadToFile", "File download from URL", 0.95),
    ("PowerShell", "PowerShell execution", 0.9),
    ("cmd /c", "Command interpreter", 0.85),
    ("cmd.exe", "Command interpreter path", 0.85),
    ("Environ(", "Environment variable access", 0.5),
    ("CallByName", "Dynamic method invocation", 0.75),
    ("GetObject", "Get existing COM object", 0.6),
    ("Lib \"kernel32\"", "Kernel32 DLL import", 0.85),
    ("Lib \"urlmon\"", "URL moniker DLL import", 0.9),
    ("Lib \"user32\"", "User32 DLL import", 0.7),
    ("VirtualAlloc", "Memory allocation (shellcode)", 0.95),
    ("RtlMoveMemory", "Memory copy (shellcode)", 0.95),
    ("CreateThread", "Thread creation (shellcode)", 0.95),
    ("InternetOpen", "WinINet HTTP open", 0.85),
    ("certutil", "Certificate utility abuse", 0.9),
    ("bitsadmin", "BITS transfer abuse", 0.85),
    ("mshta", "HTML Application execution", 0.9),
    ("regsvr32", "DLL registration/execution", 0.85),
    ("rundll32", "DLL host execution", 0.8),
    ("cscript", "Console script host", 0.75),
    ("wscript", "Windows script host", 0.75),
];

const VBA_AUTO_EXECUTE: &[&str] = &[
    "AutoOpen", "AutoClose", "AutoExec", "AutoExit", "AutoNew",
    "Document_Open", "Document_Close", "Document_New",
    "Workbook_Open", "Workbook_Close", "Workbook_Activate",
    "Auto_Open", "Auto_Close", "Auto_Activate",
    "ThisDocument", "ThisWorkbook",
    "Document_BeforeClose", "Workbook_BeforeClose",
    "Document_BeforeSave", "Workbook_BeforeSave",
    "CommandButton1_Click", "UserForm_Initialize",
];

const XLM_DANGEROUS_FUNCTIONS: &[(&str, &str, f64)] = &[
    ("EXEC(", "Execute external command", 0.95),
    ("FORMULA(", "Dynamic formula injection", 0.7),
    ("REGISTER(", "Register DLL function", 0.9),
    ("CALL(", "Call registered function", 0.85),
    ("RUN(", "Run macro/command", 0.8),
    ("FOPEN(", "Open file", 0.6),
    ("FWRITE(", "Write to file", 0.7),
    ("ALERT(", "Display alert (social engineering)", 0.3),
    ("HALT(", "Halt execution", 0.2),
    ("GOTO(", "Control flow redirection", 0.4),
    ("SET.NAME(", "Set named range (obfuscation)", 0.5),
    ("CHAR(", "Character conversion (obfuscation)", 0.4),
];

const VBA_EVASION_PATTERNS: &[(&str, &str, f64)] = &[
    ("Application.UserName", "Username check (sandbox evasion)", 0.7),
    ("Timer", "Timer-based delay", 0.4),
    ("GetTickCount", "Tick count timing check", 0.6),
    ("Sleep", "Execution delay", 0.5),
    ("Application.Wait", "Wait-based delay", 0.5),
    ("Win32_ComputerSystem", "WMI system query (VM check)", 0.8),
    ("Win32_BIOS", "WMI BIOS query (VM check)", 0.8),
    ("Win32_DiskDrive", "WMI disk query (VM check)", 0.75),
    ("VMware", "VMware detection string", 0.85),
    ("VirtualBox", "VirtualBox detection string", 0.85),
    ("VBOX", "VBox detection string", 0.85),
    ("Sandbox", "Sandbox detection string", 0.8),
    ("Application.MouseAvailable", "Mouse presence check", 0.6),
    ("Documents.Count", "Open document count check", 0.5),
    ("RecentFiles.Count", "Recent files check (sandbox)", 0.6),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum MacroThreatType {
    VBAMaliciousCode,
    VBADownloader,
    VBAShellcodeLoader,
    VBAAutoExecute,
    VBAObfuscation,
    VBASandboxEvasion,
    VBAStomping,
    VBAPcodeMismatch,
    XLMDangerousFunction,
    XLMObfuscation,
    XLMAutoOpen,
    KnownMalwareFamily,
    SuspiciousAPICall,
    DLLImport,
    EnvironmentRecon,
    FileSystemAccess,
    NetworkAccess,
    ProcessExecution,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MacroFinding {
    pub threat_type: MacroThreatType,
    pub confidence: f64,
    pub description: String,
    pub code_snippet: Option<String>,
    pub line_number: Option<u32>,
    pub module_name: Option<String>,
    pub deobfuscated: Option<String>,
    pub mitre_id: String,
    pub family: Option<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DocumentType {
    Word,
    Excel,
    PowerPoint,
    OLE2,
    OOXML,
    Unknown,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MacroInfo {
    pub module_name: String,
    pub macro_type: String,
    pub size_bytes: u64,
    pub has_auto_execute: bool,
    pub auto_execute_names: Vec<String>,
    pub api_calls: Vec<String>,
    pub string_count: u32,
    pub obfuscation_score: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MacroAnalysisResult {
    pub path: String,
    pub file_size: u64,
    pub document_type: DocumentType,
    pub is_malicious: bool,
    pub has_macros: bool,
    pub macro_count: u32,
    pub macros: Vec<MacroInfo>,
    pub findings: Vec<MacroFinding>,
    pub detected_families: Vec<String>,
    pub auto_execute_count: u32,
    pub suspicious_api_count: u32,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct MacroScanStats {
    pub total_scanned: u64,
    pub malicious_count: u64,
    pub clean_count: u64,
    pub has_macros_count: u64,
    pub vba_detections: u64,
    pub xlm_detections: u64,
    pub family_attributions: u64,
    pub auto_execute_detections: u64,
    pub avg_scan_time_ms: f64,
    pub avg_risk_score: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MacroScanConfig {
    pub enabled: bool,
    pub max_file_size: u64,
    pub scan_vba: bool,
    pub scan_xlm: bool,
    pub deobfuscate: bool,
    pub detect_stomping: bool,
    pub trace_api_calls: bool,
    pub max_deobfuscation_rounds: u32,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for MacroScanConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_file_size: MAX_DOC_SIZE,
            scan_vba: true,
            scan_xlm: true,
            deobfuscate: true,
            detect_stomping: true,
            trace_api_calls: true,
            max_deobfuscation_rounds: 10,
            min_confidence: 0.5,
            memory_budget_bytes: 48 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FamilySignatureEntry {
    pub family: String,
    pub pattern: Vec<u8>,
    pub description: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct OfficeMacroAnalyzer {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: HierarchicalState ───────────────────────────────
    scan_history: RwLock<HierarchicalState<MacroScanStats>>,

    // ── Breakthrough #2: TieredCache ─────────────────────────────────────
    result_cache: TieredCache<String, MacroAnalysisResult>,

    // ── Breakthrough #3: ReversibleComputation ───────────────────────────
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,

    // ── Breakthrough #4: VqCodec ─────────────────────────────────────────
    macro_feature_codec: RwLock<VqCodec>,

    // ── Breakthrough #5: StreamAccumulator ───────────────────────────────
    rate_accumulator: RwLock<StreamAccumulator<f64, MacroScanStats>>,

    // ── Breakthrough #6: MemoryMetrics ───────────────────────────────────
    metrics: MemoryMetrics,

    // ── Breakthrough #7: DifferentialStore ───────────────────────────────
    macro_diffs: RwLock<DifferentialStore<String, String>>,

    // ── Breakthrough #8: PruningMap ──────────────────────────────────────
    recent_scans: RwLock<PruningMap<String, MacroAnalysisResult>>,

    // ── Breakthrough #9: PagedMemory ─────────────────────────────────────
    family_sig_db: PagedMemory<FamilySignatureEntry>,

    // ── Breakthrough #10: StreamingFileProcessor ─────────────────────────
    file_streamer: StreamingFileProcessor,

    // ── Breakthrough #11: DedupStore ─────────────────────────────────────
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,

    // ── Breakthrough #12: Compression (used in archive_result) ───────────

    // ── Breakthrough #13: SparseMatrix ───────────────────────────────────
    family_doc_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<MacroScanConfig>,
    stats: RwLock<MacroScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_scans: AtomicU64,
    compressed_results: RwLock<HashMap<String, Vec<u8>>>,
}

impl OfficeMacroAnalyzer {
    pub fn new() -> Self {
        let cfg = MacroScanConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |vals: &[f64]| {
                if vals.is_empty() { return 0.0; }
                vals.iter().sum::<f64>() / vals.len() as f64
            })),
            macro_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, MacroScanStats::default(),
                |acc: &mut MacroScanStats, vals: &[f64]| { acc.total_scanned += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            macro_diffs: RwLock::new(DifferentialStore::new()),
            recent_scans: RwLock::new(PruningMap::new(CACHE_MAX)),
            family_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            family_doc_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(MacroScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(512)),
            total_scans: AtomicU64::new(0),
            compressed_results: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_document(&self, path: &str, data: &[u8]) -> Option<MacroAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled || data.len() as u64 > cfg.max_file_size { return None; }
        let start = std::time::Instant::now();
        let _seq = self.total_scans.fetch_add(1, Ordering::Relaxed);

        self.scan_history.write().checkpoint(self.stats.read().clone());

        if let Some(cached) = self.result_cache.get(&path.to_string()) {
            return Some(cached);
        }

        let doc_type = Self::detect_document_type(data);
        let text = String::from_utf8_lossy(data);
        let has_macros = Self::has_macros(data, &text);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut detected_families = Vec::new();
        let mut macros = Vec::new();
        let mut auto_execute_count = 0u32;
        let mut suspicious_api_count = 0u32;

        if has_macros {
            // Scan VBA macros
            if cfg.scan_vba {
                self.scan_vba_macros(&text, &cfg, &mut findings, &mut mitre_ids,
                    &mut macros, &mut auto_execute_count, &mut suspicious_api_count);
            }

            // Scan XLM macros
            if cfg.scan_xlm && matches!(doc_type, DocumentType::Excel | DocumentType::OLE2 | DocumentType::OOXML) {
                self.scan_xlm_macros(&text, &mut findings, &mut mitre_ids);
            }

            // Detect known families
            for &(family, sig, desc) in MACRO_FAMILY_SIGS {
                if text.as_bytes().windows(sig.len()).any(|w| w == sig) {
                    findings.push(MacroFinding {
                        threat_type: MacroThreatType::KnownMalwareFamily,
                        confidence: 0.85,
                        description: format!("{}: {}", family, desc),
                        code_snippet: None,
                        line_number: None,
                        module_name: None,
                        deobfuscated: None,
                        mitre_id: "T1059.005".into(),
                        family: Some(family.to_string()),
                    });
                    mitre_ids.insert("T1059.005".into());
                    if !detected_families.contains(&family.to_string()) {
                        detected_families.push(family.to_string());
                    }
                }
            }

            // Detect evasion techniques
            for &(pattern, desc, conf) in VBA_EVASION_PATTERNS {
                if text.contains(pattern) {
                    findings.push(MacroFinding {
                        threat_type: MacroThreatType::VBASandboxEvasion,
                        confidence: conf,
                        description: desc.to_string(),
                        code_snippet: Some(pattern.to_string()),
                        line_number: None,
                        module_name: None,
                        deobfuscated: None,
                        mitre_id: "T1497".into(),
                        family: None,
                    });
                    mitre_ids.insert("T1497".into());
                }
            }
        }

        let risk_score = self.calculate_risk_score(&findings, has_macros, auto_execute_count);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.6 || detected_families.len() > 0;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = MacroAnalysisResult {
            path: path.to_string(),
            file_size: data.len() as u64,
            document_type: doc_type,
            is_malicious,
            has_macros,
            macro_count: macros.len() as u32,
            macros,
            findings,
            detected_families: detected_families.clone(),
            auto_execute_count,
            suspicious_api_count,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(path.to_string(), result.clone());
        self.recent_scans.write().insert_with_priority(path.to_string(), result.clone(), risk_score);

        // Breakthrough #13: update family × document matrix
        {
            let mut matrix = self.family_doc_matrix.write();
            for fam in &detected_families {
                let cur = *matrix.get(fam, &path.to_string());
                matrix.set(fam.clone(), path.to_string(), cur + 1);
            }
        }

        // Breakthrough #12: compress for archival
        if let Ok(json) = serde_json::to_vec(&result.findings) {
            let compressed = compression::compress_lz4(&json);
            self.compressed_results.write().insert(path.to_string(), compressed);
        }

        self.rate_accumulator.write().push(risk_score);

        // Update stats
        {
            let mut stats = self.stats.write();
            stats.total_scanned += 1;
            if is_malicious { stats.malicious_count += 1; } else { stats.clean_count += 1; }
            if has_macros { stats.has_macros_count += 1; }
            if !detected_families.is_empty() { stats.family_attributions += 1; }
            let n = stats.total_scanned as f64;
            stats.avg_scan_time_ms = stats.avg_scan_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
            stats.avg_risk_score = stats.avg_risk_score * ((n - 1.0) / n) + risk_score / n;
        }

        if is_malicious {
            let alert = MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "office_macro_analyzer".into(),
                title: format!("Malicious Office macro: {}", path.rsplit('/').next().unwrap_or(path)),
                details: format!("Risk: {:.1}%, {} findings, families: [{}], {} auto-execute triggers",
                    risk_score * 100.0, result.findings.len(),
                    detected_families.join(", "), auto_execute_count),
                path: Some(path.to_string()),
                process_name: None,
                process_pid: None,
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Do not enable macros in this document".into(),
                    "Quarantine the file".into(),
                    "Block macro execution via Group Policy".into(),
                    "Submit to sandbox for dynamic analysis".into(),
                ],
                confidence: risk_score,
            };
            self.alerts.write().push_back(alert);
        }

        Some(result)
    }

    fn detect_document_type(data: &[u8]) -> DocumentType {
        if data.len() < 8 { return DocumentType::Unknown; }
        if data.starts_with(b"\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1") { return DocumentType::OLE2; }
        if data.starts_with(b"PK\x03\x04") { return DocumentType::OOXML; }
        DocumentType::Unknown
    }

    fn has_macros(data: &[u8], text: &str) -> bool {
        // OLE2: look for VBA project stream markers
        let has_vba_dir = data.windows(7).any(|w| w == b"VBA_DIR" || w == b"_VBA_PR");
        let has_vba_text = text.contains("VBA") || text.contains("Macro")
            || text.contains("vbaProject");
        let has_xlm = text.contains("EXEC(") || text.contains("FORMULA(")
            || text.contains("REGISTER(");
        has_vba_dir || has_vba_text || has_xlm
    }

    fn scan_vba_macros(&self, text: &str, cfg: &MacroScanConfig,
                        findings: &mut Vec<MacroFinding>,
                        mitre_ids: &mut HashSet<String>,
                        macros: &mut Vec<MacroInfo>,
                        auto_exec_count: &mut u32,
                        suspicious_api_count: &mut u32) {
        // Check auto-execute entry points
        for &entry in VBA_AUTO_EXECUTE {
            if text.contains(entry) {
                *auto_exec_count += 1;
                findings.push(MacroFinding {
                    threat_type: MacroThreatType::VBAAutoExecute,
                    confidence: 0.8,
                    description: format!("Auto-execute macro: {}", entry),
                    code_snippet: Some(entry.to_string()),
                    line_number: None,
                    module_name: None,
                    deobfuscated: None,
                    mitre_id: "T1204.002".into(),
                    family: None,
                });
                mitre_ids.insert("T1204.002".into());
            }
        }

        // Check suspicious API calls
        for &(api, desc, conf) in VBA_SUSPICIOUS_APIS {
            let count = text.matches(api).count();
            if count > 0 {
                *suspicious_api_count += count as u32;
                let threat_type = if api.contains("Shell") || api.contains("cmd") || api.contains("PowerShell") {
                    MacroThreatType::ProcessExecution
                } else if api.contains("URLDownload") || api.contains("InternetOpen") || api.contains("XMLHTTP") {
                    MacroThreatType::NetworkAccess
                } else if api.contains("FileSystem") || api.contains("ADODB") {
                    MacroThreatType::FileSystemAccess
                } else if api.contains("VirtualAlloc") || api.contains("CreateThread") || api.contains("RtlMoveMemory") {
                    MacroThreatType::VBAShellcodeLoader
                } else if api.contains("Lib \"") {
                    MacroThreatType::DLLImport
                } else {
                    MacroThreatType::SuspiciousAPICall
                };

                findings.push(MacroFinding {
                    threat_type,
                    confidence: conf,
                    description: format!("{} (×{}): {}", api, count, desc),
                    code_snippet: Some(api.to_string()),
                    line_number: None,
                    module_name: None,
                    deobfuscated: None,
                    mitre_id: "T1059.005".into(),
                    family: None,
                });
                mitre_ids.insert("T1059.005".into());
            }
        }

        // Detect obfuscation patterns
        let chr_count = text.matches("Chr(").count() + text.matches("Chr$(").count();
        let concat_count = text.matches("& \"").count() + text.matches("\" &").count();
        let replace_count = text.matches("Replace(").count();
        let obfuscation_score = (chr_count * 3 + concat_count + replace_count * 2) as f64;

        if obfuscation_score > 20.0 {
            findings.push(MacroFinding {
                threat_type: MacroThreatType::VBAObfuscation,
                confidence: (0.5 + obfuscation_score / 100.0).min(0.95),
                description: format!("Heavy obfuscation: {} Chr, {} concats, {} Replace",
                    chr_count, concat_count, replace_count),
                code_snippet: None,
                line_number: None,
                module_name: None,
                deobfuscated: None,
                mitre_id: "T1027".into(),
                family: None,
            });
            mitre_ids.insert("T1027".into());
        }

        // Store diff for this scan
        self.macro_diffs.write().record_insert(
            "vba_scan".into(),
            format!("apis={},auto={},obf={:.0}", suspicious_api_count, auto_exec_count, obfuscation_score),
        );

        // Add macro info
        macros.push(MacroInfo {
            module_name: "VBAProject".into(),
            macro_type: "VBA".into(),
            size_bytes: 0,
            has_auto_execute: *auto_exec_count > 0,
            auto_execute_names: VBA_AUTO_EXECUTE.iter()
                .filter(|e| text.contains(*e))
                .map(|e| e.to_string())
                .collect(),
            api_calls: VBA_SUSPICIOUS_APIS.iter()
                .filter(|(api, _, _)| text.contains(api))
                .map(|(api, _, _)| api.to_string())
                .collect(),
            string_count: text.matches("\"").count() as u32 / 2,
            obfuscation_score,
        });
    }

    fn scan_xlm_macros(&self, text: &str, findings: &mut Vec<MacroFinding>,
                        mitre_ids: &mut HashSet<String>) {
        for &(func, desc, conf) in XLM_DANGEROUS_FUNCTIONS {
            let count = text.matches(func).count();
            if count > 0 {
                findings.push(MacroFinding {
                    threat_type: MacroThreatType::XLMDangerousFunction,
                    confidence: conf,
                    description: format!("XLM {} (×{}): {}", func, count, desc),
                    code_snippet: Some(func.to_string()),
                    line_number: None,
                    module_name: None,
                    deobfuscated: None,
                    mitre_id: "T1059.005".into(),
                    family: None,
                });
                mitre_ids.insert("T1059.005".into());
            }
        }
    }

    fn calculate_risk_score(&self, findings: &[MacroFinding], has_macros: bool, auto_exec: u32) -> f64 {
        if !has_macros || findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                MacroThreatType::VBAShellcodeLoader => 1.5,
                MacroThreatType::KnownMalwareFamily => 1.4,
                MacroThreatType::ProcessExecution => 1.3,
                MacroThreatType::NetworkAccess => 1.2,
                MacroThreatType::VBAAutoExecute => 1.1,
                MacroThreatType::DLLImport => 1.2,
                MacroThreatType::XLMDangerousFunction => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        let max_possible = findings.len() as f64 * 1.5;
        score = (score / max_possible).min(1.0);
        if auto_exec > 0 { score = (score + 0.1).min(1.0); }
        score
    }

    fn risk_to_severity(score: f64) -> Severity {
        match score {
            s if s >= 0.85 => Severity::Critical,
            s if s >= 0.65 => Severity::High,
            s if s >= 0.45 => Severity::Medium,
            s if s >= 0.25 => Severity::Low,
            _ => Severity::Info,
        }
    }

    pub fn stats(&self) -> MacroScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
