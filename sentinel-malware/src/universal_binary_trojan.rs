//! Module 126: UniversalBinaryTrojan — Fat/Universal Binary Abuse Detection
//!
//! Detects malicious abuse of macOS universal (fat) binaries where one
//! architecture slice is clean and another contains malware, or where
//! extra architectures are injected into legitimate binaries.
//!
//! ## Detection Capabilities
//!
//! - **Architecture mismatch**: x86_64 slice differs significantly from arm64
//! - **Slice injection**: Extra architecture slices added to legitimate binaries
//! - **Hidden architectures**: Unusual/obsolete archs (ppc, i386) hiding code
//! - **Size disparity**: One slice dramatically larger than others
//! - **Entropy disparity**: Different entropy profiles across slices
//! - **Code signature per-slice**: Signature valid on one slice, not another
//! - **Lipo manipulation**: Detection of lipo tool abuse for binary grafting
//! - **Polyglot binaries**: Files valid as both Mach-O and another format
//! - **Mach-O header anomalies**: Invalid load commands, unusual segments
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const SIZE_DISPARITY_RATIO: f64 = 3.0;
const ENTROPY_DISPARITY_THRESHOLD: f64 = 1.5;

const FAT_MAGIC: u32 = 0xCAFEBABE;
const FAT_MAGIC_64: u32 = 0xCAFEBABF;
const MH_MAGIC_64: u32 = 0xFEEDFACF;
const MH_MAGIC: u32 = 0xFEEDFACE;

const KNOWN_CPU_TYPES: &[(u32, &str, bool)] = &[
    (0x0100000C, "arm64", true),
    (0x0100000C | 0x02, "arm64e", true),
    (0x01000007, "x86_64", true),
    (0x00000007, "i386", false),      // obsolete
    (0x00000012, "ppc", false),       // obsolete
    (0x01000012, "ppc64", false),     // obsolete
    (0x0000000C, "arm", false),       // 32-bit ARM
];

const SUSPICIOUS_LOAD_COMMANDS: &[(&str, &str, f64)] = &[
    ("LC_LOAD_DYLIB @rpath", "Rpath dylib loading (hijack vector)", 0.4),
    ("LC_LOAD_WEAK_DYLIB", "Weak dylib loading (optional hijack)", 0.3),
    ("LC_RPATH", "Rpath entry (search path manipulation)", 0.3),
    ("LC_MAIN", "Main entry point", 0.1),
    ("LC_UNIXTHREAD", "Unix thread entry (classic format)", 0.2),
    ("__PAGEZERO 0x0", "Missing PAGEZERO (exploit indicator)", 0.7),
    ("__RESTRICT", "Restricted segment (anti-debug)", 0.5),
    ("__DATA_CONST", "Writable constant data (unusual)", 0.3),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum UBThreatType {
    SliceInjection,
    SizeDisparity,
    EntropyDisparity,
    ObsoleteArchitecture,
    HiddenArchitecture,
    CodeSignatureMismatch,
    LipoManipulation,
    PolyglotBinary,
    MachOHeaderAnomaly,
    MissingPageZero,
    SuspiciousLoadCommand,
    SliceEntryPointMismatch,
    UnusualSegmentLayout,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct UBThreatFinding {
    pub threat_type: UBThreatType,
    pub confidence: f64,
    pub description: String,
    pub architectures: Vec<String>,
    pub slice_sizes: Vec<u64>,
    pub mitre_id: String,
    pub file_path: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct UniversalBinaryInfo {
    pub file_path: String,
    pub total_size: u64,
    pub is_fat: bool,
    pub slices: Vec<MachOSlice>,
    pub file_hash: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MachOSlice {
    pub cpu_type: u32,
    pub cpu_subtype: u32,
    pub offset: u64,
    pub size: u64,
    pub arch_name: String,
    pub entropy: f64,
    pub is_signed: bool,
    pub has_pagezero: bool,
    pub load_commands: Vec<String>,
    pub entry_point: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct UBAnalysisResult {
    pub is_malicious: bool,
    pub files_analyzed: u32,
    pub findings: Vec<UBThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct UBScanStats {
    pub total_files: u64,
    pub fat_binaries: u64,
    pub trojan_detections: u64,
    pub injection_detections: u64,
    pub anomaly_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct UBSigEntry {
    pub pattern: String,
    pub description: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct UniversalBinaryTrojanDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<UBScanStats>>,
    result_cache: TieredCache<String, UBAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    binary_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, UBScanStats>>,
    metrics: MemoryMetrics,
    binary_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, UBAnalysisResult>>,
    sig_db: PagedMemory<UBSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<UBScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_files: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl UniversalBinaryTrojanDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            binary_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, UBScanStats::default(),
                |acc: &mut UBScanStats, vals: &[f64]| { acc.total_files += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            binary_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(UBScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_files: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_binary(&self, info: &UniversalBinaryInfo) -> Option<UBAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_files.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        if let Some(cached) = self.result_cache.get(&info.file_hash) { return Some(cached); }

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        if info.is_fat && info.slices.len() >= 2 {
            let arch_names: Vec<String> = info.slices.iter().map(|s| s.arch_name.clone()).collect();
            let slice_sizes: Vec<u64> = info.slices.iter().map(|s| s.size).collect();

            // Size disparity check
            let max_size = slice_sizes.iter().cloned().max().unwrap_or(0) as f64;
            let min_size = slice_sizes.iter().cloned().min().unwrap_or(1).max(1) as f64;
            if max_size / min_size > SIZE_DISPARITY_RATIO {
                findings.push(UBThreatFinding {
                    threat_type: UBThreatType::SizeDisparity,
                    confidence: (0.5 + ((max_size / min_size) - SIZE_DISPARITY_RATIO) * 0.05).min(0.9),
                    description: format!("Slice size ratio {:.1}x ({} slices)", max_size / min_size, info.slices.len()),
                    architectures: arch_names.clone(), slice_sizes: slice_sizes.clone(),
                    mitre_id: "T1036.005".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1036.005".into());
            }

            // Entropy disparity check
            let entropies: Vec<f64> = info.slices.iter().map(|s| s.entropy).collect();
            if entropies.len() >= 2 {
                let max_ent = entropies.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
                let min_ent = entropies.iter().cloned().fold(f64::INFINITY, f64::min);
                if max_ent - min_ent > ENTROPY_DISPARITY_THRESHOLD {
                    findings.push(UBThreatFinding {
                        threat_type: UBThreatType::EntropyDisparity,
                        confidence: (0.5 + (max_ent - min_ent - ENTROPY_DISPARITY_THRESHOLD) * 0.2).min(0.85),
                        description: format!("Entropy disparity: {:.2} to {:.2} across slices", min_ent, max_ent),
                        architectures: arch_names.clone(), slice_sizes: slice_sizes.clone(),
                        mitre_id: "T1027".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                    });
                    mitre_ids.insert("T1027".into());
                }
            }

            // Code signature mismatch
            let signed_count = info.slices.iter().filter(|s| s.is_signed).count();
            if signed_count > 0 && signed_count < info.slices.len() {
                findings.push(UBThreatFinding {
                    threat_type: UBThreatType::CodeSignatureMismatch,
                    confidence: 0.85,
                    description: format!("{}/{} slices signed", signed_count, info.slices.len()),
                    architectures: arch_names.clone(), slice_sizes: slice_sizes.clone(),
                    mitre_id: "T1553.002".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1553.002".into());
            }

            // Obsolete architecture check
            for slice in &info.slices {
                let is_obsolete = KNOWN_CPU_TYPES.iter()
                    .find(|&&(ct, _, _)| ct == slice.cpu_type)
                    .map(|&(_, _, current)| !current)
                    .unwrap_or(true);
                if is_obsolete {
                    findings.push(UBThreatFinding {
                        threat_type: UBThreatType::ObsoleteArchitecture,
                        confidence: 0.7,
                        description: format!("Obsolete architecture: {} (cpu_type=0x{:x})", slice.arch_name, slice.cpu_type),
                        architectures: vec![slice.arch_name.clone()], slice_sizes: vec![slice.size],
                        mitre_id: "T1036.005".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                    });
                    mitre_ids.insert("T1036.005".into());
                }
            }

            // More than 2 slices (unusual for modern macOS)
            if info.slices.len() > 2 {
                findings.push(UBThreatFinding {
                    threat_type: UBThreatType::SliceInjection,
                    confidence: 0.6,
                    description: format!("{} architecture slices (unusual, expected 2)", info.slices.len()),
                    architectures: arch_names.clone(), slice_sizes: slice_sizes.clone(),
                    mitre_id: "T1036.005".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1036.005".into());
            }

            // Missing PAGEZERO
            for slice in &info.slices {
                if !slice.has_pagezero {
                    findings.push(UBThreatFinding {
                        threat_type: UBThreatType::MissingPageZero,
                        confidence: 0.7,
                        description: format!("Missing __PAGEZERO in {} slice", slice.arch_name),
                        architectures: vec![slice.arch_name.clone()], slice_sizes: vec![slice.size],
                        mitre_id: "T1203".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                    });
                    mitre_ids.insert("T1203".into());
                }
            }
        }

        self.binary_diffs.write().record_insert(info.file_hash.clone(),
            format!("fat={},slices={},size={}", info.is_fat, info.slices.len(), info.total_size));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = UBAnalysisResult {
            is_malicious, files_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(info.file_hash.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(info.file_hash.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(info.file_hash.clone(), compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_files += 1;
            if info.is_fat { s.fat_binaries += 1; }
            if is_malicious { s.trojan_detections += 1; }
            let n = s.total_files as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "universal_binary_trojan".into(),
                title: format!("Universal binary trojan: {}", info.file_path),
                details: format!("Risk: {:.1}%, {} findings, {} slices",
                    risk_score * 100.0, result.findings.len(), info.slices.len()),
                path: Some(info.file_path.clone()),
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Quarantine the binary immediately".into(),
                    "Verify binary with codesign -dvvv".into(),
                    "Compare against known-good hash".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[UBThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                UBThreatType::CodeSignatureMismatch => 1.5,
                UBThreatType::PolyglotBinary => 1.5,
                UBThreatType::SliceInjection => 1.3,
                UBThreatType::MissingPageZero => 1.3,
                UBThreatType::EntropyDisparity => 1.2,
                UBThreatType::SizeDisparity => 1.1,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> UBScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
