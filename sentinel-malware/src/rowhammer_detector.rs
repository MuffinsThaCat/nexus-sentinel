//! Module 150: RowhammerDetector — DRAM Rowhammer & Memory Disturbance Attack Detection
//!
//! Detects Rowhammer and related DRAM disturbance attacks that exploit physical
//! memory characteristics to flip bits in adjacent memory rows, enabling privilege
//! escalation, sandbox escape, cryptographic key corruption, and code injection
//! without any software vulnerability.
//!
//! ## Detection Capabilities
//!
//! ### Classic Rowhammer
//! - **Single-sided Rowhammer**: Rapid repeated access to one DRAM row causing
//!   bit flips in adjacent rows
//! - **Double-sided Rowhammer**: Accessing rows on both sides of a target row
//!   for more reliable bit flips
//! - **One-location Rowhammer**: Minimal access pattern achieving flips with
//!   single aggressor address
//! - **TRRespass**: Bypassing Target Row Refresh (TRR) mitigations in modern
//!   DRAM via many-sided Rowhammer
//! - **Half-Double**: Hammering rows at distance-2 to exploit weak coupling
//!   effects in modern DRAM
//! - **Blacksmith**: Frequency-based Rowhammer bypassing all TRR implementations
//!
//! ### Rowhammer Exploitation Techniques
//! - **Page table entry flips**: Flipping PTE bits to gain write access to
//!   read-only pages or escalate privileges
//! - **Opcode flips**: Changing instruction bytes to alter program behavior
//! - **RSA key corruption**: Flipping bits in RSA public keys to factor them
//! - **Sandbox escape**: Flipping permission bits in sandboxed processes
//! - **Kernel privilege escalation**: Flipping supervisor/user bits in page
//!   table entries
//! - **VM escape**: Cross-VM bit flips for virtual machine escape
//! - **Browser-based Rowhammer**: JavaScript/WebAssembly-based Rowhammer
//!   attacks via cache eviction
//!
//! ### Detection Methods
//! - **Memory access pattern monitoring**: Detection of high-frequency row
//!   activations via performance counters
//! - **ECC error rate monitoring**: Elevated correctable ECC errors indicating
//!   Rowhammer-induced bit flips
//! - **Page allocation analysis**: Large contiguous memory allocations designed
//!   to control physical page layout
//! - **Cache flush patterns**: clflush/clflushopt sequences used to bypass
//!   cache and reach DRAM directly
//! - **Memory bus contention**: Unusual memory bandwidth saturation patterns
//! - **Huge page abuse**: Transparent huge page (THP) or explicit huge page
//!   allocation for physical address control
//!
//! ### macOS-Specific Considerations
//! - **Apple Silicon LPDDR**: Detection adapted for LPDDR4X/LPDDR5 used in
//!   Apple Silicon Macs (different row geometry)
//! - **Unified memory architecture**: Apple's unified memory means GPU can
//!   also be used as Rowhammer vector
//! - **IOKit memory allocation**: Large IOKit allocations that may be used
//!   for physical address manipulation
//! - **Metal compute shaders**: GPU compute shaders used to hammer DRAM rows
//!   via Apple's Metal framework
//!
//! ## MITRE ATT&CK: T1203, T1068, T1499.001
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const ROW_ACTIVATION_THRESHOLD: u64 = 100_000;
const ECC_ERROR_RATE_THRESHOLD: u64 = 10;
const HUGE_PAGE_ALLOC_THRESHOLD: u64 = 100;
const CLFLUSH_RATE_THRESHOLD: u64 = 50_000;
const MEMORY_BW_SATURATION_RATIO: f64 = 0.9;

// ── Rowhammer Attack Patterns ────────────────────────────────────────────────

const ROWHAMMER_PATTERNS: &[(&str, &str, &str, f64)] = &[
    // Classic variants
    ("single_sided_hammer", "Single-sided Rowhammer: rapid row activation pattern", "T1203", 0.8),
    ("double_sided_hammer", "Double-sided Rowhammer: alternating adjacent rows", "T1203", 0.9),
    ("one_location_hammer", "One-location Rowhammer: minimal access pattern", "T1203", 0.85),
    ("many_sided_hammer", "Many-sided Rowhammer (TRRespass): bypassing TRR", "T1203", 0.9),
    ("half_double", "Half-Double: distance-2 Rowhammer attack", "T1203", 0.85),
    ("blacksmith", "Blacksmith: frequency-based TRR bypass", "T1203", 0.9),
    ("rowhammer_js", "Browser-based Rowhammer via JavaScript/WASM", "T1203", 0.85),
    ("gpu_rowhammer", "GPU-based Rowhammer via compute shader", "T1203", 0.85),
    ("metal_compute_hammer", "Metal compute shader Rowhammer (macOS/Apple Silicon)", "T1203", 0.85),
    // Exploitation techniques
    ("pte_flip_detected", "Page Table Entry bit flip detected (privilege escalation)", "T1068", 0.95),
    ("opcode_flip_detected", "Instruction opcode bit flip detected", "T1203", 0.9),
    ("rsa_key_corruption", "RSA key bit corruption detected (Rowhammer factoring)", "T1003", 0.9),
    ("sandbox_bit_flip", "Sandbox permission bit flip detected", "T1068", 0.9),
    ("kernel_pte_flip", "Kernel page table supervisor bit flip", "T1068", 0.95),
    ("vm_escape_flip", "Cross-VM bit flip detected (VM escape)", "T1068", 0.95),
    ("code_signing_flip", "Code signing bit corruption detected", "T1068", 0.9),
    // Detection indicators
    ("high_row_activation", "Abnormally high DRAM row activation rate", "T1499.001", 0.7),
    ("ecc_correctable_spike", "ECC correctable error rate spike (bit flips)", "T1203", 0.8),
    ("ecc_uncorrectable", "ECC uncorrectable error (confirmed bit flip)", "T1203", 0.95),
    ("clflush_storm", "clflush/clflushopt storm (cache bypass for DRAM access)", "T1203", 0.7),
    ("memory_bw_saturation", "Memory bandwidth near saturation (hammering)", "T1499.001", 0.6),
    ("huge_page_abuse", "Excessive huge page allocation (physical layout control)", "T1203", 0.6),
    ("mmap_contiguous", "Large contiguous mmap allocation (physical targeting)", "T1203", 0.5),
    ("pagemap_read", "/proc/self/pagemap read (physical address discovery)", "T1203", 0.7),
    ("iokit_large_alloc", "Large IOKit memory allocation (physical control)", "T1203", 0.5),
    ("dma_buffer_alloc", "DMA buffer allocation (contiguous physical memory)", "T1203", 0.5),
];

// ── DRAM Technology Vulnerability Profiles ───────────────────────────────────

const DRAM_VULNERABILITY: &[(&str, &str, f64)] = &[
    ("DDR3", "DDR3 DRAM: highly vulnerable to Rowhammer (no TRR)", 0.9),
    ("DDR4_no_trr", "DDR4 without Target Row Refresh: vulnerable", 0.8),
    ("DDR4_trr", "DDR4 with TRR: partially mitigated (TRRespass/Blacksmith bypass)", 0.5),
    ("DDR5", "DDR5: improved Rowhammer mitigations (RFM)", 0.3),
    ("LPDDR4X", "LPDDR4X (Apple Silicon): moderate vulnerability", 0.5),
    ("LPDDR5", "LPDDR5 (Apple Silicon M2+): improved mitigations", 0.3),
    ("ECC_present", "ECC memory present: detects but doesn't prevent exploitation", 0.2),
    ("ECC_absent", "No ECC: bit flips undetectable by hardware", 0.7),
];

// ── macOS-Specific Rowhammer Vectors ─────────────────────────────────────────

const MACOS_VECTORS: &[(&str, &str, f64)] = &[
    ("metal_compute_dispatch", "Metal compute shader with high iteration count", 0.6),
    ("opencl_buffer_hammer", "OpenCL buffer used for memory hammering", 0.5),
    ("iokit_physmem_alloc", "IOKit physical memory allocation (contiguous)", 0.5),
    ("vm_allocate_superpage", "vm_allocate with VM_FLAGS_SUPERPAGE_SIZE_2MB", 0.6),
    ("mach_vm_map_large", "mach_vm_map large contiguous allocation", 0.5),
    ("unified_memory_gpu_hammer", "GPU hammering unified memory (Apple Silicon)", 0.7),
    ("neural_engine_memory", "ANE memory allocation (unified memory access)", 0.4),
    ("transparent_huge_page", "Transparent huge page exploitation attempt", 0.5),
    ("memory_pressure_trigger", "Memory pressure triggered to control page placement", 0.4),
    ("wired_memory_pin", "Wired/pinned memory to prevent page migration", 0.5),
];

// ── Known Rowhammer Research/Exploits ────────────────────────────────────────

const KNOWN_ROWHAMMER_ATTACKS: &[(&str, &str, &str, f64)] = &[
    ("Rowhammer-2014", "Original Rowhammer (Kim et al., 2014)", "classic", 0.8),
    ("Flip-Feng-Shui-2016", "Flip Feng Shui: cloud VM Rowhammer", "vm_escape", 0.85),
    ("Drammer-2016", "Drammer: deterministic Rowhammer on ARM/mobile", "mobile", 0.8),
    ("Throwhammer-2018", "Throwhammer: remote Rowhammer via RDMA", "remote", 0.85),
    ("RAMBleed-2019", "RAMBleed: reading data via Rowhammer bit flips", "data_leak", 0.85),
    ("TRRespass-2020", "TRRespass: bypassing TRR in all DDR4 modules", "trr_bypass", 0.9),
    ("SMASH-2021", "SMASH: synchronized many-sided Rowhammer via JavaScript", "browser", 0.85),
    ("Half-Double-2021", "Half-Double: distance-2 Rowhammer (Google)", "distance2", 0.85),
    ("Blacksmith-2021", "Blacksmith: frequency-based TRR bypass", "frequency", 0.9),
    ("ZenHammer-2024", "ZenHammer: Rowhammer on AMD Zen CPUs", "amd", 0.8),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum RowhammerThreatType {
    // Attack variants
    SingleSidedHammer,
    DoubleSidedHammer,
    ManySidedHammer,
    HalfDouble,
    Blacksmith,
    BrowserBasedHammer,
    GPUHammer,
    MetalComputeHammer,
    // Exploitation
    PTEBitFlip,
    OpcodeBitFlip,
    RSAKeyCorruption,
    SandboxBitFlip,
    KernelPTEFlip,
    VMEscapeFlip,
    CodeSigningFlip,
    // Detection indicators
    HighRowActivation,
    ECCErrorSpike,
    ECCUncorrectable,
    CacheFlushStorm,
    MemoryBWSaturation,
    HugePageAbuse,
    PhysicalAddressDiscovery,
    ContiguousAllocation,
    // macOS specific
    UnifiedMemoryGPUHammer,
    IOKitPhysMemAlloc,
    SuperpageAlloc,
    MemoryPressureManipulation,
    // Known attacks
    KnownAttackPattern,
    // DRAM vulnerability
    VulnerableDRAM,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RowhammerFinding {
    pub threat_type: RowhammerThreatType,
    pub confidence: f64,
    pub description: String,
    pub attack_variant: Option<String>,
    pub dram_type: Option<String>,
    pub row_activation_rate: Option<u64>,
    pub ecc_error_count: Option<u64>,
    pub allocation_size: Option<u64>,
    pub physical_address: Option<String>,
    pub bit_flip_offset: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RowhammerEvent {
    pub event_type: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub dram_type: Option<String>,
    pub has_ecc: Option<bool>,
    pub row_activation_rate: Option<u64>,
    pub ecc_correctable_count: Option<u64>,
    pub ecc_uncorrectable_count: Option<u64>,
    pub clflush_rate: Option<u64>,
    pub memory_bw_utilization: Option<f64>,
    pub huge_page_alloc_count: Option<u64>,
    pub allocation_size: Option<u64>,
    pub is_contiguous: bool,
    pub gpu_compute_active: bool,
    pub metal_dispatch_count: Option<u64>,
    pub integrity_check: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RowhammerAnalysisResult {
    pub is_attack: bool,
    pub events_analyzed: u32,
    pub findings: Vec<RowhammerFinding>,
    pub attack_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct RowhammerScanStats {
    pub total_events: u64,
    pub attack_detections: u64,
    pub bit_flip_detections: u64,
    pub ecc_error_spikes: u64,
    pub cache_flush_storms: u64,
    pub gpu_hammer_detections: u64,
    pub privilege_escalation_attempts: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RowhammerSigEntry { pub pattern: String, pub variant: String, pub severity: f64 }

pub struct RowhammerDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<RowhammerScanStats>>,
    result_cache: TieredCache<String, RowhammerAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    rh_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, RowhammerScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, RowhammerAnalysisResult>>,
    sig_db: PagedMemory<RowhammerSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<RowhammerScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl RowhammerDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            rh_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, RowhammerScanStats::default(),
                |acc: &mut RowhammerScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(RowhammerScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &RowhammerEvent) -> Option<RowhammerAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("rowhammer:{}:{}:{}", event.event_type, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        let ind_text = format!("{} {}",
            event.event_type, event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. Rowhammer pattern matching ───────────────────────────────
        for &(pattern, desc, mitre, conf) in ROWHAMMER_PATTERNS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "single_sided_hammer" => RowhammerThreatType::SingleSidedHammer,
                    "double_sided_hammer" => RowhammerThreatType::DoubleSidedHammer,
                    p if p.contains("many_sided") => RowhammerThreatType::ManySidedHammer,
                    "half_double" => RowhammerThreatType::HalfDouble,
                    "blacksmith" => RowhammerThreatType::Blacksmith,
                    "rowhammer_js" => RowhammerThreatType::BrowserBasedHammer,
                    "gpu_rowhammer" => RowhammerThreatType::GPUHammer,
                    "metal_compute_hammer" => RowhammerThreatType::MetalComputeHammer,
                    "pte_flip_detected" | "kernel_pte_flip" => RowhammerThreatType::PTEBitFlip,
                    "opcode_flip_detected" => RowhammerThreatType::OpcodeBitFlip,
                    "rsa_key_corruption" => RowhammerThreatType::RSAKeyCorruption,
                    "sandbox_bit_flip" => RowhammerThreatType::SandboxBitFlip,
                    "vm_escape_flip" => RowhammerThreatType::VMEscapeFlip,
                    "code_signing_flip" => RowhammerThreatType::CodeSigningFlip,
                    "high_row_activation" => RowhammerThreatType::HighRowActivation,
                    p if p.contains("ecc_correctable") => RowhammerThreatType::ECCErrorSpike,
                    "ecc_uncorrectable" => RowhammerThreatType::ECCUncorrectable,
                    "clflush_storm" => RowhammerThreatType::CacheFlushStorm,
                    "memory_bw_saturation" => RowhammerThreatType::MemoryBWSaturation,
                    p if p.contains("huge_page") => RowhammerThreatType::HugePageAbuse,
                    "pagemap_read" => RowhammerThreatType::PhysicalAddressDiscovery,
                    p if p.contains("contiguous") || p.contains("iokit_large") || p.contains("dma_buffer") => RowhammerThreatType::ContiguousAllocation,
                    _ => RowhammerThreatType::HighRowActivation,
                };
                findings.push(RowhammerFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    attack_variant: Some(pattern.to_string()),
                    dram_type: event.dram_type.clone(),
                    row_activation_rate: event.row_activation_rate,
                    ecc_error_count: event.ecc_correctable_count,
                    allocation_size: event.allocation_size,
                    physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert(if pattern.contains("flip") { "BitFlip" } else { "HammerPattern" }.to_string());
            }
        }

        // ── 2. Statistical threshold detection ──────────────────────────
        if let Some(rate) = event.row_activation_rate {
            if rate > ROW_ACTIVATION_THRESHOLD {
                findings.push(RowhammerFinding {
                    threat_type: RowhammerThreatType::HighRowActivation,
                    confidence: (0.6 + (rate as f64 / 1_000_000.0).min(0.3)),
                    description: format!("Row activation rate: {}/sec (threshold: {})", rate, ROW_ACTIVATION_THRESHOLD),
                    attack_variant: Some("high_row_activation".into()),
                    dram_type: event.dram_type.clone(),
                    row_activation_rate: Some(rate), ecc_error_count: None,
                    allocation_size: None, physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1499.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1499.001".into());
                categories.insert("RowActivation".to_string());
            }
        }

        if let Some(ecc_count) = event.ecc_correctable_count {
            if ecc_count > ECC_ERROR_RATE_THRESHOLD {
                findings.push(RowhammerFinding {
                    threat_type: RowhammerThreatType::ECCErrorSpike,
                    confidence: (0.7 + (ecc_count as f64 / 100.0).min(0.25)),
                    description: format!("ECC correctable error spike: {} errors (threshold: {})", ecc_count, ECC_ERROR_RATE_THRESHOLD),
                    attack_variant: Some("ecc_spike".into()),
                    dram_type: event.dram_type.clone(), row_activation_rate: None,
                    ecc_error_count: Some(ecc_count), allocation_size: None,
                    physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1203".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("ECCError".to_string());
            }
        }

        if let Some(count) = event.ecc_uncorrectable_count {
            if count > 0 {
                findings.push(RowhammerFinding {
                    threat_type: RowhammerThreatType::ECCUncorrectable,
                    confidence: 0.95,
                    description: format!("ECC UNCORRECTABLE error: {} errors (confirmed bit flip!)", count),
                    attack_variant: Some("ecc_uncorrectable".into()),
                    dram_type: event.dram_type.clone(), row_activation_rate: None,
                    ecc_error_count: Some(count), allocation_size: None,
                    physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1203".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("ConfirmedBitFlip".to_string());
            }
        }

        if let Some(rate) = event.clflush_rate {
            if rate > CLFLUSH_RATE_THRESHOLD {
                findings.push(RowhammerFinding {
                    threat_type: RowhammerThreatType::CacheFlushStorm,
                    confidence: 0.7,
                    description: format!("clflush storm: {}/sec (DRAM bypass for hammering)", rate),
                    attack_variant: Some("clflush_storm".into()),
                    dram_type: event.dram_type.clone(), row_activation_rate: None,
                    ecc_error_count: None, allocation_size: None,
                    physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1203".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("CacheFlush".to_string());
            }
        }

        if let Some(bw) = event.memory_bw_utilization {
            if bw > MEMORY_BW_SATURATION_RATIO {
                findings.push(RowhammerFinding {
                    threat_type: RowhammerThreatType::MemoryBWSaturation,
                    confidence: 0.5,
                    description: format!("Memory bandwidth {:.0}% utilized (possible hammering)", bw * 100.0),
                    attack_variant: None, dram_type: event.dram_type.clone(),
                    row_activation_rate: None, ecc_error_count: None,
                    allocation_size: None, physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1499.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1499.001".into());
                categories.insert("BWAnomaly".to_string());
            }
        }

        // ── 3. GPU/Metal compute hammer detection ───────────────────────
        if event.gpu_compute_active {
            if let Some(dispatches) = event.metal_dispatch_count {
                if dispatches > 10_000 {
                    findings.push(RowhammerFinding {
                        threat_type: RowhammerThreatType::MetalComputeHammer,
                        confidence: 0.7,
                        description: format!("Metal compute: {} dispatches with high memory access (GPU Rowhammer)", dispatches),
                        attack_variant: Some("metal_gpu_hammer".into()),
                        dram_type: event.dram_type.clone(), row_activation_rate: None,
                        ecc_error_count: None, allocation_size: event.allocation_size,
                        physical_address: None, bit_flip_offset: None,
                        process_name: event.process_name.clone(), process_pid: event.process_pid,
                        mitre_id: "T1203".into(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1203".into());
                    categories.insert("GPUHammer".to_string());
                }
            }
        }

        // ── 4. macOS vector matching ────────────────────────────────────
        for &(pattern, desc, conf) in MACOS_VECTORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = if pattern.contains("metal") || pattern.contains("gpu") || pattern.contains("unified") {
                    RowhammerThreatType::UnifiedMemoryGPUHammer
                } else if pattern.contains("iokit") {
                    RowhammerThreatType::IOKitPhysMemAlloc
                } else if pattern.contains("superpage") {
                    RowhammerThreatType::SuperpageAlloc
                } else if pattern.contains("pressure") {
                    RowhammerThreatType::MemoryPressureManipulation
                } else {
                    RowhammerThreatType::ContiguousAllocation
                };
                findings.push(RowhammerFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    attack_variant: Some(pattern.to_string()),
                    dram_type: event.dram_type.clone(), row_activation_rate: None,
                    ecc_error_count: None, allocation_size: event.allocation_size,
                    physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1203".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("macOSVector".to_string());
            }
        }

        // ── 5. DRAM vulnerability assessment ────────────────────────────
        if let Some(ref dram) = event.dram_type {
            for &(dtype, desc, conf) in DRAM_VULNERABILITY {
                if dram.to_lowercase().contains(&dtype.to_lowercase()) {
                    if conf > 0.5 {
                        findings.push(RowhammerFinding {
                            threat_type: RowhammerThreatType::VulnerableDRAM,
                            confidence: conf, description: desc.to_string(),
                            attack_variant: None, dram_type: Some(dram.clone()),
                            row_activation_rate: None, ecc_error_count: None,
                            allocation_size: None, physical_address: None, bit_flip_offset: None,
                            process_name: None, process_pid: None,
                            mitre_id: "T1203".into(), timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1203".into());
                        categories.insert("DRAMVulnerability".to_string());
                    }
                }
            }
        }

        // ── 6. Known attack pattern matching ────────────────────────────
        for &(name, desc, variant, conf) in KNOWN_ROWHAMMER_ATTACKS {
            if ind_lower.contains(&name.to_lowercase()) || ind_lower.contains(&variant.to_lowercase()) {
                findings.push(RowhammerFinding {
                    threat_type: RowhammerThreatType::KnownAttackPattern,
                    confidence: conf, description: format!("{}: {}", name, desc),
                    attack_variant: Some(variant.to_string()),
                    dram_type: event.dram_type.clone(), row_activation_rate: None,
                    ecc_error_count: None, allocation_size: None,
                    physical_address: None, bit_flip_offset: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1203".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("KnownAttack".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},pid={},findings={}", event.event_type, pid, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_attack = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = RowhammerAnalysisResult {
            is_attack, events_analyzed: 1, findings,
            attack_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_attack {
                s.attack_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        RowhammerThreatType::PTEBitFlip | RowhammerThreatType::OpcodeBitFlip |
                        RowhammerThreatType::RSAKeyCorruption | RowhammerThreatType::CodeSigningFlip |
                        RowhammerThreatType::ECCUncorrectable => s.bit_flip_detections += 1,
                        RowhammerThreatType::ECCErrorSpike => s.ecc_error_spikes += 1,
                        RowhammerThreatType::CacheFlushStorm => s.cache_flush_storms += 1,
                        RowhammerThreatType::GPUHammer | RowhammerThreatType::MetalComputeHammer |
                        RowhammerThreatType::UnifiedMemoryGPUHammer => s.gpu_hammer_detections += 1,
                        RowhammerThreatType::KernelPTEFlip | RowhammerThreatType::SandboxBitFlip |
                        RowhammerThreatType::VMEscapeFlip => s.privilege_escalation_attempts += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_attack {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "rowhammer_detector".into(),
                title: format!("ROWHAMMER ATTACK: {} ({})",
                    result.attack_categories.join(", "),
                    event.process_name.as_deref().unwrap_or("unknown")),
                details: format!("Risk {:.1}%, {} findings, DRAM: {:?}, categories: {}",
                    risk_score * 100.0, result.findings.len(),
                    event.dram_type, result.attack_categories.join(", ")),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the hammering process immediately: kill -9 <pid>".into(),
                    "Check ECC error logs: system_profiler SPMemoryDataType".into(),
                    "Update macOS to latest firmware (includes DRAM mitigations)".into(),
                    "If bit flips confirmed, reboot and verify system integrity".into(),
                    "Consider ECC memory for high-security workloads".into(),
                    "Apple Silicon: verify DRAM refresh rate is at maximum".into(),
                    "Restrict large contiguous memory allocations".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[RowhammerFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                RowhammerThreatType::KernelPTEFlip | RowhammerThreatType::VMEscapeFlip => 1.9,
                RowhammerThreatType::PTEBitFlip | RowhammerThreatType::CodeSigningFlip => 1.8,
                RowhammerThreatType::ECCUncorrectable => 1.7,
                RowhammerThreatType::OpcodeBitFlip | RowhammerThreatType::RSAKeyCorruption => 1.7,
                RowhammerThreatType::SandboxBitFlip => 1.6,
                RowhammerThreatType::Blacksmith | RowhammerThreatType::ManySidedHammer => 1.5,
                RowhammerThreatType::DoubleSidedHammer => 1.4,
                RowhammerThreatType::KnownAttackPattern => 1.4,
                RowhammerThreatType::MetalComputeHammer | RowhammerThreatType::GPUHammer => 1.3,
                RowhammerThreatType::ECCErrorSpike => 1.3,
                RowhammerThreatType::CacheFlushStorm => 1.2,
                RowhammerThreatType::HighRowActivation => 1.1,
                RowhammerThreatType::VulnerableDRAM => 0.8,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> RowhammerScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
