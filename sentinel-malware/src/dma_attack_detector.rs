//! Module 146: DMAAttackDetector — Direct Memory Access & Thunderbolt/PCIe Attack Detection
//!
//! Detects hardware-based Direct Memory Access attacks via Thunderbolt, PCIe,
//! FireWire, and other DMA-capable interfaces on macOS. These attacks bypass
//! the CPU and OS entirely to read/write physical memory, enabling full system
//! compromise including credential theft, code injection, and disk encryption
//! key extraction.
//!
//! ## Detection Capabilities
//!
//! ### Thunderbolt/USB4 DMA Attacks
//! - **Thunderclap**: Malicious Thunderbolt devices exploiting IOMMU gaps to
//!   perform unauthorized DMA transfers
//! - **ThunderGate**: Firmware-level Thunderbolt controller exploitation
//! - **PCILeech**: Hardware DMA attack tool detection via device signatures,
//!   FPGA-based PCIe DMA devices
//! - **Thunderbolt security level monitoring**: Detecting downgrades from
//!   SB3 (user authorization) to SB0 (no security)
//! - **Hot-plug DMA device monitoring**: New PCIe/Thunderbolt devices that
//!   immediately request large DMA windows
//!
//! ### IOMMU & VT-d Analysis
//! - **IOMMU bypass detection**: Devices accessing memory outside their
//!   allowed DMA regions
//! - **IOPTE manipulation**: IOPageTableEntry tampering for expanded DMA access
//! - **DART (Device Address Resolution Table) bypass**: Apple Silicon DART
//!   controller bypass attempts
//! - **Scatter-gather abuse**: Oversized or suspicious scatter-gather lists
//!   for DMA transfers
//!
//! ### FireWire/1394 DMA (Legacy)
//! - **Inception-style attacks**: FireWire DMA for memory forensics/attacks
//! - **SBP-2 exploitation**: SCSI Block Protocol over FireWire for DMA
//!
//! ### Physical Memory Analysis
//! - **Credential scraping patterns**: DMA reads targeting known credential
//!   storage locations in physical memory
//! - **Kernel memory access**: DMA targeting kernel text/data segments
//! - **FileVault key extraction**: DMA reads targeting AES key schedules
//!   in memory for disk encryption bypass
//! - **Screen capture via DMA**: Framebuffer DMA reads for screen capture
//! - **Keystroke logging via DMA**: DMA access to HID buffer regions
//!
//! ### Device Authenticity
//! - **Spoofed Thunderbolt devices**: Devices claiming to be legitimate
//!   peripherals but with mismatched vendor/product IDs
//! - **FPGA-based attack hardware**: Screamer, PCILeech FPGA boards,
//!   Hak5 devices detected by PCI vendor/device ID
//! - **USB-C/Thunderbolt confusion**: Devices exploiting the dual-mode
//!   nature of USB-C/Thunderbolt connectors
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1200 — Hardware Additions
//! - T1052 — Exfiltration Over Physical Medium
//! - T1040 — Network Sniffing (bus-level)
//! - T1056.001 — Keylogging (via DMA)
//! - T1003 — OS Credential Dumping (via DMA)
//! - T1495 — Firmware Corruption
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs with elevated parameters for
//! real-time hardware event monitoring.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const DMA_WINDOW_SUSPICIOUS_SIZE: u64 = 256 * 1024 * 1024; // 256MB
const RAPID_HOTPLUG_THRESHOLD: u32 = 3;
const RAPID_HOTPLUG_WINDOW_SECS: u64 = 10;

// ── Known DMA Attack Hardware ────────────────────────────────────────────────

const KNOWN_ATTACK_DEVICES: &[(&str, &str, &str, f64)] = &[
    // FPGA-based DMA attack boards
    ("1172:e001", "Altera/Intel FPGA (PCILeech-compatible)", "PCILeech", 0.85),
    ("10ee:7024", "Xilinx Artix-7 FPGA (Screamer/PCILeech)", "Screamer", 0.9),
    ("10ee:7028", "Xilinx Artix-7 35T FPGA", "PCILeech", 0.85),
    ("10ee:7032", "Xilinx Kintex-7 FPGA", "PCILeech", 0.85),
    ("10ee:9024", "Xilinx FPGA variant", "PCILeech", 0.8),
    ("1337:0001", "Known DMA attack tool vendor ID", "Custom", 0.95),
    ("dead:beef", "Debug/test device ID (suspicious)", "Debug", 0.7),
    ("0000:0000", "Null vendor/product ID (possible FPGA)", "Unknown", 0.7),
    ("ffff:ffff", "Invalid vendor/product ID", "Invalid", 0.8),
    // Thunderbolt-specific attack signatures
    ("8086:1513", "Intel Thunderbolt controller (Cactus Ridge) — verify legitimacy", "Thunderbolt", 0.3),
    ("8086:156c", "Intel Thunderbolt controller (Falcon Ridge)", "Thunderbolt", 0.3),
    ("8086:15d2", "Intel Thunderbolt 3 controller (Alpine Ridge)", "Thunderbolt", 0.2),
    ("8086:15ef", "Intel Thunderbolt 3 controller (Titan Ridge)", "Thunderbolt", 0.2),
    // FireWire attack signatures
    ("dead:0001", "Known Inception tool FireWire signature", "Inception", 0.95),
    ("1234:5678", "Generic test device (possible attack tool)", "Generic", 0.6),
];

// ── Suspicious DMA Patterns ──────────────────────────────────────────────────

const DMA_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("large_dma_window", "DMA window request >256MB (unusual for peripheral)", "T1200", 0.7),
    ("full_memory_map", "Device requesting full physical memory map", "T1200", 0.95),
    ("kernel_region_access", "DMA targeting kernel memory region", "T1003", 0.9),
    ("credential_region_scan", "DMA sequential read pattern in credential region", "T1003", 0.9),
    ("filevault_key_region", "DMA access to AES key schedule memory region", "T1003", 0.95),
    ("framebuffer_access", "DMA read of framebuffer region (screen capture)", "T1113", 0.7),
    ("hid_buffer_access", "DMA access to HID input buffer (keystroke capture)", "T1056.001", 0.85),
    ("sequential_scan", "Sequential physical memory scan (forensic dump)", "T1003", 0.85),
    ("iommu_bypass_attempt", "IOMMU bypass attempt detected", "T1200", 0.95),
    ("dart_bypass", "Apple DART controller bypass attempt", "T1200", 0.95),
    ("iopte_tamper", "IOPageTableEntry modification detected", "T1200", 0.95),
    ("scatter_gather_overflow", "Scatter-gather list exceeds expected size", "T1200", 0.8),
    ("hotplug_immediate_dma", "Device performing DMA within 100ms of hotplug", "T1200", 0.8),
    ("security_level_downgrade", "Thunderbolt security level downgraded", "T1200", 0.9),
    ("firmware_flash_attempt", "Thunderbolt controller firmware flash attempt", "T1495", 0.9),
    ("peer_to_peer_dma", "Peer-to-peer DMA between devices (bypass CPU)", "T1200", 0.7),
    ("write_to_kernel_text", "DMA write targeting kernel text segment", "T1200", 0.98),
    ("rapid_read_pattern", "Rapid small DMA reads (memory scanning pattern)", "T1003", 0.7),
    ("page_table_walk", "DMA reads consistent with page table walking", "T1003", 0.85),
    ("firewire_sbp2_attack", "FireWire SBP-2 DMA attack detected", "T1200", 0.9),
];

// ── Thunderbolt Security Levels ──────────────────────────────────────────────

const TB_SECURITY_CONCERNS: &[(&str, &str, f64)] = &[
    ("SB0_none", "Thunderbolt Security Level 0: No security (all DMA allowed)", 0.8),
    ("SB1_user", "Thunderbolt Security Level 1: User authorization only", 0.3),
    ("SB2_secure_connect", "Thunderbolt Security Level 2: Secure Connect (good)", 0.1),
    ("SB3_dp_only", "Thunderbolt Security Level 3: DisplayPort only (most secure)", 0.05),
    ("downgrade_detected", "Security level downgraded from previous boot", 0.9),
    ("boot_level_changed", "Thunderbolt boot-level security changed", 0.7),
    ("pre_boot_acl_modified", "Pre-boot ACL modified (allows DMA before OS)", 0.8),
];

// ── Spoofed Device Indicators ────────────────────────────────────────────────

const DEVICE_SPOOF_INDICATORS: &[(&str, &str, f64)] = &[
    ("vendor_mismatch", "Device vendor ID doesn't match reported device type", 0.8),
    ("class_mismatch", "PCI class code doesn't match device behavior", 0.7),
    ("subsystem_mismatch", "Subsystem ID inconsistent with vendor", 0.6),
    ("capability_anomaly", "PCIe capabilities don't match legitimate device", 0.7),
    ("bar_size_anomaly", "BAR (Base Address Register) size unusual for device type", 0.6),
    ("link_speed_anomaly", "PCIe link speed inconsistent with device claims", 0.5),
    ("serial_missing", "Thunderbolt device missing serial number", 0.5),
    ("firmware_version_zero", "Device firmware version is 0x0 (FPGA default)", 0.8),
    ("identical_uuid", "Multiple devices with identical UUID (clone detected)", 0.85),
    ("name_spoofed_apple", "Device name claims to be Apple but non-Apple vendor ID", 0.85),
];

// ── macOS DMA Protection Mechanisms ──────────────────────────────────────────

const PROTECTION_STATUS: &[(&str, &str, f64)] = &[
    ("iommu_disabled", "IOMMU/VT-d is disabled (all DMA unrestricted)", 0.9),
    ("dart_disabled", "Apple DART is disabled on Apple Silicon", 0.95),
    ("thunderbolt_dma_unrestricted", "Thunderbolt DMA is unrestricted", 0.8),
    ("kernel_dma_protection_off", "Kernel DMA protection is disabled", 0.85),
    ("secure_boot_off", "Secure boot disabled (firmware attacks possible)", 0.7),
    ("t2_chip_absent", "No T2/Apple Silicon (no hardware DMA protection)", 0.4),
    ("filevault_disabled", "FileVault disabled (keys in plaintext memory)", 0.5),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DMAThreatType {
    // Attack hardware
    KnownAttackDevice,
    FPGADevice,
    SpoofedDevice,
    SuspiciousHotplug,
    // DMA operations
    KernelMemoryDMA,
    CredentialScraping,
    FileVaultKeyExtraction,
    FramebufferCapture,
    HIDBufferCapture,
    SequentialMemoryScan,
    WriteToKernelText,
    PageTableWalk,
    // IOMMU bypass
    IOMMUBypass,
    DARTBypass,
    IOPTETamper,
    ScatterGatherOverflow,
    PeerToPeerDMA,
    // Security level
    SecurityLevelDowngrade,
    NoSecurity,
    ProtectionDisabled,
    // Thunderbolt-specific
    FirmwareFlashAttempt,
    ThunderGateExploit,
    PreBootACLModified,
    // FireWire
    FireWireDMAAttack,
    InceptionAttack,
    // Large DMA
    LargeDMAWindow,
    FullMemoryMapRequest,
    ImmediatePostHotplugDMA,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DMAFinding {
    pub threat_type: DMAThreatType,
    pub confidence: f64,
    pub description: String,
    pub device_vendor_id: Option<String>,
    pub device_product_id: Option<String>,
    pub device_name: Option<String>,
    pub device_class: Option<String>,
    pub bus_type: Option<String>,
    pub dma_address: Option<String>,
    pub dma_size: Option<u64>,
    pub physical_address: Option<String>,
    pub attack_tool: Option<String>,
    pub security_level: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DMAEvent {
    pub event_type: String,
    pub device_vendor_id: Option<String>,
    pub device_product_id: Option<String>,
    pub device_name: Option<String>,
    pub device_class: Option<u32>,
    pub bus_type: Option<String>,          // "thunderbolt", "pcie", "firewire", "usb4"
    pub dma_address: Option<u64>,
    pub dma_size: Option<u64>,
    pub dma_direction: Option<String>,     // "read", "write", "bidirectional"
    pub physical_address_start: Option<u64>,
    pub physical_address_end: Option<u64>,
    pub thunderbolt_security_level: Option<u32>,
    pub iommu_enabled: Option<bool>,
    pub dart_enabled: Option<bool>,
    pub device_serial: Option<String>,
    pub device_firmware_version: Option<String>,
    pub is_hotplug: bool,
    pub time_since_hotplug_ms: Option<u64>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DMAAnalysisResult {
    pub is_attack: bool,
    pub events_analyzed: u32,
    pub findings: Vec<DMAFinding>,
    pub attack_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct DMAScanStats {
    pub total_events: u64,
    pub attack_detections: u64,
    pub known_device_detections: u64,
    pub iommu_bypass_detections: u64,
    pub credential_scrape_detections: u64,
    pub security_downgrade_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DMASigEntry { pub vendor_product: String, pub tool: String, pub severity: f64 }

pub struct DMAAttackDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<DMAScanStats>>,
    result_cache: TieredCache<String, DMAAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    dma_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, DMAScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, DMAAnalysisResult>>,
    sig_db: PagedMemory<DMASigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<DMAScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    device_tracker: RwLock<HashMap<String, Vec<u64>>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl DMAAttackDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            dma_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, DMAScanStats::default(),
                |acc: &mut DMAScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(DMAScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            device_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &DMAEvent) -> Option<DMAAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let device_id = format!("{}:{}",
            event.device_vendor_id.as_deref().unwrap_or("????"),
            event.device_product_id.as_deref().unwrap_or("????"));
        let cache_key = format!("dma:{}:{}:{}", device_id, event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        // Track device hotplug
        {
            let mut tracker = self.device_tracker.write();
            let entry = tracker.entry(device_id.clone()).or_insert_with(Vec::new);
            entry.push(event.timestamp);
            if entry.len() > 100 { entry.drain(..50); }
        }

        // ── 1. Known attack device matching ─────────────────────────────
        for &(vid_pid, desc, tool, conf) in KNOWN_ATTACK_DEVICES {
            if device_id.to_lowercase() == vid_pid.to_lowercase() {
                let tt = if tool.contains("PCILeech") || tool.contains("Screamer") || tool.contains("Custom") {
                    DMAThreatType::KnownAttackDevice
                } else if tool.contains("Inception") {
                    DMAThreatType::InceptionAttack
                } else if tool == "Unknown" || tool == "Invalid" || tool == "Debug" {
                    DMAThreatType::FPGADevice
                } else {
                    DMAThreatType::SuspiciousHotplug
                };
                findings.push(DMAFinding {
                    threat_type: tt, confidence: conf,
                    description: format!("{}: {}", desc, device_id),
                    device_vendor_id: event.device_vendor_id.clone(),
                    device_product_id: event.device_product_id.clone(),
                    device_name: event.device_name.clone(),
                    device_class: event.device_class.map(|c| format!("0x{:04x}", c)),
                    bus_type: event.bus_type.clone(),
                    dma_address: event.dma_address.map(|a| format!("0x{:016x}", a)),
                    dma_size: event.dma_size,
                    physical_address: event.physical_address_start.map(|a| format!("0x{:016x}", a)),
                    attack_tool: Some(tool.to_string()),
                    security_level: None,
                    mitre_id: "T1200".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1200".into());
                categories.insert("KnownAttackDevice".to_string());
            }
        }

        // ── 2. DMA pattern matching ─────────────────────────────────────
        let indicator_text = format!("{} {}",
            event.event_type,
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = indicator_text.to_lowercase();

        for &(pattern, desc, mitre, conf) in DMA_PATTERNS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "kernel_region_access" | "write_to_kernel_text" => DMAThreatType::KernelMemoryDMA,
                    "credential_region_scan" => DMAThreatType::CredentialScraping,
                    "filevault_key_region" => DMAThreatType::FileVaultKeyExtraction,
                    "framebuffer_access" => DMAThreatType::FramebufferCapture,
                    "hid_buffer_access" => DMAThreatType::HIDBufferCapture,
                    "sequential_scan" | "rapid_read_pattern" => DMAThreatType::SequentialMemoryScan,
                    "page_table_walk" => DMAThreatType::PageTableWalk,
                    "iommu_bypass_attempt" => DMAThreatType::IOMMUBypass,
                    "dart_bypass" => DMAThreatType::DARTBypass,
                    "iopte_tamper" => DMAThreatType::IOPTETamper,
                    "scatter_gather_overflow" => DMAThreatType::ScatterGatherOverflow,
                    "peer_to_peer_dma" => DMAThreatType::PeerToPeerDMA,
                    "security_level_downgrade" => DMAThreatType::SecurityLevelDowngrade,
                    "firmware_flash_attempt" => DMAThreatType::FirmwareFlashAttempt,
                    "large_dma_window" => DMAThreatType::LargeDMAWindow,
                    "full_memory_map" => DMAThreatType::FullMemoryMapRequest,
                    "hotplug_immediate_dma" => DMAThreatType::ImmediatePostHotplugDMA,
                    "firewire_sbp2_attack" => DMAThreatType::FireWireDMAAttack,
                    _ => DMAThreatType::KernelMemoryDMA,
                };
                findings.push(DMAFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    device_vendor_id: event.device_vendor_id.clone(),
                    device_product_id: event.device_product_id.clone(),
                    device_name: event.device_name.clone(),
                    device_class: event.device_class.map(|c| format!("0x{:04x}", c)),
                    bus_type: event.bus_type.clone(),
                    dma_address: event.dma_address.map(|a| format!("0x{:016x}", a)),
                    dma_size: event.dma_size,
                    physical_address: event.physical_address_start.map(|a| format!("0x{:016x}", a)),
                    attack_tool: None, security_level: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("DMAPattern".to_string());
            }
        }

        // ── 3. Large DMA window heuristic ───────────────────────────────
        if let Some(size) = event.dma_size {
            if size > DMA_WINDOW_SUSPICIOUS_SIZE {
                findings.push(DMAFinding {
                    threat_type: DMAThreatType::LargeDMAWindow,
                    confidence: 0.7,
                    description: format!("Large DMA window: {} MB from device {}",
                        size / (1024 * 1024), device_id),
                    device_vendor_id: event.device_vendor_id.clone(),
                    device_product_id: event.device_product_id.clone(),
                    device_name: event.device_name.clone(),
                    device_class: None, bus_type: event.bus_type.clone(),
                    dma_address: None, dma_size: Some(size),
                    physical_address: None, attack_tool: None, security_level: None,
                    mitre_id: "T1200".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1200".into());
                categories.insert("LargeDMA".to_string());
            }
        }

        // ── 4. Immediate post-hotplug DMA ───────────────────────────────
        if event.is_hotplug {
            if let Some(ms) = event.time_since_hotplug_ms {
                if ms < 100 && event.dma_size.is_some() {
                    findings.push(DMAFinding {
                        threat_type: DMAThreatType::ImmediatePostHotplugDMA,
                        confidence: 0.8,
                        description: format!("DMA {}ms after hotplug from {}", ms, device_id),
                        device_vendor_id: event.device_vendor_id.clone(),
                        device_product_id: event.device_product_id.clone(),
                        device_name: event.device_name.clone(),
                        device_class: None, bus_type: event.bus_type.clone(),
                        dma_address: None, dma_size: event.dma_size,
                        physical_address: None, attack_tool: None, security_level: None,
                        mitre_id: "T1200".into(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1200".into());
                    categories.insert("SuspiciousHotplug".to_string());
                }
            }
        }

        // ── 5. Thunderbolt security level ───────────────────────────────
        if let Some(level) = event.thunderbolt_security_level {
            for &(pattern, desc, conf) in TB_SECURITY_CONCERNS {
                let level_match = match pattern {
                    "SB0_none" => level == 0,
                    "SB1_user" => level == 1,
                    "SB2_secure_connect" => level == 2,
                    "SB3_dp_only" => level == 3,
                    _ => ind_lower.contains(&pattern.to_lowercase()),
                };
                if level_match && conf > 0.3 {
                    findings.push(DMAFinding {
                        threat_type: if pattern.contains("downgrade") { DMAThreatType::SecurityLevelDowngrade }
                            else if pattern.contains("SB0") { DMAThreatType::NoSecurity }
                            else if pattern.contains("pre_boot") { DMAThreatType::PreBootACLModified }
                            else { DMAThreatType::SecurityLevelDowngrade },
                        confidence: conf, description: desc.to_string(),
                        device_vendor_id: None, device_product_id: None,
                        device_name: None, device_class: None,
                        bus_type: Some("thunderbolt".into()),
                        dma_address: None, dma_size: None, physical_address: None,
                        attack_tool: None, security_level: Some(format!("SB{}", level)),
                        mitre_id: "T1200".into(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1200".into());
                    categories.insert("SecurityLevel".to_string());
                }
            }
        }

        // ── 6. Protection status ────────────────────────────────────────
        if let Some(false) = event.iommu_enabled {
            findings.push(DMAFinding {
                threat_type: DMAThreatType::ProtectionDisabled,
                confidence: 0.9,
                description: "IOMMU/VT-d disabled — all DMA unrestricted".into(),
                device_vendor_id: None, device_product_id: None, device_name: None,
                device_class: None, bus_type: None, dma_address: None, dma_size: None,
                physical_address: None, attack_tool: None, security_level: None,
                mitre_id: "T1200".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1200".into());
            categories.insert("ProtectionDisabled".to_string());
        }
        if let Some(false) = event.dart_enabled {
            findings.push(DMAFinding {
                threat_type: DMAThreatType::ProtectionDisabled,
                confidence: 0.95,
                description: "Apple DART disabled — DMA unrestricted on Apple Silicon".into(),
                device_vendor_id: None, device_product_id: None, device_name: None,
                device_class: None, bus_type: None, dma_address: None, dma_size: None,
                physical_address: None, attack_tool: None, security_level: None,
                mitre_id: "T1200".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1200".into());
            categories.insert("ProtectionDisabled".to_string());
        }

        // ── 7. Device spoof detection ───────────────────────────────────
        for &(pattern, desc, conf) in DEVICE_SPOOF_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                findings.push(DMAFinding {
                    threat_type: DMAThreatType::SpoofedDevice,
                    confidence: conf, description: desc.to_string(),
                    device_vendor_id: event.device_vendor_id.clone(),
                    device_product_id: event.device_product_id.clone(),
                    device_name: event.device_name.clone(),
                    device_class: event.device_class.map(|c| format!("0x{:04x}", c)),
                    bus_type: event.bus_type.clone(),
                    dma_address: None, dma_size: None, physical_address: None,
                    attack_tool: None, security_level: None,
                    mitre_id: "T1200".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1200".into());
                categories.insert("SpoofedDevice".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("device={},type={},findings={}", device_id, event.event_type, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_attack = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = DMAAnalysisResult {
            is_attack, events_analyzed: 1, findings,
            attack_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_attack {
                s.attack_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        DMAThreatType::KnownAttackDevice | DMAThreatType::FPGADevice |
                        DMAThreatType::InceptionAttack => s.known_device_detections += 1,
                        DMAThreatType::IOMMUBypass | DMAThreatType::DARTBypass |
                        DMAThreatType::IOPTETamper => s.iommu_bypass_detections += 1,
                        DMAThreatType::CredentialScraping | DMAThreatType::FileVaultKeyExtraction =>
                            s.credential_scrape_detections += 1,
                        DMAThreatType::SecurityLevelDowngrade | DMAThreatType::NoSecurity |
                        DMAThreatType::ProtectionDisabled => s.security_downgrade_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_attack {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "dma_attack_detector".into(),
                title: format!("DMA ATTACK: {} from {}",
                    result.attack_categories.join(", "), device_id),
                details: format!("Risk {:.1}%, {} findings, device: {:?} via {:?}",
                    risk_score * 100.0, result.findings.len(),
                    event.device_name, event.bus_type),
                path: None,
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "IMMEDIATELY disconnect the suspicious Thunderbolt/PCIe device".into(),
                    "Lock the screen and do NOT enter passwords".into(),
                    "Set Thunderbolt security to Level 3 (DP only) if not needed".into(),
                    "Enable FileVault disk encryption".into(),
                    "Check: System Preferences → Security → Thunderbolt".into(),
                    "On Apple Silicon: verify DART is enabled".into(),
                    "If FileVault key theft suspected: change password and rotate keys".into(),
                    "Consider physical port blockers for unused Thunderbolt ports".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[DMAFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                DMAThreatType::WriteToKernelText => 2.0,
                DMAThreatType::FileVaultKeyExtraction => 1.9,
                DMAThreatType::KnownAttackDevice => 1.8,
                DMAThreatType::IOMMUBypass | DMAThreatType::DARTBypass => 1.8,
                DMAThreatType::CredentialScraping => 1.7,
                DMAThreatType::FullMemoryMapRequest => 1.7,
                DMAThreatType::FirmwareFlashAttempt => 1.6,
                DMAThreatType::KernelMemoryDMA => 1.6,
                DMAThreatType::InceptionAttack | DMAThreatType::FireWireDMAAttack => 1.6,
                DMAThreatType::IOPTETamper => 1.5,
                DMAThreatType::SecurityLevelDowngrade => 1.4,
                DMAThreatType::SpoofedDevice => 1.3,
                DMAThreatType::ImmediatePostHotplugDMA => 1.3,
                DMAThreatType::ProtectionDisabled | DMAThreatType::NoSecurity => 1.3,
                DMAThreatType::SequentialMemoryScan => 1.2,
                DMAThreatType::LargeDMAWindow => 1.0,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> DMAScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
