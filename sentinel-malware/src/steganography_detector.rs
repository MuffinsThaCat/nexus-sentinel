//! Module 153: SteganographyDetector — Hidden Data & Covert Payload Detection
//!
//! Detects steganographic techniques used to hide malicious payloads, C2
//! communications, exfiltrated data, and covert channels within innocent-looking
//! carrier files on macOS. Analyzes images, audio, video, documents, and
//! network traffic for statistical anomalies indicating hidden data.
//!
//! ## Detection Capabilities
//!
//! ### Image Steganography
//! - **LSB (Least Significant Bit) embedding**: Statistical detection of
//!   data hidden in the least significant bits of pixel values using
//!   chi-squared analysis, RS analysis, and sample pairs analysis
//! - **DCT coefficient manipulation**: JPEG steganography detection via
//!   analysis of DCT coefficient histograms (JSteg, F5, OutGuess, Steghide)
//! - **Palette-based hiding**: PNG/GIF palette reordering for data hiding
//! - **Alpha channel abuse**: Data hidden in the alpha transparency channel
//! - **EXIF/metadata hiding**: Payloads embedded in EXIF, IPTC, XMP metadata
//! - **Appended data detection**: Data appended after image EOF markers
//! - **PNG chunk abuse**: Custom or malformed PNG chunks hiding data
//! - **IDAT manipulation**: PNG IDAT chunk data anomalies
//!
//! ### Audio Steganography
//! - **LSB audio embedding**: Data in least significant bits of audio samples
//! - **Phase coding**: Data encoded in phase relationships between frequencies
//! - **Spread spectrum**: Data spread across audio frequency spectrum
//! - **Echo hiding**: Data encoded in echo patterns
//! - **MP3 frame padding**: Data hidden in MP3 frame padding bits
//! - **Metadata hiding**: Payloads in ID3 tags and audio metadata
//!
//! ### Document Steganography
//! - **PDF stream hiding**: Data hidden in PDF content streams, JavaScript,
//!   or embedded objects
//! - **Office document hiding**: OLE/OOXML embedded objects, macros,
//!   and custom XML parts with hidden data
//! - **Unicode steganography**: Zero-width characters, homoglyphs, and
//!   invisible Unicode for text-based hiding
//! - **Whitespace steganography**: Trailing spaces/tabs encoding data
//! - **Font-based hiding**: Microscopic font size or white-on-white text
//!
//! ### Network Steganography
//! - **DNS tunneling payloads**: Encoded data in DNS query/response fields
//! - **HTTP header hiding**: Data in custom or padded HTTP headers
//! - **TCP/IP covert channels**: Data in IP ID, TCP sequence numbers,
//!   TCP urgent pointer, IP TTL fields
//! - **ICMP payload hiding**: Data in ICMP echo request/reply payloads
//! - **TLS certificate hiding**: Data embedded in X.509 certificate fields
//!
//! ### Filesystem Steganography
//! - **Slack space hiding**: Data in file slack space (unused cluster bytes)
//! - **Alternate data streams**: HFS+ resource forks used for data hiding
//! - **Extended attribute hiding**: Data in xattrs beyond normal usage
//! - **APFS clone abuse**: APFS clone semantics exploited for hidden storage
//! - **Sparse file regions**: Data hidden in sparse file holes
//!
//! ## MITRE ATT&CK: T1027.003, T1001.002, T1036, T1564.004
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const CHI_SQUARED_THRESHOLD: f64 = 0.95;
const ENTROPY_HIGH_THRESHOLD: f64 = 7.9;
const APPENDED_DATA_MIN_SIZE: usize = 64;

// ── Known Steganography Tools ────────────────────────────────────────────────

const STEGO_TOOLS: &[(&str, &str, &str, f64)] = &[
    ("steghide", "Steghide — JPEG/BMP/WAV/AU embedding", "image/audio", 0.9),
    ("outguess", "OutGuess — JPEG statistical steganography", "image", 0.9),
    ("openstego", "OpenStego — LSB image steganography", "image", 0.85),
    ("stegsolve", "StegSolve — image stego analysis/embedding", "image", 0.8),
    ("f5", "F5 algorithm — JPEG matrix encoding", "image", 0.9),
    ("jsteg", "JSteg — JPEG DCT coefficient LSB embedding", "image", 0.85),
    ("invisible_secrets", "Invisible Secrets — multi-format steganography", "multi", 0.85),
    ("snow", "SNOW — whitespace steganography in text", "text", 0.8),
    ("stegano", "Stegano Python library", "image", 0.75),
    ("coagula", "Coagula — audio spectrogram image embedding", "audio", 0.7),
    ("deepsound", "DeepSound — audio steganography", "audio", 0.85),
    ("mp3stego", "MP3Stego — MP3 compression steganography", "audio", 0.85),
    ("silenteye", "SilentEye — image/audio steganography", "multi", 0.8),
    ("openpuff", "OpenPuff — multi-carrier steganography", "multi", 0.85),
    ("stegsnow", "stegsnow — whitespace/tab steganography", "text", 0.8),
    ("zsteg", "zsteg — PNG/BMP steganography detector", "image", 0.7),
    ("stegdetect", "stegdetect — JPEG steganography detection", "image", 0.7),
    ("binwalk", "binwalk — firmware/file embedded data extraction", "binary", 0.6),
    ("foremost", "foremost — file carving (stego extraction)", "binary", 0.5),
    ("exiftool_embed", "ExifTool used for metadata payload embedding", "metadata", 0.6),
];

// ── Image Steganography Indicators ───────────────────────────────────────────

const IMAGE_STEGO_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("lsb_chi_squared", "LSB chi-squared test anomaly (data hidden in LSB)", "T1027.003", 0.85),
    ("lsb_rs_analysis", "RS analysis anomaly (Regular/Singular groups)", "T1027.003", 0.85),
    ("lsb_sample_pairs", "Sample pairs analysis anomaly", "T1027.003", 0.8),
    ("dct_histogram_anomaly", "JPEG DCT coefficient histogram anomaly (F5/JSteg)", "T1027.003", 0.85),
    ("dct_zero_excess", "Excess zero DCT coefficients (OutGuess signature)", "T1027.003", 0.8),
    ("palette_anomaly", "PNG/GIF palette ordering anomaly", "T1027.003", 0.7),
    ("alpha_channel_data", "Data patterns in alpha channel (normally uniform)", "T1027.003", 0.75),
    ("exif_oversized", "Oversized EXIF metadata (possible payload)", "T1027.003", 0.6),
    ("exif_binary_data", "Binary data in EXIF text fields", "T1027.003", 0.8),
    ("appended_after_eof", "Data appended after image EOF marker", "T1027.003", 0.85),
    ("png_unknown_chunk", "Unknown/custom PNG chunk (data hiding)", "T1027.003", 0.7),
    ("png_idat_anomaly", "PNG IDAT chunk size/compression anomaly", "T1027.003", 0.7),
    ("jpeg_comment_binary", "Binary data in JPEG COM marker", "T1027.003", 0.75),
    ("bmp_padding_data", "Non-zero data in BMP row padding", "T1027.003", 0.7),
    ("image_entropy_high", "Image region with unusually high entropy", "T1027.003", 0.6),
    ("pixel_distribution_anomaly", "Pixel value distribution inconsistent with natural image", "T1027.003", 0.7),
    ("steghide_signature", "Steghide tool signature in file", "T1027.003", 0.95),
    ("outguess_signature", "OutGuess tool signature detected", "T1027.003", 0.95),
];

// ── Audio Steganography Indicators ───────────────────────────────────────────

const AUDIO_STEGO_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("audio_lsb_anomaly", "Audio LSB distribution anomaly (data embedding)", "T1027.003", 0.8),
    ("audio_phase_anomaly", "Audio phase relationship anomaly (phase coding)", "T1027.003", 0.75),
    ("audio_spectral_anomaly", "Audio spectral content anomaly (spread spectrum)", "T1027.003", 0.7),
    ("mp3_padding_data", "Non-zero data in MP3 frame padding", "T1027.003", 0.75),
    ("mp3_reservoir_anomaly", "MP3 bit reservoir anomaly", "T1027.003", 0.7),
    ("id3_oversized", "Oversized ID3 tag (possible payload)", "T1027.003", 0.6),
    ("audio_appended_data", "Data appended after audio stream end", "T1027.003", 0.8),
    ("wav_data_anomaly", "WAV data chunk anomaly (extra data)", "T1027.003", 0.7),
    ("audio_echo_pattern", "Artificial echo pattern (echo hiding)", "T1027.003", 0.6),
    ("deepsound_signature", "DeepSound tool signature in audio", "T1027.003", 0.9),
    ("mp3stego_signature", "MP3Stego signature detected", "T1027.003", 0.9),
];

// ── Document & Text Steganography Indicators ─────────────────────────────────

const DOCUMENT_STEGO_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("pdf_hidden_stream", "PDF hidden content stream", "T1027.003", 0.7),
    ("pdf_embedded_binary", "Binary data in PDF embedded object", "T1027.003", 0.75),
    ("pdf_javascript_hidden", "Hidden JavaScript in PDF", "T1027.003", 0.8),
    ("office_hidden_ole", "Hidden OLE object in Office document", "T1027.003", 0.7),
    ("office_custom_xml", "Custom XML part with encoded data", "T1027.003", 0.6),
    ("unicode_zero_width", "Zero-width Unicode characters (invisible text)", "T1027.003", 0.85),
    ("unicode_homoglyph", "Homoglyph character substitution", "T1027.003", 0.7),
    ("whitespace_encoding", "Trailing whitespace encoding data", "T1027.003", 0.8),
    ("font_invisible_text", "Microscopic or white-on-white text", "T1027.003", 0.7),
    ("rtf_hidden_content", "RTF hidden content fields", "T1027.003", 0.65),
    ("html_comment_data", "HTML comment with encoded data", "T1027.003", 0.5),
    ("css_invisible_content", "CSS hidden content (display:none with data)", "T1027.003", 0.6),
];

// ── Network Steganography Indicators ─────────────────────────────────────────

const NETWORK_STEGO_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("dns_encoded_payload", "Encoded data in DNS query names", "T1001.002", 0.8),
    ("dns_txt_large", "Oversized DNS TXT record (data exfiltration)", "T1001.002", 0.7),
    ("http_header_padding", "Unusual HTTP header padding (covert channel)", "T1001.002", 0.6),
    ("http_custom_header_data", "Custom HTTP header with encoded data", "T1001.002", 0.65),
    ("tcp_seq_anomaly", "TCP sequence number pattern (covert channel)", "T1001.002", 0.7),
    ("ip_id_pattern", "IP ID field pattern (covert channel)", "T1001.002", 0.65),
    ("ip_ttl_channel", "IP TTL modulation (covert channel)", "T1001.002", 0.7),
    ("icmp_payload_data", "Encoded data in ICMP echo payload", "T1001.002", 0.75),
    ("tls_cert_oversized", "Oversized TLS certificate field (data hiding)", "T1001.002", 0.6),
    ("tcp_urgent_channel", "TCP urgent pointer covert channel", "T1001.002", 0.7),
];

// ── Filesystem Steganography Indicators ──────────────────────────────────────

const FS_STEGO_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("slack_space_data", "Data in file slack space", "T1564.004", 0.8),
    ("resource_fork_payload", "Payload data in HFS+ resource fork", "T1564.004", 0.7),
    ("xattr_large_binary", "Large binary extended attribute (data hiding)", "T1564.004", 0.7),
    ("xattr_hidden_name", "Hidden/obfuscated xattr name", "T1564.004", 0.65),
    ("apfs_clone_hidden", "APFS clone with hidden divergent content", "T1564.004", 0.7),
    ("sparse_file_data", "Data in sparse file holes", "T1564.004", 0.65),
    ("ads_resource_fork", "Alternate data stream via resource fork", "T1564.004", 0.7),
    ("hidden_partition", "Hidden disk partition detected", "T1564.004", 0.8),
    ("unallocated_data", "Structured data in unallocated disk space", "T1564.004", 0.75),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum StegoThreatType {
    // Image
    LSBEmbedding,
    DCTManipulation,
    PaletteAnomaly,
    AlphaChannelHiding,
    MetadataPayload,
    AppendedData,
    PNGChunkAbuse,
    ImageEntropyAnomaly,
    KnownToolSignature,
    // Audio
    AudioLSBEmbedding,
    AudioPhaseEncoding,
    AudioSpreadSpectrum,
    MP3Padding,
    AudioMetadataPayload,
    AudioAppendedData,
    EchoHiding,
    // Document
    PDFHiddenStream,
    OfficeHiddenOLE,
    UnicodeZeroWidth,
    WhitespaceEncoding,
    InvisibleText,
    HTMLHiddenContent,
    // Network
    DNSTunnelPayload,
    HTTPHeaderHiding,
    TCPCovertChannel,
    IPCovertChannel,
    ICMPPayload,
    TLSCertHiding,
    // Filesystem
    SlackSpaceHiding,
    ResourceForkPayload,
    XattrHiding,
    APFSCloneHiding,
    SparseFileHiding,
    HiddenPartition,
    // Tool detection
    StegoToolDetected,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StegoFinding {
    pub threat_type: StegoThreatType,
    pub confidence: f64,
    pub description: String,
    pub carrier_type: Option<String>,
    pub carrier_path: Option<String>,
    pub tool_name: Option<String>,
    pub detection_method: Option<String>,
    pub entropy_value: Option<f64>,
    pub chi_squared_value: Option<f64>,
    pub hidden_data_size_est: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StegoEvent {
    pub event_type: String,
    pub file_path: Option<String>,
    pub file_type: Option<String>,
    pub file_size: Option<u64>,
    pub entropy: Option<f64>,
    pub chi_squared_result: Option<f64>,
    pub appended_data_size: Option<usize>,
    pub metadata_size: Option<usize>,
    pub tool_detected: Option<String>,
    pub network_protocol: Option<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StegoAnalysisResult {
    pub is_stego: bool,
    pub events_analyzed: u32,
    pub findings: Vec<StegoFinding>,
    pub stego_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct StegoScanStats {
    pub total_events: u64,
    pub stego_detections: u64,
    pub image_stego_detections: u64,
    pub audio_stego_detections: u64,
    pub document_stego_detections: u64,
    pub network_stego_detections: u64,
    pub filesystem_stego_detections: u64,
    pub tool_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StegoSigEntry { pub tool: String, pub carrier: String, pub severity: f64 }

pub struct SteganographyDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<StegoScanStats>>,
    result_cache: TieredCache<String, StegoAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    stego_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, StegoScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, StegoAnalysisResult>>,
    sig_db: PagedMemory<StegoSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<StegoScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SteganographyDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            stego_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, StegoScanStats::default(),
                |acc: &mut StegoScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(StegoScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &StegoEvent) -> Option<StegoAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("stego:{}:{}:{}",
            event.event_type, event.file_path.as_deref().unwrap_or("none"), event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        let ind_text = format!("{} {} {}",
            event.event_type,
            event.integrity_check.as_deref().unwrap_or(""),
            event.tool_detected.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. Stego tool detection ─────────────────────────────────────
        for &(tool, desc, carrier, conf) in STEGO_TOOLS {
            if ind_lower.contains(&tool.to_lowercase()) {
                findings.push(StegoFinding {
                    threat_type: StegoThreatType::StegoToolDetected,
                    confidence: conf, description: desc.to_string(),
                    carrier_type: Some(carrier.to_string()),
                    carrier_path: event.file_path.clone(),
                    tool_name: Some(tool.to_string()),
                    detection_method: Some("tool_signature".into()),
                    entropy_value: None, chi_squared_value: None, hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1027.003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1027.003".into());
                categories.insert("ToolDetection".to_string());
            }
        }

        // ── 2. Image stego indicators ───────────────────────────────────
        for &(pattern, desc, mitre, conf) in IMAGE_STEGO_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("lsb") => StegoThreatType::LSBEmbedding,
                    p if p.contains("dct") => StegoThreatType::DCTManipulation,
                    p if p.contains("palette") => StegoThreatType::PaletteAnomaly,
                    p if p.contains("alpha") => StegoThreatType::AlphaChannelHiding,
                    p if p.contains("exif") || p.contains("jpeg_comment") => StegoThreatType::MetadataPayload,
                    p if p.contains("appended") => StegoThreatType::AppendedData,
                    p if p.contains("png_") || p.contains("idat") => StegoThreatType::PNGChunkAbuse,
                    p if p.contains("entropy") || p.contains("pixel_distribution") => StegoThreatType::ImageEntropyAnomaly,
                    p if p.contains("steghide") || p.contains("outguess") => StegoThreatType::KnownToolSignature,
                    _ => StegoThreatType::LSBEmbedding,
                };
                findings.push(StegoFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    carrier_type: Some("image".into()), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some(pattern.to_string()),
                    entropy_value: event.entropy, chi_squared_value: event.chi_squared_result,
                    hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("ImageStego".to_string());
            }
        }

        // ── 3. Audio stego indicators ───────────────────────────────────
        for &(pattern, desc, mitre, conf) in AUDIO_STEGO_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("lsb") => StegoThreatType::AudioLSBEmbedding,
                    p if p.contains("phase") => StegoThreatType::AudioPhaseEncoding,
                    p if p.contains("spectral") || p.contains("spread") => StegoThreatType::AudioSpreadSpectrum,
                    p if p.contains("mp3") => StegoThreatType::MP3Padding,
                    p if p.contains("id3") => StegoThreatType::AudioMetadataPayload,
                    p if p.contains("appended") => StegoThreatType::AudioAppendedData,
                    p if p.contains("echo") => StegoThreatType::EchoHiding,
                    p if p.contains("deepsound") || p.contains("mp3stego") => StegoThreatType::KnownToolSignature,
                    _ => StegoThreatType::AudioLSBEmbedding,
                };
                findings.push(StegoFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    carrier_type: Some("audio".into()), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some(pattern.to_string()),
                    entropy_value: event.entropy, chi_squared_value: None, hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("AudioStego".to_string());
            }
        }

        // ── 4. Document stego indicators ────────────────────────────────
        for &(pattern, desc, mitre, conf) in DOCUMENT_STEGO_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("pdf") => StegoThreatType::PDFHiddenStream,
                    p if p.contains("office") || p.contains("ole") => StegoThreatType::OfficeHiddenOLE,
                    p if p.contains("zero_width") || p.contains("homoglyph") => StegoThreatType::UnicodeZeroWidth,
                    p if p.contains("whitespace") => StegoThreatType::WhitespaceEncoding,
                    p if p.contains("font") || p.contains("invisible") => StegoThreatType::InvisibleText,
                    p if p.contains("html") || p.contains("css") || p.contains("rtf") => StegoThreatType::HTMLHiddenContent,
                    _ => StegoThreatType::PDFHiddenStream,
                };
                findings.push(StegoFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    carrier_type: Some("document".into()), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some(pattern.to_string()),
                    entropy_value: None, chi_squared_value: None, hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("DocumentStego".to_string());
            }
        }

        // ── 5. Network stego indicators ─────────────────────────────────
        for &(pattern, desc, mitre, conf) in NETWORK_STEGO_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("dns") => StegoThreatType::DNSTunnelPayload,
                    p if p.contains("http") => StegoThreatType::HTTPHeaderHiding,
                    p if p.contains("tcp") => StegoThreatType::TCPCovertChannel,
                    p if p.contains("ip_") => StegoThreatType::IPCovertChannel,
                    p if p.contains("icmp") => StegoThreatType::ICMPPayload,
                    p if p.contains("tls") => StegoThreatType::TLSCertHiding,
                    _ => StegoThreatType::TCPCovertChannel,
                };
                findings.push(StegoFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    carrier_type: Some("network".into()), carrier_path: None,
                    tool_name: None, detection_method: Some(pattern.to_string()),
                    entropy_value: None, chi_squared_value: None, hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("NetworkStego".to_string());
            }
        }

        // ── 6. Filesystem stego indicators ──────────────────────────────
        for &(pattern, desc, mitre, conf) in FS_STEGO_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("slack") => StegoThreatType::SlackSpaceHiding,
                    p if p.contains("resource_fork") || p.contains("ads") => StegoThreatType::ResourceForkPayload,
                    p if p.contains("xattr") => StegoThreatType::XattrHiding,
                    p if p.contains("apfs_clone") => StegoThreatType::APFSCloneHiding,
                    p if p.contains("sparse") => StegoThreatType::SparseFileHiding,
                    p if p.contains("partition") || p.contains("unallocated") => StegoThreatType::HiddenPartition,
                    _ => StegoThreatType::SlackSpaceHiding,
                };
                findings.push(StegoFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    carrier_type: Some("filesystem".into()), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some(pattern.to_string()),
                    entropy_value: None, chi_squared_value: None, hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("FilesystemStego".to_string());
            }
        }

        // ── 7. Statistical heuristics ───────────────────────────────────
        if let Some(entropy) = event.entropy {
            if entropy > ENTROPY_HIGH_THRESHOLD {
                findings.push(StegoFinding {
                    threat_type: StegoThreatType::ImageEntropyAnomaly,
                    confidence: 0.5 + ((entropy - 7.0) * 0.3).min(0.4),
                    description: format!("File entropy {:.3} exceeds threshold {:.1}", entropy, ENTROPY_HIGH_THRESHOLD),
                    carrier_type: event.file_type.clone(), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some("entropy_analysis".into()),
                    entropy_value: Some(entropy), chi_squared_value: None, hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1027.003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1027.003".into());
                categories.insert("StatisticalAnomaly".to_string());
            }
        }

        if let Some(chi) = event.chi_squared_result {
            if chi > CHI_SQUARED_THRESHOLD {
                findings.push(StegoFinding {
                    threat_type: StegoThreatType::LSBEmbedding,
                    confidence: 0.7 + ((chi - 0.9) * 2.0).min(0.25),
                    description: format!("Chi-squared test {:.4} indicates LSB embedding", chi),
                    carrier_type: event.file_type.clone(), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some("chi_squared".into()),
                    entropy_value: None, chi_squared_value: Some(chi), hidden_data_size_est: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1027.003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1027.003".into());
                categories.insert("StatisticalAnomaly".to_string());
            }
        }

        if let Some(size) = event.appended_data_size {
            if size > APPENDED_DATA_MIN_SIZE {
                findings.push(StegoFinding {
                    threat_type: StegoThreatType::AppendedData,
                    confidence: 0.7 + (size as f64 / 10000.0).min(0.25),
                    description: format!("{} bytes of data appended after file EOF marker", size),
                    carrier_type: event.file_type.clone(), carrier_path: event.file_path.clone(),
                    tool_name: None, detection_method: Some("appended_data".into()),
                    entropy_value: None, chi_squared_value: None, hidden_data_size_est: Some(size as u64),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1027.003".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1027.003".into());
                categories.insert("AppendedData".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},findings={}", event.event_type, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_stego = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = StegoAnalysisResult {
            is_stego, events_analyzed: 1, findings,
            stego_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_stego {
                s.stego_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        StegoThreatType::LSBEmbedding | StegoThreatType::DCTManipulation |
                        StegoThreatType::PaletteAnomaly | StegoThreatType::AlphaChannelHiding |
                        StegoThreatType::MetadataPayload | StegoThreatType::AppendedData |
                        StegoThreatType::PNGChunkAbuse | StegoThreatType::ImageEntropyAnomaly |
                        StegoThreatType::KnownToolSignature => s.image_stego_detections += 1,
                        StegoThreatType::AudioLSBEmbedding | StegoThreatType::AudioPhaseEncoding |
                        StegoThreatType::AudioSpreadSpectrum | StegoThreatType::MP3Padding |
                        StegoThreatType::AudioMetadataPayload | StegoThreatType::AudioAppendedData |
                        StegoThreatType::EchoHiding => s.audio_stego_detections += 1,
                        StegoThreatType::PDFHiddenStream | StegoThreatType::OfficeHiddenOLE |
                        StegoThreatType::UnicodeZeroWidth | StegoThreatType::WhitespaceEncoding |
                        StegoThreatType::InvisibleText | StegoThreatType::HTMLHiddenContent =>
                            s.document_stego_detections += 1,
                        StegoThreatType::DNSTunnelPayload | StegoThreatType::HTTPHeaderHiding |
                        StegoThreatType::TCPCovertChannel | StegoThreatType::IPCovertChannel |
                        StegoThreatType::ICMPPayload | StegoThreatType::TLSCertHiding =>
                            s.network_stego_detections += 1,
                        StegoThreatType::SlackSpaceHiding | StegoThreatType::ResourceForkPayload |
                        StegoThreatType::XattrHiding | StegoThreatType::APFSCloneHiding |
                        StegoThreatType::SparseFileHiding | StegoThreatType::HiddenPartition =>
                            s.filesystem_stego_detections += 1,
                        StegoThreatType::StegoToolDetected => s.tool_detections += 1,
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_stego {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "steganography_detector".into(),
                title: format!("STEGANOGRAPHY: {} in {:?}",
                    result.stego_categories.join(", "),
                    event.file_path),
                details: format!("Risk {:.1}%, {} findings, type: {:?}",
                    risk_score * 100.0, result.findings.len(), event.file_type),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Quarantine the suspected carrier file".into(),
                    "Extract hidden data: steghide extract / zsteg / binwalk".into(),
                    "Analyze extracted payload in sandbox".into(),
                    "Check for C2 communication via steganographic channel".into(),
                    "Scan all files from same source for similar embedding".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[StegoFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                StegoThreatType::KnownToolSignature | StegoThreatType::StegoToolDetected => 1.5,
                StegoThreatType::DCTManipulation | StegoThreatType::LSBEmbedding => 1.4,
                StegoThreatType::DNSTunnelPayload => 1.4,
                StegoThreatType::HiddenPartition => 1.4,
                StegoThreatType::AppendedData | StegoThreatType::AudioAppendedData => 1.3,
                StegoThreatType::UnicodeZeroWidth => 1.3,
                StegoThreatType::SlackSpaceHiding => 1.3,
                StegoThreatType::PDFHiddenStream => 1.2,
                StegoThreatType::TCPCovertChannel | StegoThreatType::IPCovertChannel => 1.2,
                StegoThreatType::ImageEntropyAnomaly => 0.9,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> StegoScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
