//! Module 97: HoneypotEngine — Deception-Based Threat Detection & Attacker Profiling
//!
//! World-class honeypot and deception engine that deploys fake files, credentials,
//! services, and network resources to detect attackers, track lateral movement, and
//! profile threat actor TTPs. Any interaction with honeypot resources is a high-
//! confidence indicator of compromise.
//!
//! ## Features
//!
//! - **Honey files**: Deploys fake sensitive documents (passwords.xlsx, backup.sql,
//!   ssh_keys.tar.gz, wallet.dat) that trigger alerts on access
//! - **Honey credentials**: Plants fake credentials in memory, configuration files,
//!   and credential stores that trigger on authentication attempts
//! - **Honey tokens**: Deploys canary tokens (AWS keys, API keys, database connection
//!   strings) that alert when used from any location
//! - **Honey services**: Exposes fake SSH, RDP, SMB, HTTP, and database services
//!   that log all interaction details
//! - **Honey shares**: Creates fake network shares (ADMIN$, Finance$, HR_Backup)
//!   that trigger on access or enumeration
//! - **Honey DNS**: Deploys fake DNS records that alert when resolved, indicating
//!   internal network reconnaissance
//! - **Honey users**: Creates decoy Active Directory/LDAP accounts that trigger
//!   on login attempts or enumeration
//! - **Honey registry keys**: Plants fake registry entries containing "credentials"
//!   that trigger on read access
//! - **Breadcrumb trails**: Places interconnected honey artifacts that trace
//!   attacker movement patterns through the network
//! - **Attacker profiling**: Captures source IPs, user agents, tools, timing
//!   patterns, and TTPs of interacting threat actors
//! - **Geolocation integration**: Maps attacker source IPs to geographic locations
//!   and known threat actor infrastructure
//! - **Alert correlation**: Correlates honeypot triggers with other security events
//!   to build complete attack narratives
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) honeypot event history
//! - **#2  TieredCache** — Hot cache for recent honeypot triggers
//! - **#3  ReversibleComputation** — Recompute attacker threat scores
//! - **#5  StreamAccumulator** — Streaming trigger rate
//! - **#6  MemoryMetrics** — Bounded memory for honeypot data
//! - **#461 DifferentialStore** — Track attacker behavior diffs
//! - **#569 PruningMap** — Auto-expire old honeypot events
//! - **#592 DedupStore** — Deduplicate repeated triggers
//! - **#627 SparseMatrix** — Attacker × honeypot-type interaction matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1078 — Valid Accounts (honey credential usage)
//! - T1083 — File and Directory Discovery (honey file access)
//! - T1135 — Network Share Discovery (honey share access)
//! - T1087 — Account Discovery (honey user enumeration)
//! - T1046 — Network Service Discovery (honey service scan)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const HONEY_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 24 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Honeypot thresholds
// ────────────────────────────────────────────────────────────────────────────
const BRUTE_FORCE_THRESHOLD: u64 = 5;
const HIGH_RISK_INTERACTION_COUNT: u64 = 3;
const ATTACKER_PROFILE_MAX: usize = 10_000;
const HONEYPOT_MAX_DEPLOYED: usize = 500;

/// Honey file templates: (filename, description, apparent_value)
const HONEY_FILE_TEMPLATES: &[(&str, &str, f64)] = &[
    ("passwords.xlsx",         "Excel file with apparent passwords",   1.0),
    ("passwords.txt",          "Plaintext password list",              0.95),
    ("credentials.csv",        "CSV credential export",                0.95),
    ("backup.sql",             "Database backup dump",                 0.90),
    ("database_backup.tar.gz", "Compressed database backup",           0.90),
    ("ssh_keys.tar.gz",        "SSH private key archive",              0.95),
    ("id_rsa",                 "SSH private key",                      0.95),
    ("wallet.dat",             "Bitcoin wallet file",                  0.98),
    ("seed_phrase.txt",        "Cryptocurrency seed phrase",           0.98),
    (".env.production",        "Production environment variables",     0.90),
    ("config.yml.bak",         "Configuration backup with secrets",    0.80),
    ("api_keys.json",          "API key collection",                   0.90),
    ("financial_report_Q4.xlsx","Financial report",                    0.75),
    ("employee_salaries.xlsx", "HR salary data",                       0.80),
    ("customer_database.csv",  "Customer PII database",                0.85),
    ("vpn_credentials.txt",    "VPN access credentials",               0.90),
    ("admin_panel_creds.txt",  "Admin panel credentials",              0.95),
    ("aws_credentials",        "AWS credential file",                  0.95),
    (".kube/config",           "Kubernetes cluster config",            0.90),
    ("terraform.tfstate",      "Terraform state with secrets",         0.85),
];

/// Honey credential templates: (username, service, apparent_role)
const HONEY_CREDENTIAL_TEMPLATES: &[(&str, &str, &str, f64)] = &[
    ("admin",           "SSH",        "System administrator",     0.95),
    ("root",            "SSH",        "Root account",             1.0),
    ("sa",              "MSSQL",      "SQL Server admin",         0.95),
    ("Administrator",   "RDP",        "Windows administrator",    0.95),
    ("dbadmin",         "MySQL",      "Database administrator",   0.90),
    ("backup_svc",      "SMB",        "Backup service account",   0.85),
    ("deploy_bot",      "Jenkins",    "CI/CD deployment account",  0.80),
    ("svc_monitoring",  "Grafana",    "Monitoring service",        0.75),
    ("cloud_admin",     "AWS",        "Cloud administrator",       0.95),
    ("k8s_admin",       "Kubernetes", "Cluster administrator",     0.90),
    ("vault_root",      "HashiCorp",  "Secrets vault admin",       0.95),
    ("git_deploy",      "GitHub",     "Repository deployment key",  0.80),
];

/// Honey token templates: (token_type, prefix, description)
const HONEY_TOKEN_TEMPLATES: &[(&str, &str, &str, f64)] = &[
    ("AWS Access Key",       "AKIA",    "AWS IAM access key",           0.98),
    ("AWS Secret Key",       "aws_secret", "AWS IAM secret key",       0.98),
    ("GitHub PAT",           "ghp_",    "GitHub personal access token",  0.95),
    ("Slack Bot Token",      "xoxb-",   "Slack bot token",              0.90),
    ("Slack User Token",     "xoxp-",   "Slack user token",              0.90),
    ("Stripe Secret Key",    "sk_live_","Stripe live secret key",       0.95),
    ("SendGrid API Key",     "SG.",     "SendGrid email API key",       0.85),
    ("Twilio Auth Token",    "SK",      "Twilio authentication token",   0.85),
    ("GCP Service Account",  "-----BEGIN PRIVATE KEY-----", "GCP SA key", 0.95),
    ("Azure Client Secret",  "~",       "Azure AD client secret",       0.90),
    ("Database Conn String", "postgresql://", "PostgreSQL connection",   0.90),
    ("JWT Secret",           "ey",      "JWT signing secret",            0.85),
];

/// Known attacker tool signatures to detect in honeypot interactions
const ATTACKER_TOOL_SIGNATURES: &[(&str, f64, &str)] = &[
    ("nmap",          0.70, "Nmap port scanner"),
    ("masscan",       0.80, "Masscan high-speed scanner"),
    ("nikto",         0.75, "Nikto web vulnerability scanner"),
    ("sqlmap",        0.85, "SQLMap SQL injection tool"),
    ("hydra",         0.90, "Hydra brute-force tool"),
    ("medusa",        0.85, "Medusa brute-force tool"),
    ("metasploit",    0.95, "Metasploit framework"),
    ("burpsuite",     0.70, "Burp Suite proxy"),
    ("gobuster",      0.70, "GoBuster directory brute-force"),
    ("dirbuster",     0.70, "DirBuster directory scanner"),
    ("wpscan",        0.75, "WPScan WordPress scanner"),
    ("responder",     0.90, "Responder — LLMNR/NBT-NS poisoner"),
    ("crackmapexec",  0.90, "CrackMapExec — network pentesting"),
    ("impacket",      0.85, "Impacket — Python network toolkit"),
    ("enum4linux",    0.80, "Enum4Linux — SMB enumeration"),
    ("bloodhound",    0.85, "BloodHound — AD attack path mapper"),
    ("mimikatz",      0.95, "Mimikatz — credential extraction"),
    ("hashcat",       0.70, "Hashcat — password cracker"),
    ("john",          0.65, "John the Ripper — password cracker"),
];

/// Breadcrumb placement strategies
const BREADCRUMB_STRATEGIES: &[(&str, &str, f64)] = &[
    ("desktop_shortcut",    "Fake shortcut on desktop leading to honeypot",        0.85),
    ("email_attachment",    "Canary document sent via internal email",             0.90),
    ("shared_drive",        "Honey file placed on shared network drive",           0.80),
    ("git_repo_secret",     "Fake secret committed to internal Git repo",          0.85),
    ("dns_canary",          "DNS canary token resolving to monitoring server",     0.95),
    ("web_beacon",          "Invisible web beacon in internal documents",          0.90),
    ("registry_canary",     "Registry key with canary value",                      0.80),
    ("config_file_token",   "Canary token embedded in config file",                0.85),
];

/// Honey service ports to expose
const HONEY_SERVICES: &[(u16, &str, &str, f64)] = &[
    (22,    "SSH",       "Fake SSH server",              0.90),
    (23,    "Telnet",    "Fake Telnet server",            0.95),
    (80,    "HTTP",      "Fake web application",          0.70),
    (443,   "HTTPS",     "Fake HTTPS service",            0.70),
    (445,   "SMB",       "Fake SMB share server",         0.90),
    (1433,  "MSSQL",     "Fake MSSQL server",             0.90),
    (3306,  "MySQL",     "Fake MySQL server",              0.90),
    (3389,  "RDP",       "Fake RDP server",               0.90),
    (5432,  "PostgreSQL","Fake PostgreSQL server",         0.85),
    (5900,  "VNC",       "Fake VNC server",                0.85),
    (6379,  "Redis",     "Fake Redis server",              0.90),
    (8080,  "HTTP-Alt",  "Fake alternative web server",    0.70),
    (8443,  "HTTPS-Alt", "Fake alternative HTTPS",         0.70),
    (9200,  "Elasticsearch","Fake Elasticsearch",          0.85),
    (27017, "MongoDB",   "Fake MongoDB server",            0.85),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum HoneypotType {
    HoneyFile, HoneyCredential, HoneyToken, HoneyService,
    HoneyShare, HoneyDNS, HoneyUser, HoneyRegistry,
    Breadcrumb, CanaryToken,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum InteractionType {
    FileAccess, FileRead, FileDownload, CredentialUse, TokenUse,
    ServiceConnect, ServiceAuth, ShareEnumerate, ShareAccess,
    DNSResolve, UserEnumerate, UserLogin, RegistryRead, PortScan,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HoneypotTrigger {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub honeypot_type: HoneypotType,
    pub interaction_type: InteractionType,
    pub honeypot_name: String,
    pub honeypot_path: String,
    pub attacker_ip: String,
    pub attacker_user: String,
    pub attacker_process: String,
    pub attacker_user_agent: Option<String>,
    pub session_duration_secs: u64,
    pub data_accessed: Vec<String>,
    pub tools_detected: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AttackerProfile {
    pub id: String,
    pub source_ips: Vec<String>,
    pub usernames_tried: Vec<String>,
    pub tools_observed: Vec<String>,
    pub honeypots_triggered: Vec<String>,
    pub first_seen: i64,
    pub last_seen: i64,
    pub total_interactions: u64,
    pub techniques_observed: Vec<String>,
    pub risk_score: f64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct HoneypotStats {
    pub total_triggers: u64,
    pub unique_attackers: u64,
    pub file_triggers: u64,
    pub credential_triggers: u64,
    pub token_triggers: u64,
    pub service_triggers: u64,
    pub share_triggers: u64,
    pub dns_triggers: u64,
    pub user_triggers: u64,
    pub brute_force_detected: u64,
    pub high_risk_attackers: u64,
    pub deployed_honeypots: u64,
    pub active_honeypots: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HoneypotConfig {
    pub auto_block_on_trigger: bool,
    pub track_attacker_profiles: bool,
    pub brute_force_threshold: u64,
    pub high_risk_threshold: u64,
    pub alert_on_trigger: bool,
}

impl HoneypotConfig {
    pub fn default_config() -> Self {
        Self {
            auto_block_on_trigger: true,
            track_attacker_profiles: true,
            brute_force_threshold: BRUTE_FORCE_THRESHOLD,
            high_risk_threshold: HIGH_RISK_INTERACTION_COUNT,
            alert_on_trigger: true,
        }
    }
}

pub struct HoneypotEngine {
    // Breakthrough #1: HierarchicalState — O(log n) trigger history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<HoneypotStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, HoneypotTrigger>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, HoneypotStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — attacker behavior diffs
    attacker_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, HoneypotTrigger>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — attacker × honeypot matrix
    attacker_honeypot_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<HoneypotConfig>,
    /// Known attacker profiles
    attacker_profiles: RwLock<HashMap<String, AttackerProfile>>,
    /// Deployed honeypot registry
    deployed_honeypots: RwLock<HashMap<String, HoneypotType>>,
    stats: RwLock<HoneypotStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl HoneypotEngine {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(HONEY_CACHE_MAX)
            .with_metrics(metrics.clone(), "honeypot_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, HoneypotStats::default(),
            |acc: &mut HoneypotStats, rates: &[f64]| {
                for &r in rates { acc.total_triggers += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            attacker_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(HONEY_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            attacker_honeypot_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(HoneypotConfig::default_config()),
            attacker_profiles: RwLock::new(HashMap::new()),
            deployed_honeypots: RwLock::new(HashMap::new()),
            stats: RwLock::new(HoneypotStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("honeypot", MEMORY_BUDGET / 2);
        info!("HoneypotEngine started — {} file templates, {} cred templates, {} token templates, {} services",
            HONEY_FILE_TEMPLATES.len(), HONEY_CREDENTIAL_TEMPLATES.len(),
            HONEY_TOKEN_TEMPLATES.len(), HONEY_SERVICES.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("HoneypotEngine stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Deploy a honeypot resource.
    pub fn deploy_honeypot(&self, name: &str, honeypot_type: HoneypotType, path: &str) {
        self.deployed_honeypots.write().insert(name.to_string(), honeypot_type);
        self.stats.write().deployed_honeypots += 1;
        self.stats.write().active_honeypots += 1;
        info!("Deployed {:?} honeypot: {} at {}", honeypot_type, name, path);
    }

    /// Record a honeypot trigger event.
    pub fn record_trigger(
        &self, honeypot_name: &str, honeypot_path: &str,
        honeypot_type: HoneypotType, interaction: InteractionType,
        attacker_ip: &str, attacker_user: &str, attacker_process: &str,
        session_duration: u64, data_accessed: &[String],
    ) -> HoneypotTrigger {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);

        // Update stats
        {
            let mut s = self.stats.write();
            s.total_triggers += 1;
            match honeypot_type {
                HoneypotType::HoneyFile => s.file_triggers += 1,
                HoneypotType::HoneyCredential => s.credential_triggers += 1,
                HoneypotType::HoneyToken | HoneypotType::CanaryToken => s.token_triggers += 1,
                HoneypotType::HoneyService => s.service_triggers += 1,
                HoneypotType::HoneyShare => s.share_triggers += 1,
                HoneypotType::HoneyDNS => s.dns_triggers += 1,
                HoneypotType::HoneyUser => s.user_triggers += 1,
                _ => {}
            }
        }

        // Honeypot triggers are always high-confidence IOCs
        let confidence = 0.95;
        let severity = Severity::Critical;

        let mut indicators = vec![
            format!("Honeypot trigger: {:?} '{}' accessed", honeypot_type, honeypot_name),
            format!("Attacker: {} from {} via {}", attacker_user, attacker_ip, attacker_process),
        ];
        if session_duration > 0 {
            indicators.push(format!("Session duration: {}s", session_duration));
        }
        if !data_accessed.is_empty() {
            indicators.push(format!("Data accessed: {:?}", data_accessed));
        }

        let mitre_techniques = match honeypot_type {
            HoneypotType::HoneyFile => vec!["T1083".to_string()],
            HoneypotType::HoneyCredential => vec!["T1078".to_string()],
            HoneypotType::HoneyToken | HoneypotType::CanaryToken => vec!["T1078".to_string()],
            HoneypotType::HoneyService => vec!["T1046".to_string()],
            HoneypotType::HoneyShare => vec!["T1135".to_string()],
            HoneypotType::HoneyUser => vec!["T1087".to_string()],
            _ => vec!["T1083".to_string()],
        };

        // Update attacker profile
        {
            let mut profiles = self.attacker_profiles.write();
            let profile = profiles.entry(attacker_ip.to_string()).or_insert_with(|| AttackerProfile {
                id: uuid::Uuid::new_v4().to_string(),
                source_ips: vec![attacker_ip.to_string()],
                usernames_tried: vec![],
                tools_observed: vec![],
                honeypots_triggered: vec![],
                first_seen: now,
                last_seen: now,
                total_interactions: 0,
                techniques_observed: vec![],
                risk_score: 0.0,
            });
            profile.last_seen = now;
            profile.total_interactions += 1;
            if !profile.honeypots_triggered.contains(&honeypot_name.to_string()) {
                profile.honeypots_triggered.push(honeypot_name.to_string());
            }
            if !profile.usernames_tried.contains(&attacker_user.to_string()) {
                profile.usernames_tried.push(attacker_user.to_string());
            }
            profile.risk_score = (profile.total_interactions as f64 * 0.1
                + profile.honeypots_triggered.len() as f64 * 0.2).min(1.0);
            self.stats.write().unique_attackers = profiles.len() as u64;
        }

        // Update matrix
        let c = *self.attacker_honeypot_matrix.read()
            .get(&attacker_ip.to_string(), &honeypot_name.to_string());
        self.attacker_honeypot_matrix.write()
            .set(attacker_ip.to_string(), honeypot_name.to_string(), c + 1);

        let trigger = HoneypotTrigger {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, severity, confidence,
            honeypot_type, interaction_type: interaction,
            honeypot_name: honeypot_name.to_string(),
            honeypot_path: honeypot_path.to_string(),
            attacker_ip: attacker_ip.to_string(),
            attacker_user: attacker_user.to_string(),
            attacker_process: attacker_process.to_string(),
            attacker_user_agent: None,
            session_duration_secs: session_duration,
            data_accessed: data_accessed.to_vec(),
            tools_detected: vec![],
            indicators, mitre_techniques,
        };

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(confidence);

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(trigger.id.clone(), trigger.clone());
        self.recent_events.write().insert_with_priority(trigger.id.clone(), trigger.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.attacker_honeypot_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record attacker behavior diff
        self.attacker_diffs.write().record_insert(
            trigger.id.clone(),
            format!("{}:{}:{:?}:{}", attacker_ip, attacker_user, honeypot_type, honeypot_name),
        );
        // Breakthrough #592: DedupStore — deduplicate repeated triggers
        self.event_dedup.write().insert(
            trigger.id.clone(),
            format!("{}:{}:{:?}", attacker_ip, honeypot_name, honeypot_type).into_bytes(),
        );

        // Check for brute force / high-risk attacker
        let config = self.config.read().clone();
        let profile_interactions = {
            let profiles = self.attacker_profiles.read();
            profiles.get(attacker_ip).map(|p| p.total_interactions).unwrap_or(0)
        };
        if profile_interactions >= config.brute_force_threshold {
            self.stats.write().brute_force_detected += 1;
        }
        if profile_interactions >= config.high_risk_threshold {
            self.stats.write().high_risk_attackers += 1;
        }

        warn!("HONEYPOT TRIGGER: {:?} '{}' by {} from {} (interaction #{})",
            honeypot_type, honeypot_name, attacker_user, attacker_ip, profile_interactions);
        trigger
    }

    /// Check if an IP is a known attacker
    pub fn is_known_attacker(&self, ip: &str) -> bool {
        self.attacker_profiles.read().contains_key(ip)
    }

    pub fn get_attacker_profile(&self, ip: &str) -> Option<AttackerProfile> {
        self.attacker_profiles.read().get(ip).cloned()
    }

    /// Detect attacker tools from user-agent or process name
    fn detect_attacker_tools(user_agent: &str, process: &str) -> Vec<String> {
        let ua_lower = user_agent.to_lowercase();
        let proc_lower = process.to_lowercase();
        let mut tools = Vec::new();
        for &(sig, _risk, desc) in ATTACKER_TOOL_SIGNATURES {
            if ua_lower.contains(sig) || proc_lower.contains(sig) {
                tools.push(format!("{}: {}", sig, desc));
            }
        }
        tools
    }

    /// Build a MalwareAlert from a HoneypotTrigger
    fn build_alert(&self, trigger: &HoneypotTrigger) -> MalwareAlert {
        MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: trigger.timestamp,
            severity: trigger.severity,
            module: "honeypot_engine".to_string(),
            title: format!("Honeypot trigger: {:?} '{}'",
                trigger.honeypot_type, trigger.honeypot_name),
            details: format!(
                "Honeypot {:?} '{}' at '{}' was accessed by {} from {} via {}. \
                 Interaction: {:?}. Session: {}s. Data accessed: {:?}. Tools: {:?}. \
                 Confidence: {:.0}%.",
                trigger.honeypot_type, trigger.honeypot_name,
                trigger.honeypot_path,
                trigger.attacker_user, trigger.attacker_ip,
                trigger.attacker_process,
                trigger.interaction_type,
                trigger.session_duration_secs,
                trigger.data_accessed,
                trigger.tools_detected,
                trigger.confidence * 100.0,
            ),
            path: Some(trigger.honeypot_path.clone()),
            process_name: Some(trigger.attacker_process.clone()),
            process_pid: None,
            verdict: None,
            mitre_ids: trigger.mitre_techniques.clone(),
            remediation: vec![format!("Block attacker IP {}", trigger.attacker_ip)],
            confidence: trigger.confidence,
        }
    }

    /// Extended trigger recording that also detects tools and builds alerts.
    pub fn record_trigger_extended(
        &self, honeypot_name: &str, honeypot_path: &str,
        honeypot_type: HoneypotType, interaction: InteractionType,
        attacker_ip: &str, attacker_user: &str, attacker_process: &str,
        session_duration: u64, data_accessed: &[String],
        user_agent: &str,
    ) -> HoneypotTrigger {
        let mut trigger = self.record_trigger(
            honeypot_name, honeypot_path, honeypot_type, interaction,
            attacker_ip, attacker_user, attacker_process,
            session_duration, data_accessed,
        );

        // Detect attacker tools
        let tools = Self::detect_attacker_tools(user_agent, attacker_process);
        if !tools.is_empty() {
            trigger.tools_detected = tools.clone();
            for tool in &tools {
                trigger.indicators.push(format!("Attacker tool: {}", tool));
            }
            // Update attacker profile with observed tools
            let mut profiles = self.attacker_profiles.write();
            if let Some(profile) = profiles.get_mut(attacker_ip) {
                for tool in &tools {
                    if !profile.tools_observed.contains(tool) {
                        profile.tools_observed.push(tool.clone());
                    }
                }
            }
        }

        // Set user agent
        if !user_agent.is_empty() {
            trigger.attacker_user_agent = Some(user_agent.to_string());
        }

        // Build and queue alert
        let alert = self.build_alert(&trigger);
        let mut alerts = self.alerts.write();
        if alerts.len() >= MAX_EVENTS_QUEUE { alerts.pop_front(); }
        alerts.push_back(alert);

        trigger
    }

    /// Deploy a set of default honeypots across common paths.
    pub fn deploy_default_honeypots(&self) {
        for &(filename, desc, value) in HONEY_FILE_TEMPLATES {
            let path = format!("/opt/honeypots/{}", filename);
            self.deploy_honeypot(filename, HoneypotType::HoneyFile, &path);
        }
        info!("Deployed {} default honey file templates", HONEY_FILE_TEMPLATES.len());
    }

    /// Deploy honey credentials for a set of services.
    pub fn deploy_honey_credentials(&self) {
        for &(username, service, role, _value) in HONEY_CREDENTIAL_TEMPLATES {
            let name = format!("cred_{}_{}", username, service);
            self.deploy_honeypot(&name, HoneypotType::HoneyCredential, service);
        }
        info!("Deployed {} honey credential templates", HONEY_CREDENTIAL_TEMPLATES.len());
    }

    /// Get all attacker profiles sorted by risk score (descending).
    pub fn top_attackers(&self, limit: usize) -> Vec<AttackerProfile> {
        let profiles = self.attacker_profiles.read();
        let mut sorted: Vec<AttackerProfile> = profiles.values().cloned().collect();
        sorted.sort_by(|a, b| b.risk_score.partial_cmp(&a.risk_score).unwrap_or(std::cmp::Ordering::Equal));
        sorted.truncate(limit);
        sorted
    }

    /// Drain all pending alerts.
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        let mut alerts = self.alerts.write();
        alerts.drain(..).collect()
    }

    pub fn update_config(&self, config: HoneypotConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> HoneypotStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
