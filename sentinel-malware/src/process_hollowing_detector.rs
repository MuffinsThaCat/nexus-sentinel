//! Module 154: ProcessHollowingDetector — Process Hollowing, Ghosting & Doppelgänging Detection
//!
//! Detects advanced process manipulation techniques used to execute malicious
//! code under the guise of legitimate processes on macOS. These techniques
//! bypass security tools that rely on process names, paths, or code signing
//! for allowlisting.
//!
//! ## Detection Capabilities
//!
//! ### Process Hollowing (RunPE)
//! - **Classic hollowing**: Launching a legitimate process in suspended state,
//!   unmapping its memory, and replacing with malicious code before resuming
//! - **Section hollowing**: Replacing specific PE/Mach-O sections rather than
//!   entire image to maintain partial legitimacy
//! - **Thread context manipulation**: Detecting modified thread entry points
//!   that differ from the expected image entry point
//! - **Memory permission anomalies**: RWX memory in processes that shouldn't
//!   have it, or code pages that differ from on-disk image
//!
//! ### Process Doppelgänging
//! - **NTFS transaction abuse** (Windows-adapted patterns): Creating transacted
//!   files that are rolled back after process creation
//! - **macOS equivalent**: Using APFS copy-on-write semantics to create
//!   temporary modified images that are cleaned up post-launch
//! - **File-backed memory mismatch**: Process image in memory differs from
//!   the file on disk (indicating post-load modification or transacted write)
//!
//! ### Process Ghosting
//! - **Delete-pending file execution**: Marking a file for deletion while
//!   it's still mapped into a process, then executing it
//! - **macOS adaptation**: Using unlink-while-open to execute files that
//!   are immediately deleted from the filesystem
//! - **Phantom process detection**: Running processes whose backing files
//!   no longer exist on disk
//!
//! ### Process Herpaderping
//! - **Post-mapping file modification**: Modifying the on-disk file after
//!   it's been mapped into memory, so disk-based scanners see different
//!   content than what's actually executing
//! - **Hash mismatch detection**: Process memory hash differs from the
//!   on-disk file hash
//!
//! ### Dylib Proxying & Injection (macOS-Specific)
//! - **DYLD_INSERT_LIBRARIES**: Detecting dylib injection via environment
//!   variable in hollowed processes
//! - **dylib proxying**: Legitimate dylibs replaced with malicious versions
//!   that forward calls to the original
//! - **LC_LOAD_DYLIB manipulation**: Modified load commands in Mach-O headers
//!   of running processes
//! - **Interposing abuse**: DYLD_INTERPOSE used to redirect function calls
//!
//! ### Thread Execution Hijacking
//! - **Thread context modification**: Changing thread instruction pointers
//!   to redirect execution to injected code
//! - **APC-like injection**: macOS equivalent of Asynchronous Procedure Call
//!   injection via Mach threads
//! - **Exception handler hijacking**: Modifying exception ports for code
//!   execution redirection
//!
//! ### Detection Methods
//! - **Memory vs disk comparison**: Hash comparison of in-memory process
//!   image against on-disk executable
//! - **Entry point verification**: Verifying thread entry points match
//!   expected Mach-O header values
//! - **Code signing verification**: Runtime code signature validation of
//!   running processes
//! - **Memory permission analysis**: Detecting unusual RWX pages or
//!   modified code pages
//! - **Process lineage analysis**: Parent-child relationship anomalies
//! - **Backing file verification**: Checking that process backing files
//!   exist and match expectations
//!
//! ## MITRE ATT&CK: T1055.012, T1055.013, T1055.003, T1036.005
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

// ── Process Hollowing Indicators ─────────────────────────────────────────────

const HOLLOWING_INDICATORS: &[(&str, &str, &str, f64)] = &[
    // Classic hollowing
    ("memory_disk_hash_mismatch", "Process memory hash differs from on-disk executable", "T1055.012", 0.9),
    ("entry_point_mismatch", "Thread entry point differs from Mach-O LC_MAIN", "T1055.012", 0.95),
    ("text_segment_modified", "__TEXT segment in memory differs from disk", "T1055.012", 0.95),
    ("code_pages_writable", "Code pages have write permission (should be R-X)", "T1055.012", 0.85),
    ("rwx_memory_region", "RWX memory region in process (code injection)", "T1055.012", 0.8),
    ("suspended_child_resume", "Child process created suspended then memory modified before resume", "T1055.012", 0.9),
    ("vm_remap_code_region", "vm_remap used to replace code region", "T1055.012", 0.9),
    ("mach_vm_write_text", "mach_vm_write targeting __TEXT segment", "T1055.012", 0.95),
    ("task_for_pid_code_inject", "task_for_pid followed by memory write to code region", "T1055.012", 0.9),
    // Section-level
    ("section_size_mismatch", "Mach-O section size in memory differs from file", "T1055.012", 0.85),
    ("load_command_mismatch", "Load commands in memory differ from on-disk binary", "T1055.012", 0.9),
    ("segment_flags_modified", "Segment flags modified in running process", "T1055.012", 0.85),
    ("dyld_image_modified", "dyld-loaded image modified in memory post-load", "T1055.012", 0.85),
];

// ── Process Ghosting Indicators ──────────────────────────────────────────────

const GHOSTING_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("backing_file_missing", "Process backing file no longer exists on disk", "T1055.012", 0.9),
    ("unlinked_while_running", "Process executable was unlinked while running", "T1055.012", 0.85),
    ("phantom_process", "Running process with no corresponding file on disk", "T1055.012", 0.9),
    ("delete_before_close", "File deleted immediately after being mapped for execution", "T1055.012", 0.85),
    ("temp_execute_delete", "Executable created in /tmp, launched, then deleted", "T1055.012", 0.8),
    ("memfd_execute", "In-memory execution without file backing", "T1055.012", 0.85),
    ("fd_execute_no_path", "Process executed from file descriptor with no filesystem path", "T1055.012", 0.9),
];

// ── Process Herpaderping Indicators ──────────────────────────────────────────

const HERPADERPING_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("post_map_modification", "On-disk file modified after being mapped into process", "T1036.005", 0.9),
    ("file_hash_changed_post_exec", "File hash changed after process started executing", "T1036.005", 0.9),
    ("content_overwrite_post_launch", "File content overwritten with benign data post-launch", "T1036.005", 0.95),
    ("file_truncated_post_exec", "File truncated after being loaded", "T1036.005", 0.85),
    ("rename_after_exec", "Executable renamed after process start", "T1036.005", 0.7),
    ("signature_mismatch_runtime", "Runtime code signature doesn't match disk file signature", "T1036.005", 0.9),
];

// ── Dylib Injection & Proxying ───────────────────────────────────────────────

const DYLIB_INJECTION_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("dyld_insert_libraries", "DYLD_INSERT_LIBRARIES set for process", "T1055.001", 0.7),
    ("dyld_force_flat_namespace", "DYLD_FORCE_FLAT_NAMESPACE set (symbol hijacking)", "T1055.001", 0.75),
    ("dyld_library_path_hijack", "DYLD_LIBRARY_PATH points to non-standard location", "T1055.001", 0.7),
    ("dylib_proxy_detected", "Dylib proxy: forwards to real dylib after injection", "T1055.001", 0.85),
    ("lc_load_dylib_modified", "LC_LOAD_DYLIB load command modified in running process", "T1055.001", 0.9),
    ("unsigned_dylib_loaded", "Unsigned dylib loaded into signed process", "T1055.001", 0.8),
    ("dylib_rpath_manipulation", "Dylib @rpath/@loader_path manipulation", "T1055.001", 0.7),
    ("interpose_section_present", "__DATA,__interpose section detected (function interposition)", "T1055.001", 0.75),
    ("dyld_interpose_active", "DYLD interposing active in process", "T1055.001", 0.75),
    ("weak_dylib_replacement", "Weak-linked dylib replaced with malicious version", "T1055.001", 0.8),
    ("framework_hijack", "macOS framework hijacked (non-Apple path)", "T1055.001", 0.8),
];

// ── Thread Hijacking Indicators ──────────────────────────────────────────────

const THREAD_HIJACK_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("thread_set_state_remote", "thread_set_state on remote thread (execution hijack)", "T1055.003", 0.9),
    ("thread_create_running_remote", "thread_create_running in remote task", "T1055.003", 0.9),
    ("exception_port_hijack", "Exception port modified for code execution redirect", "T1055.003", 0.85),
    ("thread_entry_non_image", "Thread entry point outside any mapped image", "T1055.003", 0.9),
    ("thread_entry_in_rwx", "Thread entry point in RWX memory region", "T1055.003", 0.85),
    ("mach_thread_suspend_inject", "Thread suspended, context modified, then resumed", "T1055.003", 0.9),
    ("thread_stack_pivot", "Thread stack pointer modified (stack pivot)", "T1055.003", 0.9),
];

// ── Process Lineage Anomalies ────────────────────────────────────────────────

const LINEAGE_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("unusual_parent", "Process has unexpected parent (re-parenting)", "T1036.005", 0.6),
    ("launchd_unexpected_child", "Unexpected process spawned directly by launchd", "T1036.005", 0.5),
    ("system_process_wrong_path", "System process name but running from non-system path", "T1036.005", 0.85),
    ("system_process_wrong_uid", "System process running as non-expected user", "T1036.005", 0.8),
    ("duplicate_system_process", "Duplicate of normally-singleton system process", "T1036.005", 0.8),
    ("apple_binary_unsigned", "Process claiming to be Apple binary but unsigned", "T1036.005", 0.95),
    ("code_directory_hash_mismatch", "Code Directory hash doesn't match running code", "T1036.005", 0.9),
    ("entitlements_unexpected", "Process has unexpected entitlements (injection artifact)", "T1036.005", 0.7),
    ("ad_hoc_signed_system_path", "Ad-hoc signed binary in system path", "T1036.005", 0.85),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum HollowingThreatType {
    // Classic hollowing
    MemoryDiskMismatch,
    EntryPointMismatch,
    TextSegmentModified,
    CodePagesWritable,
    RWXMemory,
    SuspendedChildModify,
    VMRemapCodeRegion,
    MachVMWriteText,
    TaskForPidInject,
    LoadCommandMismatch,
    // Ghosting
    BackingFileMissing,
    PhantomProcess,
    UnlinkedWhileRunning,
    TempExecuteDelete,
    MemFDExecute,
    // Herpaderping
    PostMapModification,
    FileHashChangedPostExec,
    ContentOverwritePostLaunch,
    SignatureMismatchRuntime,
    // Dylib injection
    DYLDInsertLibraries,
    DylibProxy,
    LCLoadDylibModified,
    UnsignedDylibLoaded,
    DylibRpathManipulation,
    InterposeSection,
    FrameworkHijack,
    WeakDylibReplacement,
    // Thread hijacking
    ThreadSetStateRemote,
    ThreadCreateRemote,
    ExceptionPortHijack,
    ThreadEntryNonImage,
    ThreadEntryRWX,
    ThreadStackPivot,
    // Lineage
    SystemProcessWrongPath,
    SystemProcessWrongUID,
    DuplicateSystemProcess,
    AppleBinaryUnsigned,
    CodeDirectoryMismatch,
    UnexpectedEntitlements,
    AdHocSignedSystemPath,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HollowingFinding {
    pub threat_type: HollowingThreatType,
    pub confidence: f64,
    pub description: String,
    pub target_process: Option<String>,
    pub target_pid: Option<u32>,
    pub source_pid: Option<u32>,
    pub expected_hash: Option<String>,
    pub actual_hash: Option<String>,
    pub expected_path: Option<String>,
    pub actual_path: Option<String>,
    pub memory_address: Option<String>,
    pub memory_permissions: Option<String>,
    pub injected_dylib: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HollowingEvent {
    pub event_type: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub process_path: Option<String>,
    pub parent_pid: Option<u32>,
    pub parent_name: Option<String>,
    pub expected_hash: Option<String>,
    pub actual_memory_hash: Option<String>,
    pub backing_file_exists: Option<bool>,
    pub code_signed: Option<bool>,
    pub code_sign_valid: Option<bool>,
    pub is_apple_binary: Option<bool>,
    pub dylibs_loaded: Vec<String>,
    pub environment_vars: Vec<String>,
    pub memory_regions: Vec<String>,   // "addr:perms:size:backing"
    pub thread_entry_points: Vec<String>,
    pub integrity_check: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HollowingAnalysisResult {
    pub is_hollowed: bool,
    pub events_analyzed: u32,
    pub findings: Vec<HollowingFinding>,
    pub technique_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct HollowingScanStats {
    pub total_events: u64,
    pub hollowing_detections: u64,
    pub ghosting_detections: u64,
    pub herpaderping_detections: u64,
    pub dylib_injection_detections: u64,
    pub thread_hijack_detections: u64,
    pub lineage_anomalies: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HollowingSigEntry { pub pattern: String, pub technique: String, pub severity: f64 }

pub struct ProcessHollowingDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<HollowingScanStats>>,
    result_cache: TieredCache<String, HollowingAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    hollow_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, HollowingScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, HollowingAnalysisResult>>,
    sig_db: PagedMemory<HollowingSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<HollowingScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl ProcessHollowingDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            hollow_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, HollowingScanStats::default(),
                |acc: &mut HollowingScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(HollowingScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &HollowingEvent) -> Option<HollowingAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let pid = event.process_pid.unwrap_or(0);
        let cache_key = format!("hollow:{}:{}:{}", event.event_type, pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        let ind_text = format!("{} {}",
            event.event_type, event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. Hollowing indicators ─────────────────────────────────────
        for &(pattern, desc, mitre, conf) in HOLLOWING_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "memory_disk_hash_mismatch" => HollowingThreatType::MemoryDiskMismatch,
                    "entry_point_mismatch" => HollowingThreatType::EntryPointMismatch,
                    "text_segment_modified" => HollowingThreatType::TextSegmentModified,
                    "code_pages_writable" => HollowingThreatType::CodePagesWritable,
                    "rwx_memory_region" => HollowingThreatType::RWXMemory,
                    p if p.contains("suspended") => HollowingThreatType::SuspendedChildModify,
                    p if p.contains("vm_remap") => HollowingThreatType::VMRemapCodeRegion,
                    p if p.contains("mach_vm_write") => HollowingThreatType::MachVMWriteText,
                    p if p.contains("task_for_pid") => HollowingThreatType::TaskForPidInject,
                    p if p.contains("load_command") => HollowingThreatType::LoadCommandMismatch,
                    _ => HollowingThreatType::MemoryDiskMismatch,
                };
                findings.push(HollowingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: event.parent_pid,
                    expected_hash: event.expected_hash.clone(),
                    actual_hash: event.actual_memory_hash.clone(),
                    expected_path: None, actual_path: event.process_path.clone(),
                    memory_address: None, memory_permissions: None, injected_dylib: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("ProcessHollowing".to_string());
            }
        }

        // Direct hash mismatch check
        if let (Some(ref expected), Some(ref actual)) = (&event.expected_hash, &event.actual_memory_hash) {
            if expected != actual {
                findings.push(HollowingFinding {
                    threat_type: HollowingThreatType::MemoryDiskMismatch,
                    confidence: 0.9,
                    description: format!("Memory hash {} != disk hash {} for pid {}",
                        &actual[..8.min(actual.len())], &expected[..8.min(expected.len())], pid),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: None, expected_hash: Some(expected.clone()),
                    actual_hash: Some(actual.clone()),
                    expected_path: None, actual_path: event.process_path.clone(),
                    memory_address: None, memory_permissions: None, injected_dylib: None,
                    mitre_id: "T1055.012".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1055.012".into());
                categories.insert("ProcessHollowing".to_string());
            }
        }

        // ── 2. Ghosting indicators ──────────────────────────────────────
        for &(pattern, desc, mitre, conf) in GHOSTING_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "backing_file_missing" | "phantom_process" => HollowingThreatType::PhantomProcess,
                    "unlinked_while_running" | "delete_before_close" => HollowingThreatType::UnlinkedWhileRunning,
                    "temp_execute_delete" => HollowingThreatType::TempExecuteDelete,
                    "memfd_execute" | "fd_execute_no_path" => HollowingThreatType::MemFDExecute,
                    _ => HollowingThreatType::BackingFileMissing,
                };
                findings.push(HollowingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: None, expected_hash: None, actual_hash: None,
                    expected_path: event.process_path.clone(), actual_path: None,
                    memory_address: None, memory_permissions: None, injected_dylib: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("ProcessGhosting".to_string());
            }
        }

        // Backing file check
        if let Some(false) = event.backing_file_exists {
            findings.push(HollowingFinding {
                threat_type: HollowingThreatType::PhantomProcess,
                confidence: 0.9,
                description: format!("Phantom process: pid {} ({:?}) has no backing file",
                    pid, event.process_name),
                target_process: event.process_name.clone(), target_pid: event.process_pid,
                source_pid: None, expected_hash: None, actual_hash: None,
                expected_path: event.process_path.clone(), actual_path: None,
                memory_address: None, memory_permissions: None, injected_dylib: None,
                mitre_id: "T1055.012".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1055.012".into());
            categories.insert("ProcessGhosting".to_string());
        }

        // ── 3. Herpaderping indicators ──────────────────────────────────
        for &(pattern, desc, mitre, conf) in HERPADERPING_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "post_map_modification" | "file_hash_changed_post_exec" => HollowingThreatType::PostMapModification,
                    "content_overwrite_post_launch" | "file_truncated_post_exec" => HollowingThreatType::ContentOverwritePostLaunch,
                    "signature_mismatch_runtime" => HollowingThreatType::SignatureMismatchRuntime,
                    _ => HollowingThreatType::FileHashChangedPostExec,
                };
                findings.push(HollowingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: None, expected_hash: event.expected_hash.clone(),
                    actual_hash: event.actual_memory_hash.clone(),
                    expected_path: None, actual_path: event.process_path.clone(),
                    memory_address: None, memory_permissions: None, injected_dylib: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("Herpaderping".to_string());
            }
        }

        // ── 4. Dylib injection indicators ───────────────────────────────
        for &(pattern, desc, mitre, conf) in DYLIB_INJECTION_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) ||
               event.environment_vars.iter().any(|v| v.to_lowercase().contains(&pattern.to_lowercase())) {
                let tt = match pattern {
                    "dyld_insert_libraries" => HollowingThreatType::DYLDInsertLibraries,
                    "dylib_proxy_detected" => HollowingThreatType::DylibProxy,
                    "lc_load_dylib_modified" => HollowingThreatType::LCLoadDylibModified,
                    "unsigned_dylib_loaded" => HollowingThreatType::UnsignedDylibLoaded,
                    p if p.contains("rpath") || p.contains("library_path") => HollowingThreatType::DylibRpathManipulation,
                    p if p.contains("interpose") => HollowingThreatType::InterposeSection,
                    p if p.contains("framework") => HollowingThreatType::FrameworkHijack,
                    p if p.contains("weak") => HollowingThreatType::WeakDylibReplacement,
                    _ => HollowingThreatType::DYLDInsertLibraries,
                };
                findings.push(HollowingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: None, expected_hash: None, actual_hash: None,
                    expected_path: None, actual_path: event.process_path.clone(),
                    memory_address: None, memory_permissions: None,
                    injected_dylib: event.dylibs_loaded.first().cloned(),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("DylibInjection".to_string());
            }
        }

        // ── 5. Thread hijacking indicators ──────────────────────────────
        for &(pattern, desc, mitre, conf) in THREAD_HIJACK_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "thread_set_state_remote" => HollowingThreatType::ThreadSetStateRemote,
                    "thread_create_running_remote" => HollowingThreatType::ThreadCreateRemote,
                    "exception_port_hijack" => HollowingThreatType::ExceptionPortHijack,
                    "thread_entry_non_image" => HollowingThreatType::ThreadEntryNonImage,
                    "thread_entry_in_rwx" => HollowingThreatType::ThreadEntryRWX,
                    "thread_stack_pivot" | "mach_thread_suspend_inject" => HollowingThreatType::ThreadStackPivot,
                    _ => HollowingThreatType::ThreadSetStateRemote,
                };
                findings.push(HollowingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: event.parent_pid,
                    expected_hash: None, actual_hash: None,
                    expected_path: None, actual_path: None,
                    memory_address: None, memory_permissions: None, injected_dylib: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("ThreadHijack".to_string());
            }
        }

        // ── 6. Process lineage anomalies ────────────────────────────────
        for &(pattern, desc, mitre, conf) in LINEAGE_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "system_process_wrong_path" => HollowingThreatType::SystemProcessWrongPath,
                    "system_process_wrong_uid" => HollowingThreatType::SystemProcessWrongUID,
                    "duplicate_system_process" => HollowingThreatType::DuplicateSystemProcess,
                    "apple_binary_unsigned" => HollowingThreatType::AppleBinaryUnsigned,
                    "code_directory_hash_mismatch" => HollowingThreatType::CodeDirectoryMismatch,
                    "entitlements_unexpected" => HollowingThreatType::UnexpectedEntitlements,
                    "ad_hoc_signed_system_path" => HollowingThreatType::AdHocSignedSystemPath,
                    _ => HollowingThreatType::SystemProcessWrongPath,
                };
                findings.push(HollowingFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    target_process: event.process_name.clone(), target_pid: event.process_pid,
                    source_pid: event.parent_pid, expected_hash: None, actual_hash: None,
                    expected_path: None, actual_path: event.process_path.clone(),
                    memory_address: None, memory_permissions: None, injected_dylib: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("LineageAnomaly".to_string());
            }
        }

        // Code signing validation
        if let (Some(true), Some(false)) = (event.is_apple_binary, event.code_sign_valid) {
            findings.push(HollowingFinding {
                threat_type: HollowingThreatType::AppleBinaryUnsigned,
                confidence: 0.95,
                description: format!("Apple binary {:?} has invalid code signature", event.process_name),
                target_process: event.process_name.clone(), target_pid: event.process_pid,
                source_pid: None, expected_hash: None, actual_hash: None,
                expected_path: None, actual_path: event.process_path.clone(),
                memory_address: None, memory_permissions: None, injected_dylib: None,
                mitre_id: "T1036.005".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1036.005".into());
            categories.insert("LineageAnomaly".to_string());
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},pid={},findings={}", event.event_type, pid, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_hollowed = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = HollowingAnalysisResult {
            is_hollowed, events_analyzed: 1, findings,
            technique_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_hollowed {
                s.hollowing_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        HollowingThreatType::PhantomProcess | HollowingThreatType::BackingFileMissing |
                        HollowingThreatType::UnlinkedWhileRunning | HollowingThreatType::TempExecuteDelete |
                        HollowingThreatType::MemFDExecute => s.ghosting_detections += 1,
                        HollowingThreatType::PostMapModification | HollowingThreatType::FileHashChangedPostExec |
                        HollowingThreatType::ContentOverwritePostLaunch | HollowingThreatType::SignatureMismatchRuntime =>
                            s.herpaderping_detections += 1,
                        HollowingThreatType::DYLDInsertLibraries | HollowingThreatType::DylibProxy |
                        HollowingThreatType::LCLoadDylibModified | HollowingThreatType::UnsignedDylibLoaded |
                        HollowingThreatType::DylibRpathManipulation | HollowingThreatType::InterposeSection |
                        HollowingThreatType::FrameworkHijack | HollowingThreatType::WeakDylibReplacement =>
                            s.dylib_injection_detections += 1,
                        HollowingThreatType::ThreadSetStateRemote | HollowingThreatType::ThreadCreateRemote |
                        HollowingThreatType::ExceptionPortHijack | HollowingThreatType::ThreadEntryNonImage |
                        HollowingThreatType::ThreadEntryRWX | HollowingThreatType::ThreadStackPivot =>
                            s.thread_hijack_detections += 1,
                        HollowingThreatType::SystemProcessWrongPath | HollowingThreatType::SystemProcessWrongUID |
                        HollowingThreatType::DuplicateSystemProcess | HollowingThreatType::AppleBinaryUnsigned |
                        HollowingThreatType::CodeDirectoryMismatch | HollowingThreatType::AdHocSignedSystemPath =>
                            s.lineage_anomalies += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_hollowed {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "process_hollowing_detector".into(),
                title: format!("PROCESS MANIPULATION: {} ({:?} pid {})",
                    result.technique_categories.join(", "),
                    event.process_name, pid),
                details: format!("Risk {:.1}%, {} findings, techniques: {}",
                    risk_score * 100.0, result.findings.len(),
                    result.technique_categories.join(", ")),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the hollowed/injected process: kill -9 <pid>".into(),
                    "Dump process memory for analysis: vmmap <pid>".into(),
                    "Verify code signature: codesign -dvvv <path>".into(),
                    "Check loaded dylibs: DYLD_PRINT_LIBRARIES=1".into(),
                    "Inspect parent process: ps -o ppid= -p <pid>".into(),
                    "Check for DYLD_INSERT_LIBRARIES: ps eww -p <pid>".into(),
                    "Scan disk binary with malware scanner".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[HollowingFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                HollowingThreatType::EntryPointMismatch | HollowingThreatType::TextSegmentModified => 1.8,
                HollowingThreatType::MachVMWriteText | HollowingThreatType::VMRemapCodeRegion => 1.7,
                HollowingThreatType::AppleBinaryUnsigned | HollowingThreatType::CodeDirectoryMismatch => 1.7,
                HollowingThreatType::MemoryDiskMismatch => 1.6,
                HollowingThreatType::ContentOverwritePostLaunch | HollowingThreatType::SignatureMismatchRuntime => 1.6,
                HollowingThreatType::PhantomProcess | HollowingThreatType::MemFDExecute => 1.5,
                HollowingThreatType::ThreadSetStateRemote | HollowingThreatType::ThreadCreateRemote => 1.5,
                HollowingThreatType::ThreadStackPivot | HollowingThreatType::ThreadEntryNonImage => 1.5,
                HollowingThreatType::SuspendedChildModify => 1.5,
                HollowingThreatType::LCLoadDylibModified => 1.4,
                HollowingThreatType::DylibProxy | HollowingThreatType::FrameworkHijack => 1.3,
                HollowingThreatType::SystemProcessWrongPath | HollowingThreatType::DuplicateSystemProcess => 1.3,
                HollowingThreatType::RWXMemory | HollowingThreatType::CodePagesWritable => 1.2,
                HollowingThreatType::DYLDInsertLibraries => 1.0,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> HollowingScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
