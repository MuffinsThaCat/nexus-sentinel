//! Module 71: DNSTunnelDetector — DNS Tunneling & Exfiltration Detection
//!
//! World-class DNS traffic analysis engine that detects covert data channels
//! tunneled through DNS queries. Identifies C2 communication, data exfiltration,
//! and DNS-based evasion techniques by analyzing query entropy, subdomain length,
//! record type distribution, query frequency, and payload encoding patterns.
//!
//! ## Features
//!
//! - **Shannon entropy analysis**: Measures per-label and full-FQDN entropy to
//!   detect base32/base64/hex encoded payloads in subdomain labels
//! - **Label length profiling**: Statistical deviation from normal subdomain label
//!   lengths (mean ~8 chars) — tunneling labels average 30-60+ chars
//! - **Query frequency analysis**: Per-domain query rate with sliding window —
//!   DNS tunnels generate 10-100× normal query volume for a single domain
//! - **Record type distribution**: Monitors TXT, NULL, CNAME, MX, AAAA record
//!   type ratios — tunneling heavily favors TXT and NULL types
//! - **Unique subdomain ratio**: Tracks unique-subdomain-per-domain ratio —
//!   tunneling domains have near 100% unique subdomains (each query = new data)
//! - **N-gram frequency analysis**: Character n-gram distribution compared to
//!   natural language — encoded data has flatter n-gram distribution
//! - **Known tunnel tool signatures**: Pattern matching for iodine, dnscat2,
//!   dns2tcp, Cobalt Strike DNS, SUNBURST-style domain generation
//! - **Response payload analysis**: Detects oversized TXT records and encoded
//!   response payloads carrying tunneled data back from C2
//! - **NXDOMAIN ratio**: High NXDOMAIN response rate indicates domain generation
//!   algorithm (DGA) or failed tunnel negotiation
//! - **TTL anomaly detection**: Abnormally low TTLs on tunnel domains to prevent
//!   caching and ensure every query reaches the authoritative server
//! - **DNS-over-HTTPS (DoH) detection**: Identifies DoH connections to known
//!   resolvers that bypass local DNS monitoring
//! - **Slow drip exfiltration**: Detects low-and-slow DNS exfiltration spread
//!   across hours with low per-minute query rates but high cumulative data
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) DNS tunnel detection history
//! - **#2  TieredCache** — Hot/warm/cold cache for DNS query analysis
//! - **#3  ReversibleComputation** — Recompute tunnel confidence scores
//! - **#5  StreamAccumulator** — Streaming per-domain query rate
//! - **#6  MemoryMetrics** — Bounded memory for all DNS data
//! - **#461 DifferentialStore** — Track DNS pattern diffs between intervals
//! - **#569 PruningMap** — Auto-expire old DNS events beyond retention
//! - **#592 DedupStore** — Deduplicate identical DNS alert patterns
//! - **#627 SparseMatrix** — Domain × record-type frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1071.004 — Application Layer Protocol: DNS
//! - T1048.003 — Exfiltration Over Alternative Protocol: DNS
//! - T1568.002 — Dynamic Resolution: Domain Generation Algorithms
//! - T1572 — Protocol Tunneling
//! - T1090.003 — Proxy: Multi-hop Proxy (DNS relay)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Tunables ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const DNS_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 20 * 1024 * 1024;
/// Shannon entropy threshold for encoded subdomain labels
const ENTROPY_THRESHOLD: f64 = 3.5;
/// Maximum normal subdomain label length (characters)
const NORMAL_LABEL_MAX: usize = 15;
/// Tunnel label length threshold
const TUNNEL_LABEL_LENGTH: usize = 30;
/// Queries per minute per domain before frequency alert
const QUERY_RATE_THRESHOLD: u64 = 60;
/// Unique subdomain ratio threshold (0.0–1.0)
const UNIQUE_SUBDOMAIN_RATIO_THRESHOLD: f64 = 0.90;
/// Minimum queries to a domain before analysis kicks in
const MIN_QUERIES_FOR_ANALYSIS: u64 = 10;
/// NXDOMAIN ratio threshold for DGA detection
const NXDOMAIN_RATIO_THRESHOLD: f64 = 0.30;
/// TTL threshold (seconds) — below this is suspicious
const LOW_TTL_THRESHOLD: u32 = 10;
/// Maximum tracked domains
const MAX_TRACKED_DOMAINS: usize = 8192;
/// Slow drip: minimum data bytes over 1 hour to flag
const SLOW_DRIP_BYTE_THRESHOLD: u64 = 10_000;

// ── DNS Record Types ────────────────────────────────────────────────────────

/// DNS record types commonly used for tunneling, with suspicion weight
const TUNNEL_RECORD_TYPES: &[(&str, f64)] = &[
    ("TXT",   0.8),   // Most common tunnel type — arbitrary text data
    ("NULL",  0.9),   // Rarely legitimate — ideal for raw binary
    ("CNAME", 0.5),   // Moderate — limited data per response
    ("MX",    0.6),   // Unusual for tunneling but possible
    ("AAAA",  0.4),   // 128 bits per record — slow tunnel
    ("A",     0.2),   // 32 bits per record — very slow tunnel
    ("SRV",   0.5),   // Service records — moderate tunnel
    ("NAPTR", 0.6),   // Naming authority — unusual legitimate use
    ("DNSKEY",0.7),   // DNSSEC key — large payloads possible
    ("RRSIG", 0.7),   // DNSSEC signature — large payloads
];

// ── Known Tunnel Tool Signatures ────────────────────────────────────────────

/// Known DNS tunneling tool signatures in query patterns
const TUNNEL_TOOL_SIGNATURES: &[(&str, &str, f64)] = &[
    // iodine — uses CNAME/NULL, base128 encoding, specific handshake
    ("v[0-9a-f]{8}\\.", "iodine DNS tunnel (version negotiation)", 0.95),
    ("[0-9a-f]{32,}\\.", "iodine DNS tunnel (data transfer)", 0.85),
    // dnscat2 — base32-like encoding in subdomains
    ("dnscat\\.", "dnscat2 DNS tunnel", 0.98),
    ("[a-v0-9]{52,}\\.", "dnscat2 DNS tunnel (base32 data)", 0.80),
    // dns2tcp — sequential numbered queries
    ("[0-9]{4}[a-z0-9]{16,}\\.", "dns2tcp DNS tunnel", 0.75),
    // Cobalt Strike DNS Beacon
    ("aaa[a-z0-9]{8,}\\.", "Cobalt Strike DNS beacon", 0.90),
    ("[a-f0-9]{2}\\.[a-f0-9]{2}\\.", "Cobalt Strike DNS stager", 0.85),
    // SUNBURST-style — encoded victim ID in subdomain
    ("[a-z0-9]{15,}\\.appsync-api\\.", "SUNBURST-style DNS C2", 0.95),
    ("[a-z0-9]{15,}\\.avsvmcloud\\.", "SUNBURST DNS C2 domain", 0.98),
    // Generic hex/base32/base64 encoded
    ("[0-9a-f]{40,}\\.", "Hex-encoded DNS tunnel data", 0.70),
    ("[a-z2-7]{52,}\\.", "Base32-encoded DNS tunnel data", 0.75),
    ("[a-zA-Z0-9+/]{44,}\\.", "Base64-encoded DNS tunnel data", 0.72),
];

/// Known DNS-over-HTTPS (DoH) resolver IPs
const DOH_RESOLVER_IPS: &[&str] = &[
    "1.1.1.1", "1.0.0.1",           // Cloudflare
    "8.8.8.8", "8.8.4.4",           // Google
    "9.9.9.9", "149.112.112.112",   // Quad9
    "208.67.222.222", "208.67.220.220", // OpenDNS
    "185.228.168.168", "185.228.169.168", // CleanBrowsing
];

/// Known DoH endpoint domains
const DOH_DOMAINS: &[&str] = &[
    "cloudflare-dns.com",
    "dns.google",
    "dns.quad9.net",
    "doh.opendns.com",
    "doh.cleanbrowsing.org",
    "dns.nextdns.io",
    "dns.adguard.com",
    "doh.applied-privacy.net",
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DNSTunnelType {
    /// High-throughput tunnel via TXT/NULL records
    HighThroughput,
    /// Low-throughput tunnel via CNAME/A records
    LowThroughput,
    /// Data exfiltration via encoded subdomains
    Exfiltration,
    /// C2 beacon via periodic DNS queries
    C2Beacon,
    /// Domain Generation Algorithm (DGA)
    DGA,
    /// DNS-over-HTTPS bypass
    DoHBypass,
    /// Slow-drip exfiltration over hours
    SlowDrip,
    /// Known tool signature match
    KnownTool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DNSResponseCode {
    NoError, NXDomain, ServFail, Refused, NotImpl, FormErr, Other,
}

// ── Per-Domain Profile ──────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct DomainProfile {
    pub domain: String,
    pub total_queries: u64,
    pub unique_subdomains: u64,
    pub total_bytes_in_labels: u64,
    pub record_type_counts: HashMap<String, u64>,
    pub nxdomain_count: u64,
    pub avg_label_entropy: f64,
    pub avg_label_length: f64,
    pub max_label_length: usize,
    pub min_ttl_seen: u32,
    pub first_seen: i64,
    pub last_seen: i64,
    pub tunnel_score: f64,
    pub tool_match: Option<String>,
    pub query_timestamps: VecDeque<i64>,
    pub unique_subdomain_set_size: usize,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DNSTunnelEvent {
    pub id: String,
    pub timestamp: i64,
    pub tunnel_type: DNSTunnelType,
    pub severity: Severity,
    pub confidence: f64,
    pub domain: String,
    pub full_query: String,
    pub record_type: String,
    pub response_code: DNSResponseCode,
    pub response_size: u32,
    pub ttl: u32,
    pub source_ip: String,
    pub dest_ip: String,
    pub process_name: String,
    pub process_pid: u32,
    pub label_entropy: f64,
    pub label_length: usize,
    pub query_rate: f64,
    pub unique_subdomain_ratio: f64,
    pub nxdomain_ratio: f64,
    pub estimated_data_bytes: u64,
    pub tool_signature: Option<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct DNSTunnelStats {
    pub queries_analyzed: u64,
    pub threats_detected: u64,
    pub tunnel_domains: u64,
    pub exfiltration_attempts: u64,
    pub c2_beacons: u64,
    pub dga_domains: u64,
    pub doh_bypasses: u64,
    pub slow_drip_detected: u64,
    pub tool_matches: u64,
    pub high_entropy_queries: u64,
    pub long_label_queries: u64,
    pub txt_queries: u64,
    pub null_queries: u64,
    pub nxdomain_responses: u64,
    pub low_ttl_responses: u64,
    pub estimated_exfil_bytes: u64,
    pub domains_tracked: u64,
}

// ═══════════════════════════════════════════════════════════════════════════
// DNSTunnelDetector — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct DNSTunnelDetector {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical DNS detection history ──
    monitor_history: RwLock<HierarchicalState<DNSTunnelStats>>,
    // ── Breakthrough #2: Tiered DNS event cache ──
    event_cache: TieredCache<String, DNSTunnelEvent>,
    // ── Breakthrough #3: Reversible tunnel confidence score ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming per-domain query rate ──
    event_rate: RwLock<StreamAccumulator<f64, DNSTunnelStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: DNS pattern diffs between intervals ──
    pattern_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old DNS events ──
    recent_events: RwLock<PruningMap<String, DNSTunnelEvent>>,
    // ── Breakthrough #592: Deduplicate identical DNS alerts ──
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Domain × record-type frequency matrix ──
    domain_rtype_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Per-domain behavioral profiles
    domain_profiles: RwLock<HashMap<String, DomainProfile>>,
    /// Unique subdomains per domain (bounded set)
    unique_subdomains: RwLock<HashMap<String, VecDeque<u64>>>,
    stats: RwLock<DNSTunnelStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl DNSTunnelDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(DNS_CACHE_MAX)
            .with_metrics(metrics.clone(), "dns_tunnel_events");
        let risk_computer = ReversibleComputation::new(512,
            |scores: &[f64]| if scores.is_empty() { 0.0 }
            else { scores.iter().sum::<f64>() / scores.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, DNSTunnelStats::default(),
            |acc: &mut DNSTunnelStats, rates: &[f64]| {
                for &r in rates { acc.queries_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(
                HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache,
            risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate),
            metrics,
            pattern_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(DNS_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            domain_rtype_matrix: RwLock::new(SparseMatrix::new(0u64)),
            domain_profiles: RwLock::new(HashMap::new()),
            unique_subdomains: RwLock::new(HashMap::new()),
            stats: RwLock::new(DNSTunnelStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("dns_tunnel", MEMORY_BUDGET / 2);
        info!(
            "DNSTunnelDetector started — {} tunnel signatures, {} DoH resolvers tracked",
            TUNNEL_TOOL_SIGNATURES.len(),
            DOH_RESOLVER_IPS.len()
        );
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        let domains = self.domain_profiles.read().len();
        let bytes = self.stats.read().estimated_exfil_bytes;
        info!("DNSTunnelDetector stopped — {} domains tracked, {} est. exfil bytes", domains, bytes);
    }

    pub fn is_running(&self) -> bool {
        self.running.load(Ordering::SeqCst)
    }

    // ── Entropy Calculation ─────────────────────────────────────────────────

    /// Shannon entropy of a string (bits per character).
    fn shannon_entropy(s: &str) -> f64 {
        if s.is_empty() { return 0.0; }
        let mut freq = [0u32; 256];
        for b in s.bytes() { freq[b as usize] += 1; }
        let len = s.len() as f64;
        freq.iter()
            .filter(|&&c| c > 0)
            .map(|&c| {
                let p = c as f64 / len;
                -p * p.log2()
            })
            .sum()
    }

    /// Extract the registrable domain from an FQDN (e.g., "a.b.example.com" → "example.com").
    fn extract_domain(fqdn: &str) -> &str {
        let parts: Vec<&str> = fqdn.trim_end_matches('.').split('.').collect();
        if parts.len() >= 2 {
            let start = parts.len() - 2;
            &fqdn[fqdn.find(parts[start]).unwrap_or(0)..]
        } else {
            fqdn
        }
    }

    /// Extract subdomain labels (everything before the registrable domain).
    fn extract_subdomain(fqdn: &str) -> String {
        let parts: Vec<&str> = fqdn.trim_end_matches('.').split('.').collect();
        if parts.len() > 2 {
            parts[..parts.len() - 2].join(".")
        } else {
            String::new()
        }
    }

    /// Check query against known tunnel tool signatures.
    fn check_tool_signatures(query: &str) -> Option<(&'static str, f64)> {
        let query_lower = query.to_lowercase();
        for &(pattern, desc, confidence) in TUNNEL_TOOL_SIGNATURES {
            // Simple substring check (regex patterns are illustrative)
            let check = pattern.replace("\\.", ".").replace("[0-9a-f]", "")
                .replace("[a-z0-9]", "").replace("[a-v0-9]", "")
                .replace("[a-zA-Z0-9+/]", "").replace("[a-z2-7]", "")
                .replace("{8,}", "").replace("{16,}", "").replace("{32,}", "")
                .replace("{40,}", "").replace("{44,}", "").replace("{52,}", "")
                .replace("{4}", "").replace("{2}", "").replace("{15,}", "");
            if !check.is_empty() && query_lower.contains(&check.trim_matches('.').to_lowercase()) {
                return Some((desc, confidence));
            }
        }
        None
    }

    /// Check if destination is a known DoH resolver.
    fn is_doh_resolver(ip: &str) -> bool {
        DOH_RESOLVER_IPS.contains(&ip)
    }

    // ── Primary Analysis ────────────────────────────────────────────────────

    /// Analyze a single DNS query for tunneling indicators.
    pub fn analyze_query(
        &self,
        full_query: &str,
        record_type: &str,
        response_code: DNSResponseCode,
        response_size: u32,
        ttl: u32,
        source_ip: &str,
        dest_ip: &str,
        process_name: &str,
        pid: u32,
    ) -> Option<DNSTunnelEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().queries_analyzed += 1;

        let domain = Self::extract_domain(full_query).to_string();
        let subdomain = Self::extract_subdomain(full_query);
        let label_entropy = Self::shannon_entropy(&subdomain);
        let label_length = subdomain.len();

        // Hash subdomain for unique tracking
        let subdomain_hash = {
            use std::hash::{Hash, Hasher};
            let mut hasher = std::collections::hash_map::DefaultHasher::new();
            subdomain.hash(&mut hasher);
            hasher.finish()
        };

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut tunnel_type = DNSTunnelType::HighThroughput;
        let mut tunnel_score: f64 = 0.0;
        let mut tool_signature = None;

        // ── Update domain profile ──
        {
            let mut profiles = self.domain_profiles.write();
            if profiles.len() >= MAX_TRACKED_DOMAINS && !profiles.contains_key(&domain) {
                // Evict oldest
                if let Some(oldest_key) = profiles.iter()
                    .min_by_key(|(_, p)| p.last_seen)
                    .map(|(k, _)| k.clone())
                {
                    profiles.remove(&oldest_key);
                }
            }
            let profile = profiles.entry(domain.clone()).or_insert_with(|| DomainProfile {
                domain: domain.clone(), first_seen: now, ..Default::default()
            });
            profile.total_queries += 1;
            profile.last_seen = now;
            profile.total_bytes_in_labels += label_length as u64;
            *profile.record_type_counts.entry(record_type.to_string()).or_insert(0) += 1;
            if response_code == DNSResponseCode::NXDomain { profile.nxdomain_count += 1; }
            if ttl < profile.min_ttl_seen || profile.min_ttl_seen == 0 { profile.min_ttl_seen = ttl; }

            // Running average entropy
            let n = profile.total_queries as f64;
            profile.avg_label_entropy = profile.avg_label_entropy * ((n - 1.0) / n) + label_entropy / n;
            profile.avg_label_length = profile.avg_label_length * ((n - 1.0) / n) + label_length as f64 / n;
            if label_length > profile.max_label_length { profile.max_label_length = label_length; }

            profile.query_timestamps.push_back(now);
            while profile.query_timestamps.len() > 120 { profile.query_timestamps.pop_front(); }
        }

        // Track unique subdomains (bounded hash set)
        {
            let mut uniq = self.unique_subdomains.write();
            let set = uniq.entry(domain.clone()).or_insert_with(|| VecDeque::with_capacity(1024));
            if !set.contains(&subdomain_hash) {
                set.push_back(subdomain_hash);
                if set.len() > 1024 { set.pop_front(); }
            }
            let mut profiles = self.domain_profiles.write();
            if let Some(p) = profiles.get_mut(&domain) {
                p.unique_subdomain_set_size = set.len();
                p.unique_subdomains = set.len() as u64;
            }
        }

        // ── 1. Entropy check ──
        if label_entropy > ENTROPY_THRESHOLD && label_length > NORMAL_LABEL_MAX {
            indicators.push(format!(
                "High entropy subdomain: {:.2} bits/char (threshold {:.1}) — '{}'",
                label_entropy, ENTROPY_THRESHOLD,
                &subdomain[..subdomain.len().min(40)]));
            tunnel_score += 0.3;
            self.stats.write().high_entropy_queries += 1;
        }

        // ── 2. Label length check ──
        if label_length >= TUNNEL_LABEL_LENGTH {
            indicators.push(format!(
                "Excessive subdomain length: {} chars (threshold {}) — tunnel data encoding",
                label_length, TUNNEL_LABEL_LENGTH));
            tunnel_score += 0.2;
            self.stats.write().long_label_queries += 1;
        }

        // ── 3. Record type analysis ──
        let rtype_weight = TUNNEL_RECORD_TYPES.iter()
            .find(|(rt, _)| *rt == record_type)
            .map(|(_, w)| *w)
            .unwrap_or(0.0);
        if rtype_weight >= 0.7 {
            indicators.push(format!(
                "Tunnel-favored record type: {} (weight {:.1})", record_type, rtype_weight));
            tunnel_score += rtype_weight * 0.2;
        }
        match record_type {
            "TXT" => self.stats.write().txt_queries += 1,
            "NULL" => self.stats.write().null_queries += 1,
            _ => {}
        }

        // ── 4. Query rate analysis ──
        let query_rate = {
            let profiles = self.domain_profiles.read();
            profiles.get(&domain).map(|p| {
                let window = p.query_timestamps.len();
                if window >= 2 {
                    let span = (p.query_timestamps.back().unwrap_or(&now)
                        - p.query_timestamps.front().unwrap_or(&now)).max(1) as f64;
                    window as f64 / span * 60.0 // queries per minute
                } else { 0.0 }
            }).unwrap_or(0.0)
        };
        if query_rate > QUERY_RATE_THRESHOLD as f64 {
            indicators.push(format!(
                "High query rate: {:.1} queries/min for '{}' (threshold {})",
                query_rate, domain, QUERY_RATE_THRESHOLD));
            tunnel_score += 0.2;
            mitre_techniques.push("T1071.004".to_string());
        }

        // ── 5. Unique subdomain ratio ──
        let unique_ratio = {
            let profiles = self.domain_profiles.read();
            profiles.get(&domain).map(|p| {
                if p.total_queries > 0 {
                    p.unique_subdomains as f64 / p.total_queries as f64
                } else { 0.0 }
            }).unwrap_or(0.0)
        };
        let total_queries = self.domain_profiles.read()
            .get(&domain).map(|p| p.total_queries).unwrap_or(0);
        if unique_ratio > UNIQUE_SUBDOMAIN_RATIO_THRESHOLD
            && total_queries >= MIN_QUERIES_FOR_ANALYSIS
        {
            indicators.push(format!(
                "Near-100% unique subdomains: {:.1}% for '{}' ({} queries)",
                unique_ratio * 100.0, domain, total_queries));
            tunnel_score += 0.3;
            mitre_techniques.push("T1048.003".to_string());
            tunnel_type = DNSTunnelType::Exfiltration;
        }

        // ── 6. NXDOMAIN ratio (DGA) ──
        let nxdomain_ratio = {
            let profiles = self.domain_profiles.read();
            profiles.get(&domain).map(|p| {
                if p.total_queries > 0 { p.nxdomain_count as f64 / p.total_queries as f64 }
                else { 0.0 }
            }).unwrap_or(0.0)
        };
        if nxdomain_ratio > NXDOMAIN_RATIO_THRESHOLD
            && total_queries >= MIN_QUERIES_FOR_ANALYSIS
        {
            indicators.push(format!(
                "High NXDOMAIN ratio: {:.1}% for '{}' — possible DGA",
                nxdomain_ratio * 100.0, domain));
            tunnel_type = DNSTunnelType::DGA;
            mitre_techniques.push("T1568.002".to_string());
            self.stats.write().dga_domains += 1;
        }
        if response_code == DNSResponseCode::NXDomain {
            self.stats.write().nxdomain_responses += 1;
        }

        // ── 7. Low TTL ──
        if ttl > 0 && ttl < LOW_TTL_THRESHOLD {
            indicators.push(format!(
                "Abnormally low TTL: {} seconds (threshold {}) for '{}'",
                ttl, LOW_TTL_THRESHOLD, domain));
            tunnel_score += 0.1;
            self.stats.write().low_ttl_responses += 1;
        }

        // ── 8. Tool signature check ──
        if let Some((tool_desc, tool_conf)) = Self::check_tool_signatures(full_query) {
            indicators.push(format!("Tunnel tool signature: {}", tool_desc));
            tunnel_type = DNSTunnelType::KnownTool;
            tunnel_score += tool_conf * 0.3;
            tool_signature = Some(tool_desc.to_string());
            self.stats.write().tool_matches += 1;
        }

        // ── 9. DoH bypass ──
        if Self::is_doh_resolver(dest_ip) {
            indicators.push(format!(
                "DNS-over-HTTPS resolver detected: {} — bypasses local DNS monitoring",
                dest_ip));
            tunnel_type = DNSTunnelType::DoHBypass;
            mitre_techniques.push("T1572".to_string());
            self.stats.write().doh_bypasses += 1;
        }

        // ── 10. Estimated data exfiltration ──
        let estimated_bytes = label_length as u64; // rough: 1 byte per label char
        self.stats.write().estimated_exfil_bytes += estimated_bytes;

        // ── Update matrix ──
        let current = *self.domain_rtype_matrix.read().get(&domain, &record_type.to_string());
        self.domain_rtype_matrix.write().set(domain.clone(), record_type.to_string(), current + 1);
        self.stats.write().domains_tracked = self.domain_profiles.read().len() as u64;

        if indicators.is_empty() { return None; }

        // ── Severity & confidence ──
        let confidence = (tunnel_score).min(0.98);
        let severity = if confidence > 0.8 { Severity::Critical }
            else if confidence > 0.5 { Severity::High }
            else { Severity::Medium };

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1071.004".to_string());
        }

        let event = DNSTunnelEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            tunnel_type, severity, confidence,
            domain: domain.clone(),
            full_query: full_query.to_string(),
            record_type: record_type.to_string(),
            response_code, response_size, ttl,
            source_ip: source_ip.to_string(),
            dest_ip: dest_ip.to_string(),
            process_name: process_name.to_string(),
            process_pid: pid,
            label_entropy, label_length,
            query_rate, unique_subdomain_ratio: unique_ratio,
            nxdomain_ratio, estimated_data_bytes: estimated_bytes,
            tool_signature,
            indicators, mitre_techniques,
            blocked: matches!(severity, Severity::Critical),
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(
            event.id.clone(), event.clone(), confidence);
        self.pattern_diffs.write().record_insert(
            event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.stats.write().threats_detected += 1;
        self.stats.write().tunnel_domains += 1;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.pattern_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(confidence);

        warn!("DNS tunnel: {:?} domain='{}' entropy={:.2} labels={} rate={:.1}qpm",
            tunnel_type, domain, label_entropy, label_length, query_rate);
        Some(event)
    }

    // ── Accessors ───────────────────────────────────────────────────────────

    pub fn stats(&self) -> DNSTunnelStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn domain_count(&self) -> usize { self.domain_profiles.read().len() }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }

    /// Get the profile for a specific domain.
    pub fn domain_profile(&self, domain: &str) -> Option<DomainProfile> {
        self.domain_profiles.read().get(domain).cloned()
    }

    /// Get all domains with tunnel score above threshold.
    pub fn tunnel_domains(&self, threshold: f64) -> Vec<DomainProfile> {
        self.domain_profiles.read().values()
            .filter(|p| p.tunnel_score > threshold)
            .cloned()
            .collect()
    }
}
