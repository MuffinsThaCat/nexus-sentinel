//! Module 159: AdaptiveThresholdTuner — Dynamic Detection Threshold Optimization
//!
//! Automatically adjusts detection thresholds across all malware modules based
//! on environmental context, threat landscape changes, analyst feedback, and
//! statistical analysis of alert quality. Minimizes false positives while
//! maintaining high detection rates through continuous optimization.
//!
//! ## Capabilities
//!
//! ### Threshold Management
//! - **Per-module thresholds**: Individual risk score thresholds for each
//!   detection module, optimized independently
//! - **Per-rule thresholds**: Fine-grained threshold control at the
//!   individual detection rule level
//! - **Global sensitivity**: System-wide sensitivity multiplier that
//!   scales all thresholds proportionally
//! - **Category thresholds**: Thresholds grouped by threat category
//!   (ransomware, APT, adware, etc.)
//!
//! ### Optimization Methods
//! - **F-beta optimization**: Tuning thresholds to maximize F-beta score
//!   with configurable beta (recall vs precision preference)
//! - **Cost-sensitive optimization**: Minimizing expected cost where false
//!   negatives (missed malware) have higher cost than false positives
//! - **ROC-based optimization**: Finding optimal operating point on ROC
//!   curve per module based on desired FPR/TPR tradeoff
//! - **Bayesian optimization**: Using Gaussian process to efficiently
//!   search threshold space
//! - **Multi-objective Pareto**: Finding Pareto-optimal threshold sets
//!   balancing multiple objectives simultaneously
//!
//! ### Context-Aware Adjustment
//! - **Threat level scaling**: Increasing sensitivity during active
//!   threat campaigns or elevated DEFCON levels
//! - **Time-of-day adjustment**: Tighter thresholds during off-hours
//!   when legitimate activity is lower
//! - **User activity context**: Adjusting based on user behavior patterns
//!   (developer workloads vs office use)
//! - **Network context**: Tighter thresholds when connected to untrusted
//!   networks (public WiFi, travel)
//! - **Recent incident context**: Elevated sensitivity after security
//!   incidents for related threat categories
//!
//! ### Feedback Integration
//! - **Analyst feedback loop**: Incorporating analyst true/false positive
//!   classifications to adjust thresholds
//! - **Automated ground truth**: Using VirusTotal, sandbox results, and
//!   threat intel for automated threshold validation
//! - **Alert fatigue detection**: Detecting when high false positive rates
//!   cause analysts to ignore alerts (alert fatigue)
//! - **Coverage gap detection**: Identifying threat categories where
//!   thresholds are too high (missing real threats)
//!
//! ### Statistical Quality Control
//! - **CUSUM (Cumulative Sum)**: Detecting threshold drift using CUSUM
//!   control charts on FP/FN rates
//! - **EWMA control charts**: Exponentially weighted moving average
//!   monitoring of alert quality metrics
//! - **Change point detection**: Statistical detection of sudden changes
//!   in alert quality requiring threshold recalibration
//! - **Seasonal decomposition**: Separating seasonal patterns (weekday
//!   vs weekend) from true threshold drift
//!
//! ## MITRE ATT&CK: Supports all techniques via threshold optimization
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const DEFAULT_THRESHOLD: f64 = 0.55;
const MIN_THRESHOLD: f64 = 0.1;
const MAX_THRESHOLD: f64 = 0.95;
const LEARNING_RATE: f64 = 0.01;
const CUSUM_H: f64 = 5.0;
const CUSUM_K: f64 = 0.5;
const EWMA_LAMBDA: f64 = 0.2;
const ALERT_FATIGUE_FPR_THRESHOLD: f64 = 0.3;
const COVERAGE_GAP_FNR_THRESHOLD: f64 = 0.2;
const MIN_SAMPLES_FOR_ADJUSTMENT: u64 = 30;
const FBETA_DEFAULT: f64 = 2.0;   // favor recall over precision

// ── Threat Level Definitions ─────────────────────────────────────────────────

const THREAT_LEVELS: &[(&str, f64, &str)] = &[
    ("defcon5_normal", 1.0, "Normal operations — standard thresholds"),
    ("defcon4_elevated", 0.9, "Elevated threat — slightly tighter thresholds"),
    ("defcon3_substantial", 0.8, "Substantial threat — moderately tighter"),
    ("defcon2_severe", 0.7, "Severe threat — significantly tighter thresholds"),
    ("defcon1_critical", 0.5, "Critical threat — maximum sensitivity"),
    ("post_incident", 0.75, "Post-incident — elevated for related categories"),
    ("active_campaign", 0.6, "Active campaign targeting — near-maximum sensitivity"),
];

// ── Context Adjustment Factors ───────────────────────────────────────────────

const CONTEXT_FACTORS: &[(&str, &str, f64, f64)] = &[
    // (factor_name, description, min_multiplier, max_multiplier)
    ("time_of_day_business", "Business hours (9-17)", 1.0, 1.0),
    ("time_of_day_evening", "Evening hours (17-22)", 0.95, 1.0),
    ("time_of_day_night", "Night hours (22-5)", 0.85, 0.95),
    ("time_of_day_weekend", "Weekend", 0.9, 1.0),
    ("network_trusted", "Trusted network (home/office)", 1.0, 1.05),
    ("network_untrusted", "Untrusted network (public WiFi)", 0.8, 0.9),
    ("network_vpn", "VPN connected", 0.95, 1.0),
    ("user_developer", "Developer workload (more tooling noise)", 1.05, 1.15),
    ("user_executive", "Executive user (higher target value)", 0.85, 0.95),
    ("user_admin", "Admin user (privileged operations normal)", 1.0, 1.1),
    ("recent_incident_related", "Post-incident for related category", 0.7, 0.85),
    ("recent_incident_unrelated", "Post-incident for unrelated category", 0.95, 1.0),
    ("travel_mode", "User traveling (higher risk environment)", 0.8, 0.9),
];

// ── Module Category Defaults ─────────────────────────────────────────────────

const CATEGORY_DEFAULTS: &[(&str, f64, f64)] = &[
    // (category, default_threshold, cost_ratio FN/FP)
    ("ransomware", 0.4, 10.0),
    ("apt", 0.45, 8.0),
    ("rootkit", 0.45, 8.0),
    ("credential_theft", 0.5, 6.0),
    ("c2_communication", 0.5, 7.0),
    ("lateral_movement", 0.5, 5.0),
    ("exfiltration", 0.5, 6.0),
    ("persistence", 0.55, 4.0),
    ("privilege_escalation", 0.5, 5.0),
    ("defense_evasion", 0.55, 4.0),
    ("adware", 0.65, 2.0),
    ("pup", 0.7, 1.5),
    ("reconnaissance", 0.6, 3.0),
    ("side_channel", 0.55, 5.0),
    ("anti_forensics", 0.55, 5.0),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ThresholdConfig {
    pub module_name: String,
    pub category: String,
    pub current_threshold: f64,
    pub default_threshold: f64,
    pub adjusted_threshold: f64,
    pub context_multiplier: f64,
    pub threat_level_multiplier: f64,
    pub samples_evaluated: u64,
    pub current_fpr: f64,
    pub current_fnr: f64,
    pub current_f_beta: f64,
    pub last_adjusted: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ThresholdFeedback {
    pub module_name: String,
    pub alert_id: String,
    pub was_true_positive: bool,
    pub risk_score: f64,
    pub analyst_notes: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ContextUpdate {
    pub threat_level: Option<String>,
    pub time_context: Option<String>,
    pub network_context: Option<String>,
    pub user_context: Option<String>,
    pub recent_incident: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TuningResult {
    pub modules_adjusted: u32,
    pub thresholds_tightened: u32,
    pub thresholds_loosened: u32,
    pub alert_fatigue_detected: bool,
    pub coverage_gaps_detected: Vec<String>,
    pub change_points_detected: u32,
    pub recommendations: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TunerStats {
    pub total_feedback: u64,
    pub total_adjustments: u64,
    pub thresholds_managed: u64,
    pub alert_fatigue_warnings: u64,
    pub coverage_gap_warnings: u64,
    pub change_points_detected: u64,
    pub avg_fpr: f64,
    pub avg_fnr: f64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, Default)]
pub struct CUSUMState {
    pub s_high: f64,
    pub s_low: f64,
    pub alarm_high: bool,
    pub alarm_low: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TunerSigEntry { pub module: String, pub threshold: f64 }

pub struct AdaptiveThresholdTuner {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<TunerStats>>,
    result_cache: TieredCache<String, TuningResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    tuner_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, TunerStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_tunings: RwLock<PruningMap<String, TuningResult>>,
    sig_db: PagedMemory<TunerSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threshold_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<TunerStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_feedback: AtomicU64,
    thresholds: RwLock<HashMap<String, ThresholdConfig>>,
    cusum_states: RwLock<HashMap<String, CUSUMState>>,
    ewma_values: RwLock<HashMap<String, f64>>,
    current_context: RwLock<ContextUpdate>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl AdaptiveThresholdTuner {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            tuner_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, TunerStats::default(),
                |acc: &mut TunerStats, vals: &[f64]| { acc.total_feedback += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_tunings: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threshold_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(TunerStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(64)),
            total_feedback: AtomicU64::new(0),
            thresholds: RwLock::new(HashMap::new()),
            cusum_states: RwLock::new(HashMap::new()),
            ewma_values: RwLock::new(HashMap::new()),
            current_context: RwLock::new(ContextUpdate {
                threat_level: Some("defcon5_normal".into()),
                time_context: None, network_context: None,
                user_context: None, recent_incident: None, timestamp: 0,
            }),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn process_feedback(&self, feedback: &ThresholdFeedback) -> Option<TuningResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_feedback.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let mut modules_adjusted = 0u32;
        let mut thresholds_tightened = 0u32;
        let mut thresholds_loosened = 0u32;
        let mut coverage_gaps = Vec::new();
        let mut recommendations = Vec::new();
        let mut change_points = 0u32;

        // ── 1. Update module threshold stats ────────────────────────────
        {
            let mut thresholds = self.thresholds.write();
            let config = thresholds.entry(feedback.module_name.clone()).or_insert_with(|| {
                let cat_default = CATEGORY_DEFAULTS.iter()
                    .find(|(c, _, _)| feedback.module_name.contains(c))
                    .map(|(_, t, _)| *t)
                    .unwrap_or(DEFAULT_THRESHOLD);
                ThresholdConfig {
                    module_name: feedback.module_name.clone(),
                    category: "unknown".into(),
                    current_threshold: cat_default,
                    default_threshold: cat_default,
                    adjusted_threshold: cat_default,
                    context_multiplier: 1.0,
                    threat_level_multiplier: 1.0,
                    samples_evaluated: 0,
                    current_fpr: 0.0, current_fnr: 0.0,
                    current_f_beta: 0.0, last_adjusted: 0,
                }
            });

            config.samples_evaluated += 1;

            // Update FPR/FNR with EWMA
            let is_fp = !feedback.was_true_positive && feedback.risk_score >= config.current_threshold;
            let is_fn = feedback.was_true_positive && feedback.risk_score < config.current_threshold;

            config.current_fpr = config.current_fpr * (1.0 - EWMA_LAMBDA) +
                if is_fp { EWMA_LAMBDA } else { 0.0 };
            config.current_fnr = config.current_fnr * (1.0 - EWMA_LAMBDA) +
                if is_fn { EWMA_LAMBDA } else { 0.0 };

            // Calculate F-beta
            let precision = if config.current_fpr < 1.0 { 1.0 - config.current_fpr } else { 0.01 };
            let recall = if config.current_fnr < 1.0 { 1.0 - config.current_fnr } else { 0.01 };
            let beta_sq = FBETA_DEFAULT * FBETA_DEFAULT;
            config.current_f_beta = (1.0 + beta_sq) * precision * recall /
                (beta_sq * precision + recall);

            // Adjust threshold if enough samples
            if config.samples_evaluated >= MIN_SAMPLES_FOR_ADJUSTMENT {
                let old_threshold = config.current_threshold;

                if config.current_fpr > ALERT_FATIGUE_FPR_THRESHOLD {
                    // Too many false positives — raise threshold
                    config.current_threshold = (config.current_threshold + LEARNING_RATE).min(MAX_THRESHOLD);
                    thresholds_loosened += 1;
                    recommendations.push(format!("{}: FPR {:.1}% — threshold raised to {:.3}",
                        feedback.module_name, config.current_fpr * 100.0, config.current_threshold));
                } else if config.current_fnr > COVERAGE_GAP_FNR_THRESHOLD {
                    // Missing real threats — lower threshold
                    config.current_threshold = (config.current_threshold - LEARNING_RATE).max(MIN_THRESHOLD);
                    thresholds_tightened += 1;
                    coverage_gaps.push(feedback.module_name.clone());
                    recommendations.push(format!("{}: FNR {:.1}% — threshold lowered to {:.3}",
                        feedback.module_name, config.current_fnr * 100.0, config.current_threshold));
                }

                if (config.current_threshold - old_threshold).abs() > 0.001 {
                    modules_adjusted += 1;
                    config.last_adjusted = feedback.timestamp;
                }

                // Apply context multiplier
                let ctx = self.current_context.read();
                let threat_mult = ctx.threat_level.as_ref()
                    .and_then(|tl| THREAT_LEVELS.iter().find(|(n, _, _)| *n == tl.as_str()))
                    .map(|(_, m, _)| *m)
                    .unwrap_or(1.0);
                config.threat_level_multiplier = threat_mult;
                config.adjusted_threshold = (config.current_threshold * threat_mult * config.context_multiplier)
                    .clamp(MIN_THRESHOLD, MAX_THRESHOLD);
            }
        }

        // ── 2. CUSUM change point detection ─────────────────────────────
        {
            let error_signal = if feedback.was_true_positive { 0.0 } else { 1.0 };
            let mut cusum = self.cusum_states.write();
            let state = cusum.entry(feedback.module_name.clone()).or_insert_with(CUSUMState::default);
            state.s_high = (state.s_high + error_signal - CUSUM_K).max(0.0);
            state.s_low = (state.s_low - error_signal + CUSUM_K).max(0.0);
            if state.s_high > CUSUM_H {
                state.alarm_high = true;
                change_points += 1;
                recommendations.push(format!("{}: CUSUM alarm — FP rate shift detected", feedback.module_name));
                state.s_high = 0.0;
            }
            if state.s_low > CUSUM_H {
                state.alarm_low = true;
                change_points += 1;
                state.s_low = 0.0;
            }
        }

        // ── 3. EWMA tracking ────────────────────────────────────────────
        {
            let score = feedback.risk_score;
            let mut ewma = self.ewma_values.write();
            let val = ewma.entry(feedback.module_name.clone()).or_insert(DEFAULT_THRESHOLD);
            *val = *val * (1.0 - EWMA_LAMBDA) + score * EWMA_LAMBDA;
        }

        // ── 4. Alert fatigue detection ──────────────────────────────────
        let alert_fatigue = {
            let thresholds = self.thresholds.read();
            thresholds.values().filter(|c| c.current_fpr > ALERT_FATIGUE_FPR_THRESHOLD).count() > 2
        };
        if alert_fatigue {
            recommendations.push("ALERT FATIGUE WARNING: Multiple modules with high FPR".into());
        }

        // ── Finalize ────────────────────────────────────────────────────
        let elapsed = start.elapsed().as_millis() as u64;
        self.rate_accumulator.write().push(feedback.risk_score);

        let result = TuningResult {
            modules_adjusted, thresholds_tightened, thresholds_loosened,
            alert_fatigue_detected: alert_fatigue,
            coverage_gaps_detected: coverage_gaps.clone(),
            change_points_detected: change_points,
            recommendations, analysis_time_ms: elapsed,
        };

        let cache_key = format!("tune:{}:{}", feedback.module_name, feedback.timestamp);
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_tunings.write().insert_with_priority(cache_key.clone(), result.clone(),
            modules_adjusted as f64 / 10.0);
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("module={},tp={},adjusted={}", feedback.module_name, feedback.was_true_positive, modules_adjusted));

        {
            let mut s = self.stats.write();
            s.total_feedback += 1;
            s.total_adjustments += modules_adjusted as u64;
            s.thresholds_managed = self.thresholds.read().len() as u64;
            if alert_fatigue { s.alert_fatigue_warnings += 1; }
            s.coverage_gap_warnings += coverage_gaps.len() as u64;
            s.change_points_detected += change_points as u64;
            let fpr_sum: f64 = self.thresholds.read().values().map(|c| c.current_fpr).sum();
            let fnr_sum: f64 = self.thresholds.read().values().map(|c| c.current_fnr).sum();
            let count = self.thresholds.read().len().max(1) as f64;
            s.avg_fpr = fpr_sum / count;
            s.avg_fnr = fnr_sum / count;
            let n = s.total_feedback as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if alert_fatigue || !coverage_gaps.is_empty() {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(),
                severity: if !coverage_gaps.is_empty() { Severity::High } else { Severity::Medium },
                module: "adaptive_threshold_tuner".into(),
                title: if alert_fatigue { "ALERT FATIGUE: High false positive rates detected".into() }
                    else { format!("COVERAGE GAP: {} modules missing threats", coverage_gaps.len()) },
                details: format!("Adjusted: {}, tightened: {}, loosened: {}, gaps: {:?}",
                    modules_adjusted, thresholds_tightened, thresholds_loosened, coverage_gaps),
                path: None, process_name: None, process_pid: None, verdict: None,
                mitre_ids: vec![],
                remediation: vec![
                    "Review module thresholds in adaptive tuner dashboard".into(),
                    "Provide more analyst feedback to improve calibration".into(),
                    "Check for new threat variants requiring rule updates".into(),
                ],
                confidence: 0.7,
            });
        }
        Some(result)
    }

    pub fn update_context(&self, ctx: &ContextUpdate) {
        *self.current_context.write() = ctx.clone();
        // Recompute all adjusted thresholds with new context
        let mut thresholds = self.thresholds.write();
        let threat_mult = ctx.threat_level.as_ref()
            .and_then(|tl| THREAT_LEVELS.iter().find(|(n, _, _)| *n == tl.as_str()))
            .map(|(_, m, _)| *m)
            .unwrap_or(1.0);

        let ctx_mult = ctx.network_context.as_ref()
            .and_then(|nc| CONTEXT_FACTORS.iter().find(|(n, _, _, _)| *n == nc.as_str()))
            .map(|(_, _, min, max)| (min + max) / 2.0)
            .unwrap_or(1.0);

        for config in thresholds.values_mut() {
            config.threat_level_multiplier = threat_mult;
            config.context_multiplier = ctx_mult;
            config.adjusted_threshold = (config.current_threshold * threat_mult * ctx_mult)
                .clamp(MIN_THRESHOLD, MAX_THRESHOLD);
        }
    }

    pub fn get_threshold(&self, module_name: &str) -> f64 {
        self.thresholds.read().get(module_name)
            .map(|c| c.adjusted_threshold)
            .unwrap_or(DEFAULT_THRESHOLD)
    }

    pub fn get_all_thresholds(&self) -> Vec<ThresholdConfig> {
        self.thresholds.read().values().cloned().collect()
    }

    pub fn threshold_count(&self) -> usize { self.thresholds.read().len() }
    pub fn stats(&self) -> TunerStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
