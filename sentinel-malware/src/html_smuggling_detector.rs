//! Module 115: HTMLSmugglingDetector — HTML Smuggling & Payload Drop Detection
//!
//! Detects HTML files that assemble and drop payloads client-side via JavaScript
//! Blob/download techniques. This bypasses email and web gateway scanning because
//! the malicious payload is constructed in the browser, not transmitted as a file.
//!
//! ## Detection Capabilities
//!
//! - **Blob construction**: `new Blob()`, `URL.createObjectURL()`, `Blob.slice()`
//!   used to construct binary payloads from Base64/hex/array data
//! - **Download triggers**: `<a download=...>`, `navigator.msSaveBlob()`,
//!   `msSaveOrOpenBlob()`, programmatic click on hidden download links
//! - **Encoded payloads**: Base64-encoded PE/DLL/ISO/VHD/ZIP in JavaScript
//!   variables, arrays, template literals, or split across multiple strings
//! - **Anti-analysis**: setTimeout delays, debugger detection, DOM checks,
//!   User-Agent filtering, referrer validation, geolocation gating
//! - **Known campaigns**: Qakbot HTML smuggling, IcedID, Nokoyawa ransomware,
//!   SVCReady, Pikabot HTML delivery
//! - **File type assembly**: ISO, VHD, IMG, ZIP, 7z, RAR, MSI, EXE, DLL, SCR,
//!   LNK files assembled client-side
//! - **Obfuscation detection**: String splitting, char code arrays, XOR decode
//!   loops, eval/Function constructor abuse, WebAssembly payloads
//! - **Data URI abuse**: `data:application/octet-stream` download triggers
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 256;
const MAX_HTML_SIZE: u64 = 64 * 1024 * 1024;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 14;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const MIN_BASE64_PAYLOAD: usize = 1024;
const MIN_HEX_PAYLOAD: usize = 512;

// ── Smuggling Indicators ─────────────────────────────────────────────────────

const BLOB_CONSTRUCTION_PATTERNS: &[(&str, &str, f64)] = &[
    ("new Blob(", "Blob constructor — payload assembly", 0.6),
    ("new Blob([", "Blob from array — binary payload assembly", 0.7),
    ("URL.createObjectURL", "Object URL creation for download", 0.65),
    ("URL.revokeObjectURL", "Object URL cleanup (covering tracks)", 0.3),
    ("Blob.prototype.slice", "Blob slicing — incremental assembly", 0.5),
    ("new File(", "File constructor — payload naming", 0.55),
    ("FileReader", "FileReader — payload processing", 0.3),
    ("ArrayBuffer", "ArrayBuffer — binary data handling", 0.4),
    ("Uint8Array", "Typed array — binary payload construction", 0.5),
    ("Int8Array", "Typed array — binary manipulation", 0.45),
    ("DataView", "DataView — precise binary construction", 0.5),
    ("TextEncoder", "Text encoding for payload", 0.3),
    ("crypto.subtle", "Web Crypto — payload decryption", 0.7),
];

const DOWNLOAD_TRIGGER_PATTERNS: &[(&str, &str, f64)] = &[
    ("download=", "HTML download attribute", 0.5),
    (".click()", "Programmatic click trigger", 0.4),
    ("msSaveBlob", "IE/Edge save blob", 0.8),
    ("msSaveOrOpenBlob", "IE/Edge save/open blob", 0.8),
    ("saveAs(", "FileSaver.js saveAs", 0.6),
    ("navigator.msSaveBlob", "Navigator saveBlob", 0.8),
    ("document.createElement('a')", "Dynamic link creation for download", 0.5),
    ("createElement(\"a\")", "Dynamic link creation (double quotes)", 0.5),
    ("data:application/octet-stream", "Data URI binary download", 0.75),
    ("data:application/x-msdownload", "Data URI executable download", 0.9),
    ("data:application/zip", "Data URI ZIP download", 0.7),
    ("data:application/x-iso9660-image", "Data URI ISO download", 0.85),
];

const PAYLOAD_ENCODING_PATTERNS: &[(&str, &str, f64)] = &[
    ("atob(", "Base64 decode — payload extraction", 0.55),
    ("btoa(", "Base64 encode", 0.3),
    ("fromCharCode", "Character code construction", 0.5),
    ("charCodeAt", "Character code extraction", 0.4),
    ("String.raw", "Raw string template — payload embedding", 0.4),
    ("parseInt(", "Integer parsing for byte values", 0.2),
    ("0x", "Hex literal — byte-level construction", 0.3),
    ("\\x", "Hex escape — encoded content", 0.4),
    ("\\u00", "Unicode escape — byte encoding", 0.45),
    ("unescape(", "Legacy unescape — payload decode", 0.6),
    ("decodeURIComponent", "URI decode — payload extraction", 0.4),
    ("eval(", "Dynamic execution", 0.7),
    ("Function(", "Function constructor — code execution", 0.75),
    ("WebAssembly", "WebAssembly — compiled payload", 0.8),
    ("wasm", "WebAssembly reference", 0.6),
];

const ANTI_ANALYSIS_PATTERNS: &[(&str, &str, f64)] = &[
    ("setTimeout", "Delayed execution", 0.3),
    ("setInterval", "Periodic execution", 0.3),
    ("debugger", "Debugger statement (anti-debug)", 0.6),
    ("navigator.userAgent", "User-Agent check", 0.4),
    ("document.referrer", "Referrer validation", 0.4),
    ("performance.now", "Timing check (anti-debug)", 0.5),
    ("DevTools", "DevTools detection", 0.7),
    ("console.clear", "Console clearing", 0.5),
    ("outerHeight", "Window size check (VM detection)", 0.4),
    ("navigator.languages", "Language fingerprinting", 0.3),
    ("screen.width", "Screen resolution check", 0.3),
    ("navigator.webdriver", "Automation detection", 0.6),
    ("navigator.plugins", "Plugin fingerprinting", 0.3),
    ("Intl.DateTimeFormat", "Timezone fingerprinting", 0.3),
];

const KNOWN_CAMPAIGN_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("QakBot", ".iso", "QakBot ISO smuggling", 0.85),
    ("IcedID", ".zip", "IcedID ZIP smuggling", 0.85),
    ("Nokoyawa", ".img", "Nokoyawa IMG smuggling", 0.85),
    ("SVCReady", ".vhd", "SVCReady VHD smuggling", 0.85),
    ("Pikabot", ".js", "Pikabot JS smuggling", 0.8),
    ("BatLoader", ".bat", "BatLoader batch smuggling", 0.8),
    ("Bumblebee", ".lnk", "Bumblebee LNK smuggling", 0.85),
];

const ASSEMBLED_FILE_EXTENSIONS: &[(&str, f64)] = &[
    (".exe", 0.95), (".dll", 0.95), (".scr", 0.95), (".com", 0.9),
    (".iso", 0.85), (".vhd", 0.85), (".vhdx", 0.85), (".img", 0.85),
    (".zip", 0.6), (".7z", 0.65), (".rar", 0.65),
    (".msi", 0.8), (".msix", 0.75),
    (".lnk", 0.8), (".bat", 0.75), (".cmd", 0.75),
    (".js", 0.7), (".vbs", 0.75), (".wsf", 0.75),
    (".hta", 0.85), (".ps1", 0.85),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SmugglingThreatType {
    BlobPayloadAssembly,
    DownloadTrigger,
    EncodedPayload,
    Base64Executable,
    HexEncodedBinary,
    CharCodeConstruction,
    AntiAnalysis,
    KnownCampaignPattern,
    ExecutableFileAssembly,
    DiskImageAssembly,
    ArchiveAssembly,
    ScriptAssembly,
    DataURIAbuse,
    WebAssemblyPayload,
    ObfuscatedDelivery,
    CryptoDecryption,
    MultiStageDelivery,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SmugglingFinding {
    pub threat_type: SmugglingThreatType,
    pub confidence: f64,
    pub description: String,
    pub code_snippet: Option<String>,
    pub assembled_filename: Option<String>,
    pub payload_size_estimate: Option<u64>,
    pub mitre_id: String,
    pub campaign: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HTMLStructure {
    pub total_scripts: u32,
    pub inline_script_bytes: u64,
    pub external_scripts: u32,
    pub blob_references: u32,
    pub download_triggers: u32,
    pub base64_blocks: u32,
    pub base64_total_bytes: u64,
    pub hex_blocks: u32,
    pub anti_analysis_indicators: u32,
    pub has_hidden_elements: bool,
    pub has_auto_download: bool,
    pub obfuscation_score: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HTMLSmugglingResult {
    pub path: String,
    pub file_size: u64,
    pub is_smuggling: bool,
    pub structure: HTMLStructure,
    pub findings: Vec<SmugglingFinding>,
    pub assembled_file_types: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SmugglingScanStats {
    pub total_scanned: u64,
    pub smuggling_detected: u64,
    pub clean_count: u64,
    pub blob_assembly_detections: u64,
    pub base64_payload_detections: u64,
    pub campaign_attributions: u64,
    pub executable_assemblies: u64,
    pub disk_image_assemblies: u64,
    pub avg_scan_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SmugglingScanConfig {
    pub enabled: bool,
    pub max_file_size: u64,
    pub scan_blobs: bool,
    pub scan_downloads: bool,
    pub scan_encoding: bool,
    pub scan_anti_analysis: bool,
    pub min_base64_size: usize,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for SmugglingScanConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_file_size: MAX_HTML_SIZE,
            scan_blobs: true,
            scan_downloads: true,
            scan_encoding: true,
            scan_anti_analysis: true,
            min_base64_size: MIN_BASE64_PAYLOAD,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CampaignSigEntry {
    pub campaign: String,
    pub pattern: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct HTMLSmugglingDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SmugglingScanStats>>,
    result_cache: TieredCache<String, HTMLSmugglingResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    html_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SmugglingScanStats>>,
    metrics: MemoryMetrics,
    structure_diffs: RwLock<DifferentialStore<String, String>>,
    recent_scans: RwLock<PruningMap<String, HTMLSmugglingResult>>,
    campaign_db: PagedMemory<CampaignSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<SmugglingScanConfig>,
    stats: RwLock<SmugglingScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_scans: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl HTMLSmugglingDetector {
    pub fn new() -> Self {
        let cfg = SmugglingScanConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            html_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SmugglingScanStats::default(),
                |acc: &mut SmugglingScanStats, vals: &[f64]| { acc.total_scanned += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            structure_diffs: RwLock::new(DifferentialStore::new()),
            recent_scans: RwLock::new(PruningMap::new(CACHE_MAX)),
            campaign_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(SmugglingScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_scans: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn scan_html(&self, path: &str, data: &[u8]) -> Option<HTMLSmugglingResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled || data.len() as u64 > cfg.max_file_size { return None; }
        let start = std::time::Instant::now();
        self.total_scans.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        if let Some(cached) = self.result_cache.get(&path.to_string()) {
            return Some(cached);
        }

        let text = String::from_utf8_lossy(data);
        if !Self::is_html(&text) { return None; }

        let structure = self.parse_structure(&text);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut assembled_types = Vec::new();

        // Scan blob construction
        if cfg.scan_blobs {
            self.scan_blob_construction(&text, &mut findings, &mut mitre_ids);
        }

        // Scan download triggers
        if cfg.scan_downloads {
            self.scan_download_triggers(&text, &mut findings, &mut mitre_ids, &mut assembled_types);
        }

        // Scan encoded payloads
        if cfg.scan_encoding {
            self.scan_encoded_payloads(&text, &cfg, &mut findings, &mut mitre_ids);
        }

        // Scan anti-analysis
        if cfg.scan_anti_analysis {
            self.scan_anti_analysis(&text, &mut findings, &mut mitre_ids);
        }

        // Check for known campaigns
        self.check_known_campaigns(&text, &mut findings, &mut mitre_ids);

        // Check assembled file types
        for &(ext, conf) in ASSEMBLED_FILE_EXTENSIONS {
            if text.contains(ext) && (structure.blob_references > 0 || structure.download_triggers > 0) {
                if !assembled_types.contains(&ext.to_string()) {
                    assembled_types.push(ext.to_string());
                }
                let tt = if ext == ".exe" || ext == ".dll" || ext == ".scr" {
                    SmugglingThreatType::ExecutableFileAssembly
                } else if ext == ".iso" || ext == ".vhd" || ext == ".img" {
                    SmugglingThreatType::DiskImageAssembly
                } else if ext == ".zip" || ext == ".7z" || ext == ".rar" {
                    SmugglingThreatType::ArchiveAssembly
                } else {
                    SmugglingThreatType::ScriptAssembly
                };
                findings.push(SmugglingFinding {
                    threat_type: tt,
                    confidence: conf,
                    description: format!("HTML assembles {} file for download", ext),
                    code_snippet: None,
                    assembled_filename: None,
                    payload_size_estimate: None,
                    mitre_id: "T1027.006".into(),
                    campaign: None,
                });
                mitre_ids.insert("T1027.006".into());
            }
        }

        // Combined smuggling detection: Blob + Download + Payload = high confidence
        let has_blob = structure.blob_references > 0;
        let has_download = structure.download_triggers > 0;
        let has_payload = structure.base64_blocks > 0 || structure.hex_blocks > 0;

        if has_blob && has_download && has_payload {
            findings.push(SmugglingFinding {
                threat_type: SmugglingThreatType::MultiStageDelivery,
                confidence: 0.92,
                description: format!("Complete HTML smuggling pipeline: {} blobs + {} downloads + {} encoded payloads",
                    structure.blob_references, structure.download_triggers, structure.base64_blocks),
                code_snippet: None,
                assembled_filename: None,
                payload_size_estimate: Some(structure.base64_total_bytes * 3 / 4),
                mitre_id: "T1027.006".into(),
                campaign: None,
            });
            mitre_ids.insert("T1027.006".into());
        }

        let risk_score = self.calculate_risk_score(&findings, &structure);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_smuggling = risk_score > 0.55 || (has_blob && has_download && has_payload);
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = HTMLSmugglingResult {
            path: path.to_string(),
            file_size: data.len() as u64,
            is_smuggling,
            structure,
            findings,
            assembled_file_types: assembled_types,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(path.to_string(), result.clone());
        self.recent_scans.write().insert_with_priority(path.to_string(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &path.to_string());
                m.set(k, path.to_string(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(path.to_string(), compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_scanned += 1;
            if is_smuggling { stats.smuggling_detected += 1; } else { stats.clean_count += 1; }
            let n = stats.total_scanned as f64;
            stats.avg_scan_time_ms = stats.avg_scan_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_smuggling {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "html_smuggling_detector".into(),
                title: format!("HTML smuggling: {}", path.rsplit('/').next().unwrap_or(path)),
                details: format!("Risk: {:.1}%, {} findings, assembles: [{}]",
                    risk_score * 100.0, result.findings.len(),
                    result.assembled_file_types.join(", ")),
                path: Some(path.to_string()),
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Block HTML attachments at email gateway".into(),
                    "Enable browser isolation for HTML downloads".into(),
                    "Deploy Content Disarm & Reconstruction (CDR)".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn is_html(text: &str) -> bool {
        let lower = text.to_lowercase();
        lower.contains("<html") || lower.contains("<!doctype html") || lower.contains("<script")
    }

    fn parse_structure(&self, text: &str) -> HTMLStructure {
        let lower = text.to_lowercase();
        let total_scripts = lower.matches("<script").count() as u32;
        let external_scripts = lower.matches("src=").count().min(total_scripts as usize) as u32;
        let inline_scripts = total_scripts.saturating_sub(external_scripts);
        let inline_script_bytes = inline_scripts as u64 * 512; // rough estimate

        let mut blob_refs = 0u32;
        for &(p, _, _) in BLOB_CONSTRUCTION_PATTERNS {
            blob_refs += text.matches(p).count() as u32;
        }
        let mut download_triggers = 0u32;
        for &(p, _, _) in DOWNLOAD_TRIGGER_PATTERNS {
            download_triggers += text.matches(p).count() as u32;
        }

        // Count base64 blocks (long strings of base64 chars)
        let base64_blocks = text.matches("atob(").count() as u32
            + text.matches("base64").count() as u32;
        let base64_bytes = Self::estimate_base64_size(text);
        let hex_blocks = text.matches("\\x").count() as u32 / 10; // rough

        let anti_analysis = ANTI_ANALYSIS_PATTERNS.iter()
            .filter(|(p, _, _)| text.contains(p))
            .count() as u32;

        let has_hidden = lower.contains("display:none") || lower.contains("visibility:hidden")
            || lower.contains("opacity:0") || lower.contains("height:0");
        let has_auto = lower.contains("onload=") || lower.contains("domcontentloaded");

        let obfuscation_score = {
            let eval_count = text.matches("eval(").count();
            let func_count = text.matches("Function(").count();
            let fromcc = text.matches("fromCharCode").count();
            let split_count = text.matches("split(").count();
            (eval_count * 3 + func_count * 3 + fromcc * 2 + split_count) as f64
        };

        self.structure_diffs.write().record_insert(
            "html_struct".into(),
            format!("scripts={},blobs={},dl={},b64={}", total_scripts, blob_refs, download_triggers, base64_blocks),
        );

        HTMLStructure {
            total_scripts, inline_script_bytes, external_scripts,
            blob_references: blob_refs, download_triggers,
            base64_blocks, base64_total_bytes: base64_bytes,
            hex_blocks, anti_analysis_indicators: anti_analysis,
            has_hidden_elements: has_hidden, has_auto_download: has_auto,
            obfuscation_score,
        }
    }

    fn scan_blob_construction(&self, text: &str, findings: &mut Vec<SmugglingFinding>,
                               mitre_ids: &mut HashSet<String>) {
        for &(pattern, desc, conf) in BLOB_CONSTRUCTION_PATTERNS {
            let count = text.matches(pattern).count();
            if count > 0 && conf >= self.config.read().min_confidence {
                findings.push(SmugglingFinding {
                    threat_type: SmugglingThreatType::BlobPayloadAssembly,
                    confidence: (conf + count as f64 * 0.05).min(0.95),
                    description: format!("{} (×{})", desc, count),
                    code_snippet: Some(pattern.to_string()),
                    assembled_filename: None, payload_size_estimate: None,
                    mitre_id: "T1027.006".into(), campaign: None,
                });
                mitre_ids.insert("T1027.006".into());
            }
        }
    }

    fn scan_download_triggers(&self, text: &str, findings: &mut Vec<SmugglingFinding>,
                               mitre_ids: &mut HashSet<String>,
                               assembled_types: &mut Vec<String>) {
        for &(pattern, desc, conf) in DOWNLOAD_TRIGGER_PATTERNS {
            let count = text.matches(pattern).count();
            if count > 0 && conf >= self.config.read().min_confidence {
                let tt = if pattern.contains("data:") {
                    SmugglingThreatType::DataURIAbuse
                } else {
                    SmugglingThreatType::DownloadTrigger
                };
                findings.push(SmugglingFinding {
                    threat_type: tt,
                    confidence: conf,
                    description: format!("{} (×{})", desc, count),
                    code_snippet: Some(pattern.to_string()),
                    assembled_filename: None, payload_size_estimate: None,
                    mitre_id: "T1027.006".into(), campaign: None,
                });
                mitre_ids.insert("T1027.006".into());
            }
        }
    }

    fn scan_encoded_payloads(&self, text: &str, cfg: &SmugglingScanConfig,
                              findings: &mut Vec<SmugglingFinding>,
                              mitre_ids: &mut HashSet<String>) {
        for &(pattern, desc, conf) in PAYLOAD_ENCODING_PATTERNS {
            let count = text.matches(pattern).count();
            if count > 0 && conf >= cfg.min_confidence {
                let tt = if pattern.contains("WebAssembly") || pattern.contains("wasm") {
                    SmugglingThreatType::WebAssemblyPayload
                } else if pattern.contains("eval") || pattern.contains("Function") {
                    SmugglingThreatType::ObfuscatedDelivery
                } else if pattern.contains("crypto") {
                    SmugglingThreatType::CryptoDecryption
                } else {
                    SmugglingThreatType::EncodedPayload
                };
                findings.push(SmugglingFinding {
                    threat_type: tt,
                    confidence: (conf + count as f64 * 0.02).min(0.95),
                    description: format!("{} (×{})", desc, count),
                    code_snippet: Some(pattern.to_string()),
                    assembled_filename: None, payload_size_estimate: None,
                    mitre_id: "T1027.006".into(), campaign: None,
                });
                mitre_ids.insert("T1027.006".into());
            }
        }

        // Check for large base64 blocks
        let b64_size = Self::estimate_base64_size(text);
        if b64_size > cfg.min_base64_size as u64 {
            findings.push(SmugglingFinding {
                threat_type: SmugglingThreatType::Base64Executable,
                confidence: (0.6 + (b64_size as f64 / 100000.0).min(0.3)),
                description: format!("Large Base64 payload: ~{} bytes encoded, ~{} decoded",
                    b64_size, b64_size * 3 / 4),
                code_snippet: None,
                assembled_filename: None,
                payload_size_estimate: Some(b64_size * 3 / 4),
                mitre_id: "T1027.006".into(), campaign: None,
            });
            mitre_ids.insert("T1027.006".into());
        }
    }

    fn scan_anti_analysis(&self, text: &str, findings: &mut Vec<SmugglingFinding>,
                           mitre_ids: &mut HashSet<String>) {
        let mut indicators = 0u32;
        for &(pattern, desc, conf) in ANTI_ANALYSIS_PATTERNS {
            if text.contains(pattern) {
                indicators += 1;
            }
        }
        if indicators >= 3 {
            findings.push(SmugglingFinding {
                threat_type: SmugglingThreatType::AntiAnalysis,
                confidence: (0.5 + indicators as f64 * 0.08).min(0.9),
                description: format!("{} anti-analysis techniques detected", indicators),
                code_snippet: None,
                assembled_filename: None, payload_size_estimate: None,
                mitre_id: "T1497".into(), campaign: None,
            });
            mitre_ids.insert("T1497".into());
        }
    }

    fn check_known_campaigns(&self, text: &str, findings: &mut Vec<SmugglingFinding>,
                              mitre_ids: &mut HashSet<String>) {
        let lower = text.to_lowercase();
        for &(campaign, ext, desc, conf) in KNOWN_CAMPAIGN_PATTERNS {
            // Check for extension + blob/download pattern
            if lower.contains(ext) && (lower.contains("blob") || lower.contains("download")) {
                findings.push(SmugglingFinding {
                    threat_type: SmugglingThreatType::KnownCampaignPattern,
                    confidence: conf * 0.6, // reduced without more specific matching
                    description: desc.to_string(),
                    code_snippet: None,
                    assembled_filename: Some(format!("payload{}", ext)),
                    payload_size_estimate: None,
                    mitre_id: "T1027.006".into(),
                    campaign: Some(campaign.into()),
                });
                mitre_ids.insert("T1027.006".into());
            }
        }
    }

    fn estimate_base64_size(text: &str) -> u64 {
        // Count long runs of base64-compatible characters
        let mut total = 0u64;
        let mut run_len = 0u64;
        for c in text.chars() {
            if c.is_ascii_alphanumeric() || c == '+' || c == '/' || c == '=' {
                run_len += 1;
            } else {
                if run_len > MIN_BASE64_PAYLOAD as u64 {
                    total += run_len;
                }
                run_len = 0;
            }
        }
        if run_len > MIN_BASE64_PAYLOAD as u64 {
            total += run_len;
        }
        total
    }

    fn calculate_risk_score(&self, findings: &[SmugglingFinding], structure: &HTMLStructure) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                SmugglingThreatType::MultiStageDelivery => 1.5,
                SmugglingThreatType::ExecutableFileAssembly => 1.4,
                SmugglingThreatType::DiskImageAssembly => 1.3,
                SmugglingThreatType::WebAssemblyPayload => 1.3,
                SmugglingThreatType::KnownCampaignPattern => 1.3,
                SmugglingThreatType::Base64Executable => 1.2,
                SmugglingThreatType::CryptoDecryption => 1.2,
                SmugglingThreatType::BlobPayloadAssembly => 1.0,
                SmugglingThreatType::DataURIAbuse => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        let max = findings.len() as f64 * 1.5;
        score = (score / max).min(1.0);
        if structure.has_auto_download { score = (score + 0.1).min(1.0); }
        if structure.obfuscation_score > 20.0 { score = (score + 0.05).min(1.0); }
        score
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> SmugglingScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
