//! Module 147: FirmwareIntegrityMonitor — EFI/UEFI, T2, & Apple Silicon Firmware Security
//!
//! Comprehensive monitoring of firmware integrity across all macOS firmware
//! layers including EFI/UEFI, T2 Security Chip, Apple Silicon Secure Boot,
//! SMC (System Management Controller), peripheral firmware, and boot chain
//! verification. Detects firmware-level implants, bootkits, and persistent
//! threats that survive OS reinstallation.
//!
//! ## Detection Capabilities
//!
//! ### EFI/UEFI Firmware
//! - **EFI rootkit detection**: Persistent firmware implants in EFI System
//!   Partition (ESP), DXE drivers, and UEFI runtime services
//! - **EFI variable manipulation**: Unauthorized NVRAM variable changes,
//!   boot order manipulation, SIP configuration tampering
//! - **Option ROM analysis**: Malicious PCI/PCIe option ROMs loaded during
//!   boot that execute before the OS
//! - **EFI binary verification**: Hash verification of boot.efi, firmware
//!   drivers, and EFI applications against known-good values
//! - **Known EFI malware**: Hacking Team EFI implant, LoJax, MosaicRegressor,
//!   CosmicStrand, BlackLotus signature detection
//!
//! ### T2 Security Chip (Intel Macs)
//! - **T2 firmware verification**: Integrity monitoring of bridgeOS firmware
//!   running on the T2 chip
//! - **Secure Boot policy changes**: Detection of Secure Boot policy
//!   downgrades (Full → Medium → No Security)
//! - **External boot changes**: Monitoring for enabling external/USB boot
//! - **T2 DFU mode detection**: Detection of Device Firmware Update mode
//!   that could indicate firmware modification attempts
//!
//! ### Apple Silicon Secure Boot
//! - **Boot policy monitoring**: LocalPolicy, RemotePolicy integrity for
//!   Apple Silicon Macs (M1/M2/M3/M4)
//! - **1TR (One True Recovery)**: Detection of 1TR-based security changes
//! - **BootKernelCollection integrity**: Verification of the kernel
//!   collection loaded during boot
//! - **SEP firmware**: Secure Enclave Processor firmware integrity
//! - **Neural Engine firmware**: ANE firmware verification
//! - **Image4 manifest verification**: Boot manifest trust evaluation
//!
//! ### SMC & Peripheral Firmware
//! - **SMC firmware changes**: System Management Controller firmware
//!   modification detection
//! - **Bluetooth firmware**: Broadcom/Intel BT firmware integrity
//! - **WiFi firmware**: WiFi chipset firmware verification
//! - **Trackpad/Keyboard firmware**: Input device firmware integrity
//! - **SSD firmware**: Storage controller firmware changes
//! - **Thunderbolt controller firmware**: TB NVM firmware verification
//!
//! ### Boot Chain Verification
//! - **Secure Boot chain analysis**: Full verification from ROM bootloader
//!   through iBoot → XNU kernel
//! - **Boot hash chain**: Cryptographic hash chain verification at each
//!   boot stage
//! - **Kernel cache integrity**: Verification of prelinked kernel and
//!   kernel extensions loaded during boot
//! - **APFS snapshot verification**: Sealed System Volume snapshot
//!   integrity on macOS Big Sur+
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1542.001 — System Firmware (BIOS/UEFI)
//! - T1542.003 — Bootkit
//! - T1495 — Firmware Corruption
//! - T1601.001 — Patch System Image
//! - T1601.002 — Downgrade System Image
//! - T1562.001 — Disable or Modify Tools
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs with elevated parameters for firmware
//! event monitoring at the lowest system levels.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

// ── Known EFI/UEFI Malware Signatures ────────────────────────────────────────

const KNOWN_FIRMWARE_MALWARE: &[(&str, &str, &str, f64)] = &[
    ("hacking_team_efi", "Hacking Team EFI rootkit (rkloader/rkfiller)", "HackingTeam", 0.99),
    ("lojax", "LoJax/Sednit UEFI rootkit (APT28/Fancy Bear)", "LoJax", 0.99),
    ("mosaic_regressor", "MosaicRegressor UEFI implant (Chinese APT)", "MosaicRegressor", 0.99),
    ("cosmic_strand", "CosmicStrand UEFI rootkit (Chinese APT)", "CosmicStrand", 0.99),
    ("black_lotus", "BlackLotus UEFI bootkit (Secure Boot bypass)", "BlackLotus", 0.99),
    ("trickbot_efi", "TrickBot UEFI reconnaissance module", "TrickBot", 0.9),
    ("moonbounce", "MoonBounce SPI firmware implant (APT41)", "MoonBounce", 0.99),
    ("especter", "ESPecter UEFI bootkit (EFI System Partition)", "ESPecter", 0.95),
    ("finspy_efi", "FinSpy/FinFisher UEFI bootkit", "FinSpy", 0.99),
    ("thunderstrike", "Thunderstrike macOS EFI bootkit (proof-of-concept)", "Thunderstrike", 0.9),
    ("thunderstrike2", "Thunderstrike 2 worm (EFI worm via Option ROM)", "Thunderstrike2", 0.95),
    ("der_starke", "Der Starke EFI rootkit (CIA Vault 7)", "CIA_Vault7", 0.99),
    ("sonic_screwdriver", "Sonic Screwdriver (CIA Vault 7 EFI attack)", "CIA_Vault7", 0.95),
];

// ── EFI/UEFI Integrity Indicators ───────────────────────────────────────────

const EFI_INTEGRITY_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("efi_hash_mismatch", "EFI binary hash doesn't match Apple-signed version", "T1542.001", 0.95),
    ("esp_unauthorized_binary", "Unauthorized binary in EFI System Partition", "T1542.001", 0.9),
    ("esp_dxe_driver_unknown", "Unknown DXE driver in EFI firmware volume", "T1542.001", 0.85),
    ("efi_runtime_hook", "EFI runtime service function pointer modified", "T1542.001", 0.95),
    ("nvram_boot_order_changed", "NVRAM boot order modified unexpectedly", "T1542.001", 0.6),
    ("nvram_csr_modified", "CSR (SIP) active-config NVRAM variable modified", "T1562.001", 0.9),
    ("nvram_boot_args_suspicious", "Suspicious boot-args in NVRAM", "T1562.001", 0.7),
    ("option_rom_detected", "PCI Option ROM detected (potential injection)", "T1542.001", 0.5),
    ("option_rom_unsigned", "Unsigned PCI Option ROM loaded during boot", "T1542.001", 0.8),
    ("efi_smc_flash_detected", "SMC firmware flash operation detected", "T1495", 0.7),
    ("efi_capsule_update", "EFI firmware capsule update initiated", "T1495", 0.5),
    ("boot_efi_replaced", "boot.efi binary replaced or modified", "T1542.003", 0.95),
    ("efi_partition_modified", "EFI System Partition files modified", "T1542.001", 0.8),
    ("spi_flash_write", "SPI flash write operation detected", "T1495", 0.85),
    ("intel_me_abnormal", "Intel Management Engine abnormal state", "T1542.001", 0.6),
];

// ── T2 & Apple Silicon Boot Security ─────────────────────────────────────────

const BOOT_SECURITY_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("secure_boot_none", "Secure Boot set to No Security", "T1562.001", 0.85),
    ("secure_boot_medium", "Secure Boot set to Medium Security", "T1562.001", 0.5),
    ("secure_boot_downgrade", "Secure Boot downgraded from Full Security", "T1601.002", 0.9),
    ("external_boot_enabled", "External/USB boot enabled", "T1542.003", 0.6),
    ("t2_dfu_mode", "T2 chip in DFU mode (firmware update/modification)", "T1495", 0.7),
    ("t2_bridge_os_mismatch", "bridgeOS version mismatch with macOS", "T1495", 0.6),
    ("local_policy_modified", "Apple Silicon LocalPolicy modified", "T1562.001", 0.8),
    ("remote_policy_modified", "Apple Silicon RemotePolicy modified", "T1562.001", 0.85),
    ("1tr_security_change", "Security change via One True Recovery mode", "T1562.001", 0.5),
    ("boot_kernel_collection_tampered", "BootKernelCollection integrity failure", "T1601.001", 0.95),
    ("sep_firmware_mismatch", "SEP firmware version/hash mismatch", "T1495", 0.9),
    ("ane_firmware_modified", "Apple Neural Engine firmware modified", "T1495", 0.7),
    ("image4_manifest_invalid", "Image4 boot manifest validation failed", "T1542.003", 0.95),
    ("image4_nonce_replay", "Image4 anti-replay nonce mismatch (replay attack)", "T1542.003", 0.95),
    ("kernel_cache_modified", "Prelinked kernel cache modified", "T1601.001", 0.9),
    ("ssv_seal_broken", "Sealed System Volume seal broken", "T1601.001", 0.95),
    ("apfs_snapshot_modified", "APFS system snapshot modified", "T1601.001", 0.9),
    ("recovery_os_modified", "Recovery OS partition modified", "T1601.001", 0.85),
    ("auxiliary_kc_tampered", "Auxiliary Kernel Collection tampered", "T1601.001", 0.9),
];

// ── Peripheral Firmware Indicators ───────────────────────────────────────────

const PERIPHERAL_FW_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("smc_firmware_changed", "SMC firmware hash changed", "T1495", 0.7),
    ("bluetooth_fw_modified", "Bluetooth controller firmware modified", "T1495", 0.6),
    ("wifi_fw_modified", "WiFi chipset firmware modified", "T1495", 0.6),
    ("trackpad_fw_modified", "Trackpad firmware modified", "T1495", 0.5),
    ("keyboard_fw_modified", "Internal keyboard firmware modified", "T1495", 0.5),
    ("ssd_fw_modified", "SSD controller firmware modified", "T1495", 0.7),
    ("thunderbolt_nvm_modified", "Thunderbolt NVM firmware modified", "T1495", 0.8),
    ("thunderbolt_nvm_downgrade", "Thunderbolt firmware downgraded", "T1601.002", 0.85),
    ("gpu_firmware_modified", "GPU firmware modified", "T1495", 0.6),
    ("touchbar_fw_modified", "Touch Bar firmware modified", "T1495", 0.5),
    ("camera_fw_modified", "FaceTime camera firmware modified", "T1495", 0.5),
    ("usb_controller_fw", "USB controller firmware modified", "T1495", 0.5),
    ("pmu_fw_modified", "Power Management Unit firmware modified", "T1495", 0.6),
];

// ── Boot Chain Stage Names ───────────────────────────────────────────────────

const BOOT_CHAIN_STAGES: &[(&str, &str)] = &[
    ("secrom", "Secure ROM (BootROM) — immutable root of trust"),
    ("llb", "Low-Level Bootloader (LLB/iBoot1)"),
    ("iboot", "iBoot (second-stage bootloader)"),
    ("sep_boot", "SEP boot firmware"),
    ("kernel", "XNU kernel"),
    ("kernel_cache", "Prelinked kernel / KernelCollection"),
    ("auxiliary_kc", "Auxiliary Kernel Collection (3rd-party KEXTs)"),
    ("recovery_os", "recoveryOS"),
    ("diag_os", "diagOS (Apple diagnostics)"),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum FirmwareThreatType {
    // EFI/UEFI
    KnownFirmwareMalware,
    EFIHashMismatch,
    UnauthorizedESPBinary,
    UnknownDXEDriver,
    EFIRuntimeHook,
    OptionROMAttack,
    SPIFlashWrite,
    BootEFIReplaced,
    ESPModified,
    IntelMEAbnormal,
    // NVRAM
    NVRAMBootOrderChanged,
    NVRAMCSRModified,
    NVRAMBootArgsSuspicious,
    // T2/Apple Silicon
    SecureBootDowngrade,
    SecureBootDisabled,
    ExternalBootEnabled,
    T2DFUMode,
    T2BridgeOSMismatch,
    LocalPolicyModified,
    Image4ManifestInvalid,
    Image4NonceReplay,
    SEPFirmwareMismatch,
    ANEFirmwareModified,
    // Boot chain
    BootKernelCollectionTampered,
    KernelCacheModified,
    SSVSealBroken,
    APFSSnapshotModified,
    RecoveryOSModified,
    AuxiliaryKCTampered,
    // Peripheral
    SMCFirmwareChanged,
    ThunderboltNVMModified,
    SSDFirmwareModified,
    BluetoothFWModified,
    WiFiFWModified,
    PeripheralFWModified,
    // Generic
    FirmwareDowngrade,
    FirmwareCorruption,
    BootChainBreak,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FirmwareFinding {
    pub threat_type: FirmwareThreatType,
    pub confidence: f64,
    pub description: String,
    pub firmware_component: Option<String>,
    pub expected_hash: Option<String>,
    pub actual_hash: Option<String>,
    pub firmware_version: Option<String>,
    pub boot_stage: Option<String>,
    pub malware_family: Option<String>,
    pub nvram_key: Option<String>,
    pub nvram_value: Option<String>,
    pub device_path: Option<String>,
    pub mitre_id: String,
    pub cve_id: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FirmwareEvent {
    pub event_type: String,
    pub firmware_component: Option<String>,
    pub firmware_version: Option<String>,
    pub firmware_hash: Option<String>,
    pub expected_hash: Option<String>,
    pub boot_stage: Option<String>,
    pub nvram_key: Option<String>,
    pub nvram_value: Option<String>,
    pub secure_boot_level: Option<String>,
    pub previous_secure_boot_level: Option<String>,
    pub device_path: Option<String>,
    pub integrity_check: Option<String>,
    pub is_apple_silicon: bool,
    pub has_t2_chip: bool,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FirmwareAnalysisResult {
    pub is_compromised: bool,
    pub events_analyzed: u32,
    pub findings: Vec<FirmwareFinding>,
    pub affected_components: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct FirmwareScanStats {
    pub total_events: u64,
    pub compromise_detections: u64,
    pub efi_anomalies: u64,
    pub boot_security_changes: u64,
    pub peripheral_fw_changes: u64,
    pub known_malware_detections: u64,
    pub boot_chain_failures: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FirmwareSigEntry { pub signature: String, pub family: String, pub severity: f64 }

pub struct FirmwareIntegrityMonitor {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<FirmwareScanStats>>,
    result_cache: TieredCache<String, FirmwareAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    fw_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, FirmwareScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, FirmwareAnalysisResult>>,
    sig_db: PagedMemory<FirmwareSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<FirmwareScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    firmware_baseline: RwLock<HashMap<String, String>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl FirmwareIntegrityMonitor {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            fw_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, FirmwareScanStats::default(),
                |acc: &mut FirmwareScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(FirmwareScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            firmware_baseline: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &FirmwareEvent) -> Option<FirmwareAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("fw:{}:{}:{}",
            event.event_type,
            event.firmware_component.as_deref().unwrap_or("unknown"),
            event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut components = HashSet::new();

        let indicator_text = format!("{} {}",
            event.event_type,
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = indicator_text.to_lowercase();

        // ── 1. Known firmware malware matching ──────────────────────────
        for &(sig, desc, family, conf) in KNOWN_FIRMWARE_MALWARE {
            if ind_lower.contains(&sig.to_lowercase()) {
                findings.push(FirmwareFinding {
                    threat_type: FirmwareThreatType::KnownFirmwareMalware,
                    confidence: conf, description: format!("{}: DETECTED", desc),
                    firmware_component: event.firmware_component.clone(),
                    expected_hash: event.expected_hash.clone(),
                    actual_hash: event.firmware_hash.clone(),
                    firmware_version: event.firmware_version.clone(),
                    boot_stage: event.boot_stage.clone(),
                    malware_family: Some(family.to_string()),
                    nvram_key: None, nvram_value: None,
                    device_path: event.device_path.clone(),
                    mitre_id: "T1542.001".into(), cve_id: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1542.001".into());
                components.insert(format!("MALWARE:{}", family));
            }
        }

        // ── 2. EFI integrity indicators ─────────────────────────────────
        for &(pattern, desc, mitre, conf) in EFI_INTEGRITY_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "efi_hash_mismatch" => FirmwareThreatType::EFIHashMismatch,
                    "esp_unauthorized_binary" => FirmwareThreatType::UnauthorizedESPBinary,
                    "esp_dxe_driver_unknown" => FirmwareThreatType::UnknownDXEDriver,
                    "efi_runtime_hook" => FirmwareThreatType::EFIRuntimeHook,
                    p if p.contains("nvram_boot_order") => FirmwareThreatType::NVRAMBootOrderChanged,
                    p if p.contains("nvram_csr") => FirmwareThreatType::NVRAMCSRModified,
                    p if p.contains("nvram_boot_args") => FirmwareThreatType::NVRAMBootArgsSuspicious,
                    p if p.contains("option_rom") => FirmwareThreatType::OptionROMAttack,
                    p if p.contains("spi_flash") => FirmwareThreatType::SPIFlashWrite,
                    p if p.contains("boot_efi") => FirmwareThreatType::BootEFIReplaced,
                    p if p.contains("efi_partition") => FirmwareThreatType::ESPModified,
                    p if p.contains("intel_me") => FirmwareThreatType::IntelMEAbnormal,
                    _ => FirmwareThreatType::FirmwareCorruption,
                };
                findings.push(FirmwareFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    firmware_component: event.firmware_component.clone(),
                    expected_hash: event.expected_hash.clone(),
                    actual_hash: event.firmware_hash.clone(),
                    firmware_version: event.firmware_version.clone(),
                    boot_stage: event.boot_stage.clone(),
                    malware_family: None,
                    nvram_key: event.nvram_key.clone(),
                    nvram_value: event.nvram_value.clone(),
                    device_path: event.device_path.clone(),
                    mitre_id: mitre.into(), cve_id: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                components.insert("EFI".to_string());
            }
        }

        // ── 3. Boot security indicators ─────────────────────────────────
        for &(pattern, desc, mitre, conf) in BOOT_SECURITY_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "secure_boot_none" => FirmwareThreatType::SecureBootDisabled,
                    "secure_boot_downgrade" => FirmwareThreatType::SecureBootDowngrade,
                    "external_boot_enabled" => FirmwareThreatType::ExternalBootEnabled,
                    "t2_dfu_mode" => FirmwareThreatType::T2DFUMode,
                    "t2_bridge_os_mismatch" => FirmwareThreatType::T2BridgeOSMismatch,
                    "local_policy_modified" => FirmwareThreatType::LocalPolicyModified,
                    p if p.contains("image4_manifest") => FirmwareThreatType::Image4ManifestInvalid,
                    p if p.contains("image4_nonce") => FirmwareThreatType::Image4NonceReplay,
                    p if p.contains("sep_firmware") => FirmwareThreatType::SEPFirmwareMismatch,
                    p if p.contains("ane_firmware") => FirmwareThreatType::ANEFirmwareModified,
                    p if p.contains("boot_kernel_collection") => FirmwareThreatType::BootKernelCollectionTampered,
                    p if p.contains("kernel_cache") => FirmwareThreatType::KernelCacheModified,
                    p if p.contains("ssv_seal") => FirmwareThreatType::SSVSealBroken,
                    p if p.contains("apfs_snapshot") => FirmwareThreatType::APFSSnapshotModified,
                    p if p.contains("recovery_os") => FirmwareThreatType::RecoveryOSModified,
                    p if p.contains("auxiliary_kc") => FirmwareThreatType::AuxiliaryKCTampered,
                    _ => FirmwareThreatType::BootChainBreak,
                };
                findings.push(FirmwareFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    firmware_component: event.firmware_component.clone(),
                    expected_hash: event.expected_hash.clone(),
                    actual_hash: event.firmware_hash.clone(),
                    firmware_version: event.firmware_version.clone(),
                    boot_stage: event.boot_stage.clone(),
                    malware_family: None, nvram_key: None, nvram_value: None,
                    device_path: event.device_path.clone(),
                    mitre_id: mitre.into(), cve_id: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                let comp = if event.is_apple_silicon { "AppleSilicon" }
                    else if event.has_t2_chip { "T2" } else { "BootSecurity" };
                components.insert(comp.to_string());
            }
        }

        // ── 4. Peripheral firmware indicators ───────────────────────────
        for &(pattern, desc, mitre, conf) in PERIPHERAL_FW_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "smc_firmware_changed" => FirmwareThreatType::SMCFirmwareChanged,
                    p if p.contains("thunderbolt") => FirmwareThreatType::ThunderboltNVMModified,
                    p if p.contains("ssd") => FirmwareThreatType::SSDFirmwareModified,
                    p if p.contains("bluetooth") => FirmwareThreatType::BluetoothFWModified,
                    p if p.contains("wifi") => FirmwareThreatType::WiFiFWModified,
                    _ => FirmwareThreatType::PeripheralFWModified,
                };
                findings.push(FirmwareFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    firmware_component: event.firmware_component.clone(),
                    expected_hash: event.expected_hash.clone(),
                    actual_hash: event.firmware_hash.clone(),
                    firmware_version: event.firmware_version.clone(),
                    boot_stage: None, malware_family: None,
                    nvram_key: None, nvram_value: None,
                    device_path: event.device_path.clone(),
                    mitre_id: mitre.into(), cve_id: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                components.insert("Peripheral".to_string());
            }
        }

        // ── 5. Hash baseline comparison ─────────────────────────────────
        if let (Some(ref component), Some(ref hash)) = (&event.firmware_component, &event.firmware_hash) {
            let baseline = self.firmware_baseline.read();
            if let Some(expected) = baseline.get(component) {
                if expected != hash {
                    findings.push(FirmwareFinding {
                        threat_type: FirmwareThreatType::FirmwareCorruption,
                        confidence: 0.8,
                        description: format!("Firmware hash changed for {}: expected {} got {}",
                            component, &expected[..8.min(expected.len())], &hash[..8.min(hash.len())]),
                        firmware_component: Some(component.clone()),
                        expected_hash: Some(expected.clone()),
                        actual_hash: Some(hash.clone()),
                        firmware_version: event.firmware_version.clone(),
                        boot_stage: event.boot_stage.clone(),
                        malware_family: None, nvram_key: None, nvram_value: None,
                        device_path: event.device_path.clone(),
                        mitre_id: "T1495".into(), cve_id: None,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1495".into());
                    components.insert("HashBaseline".to_string());
                }
            }
            drop(baseline);
            // Update baseline (first-seen trust model)
            self.firmware_baseline.write().entry(component.clone()).or_insert_with(|| hash.clone());
        }

        // ── 6. Secure Boot level change detection ───────────────────────
        if let (Some(ref current), Some(ref previous)) = (&event.secure_boot_level, &event.previous_secure_boot_level) {
            if current != previous {
                let is_downgrade = match (previous.as_str(), current.as_str()) {
                    ("full", "medium") | ("full", "none") | ("medium", "none") => true,
                    _ => false,
                };
                if is_downgrade {
                    findings.push(FirmwareFinding {
                        threat_type: FirmwareThreatType::SecureBootDowngrade,
                        confidence: 0.9,
                        description: format!("Secure Boot downgraded: {} → {}", previous, current),
                        firmware_component: Some("SecureBoot".into()),
                        expected_hash: None, actual_hash: None,
                        firmware_version: None, boot_stage: Some("policy".into()),
                        malware_family: None, nvram_key: None, nvram_value: None,
                        device_path: None,
                        mitre_id: "T1601.002".into(), cve_id: None,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1601.002".into());
                    components.insert("SecureBoot".to_string());
                }
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},comp={:?},findings={}",
                event.event_type, event.firmware_component, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_compromised = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let comp_vec: Vec<String> = components.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = FirmwareAnalysisResult {
            is_compromised, events_analyzed: 1, findings,
            affected_components: comp_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_compromised {
                s.compromise_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        FirmwareThreatType::KnownFirmwareMalware => s.known_malware_detections += 1,
                        FirmwareThreatType::EFIHashMismatch | FirmwareThreatType::UnauthorizedESPBinary |
                        FirmwareThreatType::UnknownDXEDriver | FirmwareThreatType::EFIRuntimeHook |
                        FirmwareThreatType::OptionROMAttack | FirmwareThreatType::BootEFIReplaced |
                        FirmwareThreatType::ESPModified | FirmwareThreatType::SPIFlashWrite =>
                            s.efi_anomalies += 1,
                        FirmwareThreatType::SecureBootDowngrade | FirmwareThreatType::SecureBootDisabled |
                        FirmwareThreatType::ExternalBootEnabled | FirmwareThreatType::LocalPolicyModified |
                        FirmwareThreatType::NVRAMCSRModified | FirmwareThreatType::NVRAMBootArgsSuspicious =>
                            s.boot_security_changes += 1,
                        FirmwareThreatType::SMCFirmwareChanged | FirmwareThreatType::ThunderboltNVMModified |
                        FirmwareThreatType::SSDFirmwareModified | FirmwareThreatType::BluetoothFWModified |
                        FirmwareThreatType::WiFiFWModified | FirmwareThreatType::PeripheralFWModified =>
                            s.peripheral_fw_changes += 1,
                        FirmwareThreatType::BootKernelCollectionTampered | FirmwareThreatType::SSVSealBroken |
                        FirmwareThreatType::Image4ManifestInvalid | FirmwareThreatType::BootChainBreak =>
                            s.boot_chain_failures += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_compromised {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "firmware_integrity_monitor".into(),
                title: format!("FIRMWARE COMPROMISE: {} ({})",
                    result.affected_components.join(", "),
                    event.firmware_component.as_deref().unwrap_or("unknown")),
                details: format!("Risk {:.1}%, {} findings, components: {}",
                    risk_score * 100.0, result.findings.len(),
                    result.affected_components.join(", ")),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "CRITICAL: Firmware compromise survives OS reinstallation".into(),
                    "Boot into Recovery (Cmd+R) or 1TR (long-press power on Apple Silicon)".into(),
                    "Verify Secure Boot: csrutil status / bputil".into(),
                    "Check firmware: /usr/libexec/firmwarecheckers/ tools".into(),
                    "Apple Silicon: DFU restore via Apple Configurator 2".into(),
                    "Intel Mac: Revive/Restore via Apple Configurator 2".into(),
                    "Check NVRAM: nvram -p".into(),
                    "If confirmed: full DFU restore is the ONLY guaranteed remediation".into(),
                    "Preserve forensic evidence before remediation".into(),
                    "Report to Apple Product Security".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[FirmwareFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                FirmwareThreatType::KnownFirmwareMalware => 2.0,
                FirmwareThreatType::EFIRuntimeHook => 1.9,
                FirmwareThreatType::BootEFIReplaced => 1.8,
                FirmwareThreatType::Image4ManifestInvalid | FirmwareThreatType::Image4NonceReplay => 1.8,
                FirmwareThreatType::SSVSealBroken => 1.7,
                FirmwareThreatType::BootKernelCollectionTampered => 1.7,
                FirmwareThreatType::SPIFlashWrite => 1.7,
                FirmwareThreatType::SEPFirmwareMismatch => 1.6,
                FirmwareThreatType::EFIHashMismatch => 1.6,
                FirmwareThreatType::UnauthorizedESPBinary => 1.5,
                FirmwareThreatType::SecureBootDisabled => 1.5,
                FirmwareThreatType::SecureBootDowngrade => 1.4,
                FirmwareThreatType::NVRAMCSRModified => 1.4,
                FirmwareThreatType::KernelCacheModified => 1.4,
                FirmwareThreatType::UnknownDXEDriver => 1.3,
                FirmwareThreatType::OptionROMAttack => 1.3,
                FirmwareThreatType::ThunderboltNVMModified => 1.2,
                FirmwareThreatType::SSDFirmwareModified => 1.2,
                FirmwareThreatType::FirmwareCorruption => 1.1,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn baseline_count(&self) -> usize { self.firmware_baseline.read().len() }
    pub fn stats(&self) -> FirmwareScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
