//! Module 91: KeyloggerDetector — Keystroke Logger & Input Capture Detection
//!
//! World-class detection engine for software keyloggers, hardware input interceptors,
//! kernel-level keyboard hooks, and clipboard capture malware. Detects keylogging
//! through API hook analysis, input event monitoring, suspicious file I/O patterns,
//! and behavioral heuristics across Windows, macOS, and Linux.
//!
//! ## Features
//!
//! - **API hook detection**: Identifies SetWindowsHookEx (WH_KEYBOARD, WH_KEYBOARD_LL),
//!   GetAsyncKeyState, GetKeyState, RegisterRawInputDevices calls
//! - **macOS input monitoring**: Detects CGEventTap, IOHIDManager, NSEvent monitoring,
//!   and Accessibility API keyboard event capture
//! - **Linux input detection**: Identifies /dev/input/* readers, xinput monitoring,
//!   libinput interception, and X11 XRecord/XTest extensions
//! - **Clipboard monitoring**: Detects continuous clipboard polling, AddClipboardFormatListener,
//!   NSPasteboard change count monitoring
//! - **Screen capture detection**: Identifies periodic screenshot capture via GDI,
//!   CGWindowListCreateImage, and framebuffer reads
//! - **File write pattern analysis**: Detects periodic small writes to log files
//!   characteristic of keystroke logging (timestamp + key data)
//! - **Network exfiltration**: Identifies periodic data uploads matching keylog
//!   transmission patterns (small, regular, encrypted payloads)
//! - **Known keylogger signatures**: Database of commercial and malware keyloggers
//!   (Ardamax, Revealer, Elite, HawkEye, Agent Tesla, Snake)
//! - **Input device enumeration**: Detects processes querying HID device lists,
//!   USB keyboard vendor/product IDs
//! - **Browser form capture**: Identifies DOM input event listeners, form submission
//!   interception, and autofill credential theft
//! - **Audio capture**: Detects microphone activation for audio keylogging
//!   (acoustic keyboard side-channel)
//! - **IME hooking**: Identifies Input Method Editor hooks for capturing non-Latin
//!   keyboard input (CJK, Arabic, etc.)
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) detection event history
//! - **#2  TieredCache** — Hot cache for recent keylogger detections
//! - **#3  ReversibleComputation** — Recompute keylogger risk scores
//! - **#5  StreamAccumulator** — Streaming detection rate
//! - **#6  MemoryMetrics** — Bounded memory for detection data
//! - **#461 DifferentialStore** — Track process behavior diffs
//! - **#569 PruningMap** — Auto-expire old detection events
//! - **#592 DedupStore** — Deduplicate identical detections
//! - **#627 SparseMatrix** — Process × technique frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1056.001 — Input Capture: Keylogging
//! - T1056.002 — Input Capture: GUI Input Capture
//! - T1056.003 — Input Capture: Web Portal Capture
//! - T1056.004 — Input Capture: Credential API Hooking
//! - T1113 — Screen Capture
//! - T1115 — Clipboard Data

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const KEYLOG_CACHE_MAX: usize = 8_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 20 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────
const MIN_APIS_FOR_KEYLOGGER: usize = 2;
const HIGH_RISK_API_THRESHOLD: f64 = 0.80;
const CLIPBOARD_POLL_INTERVAL_MS: u64 = 500;
const SCREENSHOT_INTERVAL_MS: u64 = 5_000;
const MAX_LOG_FILE_SIZE: u64 = 50 * 1024 * 1024;
const EXFIL_UPLOAD_MIN_BYTES: u64 = 1024;

/// Windows API keylogging functions: (function, risk, description)
const WINDOWS_KEYLOG_APIS: &[(&str, f64, &str)] = &[
    ("SetWindowsHookExA",      0.90, "Windows keyboard hook (ANSI)"),
    ("SetWindowsHookExW",      0.90, "Windows keyboard hook (Wide)"),
    ("GetAsyncKeyState",       0.75, "Async key state polling"),
    ("GetKeyState",            0.60, "Key state query"),
    ("GetKeyboardState",       0.65, "Full keyboard state dump"),
    ("RegisterRawInputDevices",0.70, "Raw input device registration"),
    ("GetRawInputData",        0.65, "Raw input data retrieval"),
    ("MapVirtualKeyA",         0.40, "Virtual key mapping (ANSI)"),
    ("MapVirtualKeyW",         0.40, "Virtual key mapping (Wide)"),
    ("ToUnicodeEx",            0.50, "Virtual key to Unicode translation"),
    ("GetForegroundWindow",    0.35, "Foreground window query — context capture"),
    ("GetWindowTextA",         0.30, "Window title query (ANSI)"),
    ("GetWindowTextW",         0.30, "Window title query (Wide)"),
    ("GetClipboardData",       0.55, "Clipboard data retrieval"),
    ("AddClipboardFormatListener",0.65,"Clipboard change listener"),
    ("OpenClipboard",          0.40, "Clipboard open"),
    ("BitBlt",                 0.45, "Screen capture via GDI"),
    ("PrintWindow",            0.50, "Window capture"),
    ("keybd_event",            0.35, "Keyboard event simulation"),
    ("SendInput",              0.30, "Input event injection"),
];

/// macOS keylogging APIs and frameworks
const MACOS_KEYLOG_APIS: &[(&str, f64, &str)] = &[
    ("CGEventTapCreate",           0.90, "Core Graphics event tap — keyboard interception"),
    ("CGEventTapEnable",           0.85, "Event tap enable"),
    ("IOHIDManagerCreate",         0.70, "HID manager — direct keyboard access"),
    ("IOHIDManagerRegisterInputValueCallback", 0.80, "HID input callback registration"),
    ("NSEvent.addGlobalMonitorForEvents", 0.85, "Global event monitor — keystroke capture"),
    ("NSEvent.addLocalMonitorForEvents",  0.65, "Local event monitor"),
    ("AXObserverCreate",          0.70, "Accessibility observer — UI monitoring"),
    ("AXUIElementCopyAttributeValue", 0.55, "UI element attribute access"),
    ("NSPasteboard.changeCount",  0.50, "Clipboard change monitoring"),
    ("CGWindowListCreateImage",   0.60, "Window screenshot capture"),
    ("CGDisplayCreateImage",      0.55, "Full screen capture"),
    ("AVCaptureDeviceInput",      0.65, "Audio/video capture device access"),
    ("kCGEventKeyDown",           0.75, "Keyboard down event type constant"),
    ("kCGEventKeyUp",             0.70, "Keyboard up event type constant"),
];

/// Linux keylogging methods
const LINUX_KEYLOG_METHODS: &[(&str, f64, &str)] = &[
    ("/dev/input/event",   0.85, "Direct input device reading"),
    ("xinput",             0.70, "X11 input monitoring utility"),
    ("xdotool",            0.50, "X11 automation tool"),
    ("XRecordEnableContext",0.90,"X11 XRecord extension — keystroke recording"),
    ("XTestFakeKeyEvent",  0.60, "X11 XTest — key event injection"),
    ("libinput",           0.40, "libinput framework (normal but monitor for abuse)"),
    ("evdev",              0.45, "Event device interface"),
    ("showkey",            0.65, "Kernel key code display"),
    ("xev",                0.55, "X11 event display"),
    ("strace -e read",     0.70, "Strace on read syscalls — input capture"),
    ("xclip",              0.35, "X11 clipboard utility"),
    ("xsel",               0.35, "X11 selection utility"),
    ("xdg-screenshot",     0.40, "Screenshot utility"),
    ("scrot",              0.40, "Screenshot utility"),
    ("import -window root",0.45,"ImageMagick full screen capture"),
];

/// Known keylogger malware families
const KNOWN_KEYLOGGERS: &[(&str, &str, f64)] = &[
    ("agent tesla",     "Agent Tesla — .NET keylogger/RAT",          0.98),
    ("hawkeye",         "HawkEye — keylogger/stealer",               0.95),
    ("snake keylogger", "Snake Keylogger — .NET infostealer",        0.95),
    ("formbook",        "FormBook — form grabber/keylogger",         0.95),
    ("ardamax",         "Ardamax Keylogger — commercial",            0.90),
    ("revealer",        "Revealer Keylogger — commercial",           0.85),
    ("elite keylogger", "Elite Keylogger — commercial",              0.90),
    ("perfect keylogger","Perfect Keylogger — commercial",           0.85),
    ("spyrix",          "Spyrix — monitoring/keylogger",             0.85),
    ("refog",           "Refog — employee monitoring keylogger",     0.80),
    ("actual keylogger","Actual Keylogger — commercial",             0.80),
    ("all in one keylogger","All In One Keylogger",                  0.85),
    ("kidlogger",       "KidLogger — parental monitoring",           0.60),
    ("mspy",            "mSpy — phone monitoring (desktop variant)", 0.70),
    ("flexispy",        "FlexiSpy — commercial spyware",            0.90),
    ("remcos",          "Remcos RAT — keylogging capability",        0.95),
    ("njrat",           "njRAT — keylogging module",                 0.95),
    ("darkcomet",       "DarkComet RAT — keylogger module",          0.95),
    ("nanocore",        "NanoCore RAT — keylogger plugin",           0.95),
    ("asyncrat",        "AsyncRAT — keylogger plugin",               0.90),
    ("quasar rat",      "Quasar RAT — keylogger module",             0.90),
];

/// Cross-platform persistence mechanisms used by keyloggers
const PERSISTENCE_MECHANISMS: &[(&str, f64, &str)] = &[
    ("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0.70, "Registry run key persistence"),
    ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0.75, "System-wide registry persistence"),
    ("Startup folder",          0.65, "Startup folder persistence"),
    ("Task Scheduler",          0.60, "Scheduled task persistence"),
    ("LaunchAgent",             0.70, "macOS LaunchAgent persistence"),
    ("LaunchDaemon",            0.75, "macOS LaunchDaemon persistence"),
    (".bashrc",                 0.50, "Linux shell profile persistence"),
    (".profile",                0.50, "Linux profile persistence"),
    ("systemd service",         0.65, "Linux systemd persistence"),
    ("crontab",                 0.55, "Cron job persistence"),
    ("WMI subscription",        0.70, "WMI event subscription persistence"),
    ("COM hijacking",           0.75, "COM object hijacking persistence"),
];

/// Exfiltration methods used by keyloggers
const EXFILTRATION_METHODS: &[(&str, f64, &str)] = &[
    ("smtp",        0.80, "Email (SMTP) exfiltration"),
    ("ftp",         0.75, "FTP upload exfiltration"),
    ("http post",   0.70, "HTTP POST exfiltration"),
    ("telegram",    0.85, "Telegram bot exfiltration"),
    ("discord",     0.80, "Discord webhook exfiltration"),
    ("pastebin",    0.75, "Pastebin upload exfiltration"),
    ("dropbox",     0.70, "Cloud storage exfiltration"),
    ("google drive",0.70, "Google Drive exfiltration"),
    ("onedrive",    0.65, "OneDrive exfiltration"),
    ("dns tunnel",  0.90, "DNS tunneling exfiltration"),
    ("icmp tunnel", 0.90, "ICMP tunneling exfiltration"),
];

/// Anti-analysis techniques used by advanced keyloggers
const ANTI_ANALYSIS_TECHNIQUES: &[(&str, f64, &str)] = &[
    ("IsDebuggerPresent",   0.60, "Debugger detection"),
    ("NtQueryInformationProcess", 0.65, "Process info query — anti-debug"),
    ("CheckRemoteDebuggerPresent", 0.70, "Remote debugger detection"),
    ("VMware",              0.50, "VM detection string"),
    ("VirtualBox",          0.50, "VirtualBox detection"),
    ("Sandboxie",           0.60, "Sandbox detection"),
    ("GetTickCount",        0.30, "Timing-based anti-analysis"),
    ("rdtsc",               0.45, "CPU timing anti-analysis"),
    ("OutputDebugString",   0.35, "Debug output — sandbox detection"),
];

/// Behavioral indicators of keylogging
const BEHAVIORAL_INDICATORS: &[(&str, f64, &str)] = &[
    ("periodic small file writes",     0.65, "Regular small log file appends"),
    ("foreground window tracking",     0.55, "Monitoring active window changes"),
    ("keyboard hook installed",        0.90, "Low-level keyboard hook active"),
    ("clipboard polling loop",         0.70, "Continuous clipboard change monitoring"),
    ("screenshot timer",               0.60, "Periodic screenshot capture"),
    ("hidden window with input hooks", 0.80, "Invisible window capturing input"),
    ("encrypted log file",             0.70, "Encrypted keystroke log file"),
    ("periodic network upload",        0.65, "Regular small data exfiltration"),
    ("email sending module",           0.75, "SMTP-based log exfiltration"),
    ("ftp upload module",              0.70, "FTP-based log exfiltration"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum KeylogTechnique {
    APIHook, EventTap, RawInput, ClipboardCapture, ScreenCapture,
    InputDeviceRead, FormGrabbing, AudioCapture, IMEHook,
    BehavioralPattern, KnownMalware, NetworkExfiltration,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeylogDetection {
    pub id: String,
    pub timestamp: i64,
    pub process_name: String,
    pub process_id: u32,
    pub process_path: String,
    pub severity: Severity,
    pub confidence: f64,
    pub techniques: Vec<KeylogTechnique>,
    pub apis_detected: Vec<String>,
    pub known_family: Option<String>,
    pub behavioral_indicators: Vec<String>,
    pub exfiltration_method: Option<String>,
    pub target_applications: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct KeylogStats {
    pub processes_analyzed: u64,
    pub threats_detected: u64,
    pub api_hooks_detected: u64,
    pub event_taps_detected: u64,
    pub clipboard_captures: u64,
    pub screen_captures: u64,
    pub known_keyloggers: u64,
    pub form_grabbers: u64,
    pub behavioral_detections: u64,
    pub persistence_detected: u64,
    pub exfiltration_detected: u64,
    pub anti_analysis_detected: u64,
    pub raw_input_detected: u64,
    pub blocked_processes: u64,
    pub safe_processes: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeylogDetectorConfig {
    pub block_known_keyloggers: bool,
    pub block_api_hooks: bool,
    pub block_event_taps: bool,
    pub scan_persistence: bool,
    pub scan_exfiltration: bool,
    pub scan_anti_analysis: bool,
    pub min_apis_threshold: usize,
    pub block_on_high_severity: bool,
}

impl KeylogDetectorConfig {
    pub fn default_config() -> Self {
        Self {
            block_known_keyloggers: true,
            block_api_hooks: true,
            block_event_taps: true,
            scan_persistence: true,
            scan_exfiltration: true,
            scan_anti_analysis: true,
            min_apis_threshold: MIN_APIS_FOR_KEYLOGGER,
            block_on_high_severity: true,
        }
    }
}

pub struct KeyloggerDetector {
    // Breakthrough #1: HierarchicalState — O(log n) detection history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<KeylogStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold detection cache
    event_cache: TieredCache<String, KeylogDetection>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed analysis rate
    event_rate: RwLock<StreamAccumulator<f64, KeylogStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — behavior diffs
    behavior_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, KeylogDetection>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — process × technique matrix
    process_technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<KeylogDetectorConfig>,
    stats: RwLock<KeylogStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl KeyloggerDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(KEYLOG_CACHE_MAX)
            .with_metrics(metrics.clone(), "keylog_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, KeylogStats::default(),
            |acc: &mut KeylogStats, rates: &[f64]| {
                for &r in rates { acc.processes_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            behavior_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(KEYLOG_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            process_technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(KeylogDetectorConfig::default_config()),
            stats: RwLock::new(KeylogStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("keylogger", MEMORY_BUDGET / 2);
        info!("KeyloggerDetector started — {} Win APIs, {} macOS APIs, {} Linux methods, {} known families",
            WINDOWS_KEYLOG_APIS.len(), MACOS_KEYLOG_APIS.len(),
            LINUX_KEYLOG_METHODS.len(), KNOWN_KEYLOGGERS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("KeyloggerDetector stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Analyze a process for keylogging behavior.
    pub fn analyze_process(
        &self, process_name: &str, pid: u32, process_path: &str,
        imported_apis: &[String], behavioral_flags: &[String],
    ) -> Option<KeylogDetection> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().processes_analyzed += 1;

        let name_lower = process_name.to_lowercase();
        let mut techniques = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut apis_detected = Vec::new();
        let mut known_family: Option<String> = None;
        let mut behav_inds = Vec::new();
        let mut max_risk: f64 = 0.0;

        // ── 1. Known keylogger family match ──
        for &(sig, desc, risk) in KNOWN_KEYLOGGERS {
            if name_lower.contains(sig) || process_path.to_lowercase().contains(sig) {
                known_family = Some(desc.to_string());
                indicators.push(format!("KNOWN KEYLOGGER: {} — {}", sig, desc));
                techniques.push(KeylogTechnique::KnownMalware);
                self.stats.write().known_keyloggers += 1;
                max_risk = max_risk.max(risk);
                break;
            }
        }

        // ── 2. Windows API detection ──
        for &(api, risk, desc) in WINDOWS_KEYLOG_APIS {
            if imported_apis.iter().any(|a| a.contains(api)) {
                apis_detected.push(api.to_string());
                indicators.push(format!("Win API: {} — {}", api, desc));
                max_risk = max_risk.max(risk);

                if api.contains("Hook") { techniques.push(KeylogTechnique::APIHook); self.stats.write().api_hooks_detected += 1; }
                if api.contains("Clipboard") { techniques.push(KeylogTechnique::ClipboardCapture); self.stats.write().clipboard_captures += 1; }
                if api.contains("BitBlt") || api.contains("PrintWindow") { techniques.push(KeylogTechnique::ScreenCapture); self.stats.write().screen_captures += 1; }
                if api.contains("RawInput") { techniques.push(KeylogTechnique::RawInput); }
            }
        }

        // ── 3. macOS API detection ──
        for &(api, risk, desc) in MACOS_KEYLOG_APIS {
            if imported_apis.iter().any(|a| a.contains(api)) {
                apis_detected.push(api.to_string());
                indicators.push(format!("macOS API: {} — {}", api, desc));
                max_risk = max_risk.max(risk);

                if api.contains("EventTap") { techniques.push(KeylogTechnique::EventTap); self.stats.write().event_taps_detected += 1; }
                if api.contains("Pasteboard") { techniques.push(KeylogTechnique::ClipboardCapture); }
                if api.contains("Image") || api.contains("Capture") { techniques.push(KeylogTechnique::ScreenCapture); }
                if api.contains("IOHID") { techniques.push(KeylogTechnique::InputDeviceRead); }
            }
        }

        // ── 4. Linux method detection ──
        for &(method, risk, desc) in LINUX_KEYLOG_METHODS {
            if imported_apis.iter().any(|a| a.contains(method)) {
                apis_detected.push(method.to_string());
                indicators.push(format!("Linux: {} — {}", method, desc));
                max_risk = max_risk.max(risk);

                if method.contains("/dev/input") { techniques.push(KeylogTechnique::InputDeviceRead); }
                if method.contains("XRecord") { techniques.push(KeylogTechnique::APIHook); }
                if method.contains("clip") || method.contains("sel") { techniques.push(KeylogTechnique::ClipboardCapture); }
                if method.contains("screenshot") || method.contains("scrot") || method.contains("import") { techniques.push(KeylogTechnique::ScreenCapture); }
            }
        }

        // ── 5. Behavioral indicators ──
        for &(behavior, risk, desc) in BEHAVIORAL_INDICATORS {
            if behavioral_flags.iter().any(|f| f.to_lowercase().contains(behavior)) {
                behav_inds.push(desc.to_string());
                indicators.push(format!("Behavior: {}", desc));
                techniques.push(KeylogTechnique::BehavioralPattern);
                max_risk = max_risk.max(risk);
            }
        }
        if !behav_inds.is_empty() {
            self.stats.write().behavioral_detections += 1;
        }

        if techniques.is_empty() && known_family.is_none() {
            self.stats.write().safe_processes += 1;
            return None;
        }

        let config = self.config.read().clone();

        // ── 6. Persistence mechanism detection ──
        if config.scan_persistence {
            let path_lower = process_path.to_lowercase();
            let all_flags: Vec<String> = behavioral_flags.iter()
                .map(|f| f.to_lowercase()).collect();
            for &(mech, risk, desc) in PERSISTENCE_MECHANISMS {
                let mech_lower = mech.to_lowercase();
                if path_lower.contains(&mech_lower) || all_flags.iter().any(|f| f.contains(&mech_lower)) {
                    indicators.push(format!("Persistence: {} — {}", mech, desc));
                    max_risk = max_risk.max(risk);
                    self.stats.write().persistence_detected += 1;
                }
            }
        }

        // ── 7. Exfiltration method detection ──
        let mut exfil_method: Option<String> = None;
        if config.scan_exfiltration {
            let all_flags: Vec<String> = behavioral_flags.iter()
                .map(|f| f.to_lowercase()).collect();
            for &(method, risk, desc) in EXFILTRATION_METHODS {
                if all_flags.iter().any(|f| f.contains(method)) {
                    indicators.push(format!("Exfiltration: {} — {}", method, desc));
                    techniques.push(KeylogTechnique::NetworkExfiltration);
                    exfil_method = Some(desc.to_string());
                    max_risk = max_risk.max(risk);
                    self.stats.write().exfiltration_detected += 1;
                    break;
                }
            }
        }

        // ── 8. Anti-analysis detection ──
        if config.scan_anti_analysis {
            let mut anti_count = 0usize;
            for &(technique, risk, desc) in ANTI_ANALYSIS_TECHNIQUES {
                if imported_apis.iter().any(|a| a.contains(technique)) {
                    indicators.push(format!("Anti-analysis: {} — {}", technique, desc));
                    max_risk = max_risk.max(risk);
                    anti_count += 1;
                }
            }
            if anti_count >= 2 {
                self.stats.write().anti_analysis_detected += 1;
                mitre_techniques.push("T1497".to_string());
            }
        }

        // ── 9. API combination analysis ──
        let has_hook = apis_detected.iter().any(|a| a.contains("Hook") || a.contains("EventTap"));
        let has_window_query = apis_detected.iter().any(|a| a.contains("GetForegroundWindow") || a.contains("GetWindowText"));
        let has_key_query = apis_detected.iter().any(|a| a.contains("GetAsyncKeyState") || a.contains("GetKeyState"));
        if has_hook && has_window_query {
            indicators.push("Hook + window tracking — targeted keystroke capture".to_string());
            max_risk = max_risk.max(0.92);
        }
        if has_key_query && has_window_query {
            indicators.push("Key polling + window tracking — polling-based keylogger".to_string());
            max_risk = max_risk.max(0.85);
        }

        // ── Finalize ──
        techniques.sort();
        techniques.dedup();
        mitre_techniques.push("T1056.001".to_string());
        if techniques.contains(&KeylogTechnique::ClipboardCapture) {
            mitre_techniques.push("T1115".to_string());
        }
        if techniques.contains(&KeylogTechnique::ScreenCapture) {
            mitre_techniques.push("T1113".to_string());
        }
        if techniques.contains(&KeylogTechnique::NetworkExfiltration) {
            mitre_techniques.push("T1041".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.50 + techniques.len() as f64 * 0.07
            + apis_detected.len() as f64 * 0.03
            + if known_family.is_some() { 0.15 } else { 0.0 }).min(0.99);
        let blocked = config.block_on_high_severity
            && matches!(severity, Severity::Critical | Severity::High);

        self.stats.write().threats_detected += 1;
        if blocked { self.stats.write().blocked_processes += 1; }

        // Breakthrough #627: SparseMatrix
        for t in &techniques {
            let c = *self.process_technique_matrix.read()
                .get(&process_name.to_string(), &format!("{:?}", t));
            self.process_technique_matrix.write()
                .set(process_name.to_string(), format!("{:?}", t), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let detection = KeylogDetection {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, process_name: process_name.to_string(),
            process_id: pid, process_path: process_path.to_string(),
            severity, confidence, techniques, apis_detected,
            known_family, behavioral_indicators: behav_inds,
            exfiltration_method: exfil_method, target_applications: vec![],
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(detection.id.clone(), detection.clone());
        self.recent_events.write().insert_with_priority(detection.id.clone(), detection.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.process_technique_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record keylogger behavior diff
        self.behavior_diffs.write().record_insert(
            detection.id.clone(),
            format!("{}:{}:{:?}", process_name, pid, detection.techniques),
        );
        // Breakthrough #592: DedupStore — deduplicate identical detections
        self.event_dedup.write().insert(
            detection.id.clone(),
            format!("{}:{}:{:?}", process_name, pid, detection.techniques).into_bytes(),
        );
        if blocked { warn!("KEYLOGGER BLOCKED: {} (PID {}) — {:?} (confidence {:.2})", process_name, pid, detection.techniques, confidence); }
        Some(detection)
    }

    /// Check if a set of APIs constitutes a keylogger signature
    pub fn is_keylogger_signature(apis: &[String]) -> bool {
        let has_hook = apis.iter().any(|a| a.contains("Hook") || a.contains("EventTap") || a.contains("XRecord"));
        let has_key_read = apis.iter().any(|a| a.contains("GetAsyncKeyState") || a.contains("GetKeyState") || a.contains("kCGEventKeyDown"));
        let has_window = apis.iter().any(|a| a.contains("GetForegroundWindow") || a.contains("GetWindowText"));
        (has_hook || has_key_read) && has_window
    }

    /// Classify keylogger type based on detected techniques
    pub fn classify_type(techniques: &[KeylogTechnique]) -> &'static str {
        if techniques.contains(&KeylogTechnique::KnownMalware) { return "known_malware"; }
        if techniques.contains(&KeylogTechnique::APIHook) { return "hook_based"; }
        if techniques.contains(&KeylogTechnique::EventTap) { return "event_tap"; }
        if techniques.contains(&KeylogTechnique::RawInput) { return "raw_input"; }
        if techniques.contains(&KeylogTechnique::InputDeviceRead) { return "device_read"; }
        if techniques.contains(&KeylogTechnique::FormGrabbing) { return "form_grabber"; }
        if techniques.contains(&KeylogTechnique::BehavioralPattern) { return "behavioral"; }
        "unknown"
    }

    pub fn update_config(&self, config: KeylogDetectorConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> KeylogStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
