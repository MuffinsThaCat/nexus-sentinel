//! Module 130: InstallerPackageAnalyzer — macOS PKG/DMG Malicious Installer Detection
//!
//! Detects malicious macOS installer packages (.pkg, .mpkg, .dmg, .app bundles)
//! that are the primary distribution vector for macOS malware. Analyzes pre/post
//! install scripts, payload contents, code signing, distribution XML, and
//! behavioral patterns to identify trojanized or malicious installers.
//!
//! ## Detection Capabilities
//!
//! - **Pre/post-install script analysis**: Shell scripts executed with root
//!   privileges during installation — download-and-execute, persistence,
//!   credential theft, payload decoding, environment checks
//! - **Distribution XML analysis**: Malicious JavaScript in distribution scripts,
//!   custom volume checks, system requirement manipulation
//! - **Payload analysis**: Hidden files in installer payloads, executable files
//!   in non-standard locations, suspicious file permissions (setuid, world-writable)
//! - **Code signing verification**: Missing signatures, ad-hoc signing, revoked
//!   certificates, signature mismatches between package and payload
//! - **DMG analysis**: Auto-open scripts in DMGs, hidden .app bundles, disguised
//!   executables with document icons, background images with social engineering
//! - **App bundle analysis**: Info.plist manipulation, LSUIElement (hidden apps),
//!   non-standard bundle structures, helper tools
//! - **Installer receipt analysis**: Checking for previously installed malware
//! - **Known malware signatures**: Shlayer, Bundlore, Adload, OSX.Dok,
//!   CrescentCore, Silver Sparrow, UpdateAgent, Genieo patterns
//! - **Evasion detection**: Anti-VM checks in scripts, sleep delays,
//!   environment variable checks, process name checking
//! - **Downloader detection**: Scripts that fetch additional payloads from
//!   C2 servers during installation
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1204.002 — User Execution: Malicious File
//! - T1059.004 — Unix Shell
//! - T1543.001 — Launch Agent
//! - T1543.004 — Launch Daemon
//! - T1553.001 — Gatekeeper Bypass
//! - T1553.002 — Code Signing
//! - T1027 — Obfuscated Files or Information
//! - T1105 — Ingress Tool Transfer
//! - T1036.005 — Match Legitimate Name or Location
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const MAX_SCRIPT_SIZE: usize = 512 * 1024;
const HIGH_ENTROPY_THRESHOLD: f64 = 6.5;

// ── Malicious Script Patterns ────────────────────────────────────────────────

const SCRIPT_DOWNLOAD_PATTERNS: &[(&str, &str, f64)] = &[
    ("curl.*-o.*&&.*chmod.*+x", "Download-and-execute via curl", 0.9),
    ("curl.*|.*sh", "Pipe-to-shell via curl", 0.95),
    ("curl.*|.*bash", "Pipe-to-bash via curl", 0.95),
    ("curl.*|.*python", "Pipe-to-python via curl", 0.9),
    ("wget.*-O.*&&.*chmod", "Download-and-execute via wget", 0.9),
    ("wget.*|.*sh", "Pipe-to-shell via wget", 0.95),
    ("/usr/bin/curl", "Curl invocation in install script", 0.5),
    ("URLSession", "NSURLSession download in script", 0.6),
    ("urllib", "Python urllib download", 0.6),
    ("requests.get", "Python requests download", 0.6),
];

const SCRIPT_PERSISTENCE_PATTERNS: &[(&str, &str, f64)] = &[
    ("LaunchAgents", "LaunchAgent creation in install script", 0.8),
    ("LaunchDaemons", "LaunchDaemon creation in install script", 0.85),
    ("launchctl load", "LaunchAgent/Daemon loading", 0.75),
    ("launchctl bootstrap", "Service bootstrapping", 0.75),
    ("loginwindow.*LoginHook", "Login hook installation", 0.9),
    ("crontab", "Cron job installation", 0.7),
    ("StartupItems", "Startup item creation (legacy)", 0.8),
    ("periodic", "Periodic task installation", 0.65),
    ("com.apple.loginitems", "Login item registration", 0.6),
    ("/etc/rc.common", "rc.common modification (legacy boot)", 0.85),
    ("/etc/profile", "Profile modification (shell persistence)", 0.7),
    (".bashrc", "Bashrc modification", 0.6),
    (".zshrc", "Zshrc modification", 0.6),
    (".bash_profile", "Bash profile modification", 0.6),
];

const SCRIPT_EVASION_PATTERNS: &[(&str, &str, f64)] = &[
    ("sysctl.*hw.model", "Hardware model check (VM detection)", 0.7),
    ("ioreg.*VirtualBox", "VirtualBox detection", 0.85),
    ("ioreg.*VMware", "VMware detection", 0.85),
    ("ioreg.*Parallels", "Parallels detection", 0.85),
    ("system_profiler.*Virtual", "Virtual machine profiling", 0.8),
    ("sleep [0-9][0-9]", "Extended sleep delay (sandbox evasion)", 0.5),
    ("sleep 1[0-9][0-9]", "Long sleep delay (>100s sandbox evasion)", 0.7),
    ("$USER", "User context check", 0.3),
    ("whoami.*root", "Root check", 0.4),
    ("pgrep.*Little Snitch", "Little Snitch detection", 0.85),
    ("pgrep.*Wireshark", "Wireshark detection", 0.75),
    ("pgrep.*tcpdump", "Tcpdump detection", 0.7),
    ("pgrep.*Activity Monitor", "Activity Monitor detection", 0.6),
    ("sw_vers.*-productVersion", "macOS version check", 0.3),
    ("uname -m", "Architecture check (Intel vs ARM)", 0.3),
    ("arch -x86_64", "Rosetta execution forcing", 0.5),
    ("csrutil status", "SIP status check", 0.6),
    ("spctl --status", "Gatekeeper status check", 0.5),
];

const SCRIPT_OBFUSCATION_PATTERNS: &[(&str, &str, f64)] = &[
    ("base64 -D", "Base64 decode in install script", 0.7),
    ("base64 --decode", "Base64 decode", 0.7),
    ("openssl enc -d", "OpenSSL decrypt in install script", 0.8),
    ("openssl aes-256", "AES decryption in install script", 0.8),
    ("eval.*base64", "Eval of base64-decoded content", 0.9),
    ("eval.*$(", "Eval of command substitution", 0.7),
    ("printf.*\\\\x", "Hex-encoded printf (shellcode)", 0.8),
    ("xxd -r", "Hex reverse in install script", 0.75),
    ("gunzip", "Gzip decompression of payload", 0.5),
    ("tar.*-xzf", "Tar extraction of hidden payload", 0.5),
    ("python.*-c.*exec", "Python exec in install script", 0.7),
    ("perl.*-e.*eval", "Perl eval in install script", 0.7),
    ("ruby.*-e.*eval", "Ruby eval in install script", 0.65),
];

const SCRIPT_CREDENTIAL_PATTERNS: &[(&str, &str, f64)] = &[
    ("security find-generic-password", "Keychain password extraction", 0.9),
    ("security find-internet-password", "Internet password extraction", 0.9),
    ("security dump-keychain", "Full keychain dump", 0.95),
    ("security unlock-keychain", "Keychain unlock in installer", 0.85),
    ("osascript.*password", "AppleScript password dialog", 0.85),
    ("sqlite3.*Login Data", "Chrome credential extraction", 0.9),
    ("sqlite3.*cookies.sqlite", "Firefox cookie extraction", 0.85),
    ("dscl.*-read.*Password", "Directory Services password read", 0.9),
];

const SCRIPT_SUSPICIOUS_COMMANDS: &[(&str, &str, f64)] = &[
    ("xattr -d com.apple.quarantine", "Quarantine flag removal", 0.8),
    ("xattr -c", "Clear extended attributes", 0.65),
    ("chmod 777", "World-writable permissions", 0.7),
    ("chmod 4755", "Setuid binary creation", 0.85),
    ("chflags hidden", "Hide file with chflags", 0.7),
    ("SetFile -a V", "Hide file with SetFile", 0.7),
    ("defaults write.*Hidden", "Hide app from Dock", 0.6),
    ("killall Finder", "Restart Finder (hide changes)", 0.4),
    ("killall Dock", "Restart Dock (hide changes)", 0.4),
    ("open -gja", "Hidden app launch", 0.6),
    ("pkill -f", "Process killing by name", 0.4),
    ("dscl.*-create.*UserShell", "Create user account", 0.85),
    ("dscl.*-append.*admin", "Add to admin group", 0.9),
    ("systemsetup.*-setremotelogin", "Enable SSH remote login", 0.8),
    ("sharing -a", "Enable file sharing", 0.6),
    ("networksetup.*-setdnsservers", "DNS server modification", 0.7),
    ("scutil.*--proxy", "Proxy configuration change", 0.6),
    ("pfctl", "Firewall manipulation", 0.7),
    ("csrutil disable", "SIP disable attempt", 0.95),
    ("nvram boot-args", "Boot argument modification", 0.85),
];

// ── DMG Analysis Patterns ────────────────────────────────────────────────────

const DMG_SUSPICIOUS_PATTERNS: &[(&str, &str, f64)] = &[
    (".DS_Store", "DS_Store with potential social engineering", 0.2),
    (".background", "Background image directory (social engineering)", 0.3),
    (".hidden", "Hidden files in DMG root", 0.6),
    (".fseventsd", "FSEvents in DMG (artifact)", 0.2),
    ("Install.app", "Generic installer app name", 0.3),
    ("Setup.app", "Generic setup app name", 0.4),
    ("Installer.app", "Generic installer name", 0.3),
    ("Install ", "Install with space (misleading name)", 0.5),
    (".command", "Shell script disguised as command file", 0.7),
    (".terminal", "Terminal script in DMG", 0.6),
    ("Drag to Applications", "Social engineering drag instruction", 0.2),
];

// ── Known Malware Installer Families ─────────────────────────────────────────

const KNOWN_MALWARE_INSTALLERS: &[(&str, &str, &[&str], f64)] = &[
    ("Shlayer", "Shlayer adware dropper", &["flash", "player", "update", "adobe"], 0.9),
    ("Bundlore", "Bundlore adware installer", &["searchbaron", "weknow", "chill-tab"], 0.85),
    ("Adload", "Adload persistent adware", &["SearchDaemon", "AnalogInterface", "SystemSpot"], 0.9),
    ("OSX.Dok", "Dok proxy hijacker", &["Dokument", "Wifiphisher"], 0.95),
    ("CrescentCore", "CrescentCore dropper", &["LaunchServices", "AdobeFlash"], 0.9),
    ("Silver Sparrow", "Silver Sparrow backdoor", &["updater", "tasker", "init_verx"], 0.95),
    ("UpdateAgent", "UpdateAgent trojan", &["PDFCreator", "ActiveDirectory"], 0.9),
    ("Genieo", "Genieo adware", &["InstallMac", "Genieo", "VSearch"], 0.85),
    ("MacKeeper", "MacKeeper PUP installer", &["MacKeeper", "zeobit"], 0.6),
    ("Atomic Stealer", "AMOS stealer DMG", &["Notion", "Photoshop", "Spotify", "Tor"], 0.95),
    ("Realst", "Realst crypto stealer", &["Meethub", "Clusee", "game"], 0.9),
    ("XCSSET", "XCSSET via Xcode projects", &["xcassets", "xcuserdata"], 0.9),
];

// ── Info.plist Suspicious Keys ───────────────────────────────────────────────

const SUSPICIOUS_PLIST_KEYS: &[(&str, &str, f64)] = &[
    ("LSUIElement", "Hidden application (no Dock icon)", 0.5),
    ("LSBackgroundOnly", "Background-only application", 0.5),
    ("SMPrivilegedExecutables", "Privileged helper tool", 0.4),
    ("NSAppleEventsUsageDescription", "Apple Events permission (automation)", 0.3),
    ("NSAppleScriptEnabled", "AppleScript enabled in app", 0.4),
    ("CFBundleDocumentTypes.*wflow", "Automator workflow handler", 0.5),
    ("com.apple.security.cs.allow-unsigned", "Unsigned code allowance", 0.7),
    ("com.apple.security.cs.disable-library", "Library validation disabled", 0.7),
    ("com.apple.security.cs.allow-dyld", "DYLD env var allowance", 0.8),
    ("com.apple.security.get-task-allow", "Task port access (debugging)", 0.6),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum InstallerThreatType {
    MaliciousPreInstallScript,
    MaliciousPostInstallScript,
    DownloadAndExecute,
    PersistenceInScript,
    CredentialTheftInScript,
    ObfuscatedScript,
    EvasionTechnique,
    SuspiciousCommand,
    UnsignedPackage,
    RevokedCertificate,
    AdHocSigned,
    HiddenPayloadFiles,
    SetuidBinary,
    MaliciousDMG,
    SocialEngineeringDMG,
    SuspiciousPlistKey,
    KnownMalwareFamily,
    HighEntropyPayload,
    QuarantineBypass,
    PayloadSizeMismatch,
    ScriptBomb,
    BundleIDSpoof,
    DistributionXMLAbuse,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct InstallerThreatFinding {
    pub threat_type: InstallerThreatType,
    pub confidence: f64,
    pub description: String,
    pub script_name: Option<String>,
    pub script_content_preview: Option<String>,
    pub payload_path: Option<String>,
    pub malware_family: Option<String>,
    pub signing_info: Option<String>,
    pub mitre_id: String,
    pub file_path: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct InstallerInfo {
    pub file_path: String,
    pub file_type: String,               // "pkg", "mpkg", "dmg", "app"
    pub file_size: u64,
    pub file_hash: String,
    pub is_signed: bool,
    pub signing_authority: Option<String>,
    pub is_notarized: bool,
    pub bundle_id: Option<String>,
    pub pre_install_script: Option<String>,
    pub post_install_script: Option<String>,
    pub distribution_xml: Option<String>,
    pub payload_files: Vec<PayloadFileInfo>,
    pub plist_keys: HashMap<String, String>,
    pub dmg_contents: Vec<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PayloadFileInfo {
    pub path: String,
    pub size: u64,
    pub permissions: u32,
    pub is_executable: bool,
    pub is_hidden: bool,
    pub entropy: f64,
    pub file_type: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct InstallerAnalysisResult {
    pub is_malicious: bool,
    pub files_analyzed: u32,
    pub findings: Vec<InstallerThreatFinding>,
    pub malware_families: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct InstallerScanStats {
    pub total_packages: u64,
    pub malicious_detections: u64,
    pub script_detections: u64,
    pub unsigned_detections: u64,
    pub known_malware_detections: u64,
    pub dmg_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct InstallerSigEntry { pub hash: String, pub family: String, pub severity: f64 }

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct InstallerPackageAnalyzer {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<InstallerScanStats>>,
    result_cache: TieredCache<String, InstallerAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    pkg_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, InstallerScanStats>>,
    metrics: MemoryMetrics,
    pkg_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, InstallerAnalysisResult>>,
    sig_db: PagedMemory<InstallerSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<InstallerScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_packages: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl InstallerPackageAnalyzer {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            pkg_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, InstallerScanStats::default(),
                |acc: &mut InstallerScanStats, vals: &[f64]| { acc.total_packages += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            pkg_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(InstallerScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_packages: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_installer(&self, info: &InstallerInfo) -> Option<InstallerAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_packages.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        if let Some(cached) = self.result_cache.get(&info.file_hash) { return Some(cached); }

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut malware_families = HashSet::new();

        // ── 1. Pre-install script analysis ──────────────────────────────
        if let Some(ref script) = info.pre_install_script {
            self.analyze_script(script, "preinstall", &info.file_path, info.timestamp,
                &mut findings, &mut mitre_ids, &mut malware_families);
        }

        // ── 2. Post-install script analysis ─────────────────────────────
        if let Some(ref script) = info.post_install_script {
            self.analyze_script(script, "postinstall", &info.file_path, info.timestamp,
                &mut findings, &mut mitre_ids, &mut malware_families);
        }

        // ── 3. Code signing analysis ────────────────────────────────────
        if !info.is_signed {
            findings.push(InstallerThreatFinding {
                threat_type: InstallerThreatType::UnsignedPackage,
                confidence: 0.6, description: "Unsigned installer package".into(),
                script_name: None, script_content_preview: None, payload_path: None,
                malware_family: None, signing_info: Some("unsigned".into()),
                mitre_id: "T1553.002".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
            });
            mitre_ids.insert("T1553.002".into());
        } else if let Some(ref auth) = info.signing_authority {
            if auth.contains("adhoc") || auth == "-" {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::AdHocSigned,
                    confidence: 0.65, description: "Ad-hoc signed package".into(),
                    script_name: None, script_content_preview: None, payload_path: None,
                    malware_family: None, signing_info: Some(auth.clone()),
                    mitre_id: "T1553.002".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1553.002".into());
            }
        }

        // ── 4. Payload file analysis ────────────────────────────────────
        for payload in &info.payload_files {
            // Hidden executables
            if payload.is_hidden && payload.is_executable {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::HiddenPayloadFiles,
                    confidence: 0.75, description: format!("Hidden executable in payload: {}", payload.path),
                    script_name: None, script_content_preview: None,
                    payload_path: Some(payload.path.clone()),
                    malware_family: None, signing_info: None,
                    mitre_id: "T1564.001".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1564.001".into());
            }
            // Setuid binaries
            if payload.permissions & 0o4000 != 0 {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::SetuidBinary,
                    confidence: 0.8, description: format!("Setuid binary in payload: {}", payload.path),
                    script_name: None, script_content_preview: None,
                    payload_path: Some(payload.path.clone()),
                    malware_family: None, signing_info: None,
                    mitre_id: "T1548.001".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1548.001".into());
            }
            // High entropy payload (packed/encrypted)
            if payload.entropy > HIGH_ENTROPY_THRESHOLD && payload.is_executable {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::HighEntropyPayload,
                    confidence: (0.5 + (payload.entropy - HIGH_ENTROPY_THRESHOLD) * 0.2).min(0.85),
                    description: format!("High entropy executable: {:.2} bits ({} bytes)", payload.entropy, payload.size),
                    script_name: None, script_content_preview: None,
                    payload_path: Some(payload.path.clone()),
                    malware_family: None, signing_info: None,
                    mitre_id: "T1027.002".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1027.002".into());
            }
        }

        // ── 5. Plist analysis ───────────────────────────────────────────
        for (key, value) in &info.plist_keys {
            for &(plist_key, desc, conf) in SUSPICIOUS_PLIST_KEYS {
                if key.contains(plist_key) {
                    findings.push(InstallerThreatFinding {
                        threat_type: InstallerThreatType::SuspiciousPlistKey,
                        confidence: conf, description: format!("{}: {}={}", desc, key, value),
                        script_name: None, script_content_preview: None, payload_path: None,
                        malware_family: None, signing_info: None,
                        mitre_id: "T1036.005".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                    });
                    mitre_ids.insert("T1036.005".into());
                }
            }
        }

        // ── 6. DMG content analysis ─────────────────────────────────────
        if info.file_type == "dmg" {
            for content in &info.dmg_contents {
                for &(pattern, desc, conf) in DMG_SUSPICIOUS_PATTERNS {
                    if content.to_lowercase().contains(&pattern.to_lowercase()) {
                        let tt = if pattern.starts_with('.') && (pattern.contains("hidden") || pattern.contains("command")) {
                            InstallerThreatType::MaliciousDMG
                        } else {
                            InstallerThreatType::SocialEngineeringDMG
                        };
                        findings.push(InstallerThreatFinding {
                            threat_type: tt, confidence: conf,
                            description: format!("{}: {}", desc, content),
                            script_name: None, script_content_preview: None,
                            payload_path: Some(content.clone()),
                            malware_family: None, signing_info: None,
                            mitre_id: "T1204.002".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                        });
                        mitre_ids.insert("T1204.002".into());
                    }
                }
            }
        }

        // ── 7. Known malware family detection ───────────────────────────
        let file_lower = info.file_path.to_lowercase();
        let bid_lower = info.bundle_id.as_deref().unwrap_or("").to_lowercase();
        for &(family, desc, indicators, conf) in KNOWN_MALWARE_INSTALLERS {
            let mut matched = false;
            for &ind in indicators {
                if file_lower.contains(&ind.to_lowercase()) || bid_lower.contains(&ind.to_lowercase()) {
                    matched = true;
                    break;
                }
            }
            if matched {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::KnownMalwareFamily,
                    confidence: conf, description: desc.to_string(),
                    script_name: None, script_content_preview: None, payload_path: None,
                    malware_family: Some(family.to_string()), signing_info: None,
                    mitre_id: "T1204.002".into(), file_path: info.file_path.clone(), timestamp: info.timestamp,
                });
                mitre_ids.insert("T1204.002".into());
                malware_families.insert(family.to_string());
            }
        }

        // ── Store state & build result ──────────────────────────────────
        self.pkg_diffs.write().record_insert(info.file_hash.clone(),
            format!("type={},signed={},findings={}", info.file_type, info.is_signed, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let families_vec: Vec<String> = malware_families.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = InstallerAnalysisResult {
            is_malicious, files_analyzed: 1, findings, malware_families: families_vec,
            risk_score, severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(info.file_hash.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(info.file_hash.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &info.file_hash);
                m.set(k, info.file_hash.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(info.file_hash.clone(), compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_packages += 1;
            if is_malicious { s.malicious_detections += 1; }
            let n = s.total_packages as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "installer_package_analyzer".into(),
                title: format!("Malicious installer: {}", info.file_path),
                details: format!("Risk: {:.1}%, {} findings, type: {}, signed: {}",
                    risk_score * 100.0, result.findings.len(), info.file_type, info.is_signed),
                path: Some(info.file_path.clone()),
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Quarantine the installer immediately".into(),
                    "Verify installer origin and code signature".into(),
                    "Check for persistence mechanisms if installed".into(),
                    "Run full system scan for dropped payloads".into(),
                    "Review LaunchAgents/Daemons for new entries".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn analyze_script(&self, script: &str, script_name: &str, file_path: &str, timestamp: u64,
        findings: &mut Vec<InstallerThreatFinding>, mitre_ids: &mut HashSet<String>,
        malware_families: &mut HashSet<String>)
    {
        let script_lower = script.to_lowercase();
        let preview = script.chars().take(300).collect::<String>();
        let threat_base = if script_name == "preinstall" {
            InstallerThreatType::MaliciousPreInstallScript
        } else { InstallerThreatType::MaliciousPostInstallScript };

        // Download patterns
        for &(pattern, desc, conf) in SCRIPT_DOWNLOAD_PATTERNS {
            if script_lower.contains(&pattern.to_lowercase()) {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::DownloadAndExecute,
                    confidence: conf, description: format!("[{}] {}", script_name, desc),
                    script_name: Some(script_name.into()),
                    script_content_preview: Some(preview.clone()),
                    payload_path: None, malware_family: None, signing_info: None,
                    mitre_id: "T1105".into(), file_path: file_path.into(), timestamp,
                });
                mitre_ids.insert("T1105".into());
            }
        }

        // Persistence patterns
        for &(pattern, desc, conf) in SCRIPT_PERSISTENCE_PATTERNS {
            if script_lower.contains(&pattern.to_lowercase()) {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::PersistenceInScript,
                    confidence: conf, description: format!("[{}] {}", script_name, desc),
                    script_name: Some(script_name.into()),
                    script_content_preview: Some(preview.clone()),
                    payload_path: None, malware_family: None, signing_info: None,
                    mitre_id: "T1543.001".into(), file_path: file_path.into(), timestamp,
                });
                mitre_ids.insert("T1543.001".into());
            }
        }

        // Evasion patterns
        for &(pattern, desc, conf) in SCRIPT_EVASION_PATTERNS {
            if script_lower.contains(&pattern.to_lowercase()) {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::EvasionTechnique,
                    confidence: conf, description: format!("[{}] {}", script_name, desc),
                    script_name: Some(script_name.into()),
                    script_content_preview: Some(preview.clone()),
                    payload_path: None, malware_family: None, signing_info: None,
                    mitre_id: "T1497".into(), file_path: file_path.into(), timestamp,
                });
                mitre_ids.insert("T1497".into());
            }
        }

        // Obfuscation patterns
        for &(pattern, desc, conf) in SCRIPT_OBFUSCATION_PATTERNS {
            if script_lower.contains(&pattern.to_lowercase()) {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::ObfuscatedScript,
                    confidence: conf, description: format!("[{}] {}", script_name, desc),
                    script_name: Some(script_name.into()),
                    script_content_preview: Some(preview.clone()),
                    payload_path: None, malware_family: None, signing_info: None,
                    mitre_id: "T1027".into(), file_path: file_path.into(), timestamp,
                });
                mitre_ids.insert("T1027".into());
            }
        }

        // Credential theft patterns
        for &(pattern, desc, conf) in SCRIPT_CREDENTIAL_PATTERNS {
            if script_lower.contains(&pattern.to_lowercase()) {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::CredentialTheftInScript,
                    confidence: conf, description: format!("[{}] {}", script_name, desc),
                    script_name: Some(script_name.into()),
                    script_content_preview: Some(preview.clone()),
                    payload_path: None, malware_family: None, signing_info: None,
                    mitre_id: "T1555.001".into(), file_path: file_path.into(), timestamp,
                });
                mitre_ids.insert("T1555.001".into());
            }
        }

        // Suspicious commands
        for &(pattern, desc, conf) in SCRIPT_SUSPICIOUS_COMMANDS {
            if script_lower.contains(&pattern.to_lowercase()) {
                findings.push(InstallerThreatFinding {
                    threat_type: InstallerThreatType::SuspiciousCommand,
                    confidence: conf, description: format!("[{}] {}", script_name, desc),
                    script_name: Some(script_name.into()),
                    script_content_preview: Some(preview.clone()),
                    payload_path: None, malware_family: None, signing_info: None,
                    mitre_id: "T1059.004".into(), file_path: file_path.into(), timestamp,
                });
                mitre_ids.insert("T1059.004".into());
            }
        }
    }

    fn calculate_risk_score(&self, findings: &[InstallerThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                InstallerThreatType::KnownMalwareFamily => 1.6,
                InstallerThreatType::DownloadAndExecute => 1.5,
                InstallerThreatType::CredentialTheftInScript => 1.5,
                InstallerThreatType::ScriptBomb => 1.4,
                InstallerThreatType::PersistenceInScript => 1.4,
                InstallerThreatType::SetuidBinary => 1.3,
                InstallerThreatType::ObfuscatedScript => 1.2,
                InstallerThreatType::EvasionTechnique => 1.2,
                InstallerThreatType::QuarantineBypass => 1.2,
                InstallerThreatType::HiddenPayloadFiles => 1.1,
                InstallerThreatType::UnsignedPackage => 0.9,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> InstallerScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
