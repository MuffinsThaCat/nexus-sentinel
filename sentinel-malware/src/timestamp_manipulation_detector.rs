//! Module 151: TimestampManipulationDetector — Anti-Forensic Timestamp Tampering Detection
//!
//! Detects manipulation of file timestamps, log timestamps, system time, and
//! temporal metadata used to hide malicious activity, evade forensic timelines,
//! and obstruct incident response on macOS.
//!
//! ## Detection Capabilities
//!
//! ### File Timestamp Manipulation (Timestomping)
//! - **Birth time (btime) manipulation**: Detecting modified file creation
//!   timestamps on APFS/HFS+ via discrepancies with other metadata
//! - **Modification time (mtime) backdating**: Files with mtime set to the
//!   distant past to appear as old system files
//! - **Access time (atime) reset**: Cleared or reset atime to hide file access
//! - **Change time (ctime) anomalies**: ctime inconsistencies that reveal
//!   metadata modification (ctime cannot be set by userspace on macOS)
//! - **Extended attribute timestamps**: Manipulated xattr timestamps
//! - **Spotlight metadata time discrepancies**: kMDItemContentCreationDate
//!   vs filesystem timestamps showing manipulation
//! - **APFS transaction log correlation**: Cross-referencing APFS transaction
//!   timestamps with file metadata timestamps
//!
//! ### Log Timestamp Manipulation
//! - **Unified log gap detection**: Missing time ranges in macOS unified log
//!   that indicate log deletion or system time changes
//! - **ASL (Apple System Log) tampering**: Modified or deleted ASL entries
//! - **syslog timestamp anomalies**: Out-of-order or backdated syslog entries
//! - **Audit log (BSM) manipulation**: OpenBSM audit trail timestamp gaps
//! - **Install.log tampering**: Modified installation log timestamps
//! - **fsevents manipulation**: File System Events timestamp inconsistencies
//!
//! ### System Time Manipulation
//! - **NTP poisoning**: Attempts to manipulate time via rogue NTP servers
//! - **settimeofday/clock_settime**: Direct system time modification
//! - **NVRAM time tampering**: RTC/CMOS time modification via NVRAM
//! - **Time zone manipulation**: Unexpected timezone changes to confuse
//!   timestamp interpretation
//! - **Kernel time skew**: Detection of time desynchronization between
//!   kernel and userspace clocks
//!
//! ### macOS-Specific Temporal Forensics
//! - **Quarantine timestamp tampering**: Modified com.apple.quarantine xattr
//!   timestamps to evade Gatekeeper history
//! - **Launch Services registration time**: LS registration timestamps vs
//!   actual file timestamps showing manipulation
//! - **Finder metadata dates**: Finder info dates inconsistent with filesystem
//! - **Time Machine exclusion**: Files excluded from Time Machine to prevent
//!   temporal recovery
//! - **Spotlight index manipulation**: Modified Spotlight index timestamps
//!
//! ## MITRE ATT&CK: T1070.006, T1070.001, T1070.002, T1562.001
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const TIMESTAMP_FUTURE_THRESHOLD_SECS: i64 = 86400;
const TIMESTAMP_ANCIENT_THRESHOLD_YEAR: i32 = 2000;
const LOG_GAP_THRESHOLD_SECS: u64 = 300;

// ── File Timestamp Anomaly Indicators ────────────────────────────────────────

const FILE_TIMESTAMP_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("mtime_before_btime", "mtime is before birth time (impossible without tampering)", "T1070.006", 0.95),
    ("ctime_before_btime", "ctime is before birth time (metadata anomaly)", "T1070.006", 0.9),
    ("mtime_future", "mtime is in the future (timestomping)", "T1070.006", 0.85),
    ("btime_future", "Birth time is in the future", "T1070.006", 0.9),
    ("mtime_ancient", "mtime set to ancient date (blending with system files)", "T1070.006", 0.8),
    ("btime_ancient", "Birth time set to ancient date", "T1070.006", 0.8),
    ("all_times_identical", "All timestamps identical (bulk timestomping tool)", "T1070.006", 0.7),
    ("mtime_round_number", "mtime is suspiciously round (epoch, midnight, etc.)", "T1070.006", 0.5),
    ("atime_never_accessed", "atime reset to creation time (access hiding)", "T1070.006", 0.6),
    ("xattr_time_mismatch", "Extended attribute timestamp inconsistent with file", "T1070.006", 0.7),
    ("spotlight_time_mismatch", "Spotlight metadata date differs from filesystem", "T1070.006", 0.75),
    ("quarantine_time_mismatch", "Quarantine xattr timestamp inconsistent", "T1070.006", 0.7),
    ("ls_registration_mismatch", "Launch Services registration time mismatch", "T1070.006", 0.65),
    ("finder_date_mismatch", "Finder metadata date inconsistent with filesystem", "T1070.006", 0.6),
    ("apfs_txn_time_mismatch", "APFS transaction log timestamp differs from metadata", "T1070.006", 0.85),
    ("resource_fork_time_anomaly", "Resource fork timestamp anomaly", "T1070.006", 0.6),
    ("code_signature_time_mismatch", "Code signature timestamp inconsistent with file mtime", "T1070.006", 0.7),
    ("touch_command_detected", "touch command used to modify timestamps", "T1070.006", 0.5),
    ("setfile_command_detected", "SetFile -d/-m used to set dates (macOS timestomping)", "T1070.006", 0.8),
    ("xattr_w_quarantine_removed", "Quarantine xattr removed (xattr -d com.apple.quarantine)", "T1070.006", 0.6),
    ("utimes_syscall", "utimes/futimes syscall used to modify timestamps", "T1070.006", 0.6),
    ("setattrlist_time", "setattrlist used to set file times directly", "T1070.006", 0.7),
];

// ── Log Manipulation Indicators ──────────────────────────────────────────────

const LOG_MANIPULATION_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("unified_log_gap", "Gap in unified log timeline (log deletion suspected)", "T1070.001", 0.8),
    ("unified_log_truncated", "Unified log tracev3 file truncated", "T1070.001", 0.85),
    ("asl_entry_deleted", "ASL log entries deleted", "T1070.001", 0.8),
    ("asl_file_modified", "ASL log file modified outside of logging daemon", "T1070.001", 0.85),
    ("syslog_out_of_order", "Syslog entries out of chronological order", "T1070.001", 0.7),
    ("syslog_backdated", "Syslog entry backdated (timestamp < previous entry)", "T1070.001", 0.8),
    ("audit_trail_gap", "OpenBSM audit trail has temporal gap", "T1070.002", 0.85),
    ("audit_log_deleted", "BSM audit log file deleted or truncated", "T1070.002", 0.9),
    ("install_log_modified", "install.log modified outside of installer", "T1070.001", 0.75),
    ("fsevents_gap", "FSEvents timeline gap (events deleted)", "T1070.001", 0.8),
    ("fsevents_modified", "FSEvents store file modified directly", "T1070.001", 0.85),
    ("log_rotation_premature", "Log rotation triggered prematurely (covering tracks)", "T1070.001", 0.7),
    ("crashreporter_deleted", "Crash reporter logs deleted", "T1070.001", 0.65),
    ("diagnostics_deleted", "DiagnosticReports deleted", "T1070.001", 0.65),
    ("log_show_filtered", "log show with time filters (reconnaissance of log gaps)", "T1070.001", 0.4),
    ("logarchive_deleted", "Log archive (.logarchive) deleted", "T1070.001", 0.8),
    ("newsyslog_tampered", "newsyslog.conf modified (log rotation manipulation)", "T1070.001", 0.7),
];

// ── System Time Manipulation Indicators ──────────────────────────────────────

const SYSTEM_TIME_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("settimeofday_call", "settimeofday() system call (time manipulation)", "T1070.006", 0.7),
    ("clock_settime_call", "clock_settime() call (direct time change)", "T1070.006", 0.7),
    ("ntp_rogue_server", "NTP synchronization with unknown/rogue server", "T1070.006", 0.7),
    ("ntp_large_offset", "NTP offset > 1 hour (possible time poisoning)", "T1070.006", 0.8),
    ("ntp_disabled", "NTP synchronization disabled (time drift possible)", "T1070.006", 0.5),
    ("timezone_changed", "System timezone changed unexpectedly", "T1070.006", 0.5),
    ("date_command_setdate", "date command used to set system date", "T1070.006", 0.7),
    ("nvram_rtc_modified", "RTC/NVRAM time modified directly", "T1070.006", 0.8),
    ("systemsetup_time", "systemsetup -settime used to change time", "T1070.006", 0.7),
    ("sntp_manipulation", "sntp used with unauthorized time server", "T1070.006", 0.6),
    ("time_jump_backward", "System time jumped backward (clock manipulation)", "T1070.006", 0.85),
    ("time_jump_forward", "System time jumped forward significantly", "T1070.006", 0.7),
    ("kernel_userspace_skew", "Kernel time and userspace time desynchronized", "T1070.006", 0.8),
    ("timed_disabled", "timed daemon disabled (no automatic time sync)", "T1070.006", 0.5),
];

// ── Time Machine & Backup Manipulation ───────────────────────────────────────

const BACKUP_MANIPULATION_INDICATORS: &[(&str, &str, f64)] = &[
    ("tmutil_exclude", "tmutil addexclusion used to exclude paths from Time Machine", 0.6),
    ("tmutil_delete", "tmutil delete used to remove backup snapshots", 0.8),
    ("tmutil_disable", "Time Machine disabled (tmutil disable)", 0.7),
    ("tm_plist_modified", "Time Machine preferences plist modified", 0.7),
    ("apfs_snapshot_deleted", "APFS snapshot deleted (tmutil deletelocalsnapshots)", 0.8),
    ("spotlight_exclude", "Path added to Spotlight exclusion list", 0.5),
    ("spotlight_index_deleted", "Spotlight index deleted (.Spotlight-V100)", 0.7),
    ("mdutil_disable", "Spotlight indexing disabled for volume (mdutil -i off)", 0.6),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TimestampThreatType {
    // File timestamps
    MtimeBeforeBtime,
    MtimeFuture,
    MtimeAncient,
    BtimeFuture,
    BtimeAncient,
    AllTimesIdentical,
    RoundTimestamp,
    AtimeReset,
    XattrTimeMismatch,
    SpotlightTimeMismatch,
    QuarantineTimeMismatch,
    APFSTxnMismatch,
    CodeSignTimeMismatch,
    TouchCommand,
    SetFileCommand,
    UtimesSyscall,
    // Log manipulation
    UnifiedLogGap,
    UnifiedLogTruncated,
    ASLDeleted,
    SyslogOutOfOrder,
    AuditTrailGap,
    AuditLogDeleted,
    FSEventsGap,
    FSEventsModified,
    LogRotationPremature,
    DiagnosticsDeleted,
    // System time
    SystemTimeSet,
    NTPRogueServer,
    NTPLargeOffset,
    TimezoneChanged,
    TimeJumpBackward,
    TimeJumpForward,
    KernelTimeskew,
    NVRAMTimeModified,
    // Backup manipulation
    TimeMachineExclusion,
    TimeMachineDisabled,
    SnapshotDeleted,
    SpotlightExclusion,
    SpotlightIndexDeleted,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimestampFinding {
    pub threat_type: TimestampThreatType,
    pub confidence: f64,
    pub description: String,
    pub file_path: Option<String>,
    pub original_time: Option<String>,
    pub tampered_time: Option<String>,
    pub time_source: Option<String>,
    pub log_file: Option<String>,
    pub gap_duration_secs: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimestampEvent {
    pub event_type: String,
    pub file_path: Option<String>,
    pub file_mtime: Option<i64>,
    pub file_btime: Option<i64>,
    pub file_ctime: Option<i64>,
    pub file_atime: Option<i64>,
    pub spotlight_date: Option<i64>,
    pub quarantine_date: Option<i64>,
    pub code_sign_date: Option<i64>,
    pub log_file: Option<String>,
    pub log_gap_start: Option<i64>,
    pub log_gap_end: Option<i64>,
    pub system_time_offset_secs: Option<i64>,
    pub ntp_server: Option<String>,
    pub ntp_offset_secs: Option<f64>,
    pub command_line: Option<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimestampAnalysisResult {
    pub is_tampered: bool,
    pub events_analyzed: u32,
    pub findings: Vec<TimestampFinding>,
    pub tampering_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TimestampScanStats {
    pub total_events: u64,
    pub tampering_detections: u64,
    pub file_timestamp_anomalies: u64,
    pub log_manipulation_detections: u64,
    pub system_time_changes: u64,
    pub backup_manipulation_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimestampSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

pub struct TimestampManipulationDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<TimestampScanStats>>,
    result_cache: TieredCache<String, TimestampAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    ts_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, TimestampScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, TimestampAnalysisResult>>,
    sig_db: PagedMemory<TimestampSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<TimestampScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl TimestampManipulationDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            ts_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, TimestampScanStats::default(),
                |acc: &mut TimestampScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(TimestampScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &TimestampEvent) -> Option<TimestampAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("ts:{}:{}:{}",
            event.event_type, event.process_pid.unwrap_or(0), event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        let ind_text = format!("{} {} {}",
            event.event_type,
            event.integrity_check.as_deref().unwrap_or(""),
            event.command_line.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // ── 1. File timestamp anomaly detection ─────────────────────────
        // Direct timestamp comparison
        if let (Some(mtime), Some(btime)) = (event.file_mtime, event.file_btime) {
            if mtime < btime {
                findings.push(TimestampFinding {
                    threat_type: TimestampThreatType::MtimeBeforeBtime,
                    confidence: 0.95,
                    description: format!("mtime ({}) before birth time ({}) — timestomping", mtime, btime),
                    file_path: event.file_path.clone(),
                    original_time: Some(format!("{}", btime)),
                    tampered_time: Some(format!("{}", mtime)),
                    time_source: Some("filesystem".into()), log_file: None,
                    gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1070.006".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.006".into());
                categories.insert("FileTimestamp".to_string());
            }

            let now = event.timestamp as i64;
            if mtime > now + TIMESTAMP_FUTURE_THRESHOLD_SECS {
                findings.push(TimestampFinding {
                    threat_type: TimestampThreatType::MtimeFuture,
                    confidence: 0.85,
                    description: format!("mtime is {} seconds in the future", mtime - now),
                    file_path: event.file_path.clone(),
                    original_time: None, tampered_time: Some(format!("{}", mtime)),
                    time_source: Some("filesystem".into()), log_file: None,
                    gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1070.006".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.006".into());
                categories.insert("FileTimestamp".to_string());
            }
        }

        // Spotlight vs filesystem mismatch
        if let (Some(mtime), Some(spotlight)) = (event.file_mtime, event.spotlight_date) {
            let diff = (mtime - spotlight).abs();
            if diff > 3600 {
                findings.push(TimestampFinding {
                    threat_type: TimestampThreatType::SpotlightTimeMismatch,
                    confidence: 0.75,
                    description: format!("Spotlight date differs from mtime by {} seconds", diff),
                    file_path: event.file_path.clone(),
                    original_time: Some(format!("{}", spotlight)),
                    tampered_time: Some(format!("{}", mtime)),
                    time_source: Some("spotlight".into()), log_file: None,
                    gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1070.006".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.006".into());
                categories.insert("FileTimestamp".to_string());
            }
        }

        // Pattern-based detection
        for &(pattern, desc, mitre, conf) in FILE_TIMESTAMP_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "touch_command_detected" => TimestampThreatType::TouchCommand,
                    "setfile_command_detected" => TimestampThreatType::SetFileCommand,
                    p if p.contains("utimes") || p.contains("setattrlist") => TimestampThreatType::UtimesSyscall,
                    p if p.contains("quarantine") => TimestampThreatType::QuarantineTimeMismatch,
                    p if p.contains("apfs_txn") => TimestampThreatType::APFSTxnMismatch,
                    p if p.contains("code_sign") => TimestampThreatType::CodeSignTimeMismatch,
                    p if p.contains("xattr") => TimestampThreatType::XattrTimeMismatch,
                    p if p.contains("all_times_identical") => TimestampThreatType::AllTimesIdentical,
                    p if p.contains("round_number") => TimestampThreatType::RoundTimestamp,
                    p if p.contains("atime") => TimestampThreatType::AtimeReset,
                    _ => TimestampThreatType::MtimeAncient,
                };
                findings.push(TimestampFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    file_path: event.file_path.clone(), original_time: None, tampered_time: None,
                    time_source: Some("filesystem".into()), log_file: None, gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("FileTimestamp".to_string());
            }
        }

        // ── 2. Log manipulation detection ───────────────────────────────
        for &(pattern, desc, mitre, conf) in LOG_MANIPULATION_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("unified_log_gap") => TimestampThreatType::UnifiedLogGap,
                    p if p.contains("unified_log_truncated") => TimestampThreatType::UnifiedLogTruncated,
                    p if p.contains("asl") => TimestampThreatType::ASLDeleted,
                    p if p.contains("syslog_out_of_order") => TimestampThreatType::SyslogOutOfOrder,
                    p if p.contains("audit_trail_gap") => TimestampThreatType::AuditTrailGap,
                    p if p.contains("audit_log_deleted") => TimestampThreatType::AuditLogDeleted,
                    p if p.contains("fsevents_gap") => TimestampThreatType::FSEventsGap,
                    p if p.contains("fsevents_modified") => TimestampThreatType::FSEventsModified,
                    p if p.contains("log_rotation") => TimestampThreatType::LogRotationPremature,
                    p if p.contains("diagnostics") || p.contains("crash") => TimestampThreatType::DiagnosticsDeleted,
                    _ => TimestampThreatType::UnifiedLogGap,
                };
                findings.push(TimestampFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    file_path: None, original_time: None, tampered_time: None,
                    time_source: Some("log".into()), log_file: event.log_file.clone(),
                    gap_duration_secs: event.log_gap_start.and_then(|s| event.log_gap_end.map(|e| (e - s) as u64)),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("LogManipulation".to_string());
            }
        }

        // Log gap detection from timestamps
        if let (Some(gap_start), Some(gap_end)) = (event.log_gap_start, event.log_gap_end) {
            let gap_secs = (gap_end - gap_start) as u64;
            if gap_secs > LOG_GAP_THRESHOLD_SECS {
                findings.push(TimestampFinding {
                    threat_type: TimestampThreatType::UnifiedLogGap,
                    confidence: (0.6 + (gap_secs as f64 / 3600.0).min(0.3)),
                    description: format!("Log gap of {} seconds detected ({:.1} minutes)", gap_secs, gap_secs as f64 / 60.0),
                    file_path: None, original_time: Some(format!("{}", gap_start)),
                    tampered_time: Some(format!("{}", gap_end)),
                    time_source: Some("unified_log".into()), log_file: event.log_file.clone(),
                    gap_duration_secs: Some(gap_secs),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1070.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.001".into());
                categories.insert("LogManipulation".to_string());
            }
        }

        // ── 3. System time manipulation ─────────────────────────────────
        for &(pattern, desc, mitre, conf) in SYSTEM_TIME_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("settimeofday") || p.contains("clock_settime") || p.contains("date_command") || p.contains("systemsetup") => TimestampThreatType::SystemTimeSet,
                    p if p.contains("ntp_rogue") => TimestampThreatType::NTPRogueServer,
                    p if p.contains("ntp_large") => TimestampThreatType::NTPLargeOffset,
                    p if p.contains("timezone") => TimestampThreatType::TimezoneChanged,
                    p if p.contains("jump_backward") => TimestampThreatType::TimeJumpBackward,
                    p if p.contains("jump_forward") => TimestampThreatType::TimeJumpForward,
                    p if p.contains("kernel") || p.contains("skew") => TimestampThreatType::KernelTimeskew,
                    p if p.contains("nvram") => TimestampThreatType::NVRAMTimeModified,
                    _ => TimestampThreatType::SystemTimeSet,
                };
                findings.push(TimestampFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    file_path: None, original_time: None, tampered_time: None,
                    time_source: Some("system".into()), log_file: None, gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("SystemTime".to_string());
            }
        }

        // NTP offset check
        if let Some(offset) = event.ntp_offset_secs {
            if offset.abs() > 3600.0 {
                findings.push(TimestampFinding {
                    threat_type: TimestampThreatType::NTPLargeOffset,
                    confidence: 0.8,
                    description: format!("NTP offset: {:.0} seconds from {:?}", offset, event.ntp_server),
                    file_path: None, original_time: None, tampered_time: None,
                    time_source: Some("ntp".into()), log_file: None, gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1070.006".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.006".into());
                categories.insert("SystemTime".to_string());
            }
        }

        // ── 4. Backup manipulation ──────────────────────────────────────
        for &(pattern, desc, conf) in BACKUP_MANIPULATION_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("tmutil_exclude") => TimestampThreatType::TimeMachineExclusion,
                    p if p.contains("tmutil_disable") => TimestampThreatType::TimeMachineDisabled,
                    p if p.contains("snapshot_deleted") || p.contains("tmutil_delete") => TimestampThreatType::SnapshotDeleted,
                    p if p.contains("spotlight_exclude") || p.contains("mdutil") => TimestampThreatType::SpotlightExclusion,
                    p if p.contains("spotlight_index_deleted") => TimestampThreatType::SpotlightIndexDeleted,
                    _ => TimestampThreatType::TimeMachineExclusion,
                };
                findings.push(TimestampFinding {
                    threat_type: tt, confidence: conf,
                    description: desc.to_string(),
                    file_path: event.file_path.clone(), original_time: None, tampered_time: None,
                    time_source: Some("backup".into()), log_file: None, gap_duration_secs: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    mitre_id: "T1070.006".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1070.006".into());
                categories.insert("BackupManipulation".to_string());
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},findings={}", event.event_type, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_tampered = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = TimestampAnalysisResult {
            is_tampered, events_analyzed: 1, findings,
            tampering_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_tampered {
                s.tampering_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        TimestampThreatType::MtimeBeforeBtime | TimestampThreatType::MtimeFuture |
                        TimestampThreatType::MtimeAncient | TimestampThreatType::BtimeFuture |
                        TimestampThreatType::AllTimesIdentical | TimestampThreatType::TouchCommand |
                        TimestampThreatType::SetFileCommand | TimestampThreatType::UtimesSyscall |
                        TimestampThreatType::SpotlightTimeMismatch | TimestampThreatType::APFSTxnMismatch =>
                            s.file_timestamp_anomalies += 1,
                        TimestampThreatType::UnifiedLogGap | TimestampThreatType::UnifiedLogTruncated |
                        TimestampThreatType::ASLDeleted | TimestampThreatType::AuditTrailGap |
                        TimestampThreatType::AuditLogDeleted | TimestampThreatType::FSEventsGap |
                        TimestampThreatType::FSEventsModified | TimestampThreatType::DiagnosticsDeleted =>
                            s.log_manipulation_detections += 1,
                        TimestampThreatType::SystemTimeSet | TimestampThreatType::NTPRogueServer |
                        TimestampThreatType::NTPLargeOffset | TimestampThreatType::TimeJumpBackward |
                        TimestampThreatType::TimeJumpForward | TimestampThreatType::KernelTimeskew =>
                            s.system_time_changes += 1,
                        TimestampThreatType::TimeMachineExclusion | TimestampThreatType::TimeMachineDisabled |
                        TimestampThreatType::SnapshotDeleted | TimestampThreatType::SpotlightExclusion |
                        TimestampThreatType::SpotlightIndexDeleted =>
                            s.backup_manipulation_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_tampered {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "timestamp_manipulation_detector".into(),
                title: format!("ANTI-FORENSIC: Timestamp tampering ({})",
                    result.tampering_categories.join(", ")),
                details: format!("Risk {:.1}%, {} findings, categories: {}",
                    risk_score * 100.0, result.findings.len(),
                    result.tampering_categories.join(", ")),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Preserve all forensic evidence before investigation".into(),
                    "Check APFS transaction log: diskutil apfs list".into(),
                    "Verify unified log: log show --start '2024-01-01'".into(),
                    "Check Time Machine snapshots: tmutil listlocalsnapshots /".into(),
                    "Verify NTP: sntp -d time.apple.com".into(),
                    "Check BSM audit: praudit /var/audit/*".into(),
                    "Verify fsevents: examine /.fseventsd/".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[TimestampFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                TimestampThreatType::AuditLogDeleted => 1.7,
                TimestampThreatType::MtimeBeforeBtime => 1.6,
                TimestampThreatType::APFSTxnMismatch => 1.5,
                TimestampThreatType::TimeJumpBackward => 1.5,
                TimestampThreatType::UnifiedLogTruncated | TimestampThreatType::FSEventsModified => 1.5,
                TimestampThreatType::UnifiedLogGap | TimestampThreatType::AuditTrailGap => 1.4,
                TimestampThreatType::NTPRogueServer | TimestampThreatType::KernelTimeskew => 1.4,
                TimestampThreatType::SnapshotDeleted => 1.3,
                TimestampThreatType::SetFileCommand => 1.3,
                TimestampThreatType::MtimeFuture | TimestampThreatType::BtimeFuture => 1.2,
                TimestampThreatType::SystemTimeSet => 1.2,
                TimestampThreatType::TouchCommand | TimestampThreatType::UtimesSyscall => 1.0,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> TimestampScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
