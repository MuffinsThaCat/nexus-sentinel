//! Module 136: XcodeTrojanDetector — Xcode Project & Build System Infection Detection
//!
//! Detects malicious modifications to Xcode projects, build phases, schemes, and
//! developer toolchains. XCSSET and similar supply-chain attacks target developers
//! by infecting Xcode projects so that every build produces trojaned binaries.
//!
//! ## Detection Capabilities
//!
//! - **XCSSET detection**: Infected .xcodeproj with malicious Run Script phases,
//!   xcuserdata payload injection, target modification
//! - **Malicious Run Script phases**: Build phases that download payloads, execute
//!   obfuscated code, modify build outputs, or install persistence
//! - **Xcode plugin injection**: Malicious .xcplugin bundles, DVTPlugInCompatibility
//!   manipulation, Alcatraz-style plugin abuse
//! - **Derived data poisoning**: Tampering with DerivedData build artifacts to
//!   inject code into compiled products
//! - **xcconfig manipulation**: Build configuration files with malicious flags,
//!   OTHER_LDFLAGS injection, framework search path hijacking
//! - **Scheme poisoning**: Pre/post-action scripts in .xcscheme files
//! - **Code signing manipulation**: Build settings that weaken or bypass signing,
//!   entitlement injection, provisioning profile swap
//! - **Xcode version spoofing**: Modified Xcode.app bundles, trojanized CLTs
//! - **Swift Package Manager abuse**: Malicious SPM dependencies with build plugins
//! - **CocoaPods/Carthage poisoning**: Trojanized pod specs, dependency confusion
//! - **Build tool replacement**: xcrun, xcodebuild, swift, clang path hijacking
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1195.001 — Supply Chain Compromise: Compromise Software Dependencies
//! - T1059.004 — Unix Shell (build script execution)
//! - T1553.002 — Code Signing (signing manipulation)
//! - T1574.006 — Dynamic Linker Hijacking
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const MALICIOUS_BUILD_SCRIPT_PATTERNS: &[(&str, &str, f64)] = &[
    ("curl.*|.*sh", "Pipe-to-shell in build script", 0.95),
    ("curl.*|.*bash", "Pipe-to-bash in build script", 0.95),
    ("curl.*-o.*&&.*chmod.*+x", "Download-execute in build script", 0.9),
    ("wget.*|.*sh", "wget pipe-to-shell", 0.95),
    ("osascript.*-e", "AppleScript execution in build phase", 0.7),
    ("python.*-c.*exec", "Python exec in build script", 0.75),
    ("ruby.*-e.*eval", "Ruby eval in build script", 0.7),
    ("base64.*-D.*|.*sh", "Base64 decode pipe-to-shell", 0.9),
    ("openssl.*enc.*-d", "OpenSSL decrypt in build script", 0.8),
    ("eval.*$(", "Eval of command substitution", 0.75),
    ("nc.*-e", "Netcat reverse shell in build script", 0.95),
    ("/dev/tcp/", "Bash TCP redirect (C2 communication)", 0.9),
    ("launchctl.*load", "LaunchAgent loading from build script", 0.85),
    ("defaults write.*LaunchAgents", "Persistence via defaults in build", 0.85),
    ("security.*find-generic-password", "Keychain theft in build script", 0.9),
    ("security.*dump-keychain", "Keychain dump in build script", 0.95),
    ("pbcopy", "Clipboard capture in build script", 0.5),
    ("screencapture", "Screenshot in build script", 0.7),
    ("DYLD_INSERT_LIBRARIES", "Dylib injection in build env", 0.85),
    ("xattr.*-d.*com.apple.quarantine", "Quarantine removal in build", 0.7),
    ("codesign.*--force.*--deep", "Force re-signing in build script", 0.6),
    ("install_name_tool", "Binary patching in build script", 0.5),
    ("otool.*-L", "Library inspection (recon)", 0.3),
    ("rm.*-rf.*DerivedData", "DerivedData wipe (evidence destruction)", 0.5),
    ("pkill.*Xcode", "Killing Xcode from build script", 0.7),
];

const XCSSET_INDICATORS: &[(&str, &str, f64)] = &[
    ("xcuserdata.*xcschemes.*xcschememanagement.plist", "XCSSET scheme injection", 0.9),
    ("com.apple.dt.Xcode.plist.*BuildSystemType", "XCSSET build system manipulation", 0.85),
    ("pods-resources.sh.*modified", "XCSSET Pods resources script tampering", 0.85),
    ("IDEWorkspaceChecks.plist.*injected", "XCSSET workspace check injection", 0.8),
    ("main.m.*obfuscated", "XCSSET main.m payload injection", 0.9),
    (".xcassets.*payload", "XCSSET asset catalog payload", 0.85),
    ("replicator.applescript", "XCSSET replicator module", 0.95),
    ("safari_remote.applescript", "XCSSET Safari exploitation module", 0.95),
];

const SUSPICIOUS_XCCONFIG_SETTINGS: &[(&str, &str, f64)] = &[
    ("OTHER_LDFLAGS.*-force_load", "Force-load flag (library injection)", 0.6),
    ("OTHER_LDFLAGS.*-weak_library", "Weak library load (hijack vector)", 0.5),
    ("FRAMEWORK_SEARCH_PATHS.*\\.\\.\\.", "Suspicious framework search path traversal", 0.7),
    ("LIBRARY_SEARCH_PATHS.*tmp", "Temp directory in library search path", 0.7),
    ("CODE_SIGN_IDENTITY.*-", "Ad-hoc code signing", 0.5),
    ("CODE_SIGN_IDENTITY.*\"\"", "Empty code signing identity", 0.6),
    ("CODE_SIGNING_REQUIRED.*NO", "Code signing disabled", 0.7),
    ("ENABLE_HARDENED_RUNTIME.*NO", "Hardened runtime disabled", 0.6),
    ("COMPILER_INDEX_STORE_ENABLE.*NO", "Index store disabled (hiding)", 0.3),
    ("GCC_PREPROCESSOR_DEFINITIONS.*DEBUG=0", "Force-disable debug in release", 0.3),
    ("STRIP_INSTALLED_PRODUCT.*NO", "Strip symbols disabled", 0.3),
];

const SUSPICIOUS_ENTITLEMENTS: &[(&str, &str, f64)] = &[
    ("com.apple.security.cs.allow-unsigned-executable-memory", "Unsigned executable memory", 0.7),
    ("com.apple.security.cs.disable-library-validation", "Library validation disabled", 0.8),
    ("com.apple.security.cs.allow-dyld-environment-variables", "DYLD env vars allowed", 0.8),
    ("com.apple.security.get-task-allow", "Task port access (debugging)", 0.5),
    ("com.apple.security.cs.debugger", "Debugger entitlement", 0.6),
    ("com.apple.security.temporary-exception", "Temporary security exception", 0.5),
    ("com.apple.security.network.client", "Network client (expected but noted)", 0.2),
    ("com.apple.security.files.all", "Full disk access entitlement", 0.4),
    ("com.apple.security.device.camera", "Camera access entitlement", 0.3),
    ("com.apple.security.device.microphone", "Microphone access entitlement", 0.3),
];

const SPM_ABUSE_PATTERNS: &[(&str, &str, f64)] = &[
    ("binaryTarget.*url", "SPM binary target from URL (supply chain risk)", 0.5),
    (".plugin.*buildTool", "SPM build tool plugin (code execution)", 0.6),
    (".plugin.*command", "SPM command plugin", 0.5),
    ("unsafeFlags", "SPM unsafe compiler/linker flags", 0.6),
    ("Package.swift.*Process", "Process spawning in Package.swift", 0.75),
    ("Package.swift.*FileManager", "File operations in Package.swift", 0.6),
    ("Package.swift.*URLSession", "Network access in Package.swift", 0.7),
];

const BUILD_TOOL_PATHS: &[(&str, &str, f64)] = &[
    ("/usr/local/bin/xcrun", "Non-standard xcrun location", 0.7),
    ("/usr/local/bin/xcodebuild", "Non-standard xcodebuild", 0.7),
    ("/usr/local/bin/swift", "Non-standard swift location", 0.5),
    ("/usr/local/bin/clang", "Non-standard clang", 0.5),
    ("/tmp/xcrun", "Temp directory xcrun (tool replacement)", 0.9),
    ("/tmp/xcodebuild", "Temp directory xcodebuild", 0.9),
    ("~/.local/bin/xcrun", "User-local xcrun override", 0.7),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum XcodeThreatType {
    MaliciousBuildScript,
    XCSSETInfection,
    PluginInjection,
    DerivedDataPoisoning,
    XcconfigManipulation,
    SchemePoisoning,
    CodeSigningWeakened,
    EntitlementInjection,
    XcodeVersionSpoof,
    SPMAbuse,
    DependencyConfusion,
    BuildToolReplacement,
    DownloadAndExecute,
    PersistenceViaBuild,
    CredentialTheftInBuild,
    ObfuscatedBuildScript,
    FrameworkHijacking,
    PostBuildPayload,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct XcodeThreatFinding {
    pub threat_type: XcodeThreatType,
    pub confidence: f64,
    pub description: String,
    pub project_path: Option<String>,
    pub target_name: Option<String>,
    pub build_phase: Option<String>,
    pub script_content_preview: Option<String>,
    pub malware_family: Option<String>,
    pub mitre_id: String,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct XcodeProjectEvent {
    pub event_type: String,   // "project_open", "build_start", "script_exec", "file_modify", "dependency_resolve"
    pub project_path: String,
    pub target_name: Option<String>,
    pub build_phase_name: Option<String>,
    pub script_content: Option<String>,
    pub file_path: Option<String>,
    pub xcconfig_content: Option<String>,
    pub entitlements: Option<HashMap<String, String>>,
    pub spm_manifest: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct XcodeAnalysisResult {
    pub is_infected: bool,
    pub events_analyzed: u32,
    pub findings: Vec<XcodeThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct XcodeScanStats {
    pub total_events: u64,
    pub infection_detections: u64,
    pub xcsset_detections: u64,
    pub build_script_detections: u64,
    pub spm_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct XcodeSigEntry { pub pattern: String, pub family: String, pub severity: f64 }

pub struct XcodeTrojanDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<XcodeScanStats>>,
    result_cache: TieredCache<String, XcodeAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    project_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, XcodeScanStats>>,
    metrics: MemoryMetrics,
    project_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, XcodeAnalysisResult>>,
    sig_db: PagedMemory<XcodeSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<XcodeScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl XcodeTrojanDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            project_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, XcodeScanStats::default(),
                |acc: &mut XcodeScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            project_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(XcodeScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &XcodeProjectEvent) -> Option<XcodeAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.project_path, event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // ── 1. Build script analysis ────────────────────────────────────
        if let Some(ref script) = event.script_content {
            let script_lower = script.to_lowercase();
            let preview = script.chars().take(300).collect::<String>();

            for &(pattern, desc, conf) in MALICIOUS_BUILD_SCRIPT_PATTERNS {
                if script_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("curl") && pattern.contains("sh") {
                        XcodeThreatType::DownloadAndExecute
                    } else if pattern.contains("launchctl") || pattern.contains("LaunchAgents") {
                        XcodeThreatType::PersistenceViaBuild
                    } else if pattern.contains("security") || pattern.contains("keychain") {
                        XcodeThreatType::CredentialTheftInBuild
                    } else if pattern.contains("base64") || pattern.contains("openssl") || pattern.contains("eval") {
                        XcodeThreatType::ObfuscatedBuildScript
                    } else {
                        XcodeThreatType::MaliciousBuildScript
                    };

                    findings.push(XcodeThreatFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("[{}] {}", event.build_phase_name.as_deref().unwrap_or("Run Script"), desc),
                        project_path: Some(event.project_path.clone()),
                        target_name: event.target_name.clone(),
                        build_phase: event.build_phase_name.clone(),
                        script_content_preview: Some(preview.clone()),
                        malware_family: None,
                        mitre_id: "T1195.001".into(),
                        file_path: event.file_path.clone(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1195.001".into());
                }
            }

            // XCSSET indicators
            for &(pattern, desc, conf) in XCSSET_INDICATORS {
                if script_lower.contains(&pattern.to_lowercase()) {
                    findings.push(XcodeThreatFinding {
                        threat_type: XcodeThreatType::XCSSETInfection,
                        confidence: conf,
                        description: format!("XCSSET: {}", desc),
                        project_path: Some(event.project_path.clone()),
                        target_name: event.target_name.clone(),
                        build_phase: event.build_phase_name.clone(),
                        script_content_preview: Some(preview.clone()),
                        malware_family: Some("XCSSET".into()),
                        mitre_id: "T1195.001".into(),
                        file_path: event.file_path.clone(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1195.001".into());
                }
            }
        }

        // ── 2. xcconfig analysis ────────────────────────────────────────
        if let Some(ref xcconfig) = event.xcconfig_content {
            let cfg_lower = xcconfig.to_lowercase();
            for &(pattern, desc, conf) in SUSPICIOUS_XCCONFIG_SETTINGS {
                if cfg_lower.contains(&pattern.split(".*").next().unwrap_or("").to_lowercase()) {
                    findings.push(XcodeThreatFinding {
                        threat_type: XcodeThreatType::XcconfigManipulation,
                        confidence: conf, description: desc.to_string(),
                        project_path: Some(event.project_path.clone()),
                        target_name: event.target_name.clone(),
                        build_phase: None, script_content_preview: None,
                        malware_family: None,
                        mitre_id: "T1574.006".into(),
                        file_path: event.file_path.clone(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1574.006".into());
                }
            }
        }

        // ── 3. Entitlement analysis ─────────────────────────────────────
        if let Some(ref ents) = event.entitlements {
            for (key, _value) in ents {
                for &(ent_key, desc, conf) in SUSPICIOUS_ENTITLEMENTS {
                    if key.contains(ent_key) {
                        findings.push(XcodeThreatFinding {
                            threat_type: XcodeThreatType::EntitlementInjection,
                            confidence: conf, description: desc.to_string(),
                            project_path: Some(event.project_path.clone()),
                            target_name: event.target_name.clone(),
                            build_phase: None, script_content_preview: None,
                            malware_family: None,
                            mitre_id: "T1553.002".into(),
                            file_path: event.file_path.clone(),
                            timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1553.002".into());
                    }
                }
            }
        }

        // ── 4. SPM manifest analysis ────────────────────────────────────
        if let Some(ref manifest) = event.spm_manifest {
            let man_lower = manifest.to_lowercase();
            for &(pattern, desc, conf) in SPM_ABUSE_PATTERNS {
                if man_lower.contains(&pattern.to_lowercase()) {
                    findings.push(XcodeThreatFinding {
                        threat_type: XcodeThreatType::SPMAbuse,
                        confidence: conf, description: desc.to_string(),
                        project_path: Some(event.project_path.clone()),
                        target_name: None, build_phase: None,
                        script_content_preview: None, malware_family: None,
                        mitre_id: "T1195.001".into(),
                        file_path: event.file_path.clone(),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1195.001".into());
                }
            }
        }

        // ── 5. Build tool path hijacking ────────────────────────────────
        if let Some(ref file) = event.file_path {
            for &(tool_path, desc, conf) in BUILD_TOOL_PATHS {
                if file.to_lowercase().contains(&tool_path.to_lowercase().replace("~/", "")) {
                    findings.push(XcodeThreatFinding {
                        threat_type: XcodeThreatType::BuildToolReplacement,
                        confidence: conf, description: desc.to_string(),
                        project_path: Some(event.project_path.clone()),
                        target_name: None, build_phase: None,
                        script_content_preview: None, malware_family: None,
                        mitre_id: "T1574.006".into(),
                        file_path: Some(file.clone()),
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1574.006".into());
                }
            }
        }

        // ── Store & finalize ────────────────────────────────────────────
        self.project_diffs.write().record_insert(cache_key.clone(),
            format!("project={},type={},findings={}", event.project_path, event.event_type, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_infected = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = XcodeAnalysisResult {
            is_infected, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_infected { s.infection_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_infected {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "xcode_trojan_detector".into(),
                title: format!("Infected Xcode project: {}", event.project_path),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: Some(event.project_path.clone()),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Do NOT build this project until cleaned".into(),
                    "Check Run Script build phases for suspicious code".into(),
                    "Verify .xcodeproj/project.pbxproj in git diff".into(),
                    "Remove xcuserdata directory and re-clone".into(),
                    "Verify Xcode.app integrity: codesign -vvvv /Applications/Xcode.app".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[XcodeThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                XcodeThreatType::XCSSETInfection => 1.6,
                XcodeThreatType::DownloadAndExecute => 1.5,
                XcodeThreatType::CredentialTheftInBuild => 1.5,
                XcodeThreatType::PersistenceViaBuild => 1.4,
                XcodeThreatType::BuildToolReplacement => 1.4,
                XcodeThreatType::ObfuscatedBuildScript => 1.3,
                XcodeThreatType::MaliciousBuildScript => 1.2,
                XcodeThreatType::EntitlementInjection => 1.1,
                XcodeThreatType::XcconfigManipulation => 1.0,
                XcodeThreatType::SPMAbuse => 1.0,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> XcodeScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
