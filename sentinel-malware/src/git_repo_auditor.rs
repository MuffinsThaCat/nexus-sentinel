//! Module 137: GitRepoAuditor — Git Repository Security & Supply Chain Detection
//!
//! Detects malicious Git repository configurations, credential theft via Git,
//! pre/post-commit hook abuse, dependency confusion, and supply-chain attacks
//! targeting developer workflows through version control.
//!
//! ## Detection Capabilities
//!
//! - **Git hook abuse**: Malicious pre-commit, post-commit, pre-push, post-checkout,
//!   post-merge hooks that execute payloads, steal credentials, or install persistence
//! - **Credential theft**: .git-credentials exposure, credential helper abuse,
//!   SSH key theft via git operations, token leakage in .git/config
//! - **Git config manipulation**: core.sshCommand hijacking, core.gitProxy abuse,
//!   credential.helper replacement, protocol.allow manipulation
//! - **Submodule attacks**: Malicious submodule URLs pointing to attacker repos,
//!   submodule path traversal (.gitmodules manipulation)
//! - **Git LFS abuse**: LFS hooks replacing legitimate hooks, LFS endpoint redirect
//! - **Secret detection**: API keys, tokens, passwords committed to repositories
//! - **Dependency confusion**: Package names that shadow internal packages
//! - **Typosquatting detection**: Package names similar to popular packages
//! - **.gitattributes abuse**: Filter driver execution via smudge/clean attributes
//! - **Shallow clone manipulation**: Hiding malicious history in truncated repos
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1195.001 — Supply Chain: Software Dependencies
//! - T1059.004 — Unix Shell (hook execution)
//! - T1552.001 — Credentials In Files
//! - T1552.004 — Private Keys
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const MALICIOUS_HOOK_PATTERNS: &[(&str, &str, f64)] = &[
    ("curl.*|.*sh", "Pipe-to-shell in git hook", 0.95),
    ("curl.*|.*bash", "Pipe-to-bash in git hook", 0.95),
    ("wget.*|.*sh", "wget pipe-to-shell in hook", 0.95),
    ("base64.*-D", "Base64 decode in git hook", 0.7),
    ("eval.*$(", "Eval of command substitution in hook", 0.75),
    ("nc.*-e", "Netcat reverse shell in hook", 0.95),
    ("/dev/tcp/", "Bash TCP redirect in hook", 0.9),
    ("osascript.*-e", "AppleScript in git hook", 0.7),
    ("python.*-c.*exec", "Python exec in git hook", 0.7),
    ("security.*find-generic-password", "Keychain access in git hook", 0.9),
    ("launchctl.*load", "Persistence installation in git hook", 0.85),
    ("defaults write.*LaunchAgents", "LaunchAgent persistence in hook", 0.85),
    ("chmod.*+x.*&&", "Make executable and run in hook", 0.6),
    ("nohup", "Background persistent execution in hook", 0.7),
    ("xattr.*-d.*quarantine", "Quarantine removal in hook", 0.7),
    ("DYLD_INSERT_LIBRARIES", "Dylib injection in hook", 0.85),
    ("ssh-add", "SSH key manipulation in hook", 0.5),
    ("git credential.*reject", "Credential rejection manipulation", 0.6),
    ("pbcopy", "Clipboard capture in hook", 0.5),
];

const GIT_CONFIG_ATTACKS: &[(&str, &str, f64)] = &[
    ("core.sshCommand", "SSH command override (C2 tunnel)", 0.8),
    ("core.gitProxy", "Git proxy override (MITM)", 0.8),
    ("core.hooksPath", "Hooks path override (hijacking)", 0.7),
    ("credential.helper.*!", "Shell command credential helper", 0.85),
    ("credential.helper.*curl", "Curl-based credential exfil", 0.9),
    ("credential.helper.*nc", "Netcat credential exfil", 0.95),
    ("protocol.ext.allow.*always", "External protocol allowed", 0.6),
    ("filter.*.smudge", "Smudge filter (code execution on checkout)", 0.7),
    ("filter.*.clean", "Clean filter (code execution on add)", 0.6),
    ("filter.*.process", "Process filter (persistent code exec)", 0.7),
    ("url.*.insteadOf", "URL rewrite rule (repo redirect)", 0.6),
    ("http.proxy", "HTTP proxy configuration (MITM)", 0.5),
    ("http.sslVerify.*false", "SSL verification disabled", 0.7),
    ("safe.directory.*\\*", "All directories marked safe (security bypass)", 0.6),
];

const SECRET_PATTERNS: &[(&str, &str, f64)] = &[
    ("AKIA[0-9A-Z]{16}", "AWS Access Key ID", 0.9),
    ("ghp_[a-zA-Z0-9]{36}", "GitHub Personal Access Token", 0.9),
    ("gho_[a-zA-Z0-9]{36}", "GitHub OAuth Token", 0.9),
    ("github_pat_", "GitHub Fine-Grained PAT", 0.85),
    ("sk-[a-zA-Z0-9]{48}", "OpenAI API Key", 0.9),
    ("sk_live_", "Stripe Live Secret Key", 0.95),
    ("pk_live_", "Stripe Live Publishable Key", 0.7),
    ("xoxb-", "Slack Bot Token", 0.85),
    ("xoxp-", "Slack User Token", 0.85),
    ("-----BEGIN RSA PRIVATE KEY-----", "RSA Private Key", 0.9),
    ("-----BEGIN OPENSSH PRIVATE KEY-----", "OpenSSH Private Key", 0.9),
    ("-----BEGIN EC PRIVATE KEY-----", "EC Private Key", 0.9),
    ("-----BEGIN PGP PRIVATE KEY BLOCK-----", "PGP Private Key", 0.9),
    ("AIza[0-9A-Za-z\\-_]{35}", "Google API Key", 0.85),
    ("SG\\.[a-zA-Z0-9_-]{22}\\.[a-zA-Z0-9_-]{43}", "SendGrid API Key", 0.9),
    ("npm_[a-zA-Z0-9]{36}", "npm Token", 0.85),
    ("pypi-AgEIcHlwaS5vcmc", "PyPI API Token", 0.9),
    ("password.*=.*['\"]", "Hardcoded password", 0.6),
    ("secret.*=.*['\"]", "Hardcoded secret", 0.6),
    ("token.*=.*['\"]", "Hardcoded token", 0.5),
    ("api_key.*=.*['\"]", "Hardcoded API key", 0.6),
];

const SUBMODULE_ATTACKS: &[(&str, &str, f64)] = &[
    ("..", "Path traversal in submodule path", 0.9),
    ("file://", "Local file protocol submodule", 0.6),
    ("ssh://.*@.*:", "SSH submodule with credentials", 0.5),
    ("http://", "Insecure HTTP submodule (MITM risk)", 0.5),
    (".git/", "Submodule path into .git directory", 0.9),
    ("~", "Home directory reference in submodule", 0.7),
];

const DANGEROUS_HOOKS: &[&str] = &[
    "pre-commit", "post-commit", "pre-push", "post-checkout",
    "post-merge", "pre-rebase", "post-rewrite", "prepare-commit-msg",
    "commit-msg", "applypatch-msg", "pre-applypatch", "post-applypatch",
    "fsmonitor-watchman", "p4-changelist", "p4-prepare-changelist",
    "p4-post-changelist", "p4-pre-submit", "sendemail-validate",
    "post-index-change",
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum GitThreatType {
    MaliciousHook,
    CredentialTheft,
    ConfigManipulation,
    SubmoduleAttack,
    SecretExposure,
    FilterDriverAbuse,
    LFSAbuse,
    DependencyConfusion,
    Typosquatting,
    SSHKeyTheft,
    HookPathHijack,
    URLRewrite,
    SSLBypass,
    DownloadAndExecute,
    PersistenceViaHook,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GitThreatFinding {
    pub threat_type: GitThreatType,
    pub confidence: f64,
    pub description: String,
    pub repo_path: String,
    pub hook_name: Option<String>,
    pub config_key: Option<String>,
    pub secret_type: Option<String>,
    pub mitre_id: String,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GitRepoEvent {
    pub event_type: String,
    pub repo_path: String,
    pub hook_name: Option<String>,
    pub hook_content: Option<String>,
    pub config_key: Option<String>,
    pub config_value: Option<String>,
    pub file_path: Option<String>,
    pub file_content: Option<String>,
    pub submodule_url: Option<String>,
    pub submodule_path: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GitAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<GitThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct GitScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub hook_detections: u64,
    pub secret_detections: u64,
    pub config_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GitSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

pub struct GitRepoAuditor {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<GitScanStats>>,
    result_cache: TieredCache<String, GitAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    repo_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, GitScanStats>>,
    metrics: MemoryMetrics,
    repo_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, GitAnalysisResult>>,
    sig_db: PagedMemory<GitSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<GitScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl GitRepoAuditor {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            repo_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, GitScanStats::default(),
                |acc: &mut GitScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            repo_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(GitScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &GitRepoEvent) -> Option<GitAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.repo_path, event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // ── 1. Hook content analysis ────────────────────────────────────
        if let Some(ref content) = event.hook_content {
            let content_lower = content.to_lowercase();
            for &(pattern, desc, conf) in MALICIOUS_HOOK_PATTERNS {
                if content_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("curl") && pattern.contains("sh") { GitThreatType::DownloadAndExecute }
                        else if pattern.contains("launchctl") || pattern.contains("LaunchAgents") { GitThreatType::PersistenceViaHook }
                        else if pattern.contains("security") || pattern.contains("credential") { GitThreatType::CredentialTheft }
                        else if pattern.contains("ssh") { GitThreatType::SSHKeyTheft }
                        else { GitThreatType::MaliciousHook };
                    findings.push(GitThreatFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("[{}] {}", event.hook_name.as_deref().unwrap_or("hook"), desc),
                        repo_path: event.repo_path.clone(),
                        hook_name: event.hook_name.clone(),
                        config_key: None, secret_type: None,
                        mitre_id: "T1059.004".into(),
                        file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1059.004".into());
                }
            }
        }

        // ── 2. Config manipulation detection ────────────────────────────
        if let Some(ref key) = event.config_key {
            let config_text = format!("{} {}", key, event.config_value.as_deref().unwrap_or(""));
            let cfg_lower = config_text.to_lowercase();
            for &(pattern, desc, conf) in GIT_CONFIG_ATTACKS {
                if cfg_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("credential") { GitThreatType::CredentialTheft }
                        else if pattern.contains("sshCommand") { GitThreatType::ConfigManipulation }
                        else if pattern.contains("filter") { GitThreatType::FilterDriverAbuse }
                        else if pattern.contains("url") && pattern.contains("insteadOf") { GitThreatType::URLRewrite }
                        else if pattern.contains("ssl") { GitThreatType::SSLBypass }
                        else if pattern.contains("hooksPath") { GitThreatType::HookPathHijack }
                        else { GitThreatType::ConfigManipulation };
                    findings.push(GitThreatFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        repo_path: event.repo_path.clone(),
                        hook_name: None, config_key: Some(key.clone()),
                        secret_type: None,
                        mitre_id: "T1195.001".into(),
                        file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1195.001".into());
                }
            }
        }

        // ── 3. Secret detection ─────────────────────────────────────────
        if let Some(ref content) = event.file_content {
            for &(pattern, desc, conf) in SECRET_PATTERNS {
                let pattern_simple = pattern.replace("[0-9A-Z]", "").replace("[a-zA-Z0-9]", "")
                    .replace("{16}", "").replace("{36}", "").replace("{48}", "")
                    .replace("{35}", "").replace("{22}", "").replace("{43}", "")
                    .replace("[a-zA-Z0-9_-]", "").replace("[a-zA-Z0-9\\-_]", "")
                    .replace("[0-9A-Za-z\\-_]", "").replace("['\"]", "")
                    .replace(".*", "");
                if !pattern_simple.is_empty() && content.contains(&pattern_simple) {
                    findings.push(GitThreatFinding {
                        threat_type: GitThreatType::SecretExposure,
                        confidence: conf, description: desc.to_string(),
                        repo_path: event.repo_path.clone(),
                        hook_name: None, config_key: None,
                        secret_type: Some(desc.to_string()),
                        mitre_id: "T1552.001".into(),
                        file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1552.001".into());
                    break; // One secret finding per file
                }
            }
        }

        // ── 4. Submodule attack detection ───────────────────────────────
        if let Some(ref url) = event.submodule_url {
            for &(pattern, desc, conf) in SUBMODULE_ATTACKS {
                let check = if let Some(ref path) = event.submodule_path {
                    format!("{} {}", url, path)
                } else { url.clone() };
                if check.contains(pattern) {
                    findings.push(GitThreatFinding {
                        threat_type: GitThreatType::SubmoduleAttack,
                        confidence: conf, description: format!("{}: {}", desc, url),
                        repo_path: event.repo_path.clone(),
                        hook_name: None, config_key: None, secret_type: None,
                        mitre_id: "T1195.001".into(),
                        file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1195.001".into());
                }
            }
        }

        self.repo_diffs.write().record_insert(cache_key.clone(),
            format!("repo={},type={},findings={}", event.repo_path, event.event_type, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = GitAnalysisResult {
            is_malicious, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_malicious { s.malicious_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "git_repo_auditor".into(),
                title: format!("Git repo threat: {}", event.repo_path),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: Some(event.repo_path.clone()),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Inspect .git/hooks/ for unauthorized scripts".into(),
                    "Run: git config --list --show-origin to audit config".into(),
                    "Check .gitmodules for suspicious URLs".into(),
                    "Use git-secrets or trufflehog to scan for secrets".into(),
                    "Verify .gitattributes filter drivers".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[GitThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                GitThreatType::DownloadAndExecute => 1.5,
                GitThreatType::CredentialTheft => 1.5,
                GitThreatType::PersistenceViaHook => 1.4,
                GitThreatType::SSHKeyTheft => 1.4,
                GitThreatType::MaliciousHook => 1.3,
                GitThreatType::FilterDriverAbuse => 1.2,
                GitThreatType::SubmoduleAttack => 1.2,
                GitThreatType::SecretExposure => 1.1,
                GitThreatType::ConfigManipulation => 1.0,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> GitScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
