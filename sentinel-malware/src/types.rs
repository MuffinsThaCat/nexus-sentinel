//! Shared types for the sentinel-malware antivirus engine.

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// φ (golden ratio) — used for optimal thresholds, scheduling intervals, cache splits
pub const PHI: f64 = 1.618033988749895;
/// 1/φ — inverse golden ratio
pub const INV_PHI: f64 = 0.6180339887498949;
/// Fibonacci sequence for adaptive window sizing
pub const FIBONACCI: [usize; 20] = [
    1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765,
];

// ── Severity ────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum Severity {
    #[default]
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl Severity {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Info     => "info",
            Self::Low      => "low",
            Self::Medium   => "medium",
            Self::High     => "high",
            Self::Critical => "critical",
        }
    }
    pub fn score(&self) -> f64 {
        match self {
            Self::Info     => 0.0,
            Self::Low      => 0.25,
            Self::Medium   => 0.5,
            Self::High     => 0.75,
            Self::Critical => 1.0,
        }
    }
}

// ── Scan Verdict ────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ScanVerdict {
    Clean,
    Suspicious { score: f64, reasons: Vec<String> },
    Malicious  { rule_name: String, details: String },
    HashMatch  { hash: String, family: String },
    Pup        { name: String, category: PupCategory },
    Ransomware { family: String, indicators: Vec<String> },
    Rootkit    { technique: String, evidence: Vec<String> },
    Exploit    { cve: Option<String>, technique: String },
    Error      { message: String },
}

impl ScanVerdict {
    pub fn is_threat(&self) -> bool {
        matches!(self, Self::Malicious { .. } | Self::HashMatch { .. }
            | Self::Ransomware { .. } | Self::Rootkit { .. } | Self::Exploit { .. })
    }
    pub fn is_suspicious(&self) -> bool {
        matches!(self, Self::Suspicious { .. } | Self::Pup { .. })
    }
    pub fn severity(&self) -> Severity {
        match self {
            Self::Ransomware { .. } => Severity::Critical,
            Self::Rootkit { .. }    => Severity::Critical,
            Self::HashMatch { .. }  => Severity::Critical,
            Self::Exploit { .. }    => Severity::High,
            Self::Malicious { .. }  => Severity::High,
            Self::Pup { .. }        => Severity::Medium,
            Self::Suspicious { .. } => Severity::Medium,
            Self::Clean             => Severity::Info,
            Self::Error { .. }      => Severity::Low,
        }
    }
}

// ── Scan Result ─────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    pub path: String,
    pub hash_sha256: String,
    pub hash_blake3: String,
    pub size_bytes: u64,
    pub file_class: FileRiskClass,
    pub verdict: ScanVerdict,
    pub scanned_at: i64,
    pub scan_duration_us: u64,
    pub entropy: f64,
    pub engines_matched: Vec<String>,
    pub mitre_ids: Vec<String>,
}

// ── File Risk Classification ────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum FileRiskClass {
    Executable,
    Script,
    Archive,
    Document,
    Media,
    Data,
    SystemConfig,
    Unknown,
}

impl Default for FileRiskClass {
    fn default() -> Self { Self::Unknown }
}

impl FileRiskClass {
    pub fn from_extension(ext: &str) -> Self {
        match ext.to_lowercase().as_str() {
            "exe" | "dll" | "sys" | "drv" | "scr" | "com" | "pif" |
            "elf" | "so" | "dylib" | "bin" | "app" | "msi" | "msp" |
            "deb" | "rpm" | "dmg" | "pkg" | "appimage" | "mach" => Self::Executable,
            "bat" | "cmd" | "ps1" | "psm1" | "psd1" | "vbs" | "vbe" |
            "js" | "jse" | "wsh" | "wsf" | "py" | "pyw" | "rb" |
            "pl" | "sh" | "bash" | "zsh" | "csh" | "ksh" | "fish" |
            "php" | "asp" | "aspx" | "jsp" | "lua" | "tcl" | "r" |
            "swift" | "go" | "rs" | "hta" | "inf" | "reg" | "sct" |
            "scpt" | "applescript" | "osascript" => Self::Script,
            "zip" | "rar" | "7z" | "tar" | "gz" | "bz2" | "xz" |
            "cab" | "iso" | "img" | "arj" | "lzh" | "z" | "ace" |
            "uue" | "jar" | "war" | "ear" | "apk" | "ipa" | "zst" |
            "lz4" | "br" | "cpio" | "shar" => Self::Archive,
            "doc" | "docx" | "docm" | "xls" | "xlsx" | "xlsm" |
            "ppt" | "pptx" | "pptm" | "pdf" | "rtf" | "odt" |
            "ods" | "odp" | "pub" | "one" | "xps" | "pages" |
            "numbers" | "key" => Self::Document,
            "jpg" | "jpeg" | "png" | "gif" | "bmp" | "svg" | "webp" |
            "mp3" | "wav" | "flac" | "ogg" | "aac" | "wma" |
            "mp4" | "avi" | "mkv" | "mov" | "wmv" | "flv" | "webm" |
            "tiff" | "ico" | "heic" | "heif" | "raw" => Self::Media,
            "plist" | "launchd" | "service" | "timer" | "socket" |
            "conf" | "cfg" | "ini" | "env" | "profile" | "bashrc" |
            "zshrc" | "crontab" => Self::SystemConfig,
            "json" | "xml" | "csv" | "tsv" | "yaml" | "yml" |
            "toml" | "log" | "txt" | "md" | "rst" |
            "html" | "htm" | "css" => Self::Data,
            _ => Self::Unknown,
        }
    }

    pub fn base_risk_score(&self) -> f64 {
        match self {
            Self::Executable   => 0.85,
            Self::Script       => 0.75,
            Self::SystemConfig => 0.65,
            Self::Archive      => 0.55,
            Self::Document     => 0.45,
            Self::Unknown      => 0.35,
            Self::Data         => 0.15,
            Self::Media        => 0.05,
        }
    }
}

// ── File Event Types ────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum FileEventKind {
    #[default]
    Created,
    Modified,
    Deleted,
    Renamed,
    Accessed,
    PermissionChanged,
    AttributeChanged,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEvent {
    pub path: PathBuf,
    pub kind: FileEventKind,
    pub timestamp: i64,
    pub process_pid: Option<u32>,
    pub process_name: Option<String>,
    pub size_bytes: Option<u64>,
}

// ── PUP Categories ──────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PupCategory {
    Adware,
    BrowserHijacker,
    Toolbar,
    Bundleware,
    SystemOptimizer,
    TechSupportScam,
    Cryptominer,
    Trackware,
    Dialer,
    Riskware,
}

// ── YARA Rule ───────────────────────────────────────────────────────────────

#[derive(Debug, Clone)]
pub struct YaraRule {
    pub id: u32,
    pub name: String,
    pub description: String,
    pub severity: Severity,
    pub family: String,
    pub tags: Vec<String>,
    pub patterns: Vec<RulePattern>,
    pub condition: RuleCondition,
    pub mitre_id: Option<String>,
    pub author: String,
    pub date: String,
    pub reference: Option<String>,
}

#[derive(Debug, Clone)]
pub enum RulePattern {
    Bytes(Vec<u8>),
    StringCI(String),
    StringExact(String),
    HexWild(Vec<HexByte>),
    Regex(String),
    Base64Encoded(String),
    Wide(String),
}

#[derive(Debug, Clone, Copy)]
pub enum HexByte {
    Exact(u8),
    Wild,
    MaskedHigh(u8),
    MaskedLow(u8),
}

#[derive(Debug, Clone)]
pub enum RuleCondition {
    AllOf,
    AnyOf,
    AtLeast(usize),
    Expression(String),
}

impl RulePattern {
    pub fn matches(&self, data: &[u8]) -> bool {
        match self {
            Self::Bytes(pat) => {
                if pat.len() > data.len() { return false; }
                data.windows(pat.len()).any(|w| w == pat.as_slice())
            }
            Self::StringCI(s) => {
                let lower = s.to_lowercase();
                let pat = lower.as_bytes();
                if pat.len() > data.len() { return false; }
                let mut buf = vec![0u8; data.len()];
                for (i, &b) in data.iter().enumerate() {
                    buf[i] = if b >= b'A' && b <= b'Z' { b + 32 } else { b };
                }
                buf.windows(pat.len()).any(|w| w == pat)
            }
            Self::StringExact(s) => {
                let pat = s.as_bytes();
                if pat.len() > data.len() { return false; }
                data.windows(pat.len()).any(|w| w == pat)
            }
            Self::HexWild(pattern) => {
                if pattern.len() > data.len() { return false; }
                data.windows(pattern.len()).any(|window| {
                    window.iter().zip(pattern.iter()).all(|(&d, h)| match h {
                        HexByte::Exact(b) => d == *b,
                        HexByte::Wild => true,
                        HexByte::MaskedHigh(b) => (d & 0xF0) == *b,
                        HexByte::MaskedLow(b) => (d & 0x0F) == *b,
                    })
                })
            }
            Self::Regex(pattern) => {
                if let Ok(re) = regex::Regex::new(pattern) {
                    re.is_match(&String::from_utf8_lossy(data))
                } else {
                    false
                }
            }
            Self::Base64Encoded(s) => {
                // Check if the base64 encoding of the string appears in data
                use std::fmt::Write;
                let encoded = base64_encode(s.as_bytes());
                let pat = encoded.as_bytes();
                if pat.len() > data.len() { return false; }
                data.windows(pat.len()).any(|w| w == pat)
            }
            Self::Wide(s) => {
                // UTF-16LE encoding check
                let wide: Vec<u8> = s.bytes().flat_map(|b| [b, 0]).collect();
                if wide.len() > data.len() { return false; }
                data.windows(wide.len()).any(|w| w == wide.as_slice())
            }
        }
    }
}

/// Minimal base64 encoder (no external dependency needed)
fn base64_encode(input: &[u8]) -> String {
    const CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let mut result = String::with_capacity((input.len() + 2) / 3 * 4);
    for chunk in input.chunks(3) {
        let b0 = chunk[0] as u32;
        let b1 = if chunk.len() > 1 { chunk[1] as u32 } else { 0 };
        let b2 = if chunk.len() > 2 { chunk[2] as u32 } else { 0 };
        let triple = (b0 << 16) | (b1 << 8) | b2;
        result.push(CHARS[((triple >> 18) & 0x3F) as usize] as char);
        result.push(CHARS[((triple >> 12) & 0x3F) as usize] as char);
        if chunk.len() > 1 {
            result.push(CHARS[((triple >> 6) & 0x3F) as usize] as char);
        } else {
            result.push('=');
        }
        if chunk.len() > 2 {
            result.push(CHARS[(triple & 0x3F) as usize] as char);
        } else {
            result.push('=');
        }
    }
    result
}

// ── Quarantine Entry ────────────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuarantineEntry {
    pub id: String,
    pub original_path: String,
    pub vault_path: String,
    pub hash_sha256: String,
    pub hash_blake3: String,
    pub verdict: ScanVerdict,
    pub quarantined_at: i64,
    pub size_bytes: u64,
    pub encryption_iv: String,
    pub restored: bool,
    pub auto_delete_at: Option<i64>,
    pub chain_of_custody: Vec<CustodyEvent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustodyEvent {
    pub timestamp: i64,
    pub action: CustodyAction,
    pub actor: String,
    pub reason: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CustodyAction {
    Quarantined,
    Analyzed,
    Submitted,
    Restored,
    Deleted,
    Extended,
    Exported,
}

// ── Malware Alert ───────────────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareAlert {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub module: String,
    pub title: String,
    pub details: String,
    pub path: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub verdict: Option<ScanVerdict>,
    pub mitre_ids: Vec<String>,
    pub remediation: Vec<String>,
    pub confidence: f64,
}

// ── Scan Statistics ─────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ScanStatistics {
    pub files_scanned: u64,
    pub bytes_scanned: u64,
    pub threats_found: u64,
    pub suspicious_found: u64,
    pub pups_found: u64,
    pub clean_files: u64,
    pub errors: u64,
    pub skipped: u64,
    pub quarantined: u64,
    pub scan_duration_ms: u64,
    pub avg_file_scan_us: u64,
    pub peak_memory_bytes: u64,
}

// ── Process Info (for rootkit/exploit detection) ────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessSnapshot {
    pub pid: u32,
    pub ppid: u32,
    pub name: String,
    pub exe_path: String,
    pub cmdline: String,
    pub user: String,
    pub start_time: i64,
    pub memory_bytes: u64,
    pub open_files: Vec<String>,
    pub open_ports: Vec<u16>,
    pub loaded_libs: Vec<String>,
    pub env_vars: Vec<(String, String)>,
    pub hidden: bool,
    pub signed: Option<bool>,
}

// ── Launch Item Types ───────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum LaunchItemType {
    LaunchDaemon,
    LaunchAgent,
    LoginItem,
    CronJob,
    AtJob,
    StartupScript,
    BrowserExtension,
    KernelExtension,
    SystemExtension,
    LoginHook,
    LogoutHook,
    PeriodicScript,
    XPCService,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LaunchItem {
    pub item_type: LaunchItemType,
    pub label: String,
    pub path: String,
    pub program: Option<String>,
    pub program_arguments: Vec<String>,
    pub run_at_load: bool,
    pub keep_alive: bool,
    pub user: Option<String>,
    pub plist_path: Option<String>,
    pub hash_sha256: Option<String>,
    pub signed: Option<bool>,
    pub signer: Option<String>,
    pub first_seen: i64,
    pub last_modified: i64,
    pub risk_score: f64,
}

// ── Memory Protection Info ──────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ProtectionFeature {
    ASLR,
    DEP,
    StackCanary,
    SIP,
    Hardened,
    Sandboxed,
    LibraryValidation,
    RestrictSegment,
    PIE,
    Fortified,
    RelRO,
    NXStack,
    SafeSEH,
    CFGuard,
    ACG,
    CET,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtectionStatus {
    pub feature: ProtectionFeature,
    pub enabled: bool,
    pub details: String,
    pub recommendation: Option<String>,
}

// ── Script Analysis ─────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ScriptLanguage {
    Bash,
    Zsh,
    PowerShell,
    Python,
    Ruby,
    Perl,
    AppleScript,
    JXA,
    JavaScript,
    VBScript,
    Batch,
    Lua,
    PHP,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScriptAnalysis {
    pub language: ScriptLanguage,
    pub path: String,
    pub obfuscation_score: f64,
    pub obfuscation_techniques: Vec<String>,
    pub deobfuscated_preview: Option<String>,
    pub suspicious_apis: Vec<String>,
    pub urls_found: Vec<String>,
    pub ips_found: Vec<String>,
    pub encoded_payloads: Vec<String>,
    pub verdict: ScanVerdict,
    pub entropy: f64,
}

// ── Archive Analysis ────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ArchiveFormat {
    Zip,
    Rar,
    SevenZip,
    TarGz,
    TarBz2,
    TarXz,
    Dmg,
    Iso,
    Cab,
    Cpio,
    Jar,
    Apk,
    Ipa,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveAnalysis {
    pub format: ArchiveFormat,
    pub path: String,
    pub total_entries: usize,
    pub suspicious_entries: Vec<ArchiveEntry>,
    pub nested_depth: usize,
    pub password_protected: bool,
    pub zip_bomb_detected: bool,
    pub total_uncompressed_bytes: u64,
    pub compression_ratio: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveEntry {
    pub name: String,
    pub size_compressed: u64,
    pub size_uncompressed: u64,
    pub file_class: FileRiskClass,
    pub verdict: ScanVerdict,
    pub nested_archive: bool,
}

// ── Reputation ──────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ReputationVerdict {
    Known,
    KnownMalicious,
    KnownClean,
    Suspicious,
    Unknown,
    Error,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationResult {
    pub hash: String,
    pub verdict: ReputationVerdict,
    pub first_seen: Option<i64>,
    pub last_seen: Option<i64>,
    pub detection_count: u32,
    pub total_submissions: u32,
    pub family: Option<String>,
    pub tags: Vec<String>,
    pub source: String,
    pub cached: bool,
    pub query_time_ms: u64,
}

// ── Scheduled Scan Config ───────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScheduleConfig {
    pub id: String,
    pub name: String,
    pub scan_type: ScheduledScanType,
    pub cron_expression: String,
    pub enabled: bool,
    pub paths: Vec<String>,
    pub exclusions: Vec<String>,
    pub max_duration_minutes: u64,
    pub cpu_limit_percent: f64,
    pub last_run: Option<i64>,
    pub next_run: Option<i64>,
    pub last_result: Option<ScanStatistics>,
    pub catch_up_missed: bool,
    pub notify_on_threat: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ScheduledScanType {
    Quick,
    Full,
    Custom,
    Critical,
}
