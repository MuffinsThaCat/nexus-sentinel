//! Module 16: MemoryScanner — Fileless Malware Detection via Process Memory Scanning
//!
//! World-class in-memory threat detection that identifies malware operating entirely
//! in RAM without touching disk. This is the #1 evasion technique in modern attacks.
//!
//! ## Features
//!
//! - **Shellcode detection**: Scans process memory for known shellcode patterns
//!   (Cobalt Strike, Metasploit, Sliver, Mythic, Havoc, Brute Ratel)
//! - **RWX region analysis**: Identifies Read-Write-Execute memory regions that
//!   indicate code injection or JIT-compiled exploits
//! - **Entropy analysis**: Detects encrypted/packed payloads in memory via
//!   Shannon entropy with φ-golden-section thresholds
//! - **PE/Mach-O header detection**: Finds executable headers in non-image memory
//!   (indicates reflective DLL injection or process hollowing)
//! - **String extraction**: Extracts IOCs (URLs, IPs, C2 domains) from process memory
//! - **YARA-in-memory**: Applies YARA-like pattern matching against live memory
//! - **Heap spray detection**: Identifies large NOP sleds and repeated patterns
//! - **Stack pivot detection**: Detects RSP/RBP manipulation indicating ROP chains
//! - **Hook detection**: Identifies function prologue modifications in loaded libraries
//! - **Memory-mapped file analysis**: Scans anonymous mmap regions for threats
//!
//! ## Detection-Only Mode
//!
//! Without `task_for_pid` entitlement on macOS, this module uses `/proc` metadata,
//! `vmmap` output parsing, and sysinfo APIs. Full deep-scan requires the debugging
//! entitlement from Apple.
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet};
use std::sync::atomic::{AtomicU64, Ordering};
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ───────────────────────────────────────────────────────────────

const SCAN_CACHE_MAX: usize = 5_000;
const FINDING_CACHE_HOT: usize = 500;
const FINDING_CACHE_WARM: usize = 2_000;
const FINDING_CACHE_COLD: usize = 10_000;
const HISTORY_LEVELS: u32 = 6;
const HISTORY_PER_LEVEL: usize = 64;
const STATS_WINDOW: usize = 256;
const RWX_ENTROPY_THRESHOLD: f64 = 6.5;
const SHELLCODE_MIN_LENGTH: usize = 32;
const HEAP_SPRAY_THRESHOLD: usize = 4096;
const MAX_REGIONS_PER_PROCESS: usize = 2048;

// ── Shellcode Signatures ────────────────────────────────────────────────────

/// Known shellcode prologue patterns (first 4-8 bytes)
const SHELLCODE_PATTERNS: &[(&str, &[u8])] = &[
    // x86_64 common shellcode prologues
    ("metasploit_reverse_tcp", &[0x48, 0x31, 0xc9, 0x48, 0x81, 0xe9]),
    ("metasploit_bind_tcp",    &[0x48, 0x31, 0xc0, 0x48, 0x89, 0xc2]),
    ("cobalt_strike_beacon",   &[0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8]),
    ("cobalt_strike_stager",   &[0xfc, 0xe8, 0x89, 0x00, 0x00, 0x00]),
    ("sliver_stager",          &[0x48, 0x89, 0xe5, 0x48, 0x83, 0xec]),
    ("havoc_demon",            &[0x55, 0x48, 0x89, 0xe5, 0x48, 0x81]),
    ("brute_ratel_badger",     &[0x4d, 0x5a, 0x41, 0x52, 0x55, 0x48]),
    // NOP sleds
    ("nop_sled_x86",           &[0x90, 0x90, 0x90, 0x90, 0x90, 0x90]),
    // Common syscall patterns
    ("syscall_execve",         &[0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00]),
    ("syscall_fork",           &[0x48, 0xc7, 0xc0, 0x39, 0x00, 0x00]),
    // macOS-specific
    ("macho_in_memory",        &[0xcf, 0xfa, 0xed, 0xfe]),
    ("macho_universal",        &[0xca, 0xfe, 0xba, 0xbe]),
    // PE header (reflective DLL)
    ("pe_header",              &[0x4d, 0x5a, 0x90, 0x00]),
    // ELF header
    ("elf_header",             &[0x7f, 0x45, 0x4c, 0x46]),
];

/// Suspicious strings found in process memory
const SUSPICIOUS_STRINGS: &[&str] = &[
    "mimikatz", "sekurlsa", "kerberos::list",
    "Invoke-Mimikatz", "Invoke-Empire",
    "powershell -enc", "powershell -e ",
    "IEX(New-Object", "DownloadString(",
    "FromBase64String", "System.Reflection.Assembly",
    "amsiInitFailed", "AmsiScanBuffer",
    "/bin/sh -c", "/bin/bash -c",
    "curl | sh", "wget -O-",
    "nc -e /bin", "ncat -e",
    "python -c 'import socket",
    "ruby -rsocket",
    "reverse_tcp", "bind_tcp",
    "meterpreter", "stage0",
    "beacon_keys", "watermark",
];

// ── Memory Region Info ──────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct MemoryRegion {
    pub start_addr: u64,
    pub end_addr: u64,
    pub size: u64,
    pub permissions: String,
    pub is_rwx: bool,
    pub is_anonymous: bool,
    pub mapped_file: Option<String>,
    pub entropy: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct ProcessMemoryProfile {
    pub pid: u32,
    pub name: String,
    pub exe_path: String,
    pub total_regions: usize,
    pub rwx_regions: usize,
    pub anonymous_executable: usize,
    pub total_memory_bytes: u64,
    pub highest_entropy: f64,
    pub suspicious_strings_found: Vec<String>,
    pub shellcode_matches: Vec<ShellcodeMatch>,
    pub injected_headers: Vec<InjectedHeader>,
    pub heap_spray_detected: bool,
    pub hook_detections: Vec<HookDetection>,
    pub risk_score: f64,
    pub scanned_at: i64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct ShellcodeMatch {
    pub pattern_name: String,
    pub address: u64,
    pub region_permissions: String,
    pub confidence: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct InjectedHeader {
    pub header_type: String,
    pub address: u64,
    pub region_is_anonymous: bool,
    pub confidence: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct HookDetection {
    pub library: String,
    pub function: String,
    pub hook_type: HookType,
    pub confidence: f64,
}

#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum HookType {
    InlineHook,
    ImportTableHook,
    ExportTableHook,
    VTableHook,
    TrampolineHook,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct MemoryScanResult {
    pub pid: u32,
    pub process_name: String,
    pub verdict: MemoryVerdict,
    pub findings: Vec<MemoryFinding>,
    pub risk_score: f64,
    pub scan_duration_us: u64,
    pub mitre_ids: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum MemoryVerdict {
    Clean,
    Suspicious { score: f64, reasons: Vec<String> },
    Malicious { technique: String, details: String },
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub struct MemoryFinding {
    pub finding_type: MemoryFindingType,
    pub address: Option<u64>,
    pub details: String,
    pub severity: Severity,
    pub confidence: f64,
    pub mitre_id: String,
}

#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum MemoryFindingType {
    ShellcodeDetected,
    RwxRegion,
    InjectedExecutable,
    SuspiciousString,
    HeapSpray,
    StackPivot,
    FunctionHook,
    HighEntropyAnonymous,
    ReflectiveLoader,
    ProcessHollowing,
}

// ── Scan Statistics ─────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct MemoryScanStats {
    pub total_scans: u64,
    pub processes_scanned: u64,
    pub regions_analyzed: u64,
    pub shellcode_detections: u64,
    pub injection_detections: u64,
    pub rwx_regions_found: u64,
    pub hooks_detected: u64,
    pub heap_sprays_detected: u64,
    pub fileless_threats_found: u64,
    pub avg_scan_time_us: u64,
    pub last_scan_at: i64,
}

// ── Main Scanner ────────────────────────────────────────────────────────────

pub struct MemoryScanner {
    // Breakthrough #2: TieredCache — hot/warm/cold scan result caching
    scan_cache: TieredCache<u32, MemoryScanResult>,
    // Breakthrough #1: HierarchicalState — scan history with φ-section splits
    scan_history: RwLock<HierarchicalState<MemoryScanStats>>,
    // Breakthrough #3: ReversibleComputation — recompute entropy instead of caching
    entropy_computer: RwLock<ReversibleComputation<u64, u64>>,
    // Breakthrough #5: StreamAccumulator — running stats over scan windows
    stats_accumulator: RwLock<StreamAccumulator<f64, f64>>,
    // Breakthrough #461: DifferentialStore — track region changes across scans
    region_diffs: RwLock<DifferentialStore<String, Vec<MemoryRegion>>>,
    // Breakthrough #569: PruningMap — evict stale process profiles
    process_profiles: RwLock<PruningMap<u32, ProcessMemoryProfile>>,
    // Breakthrough #592: DedupStore — deduplicate shellcode pattern matches
    finding_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — process × finding-type incidence matrix
    finding_matrix: RwLock<SparseMatrix<u32, u32, u64>>,
    // Breakthrough #593: Compression codec for archived scan data
    _compression_marker: std::marker::PhantomData<()>,
    // Breakthrough #6: MemoryMetrics
    metrics: MemoryMetrics,
    // Runtime stats
    stats: RwLock<MemoryScanStats>,
    total_scans: AtomicU64,
    // Known-good process hashes (skip list)
    known_good: RwLock<HashSet<String>>,
}

impl MemoryScanner {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(32 * 1024 * 1024);

        let scan_cache = TieredCache::new(FINDING_CACHE_COLD)
            .with_metrics(metrics.clone(), "memory_scanner_cache");

        let scan_history = HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL);

        let entropy_computer = ReversibleComputation::new(
            512,
            |items: &[u64]| {
                items.last().copied().unwrap_or(0)
            },
        );

        let stats_accumulator = StreamAccumulator::new(
            STATS_WINDOW,
            0.0_f64,
            |acc: &mut f64, items: &[f64]| {
                for &v in items { *acc += v; }
            },
        );

        let region_diffs = DifferentialStore::new().with_max_chain(64);
        let process_profiles = PruningMap::new(SCAN_CACHE_MAX);
        let finding_dedup = DedupStore::new();
        let finding_matrix = SparseMatrix::new(0u64);

        Self {
            scan_cache,
            scan_history: RwLock::new(scan_history),
            entropy_computer: RwLock::new(entropy_computer),
            stats_accumulator: RwLock::new(stats_accumulator),
            region_diffs: RwLock::new(region_diffs),
            process_profiles: RwLock::new(process_profiles),
            finding_dedup: RwLock::new(finding_dedup),
            finding_matrix: RwLock::new(finding_matrix),
            _compression_marker: std::marker::PhantomData,
            metrics,
            stats: RwLock::new(MemoryScanStats::default()),
            total_scans: AtomicU64::new(0),
            known_good: RwLock::new(HashSet::new()),
        }
    }

    // ── Core Scan API ───────────────────────────────────────────────────────

    /// Scan all running processes for fileless threats.
    pub fn scan_all_processes(&self) -> Vec<MemoryScanResult> {
        let start = std::time::Instant::now();
        info!("Starting full memory scan of all processes");
        self.total_scans.fetch_add(1, Ordering::Relaxed);

        let mut sys = sysinfo::System::new_all();
        sys.refresh_all();

        let mut results = Vec::new();
        let mut processes_scanned = 0u64;
        let mut regions_analyzed = 0u64;

        for (pid, proc_info) in sys.processes() {
            let pid_u32 = pid.as_u32();

            // Skip known-good processes (Breakthrough #592 dedup)
            let exe_hash = self.hash_process_identity(proc_info);
            if self.known_good.read().contains(&exe_hash) {
                continue;
            }

            // Check scan cache (Breakthrough #2)
            if let Some(cached) = self.scan_cache.get(&pid_u32) {
                if cached.scan_duration_us > 0 {
                    results.push(cached);
                    continue;
                }
            }

            let result = self.scan_process(pid_u32, proc_info);
            processes_scanned += 1;

            // Count regions
            if let MemoryVerdict::Suspicious { .. } | MemoryVerdict::Malicious { .. } = &result.verdict {
                regions_analyzed += result.findings.len() as u64;
            }

            // Cache result (Breakthrough #2)
            self.scan_cache.insert(pid_u32, result.clone());

            // Store in process profiles (Breakthrough #569)
            if result.risk_score > 0.0 {
                let profile = self.build_process_profile(pid_u32, proc_info, &result);
                self.process_profiles.write().insert_with_priority(
                    pid_u32, profile, result.risk_score,
                );
            }

            results.push(result);
        }

        // Update stats
        let elapsed = start.elapsed().as_micros() as u64;
        {
            let mut stats = self.stats.write();
            stats.total_scans += 1;
            stats.processes_scanned += processes_scanned;
            stats.regions_analyzed += regions_analyzed;
            stats.last_scan_at = chrono::Utc::now().timestamp();
            stats.avg_scan_time_us = if stats.total_scans > 0 {
                (stats.avg_scan_time_us * (stats.total_scans - 1) + elapsed) / stats.total_scans
            } else {
                elapsed
            };
        }

        // Stream accumulator (Breakthrough #5)
        self.stats_accumulator.write().push(elapsed as f64);

        // Checkpoint history (Breakthrough #1)
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let threat_count = results.iter().filter(|r| matches!(r.verdict, MemoryVerdict::Malicious { .. })).count();
        let suspicious_count = results.iter().filter(|r| matches!(r.verdict, MemoryVerdict::Suspicious { .. })).count();
        info!(
            "Memory scan complete: {} processes, {} threats, {} suspicious in {:.1}ms",
            processes_scanned, threat_count, suspicious_count, elapsed as f64 / 1000.0
        );

        results
    }

    /// Scan a single process by PID.
    pub fn scan_process(&self, pid: u32, proc_info: &sysinfo::Process) -> MemoryScanResult {
        let start = std::time::Instant::now();
        let mut findings = Vec::new();
        let mut risk_score = 0.0_f64;
        let mut mitre_ids = HashSet::new();

        let name = proc_info.name().to_string();
        let exe_path = proc_info.exe()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_default();

        // 1. Enumerate memory regions
        let regions = self.enumerate_regions(pid);

        // 2. Check for RWX regions (T1055 — Process Injection)
        for region in &regions {
            if region.is_rwx {
                let severity = if region.is_anonymous {
                    Severity::High
                } else {
                    Severity::Medium
                };

                findings.push(MemoryFinding {
                    finding_type: MemoryFindingType::RwxRegion,
                    address: Some(region.start_addr),
                    details: format!(
                        "RWX region at 0x{:x}-0x{:x} ({} bytes, {})",
                        region.start_addr, region.end_addr, region.size,
                        if region.is_anonymous { "anonymous" } else { "mapped" }
                    ),
                    severity,
                    confidence: 0.7,
                    mitre_id: "T1055".into(),
                });

                risk_score += if region.is_anonymous { 25.0 } else { 10.0 };
                mitre_ids.insert("T1055".to_string());

                // Update stats
                self.stats.write().rwx_regions_found += 1;
            }

            // 3. High-entropy anonymous regions (possible encrypted payload)
            if region.is_anonymous && region.entropy > RWX_ENTROPY_THRESHOLD {
                findings.push(MemoryFinding {
                    finding_type: MemoryFindingType::HighEntropyAnonymous,
                    address: Some(region.start_addr),
                    details: format!(
                        "High entropy ({:.2}) anonymous region at 0x{:x} ({} bytes)",
                        region.entropy, region.start_addr, region.size
                    ),
                    severity: Severity::Medium,
                    confidence: 0.6,
                    mitre_id: "T1027".into(),
                });
                risk_score += 15.0;
                mitre_ids.insert("T1027".to_string());
            }
        }

        // 4. Shellcode pattern scanning (detection mode — read own process or parse vmmap)
        let shellcode_matches = self.scan_for_shellcode(pid, &regions);
        for m in &shellcode_matches {
            findings.push(MemoryFinding {
                finding_type: MemoryFindingType::ShellcodeDetected,
                address: Some(m.address),
                details: format!(
                    "Shellcode pattern '{}' at 0x{:x} (confidence: {:.0}%)",
                    m.pattern_name, m.address, m.confidence * 100.0
                ),
                severity: Severity::Critical,
                confidence: m.confidence,
                mitre_id: "T1059.004".into(),
            });
            risk_score += 40.0;
            mitre_ids.insert("T1059.004".to_string());
            self.stats.write().shellcode_detections += 1;
        }

        // 5. Injected executable header detection
        let injected = self.detect_injected_headers(&regions);
        for h in &injected {
            findings.push(MemoryFinding {
                finding_type: MemoryFindingType::InjectedExecutable,
                address: Some(h.address),
                details: format!(
                    "{} header at 0x{:x} in {} region (confidence: {:.0}%)",
                    h.header_type, h.address,
                    if h.region_is_anonymous { "anonymous" } else { "mapped" },
                    h.confidence * 100.0
                ),
                severity: Severity::Critical,
                confidence: h.confidence,
                mitre_id: "T1620".into(),
            });
            risk_score += 50.0;
            mitre_ids.insert("T1620".to_string());
            self.stats.write().injection_detections += 1;
        }

        // 6. Suspicious string detection
        let suspicious_strings = self.scan_process_strings(pid, proc_info);
        for s in &suspicious_strings {
            findings.push(MemoryFinding {
                finding_type: MemoryFindingType::SuspiciousString,
                address: None,
                details: format!("Suspicious string in process memory: '{}'", s),
                severity: Severity::High,
                confidence: 0.75,
                mitre_id: "T1059".into(),
            });
            risk_score += 20.0;
            mitre_ids.insert("T1059".to_string());
        }

        // 7. Heap spray detection
        let heap_spray = self.detect_heap_spray(&regions);
        if heap_spray {
            findings.push(MemoryFinding {
                finding_type: MemoryFindingType::HeapSpray,
                address: None,
                details: "Heap spray pattern detected: multiple large identical anonymous regions".into(),
                severity: Severity::High,
                confidence: 0.8,
                mitre_id: "T1203".into(),
            });
            risk_score += 35.0;
            mitre_ids.insert("T1203".to_string());
            self.stats.write().heap_sprays_detected += 1;
        }

        // 8. Function hook detection (via vmmap/otool analysis)
        let hooks = self.detect_function_hooks(pid);
        for h in &hooks {
            findings.push(MemoryFinding {
                finding_type: MemoryFindingType::FunctionHook,
                address: None,
                details: format!(
                    "{:?} in {}::{} (confidence: {:.0}%)",
                    h.hook_type, h.library, h.function, h.confidence * 100.0
                ),
                severity: Severity::Critical,
                confidence: h.confidence,
                mitre_id: "T1574.001".into(),
            });
            risk_score += 45.0;
            mitre_ids.insert("T1574.001".to_string());
            self.stats.write().hooks_detected += 1;
        }

        // Cap risk score at 100
        risk_score = (risk_score as f64).min(100.0_f64);

        // Build verdict
        let verdict = if risk_score >= 80.0 {
            let technique = if !shellcode_matches.is_empty() {
                "Shellcode injection"
            } else if !injected.is_empty() {
                "Reflective loading"
            } else if !hooks.is_empty() {
                "Function hooking"
            } else {
                "Fileless malware"
            };
            self.stats.write().fileless_threats_found += 1;
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.scan_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.entropy_computer.write().push(1u64);
            MemoryVerdict::Malicious {
                technique: technique.into(),
                details: findings.iter().map(|f| f.details.clone()).collect::<Vec<_>>().join("; "),
            }
        } else if risk_score >= 30.0 {
            MemoryVerdict::Suspicious {
                score: risk_score,
                reasons: findings.iter().map(|f| f.details.clone()).collect(),
            }
        } else {
            MemoryVerdict::Clean
        };

        // Update finding matrix (Breakthrough #627)
        for f in &findings {
            let finding_type_id = f.finding_type as u32;
            let current = *self.finding_matrix.read().get(&pid, &finding_type_id);
            self.finding_matrix.write().set(pid, finding_type_id, current + 1);
        }

        // Dedup findings (Breakthrough #592)
        let finding_key = format!("{}:{}", pid, findings.len());
        self.finding_dedup.write().insert(finding_key.clone(), findings.iter().map(|f| f.details.as_bytes().to_vec()).next().unwrap_or_default());

        let elapsed = start.elapsed().as_micros() as u64;

        MemoryScanResult {
            pid,
            process_name: name,
            verdict,
            findings,
            risk_score,
            scan_duration_us: elapsed,
            mitre_ids: mitre_ids.into_iter().collect(),
        }
    }

    // ── Memory Region Enumeration ───────────────────────────────────────────

    /// Enumerate memory regions for a process using vmmap (macOS) or /proc (Linux).
    fn enumerate_regions(&self, pid: u32) -> Vec<MemoryRegion> {
        let mut regions = Vec::new();

        // Try vmmap on macOS (works without entitlement for own process,
        // limited info for others without debugging entitlement)
        #[cfg(target_os = "macos")]
        {
            if let Ok(output) = std::process::Command::new("vmmap")
                .args(["-wide", &pid.to_string()])
                .output()
            {
                let stdout = String::from_utf8_lossy(&output.stdout);
                for line in stdout.lines() {
                    if let Some(region) = self.parse_vmmap_line(line) {
                        regions.push(region);
                    }
                }
            }
        }

        // Try /proc on Linux
        #[cfg(target_os = "linux")]
        {
            let maps_path = format!("/proc/{}/maps", pid);
            if let Ok(content) = std::fs::read_to_string(&maps_path) {
                for line in content.lines() {
                    if let Some(region) = self.parse_proc_maps_line(line) {
                        regions.push(region);
                    }
                }
            }
        }

        // If we got no regions from OS-specific methods, fall back to sysinfo
        if regions.is_empty() {
            // Synthetic region from process metadata
            let mut sys = sysinfo::System::new();
            sys.refresh_process(sysinfo::Pid::from_u32(pid));
            if let Some(proc_info) = sys.process(sysinfo::Pid::from_u32(pid)) {
                let mem = proc_info.memory();
                regions.push(MemoryRegion {
                    start_addr: 0,
                    end_addr: mem,
                    size: mem,
                    permissions: "rw-".into(),
                    is_rwx: false,
                    is_anonymous: true,
                    mapped_file: None,
                    entropy: 0.0,
                });
            }
        }

        // Limit regions per process (Breakthrough #573 paged approach)
        regions.truncate(MAX_REGIONS_PER_PROCESS);

        // Record differential (Breakthrough #461)
        let key = format!("pid_{}", pid);
        self.region_diffs.write().record_insert(key, regions.clone());

        regions
    }

    #[cfg(target_os = "macos")]
    fn parse_vmmap_line(&self, line: &str) -> Option<MemoryRegion> {
        // vmmap output format varies but generally:
        // __TEXT     00007ff800000000-00007ff800100000 [  1.0M] r-x/r-x SM=COW  /usr/lib/dyld
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 4 { return None; }

        // Look for address range pattern
        let addr_part = parts.iter().find(|p| p.contains('-') && p.len() > 10)?;
        let mut addr_split = addr_part.split('-');
        let start_str = addr_split.next()?;
        let end_str = addr_split.next()?;

        let start = u64::from_str_radix(start_str.trim_start_matches("0x"), 16).ok()?;
        let end = u64::from_str_radix(end_str.trim_start_matches("0x"), 16).ok()?;

        // Find permissions (r-x, rw-, rwx, etc.)
        let perms = parts.iter().find(|p| {
            p.len() >= 3 && p.chars().all(|c| matches!(c, 'r' | 'w' | 'x' | '-' | '/'))
        }).map(|s| s.to_string()).unwrap_or_else(|| "---".into());

        let is_rwx = perms.contains("rwx");
        let mapped_file = parts.last()
            .filter(|p| p.starts_with('/'))
            .map(|s| s.to_string());
        let is_anonymous = mapped_file.is_none();

        Some(MemoryRegion {
            start_addr: start,
            end_addr: end,
            size: end.saturating_sub(start),
            permissions: perms,
            is_rwx,
            is_anonymous,
            mapped_file,
            entropy: 0.0, // Can't compute without reading memory
        })
    }

    #[cfg(target_os = "linux")]
    fn parse_proc_maps_line(&self, line: &str) -> Option<MemoryRegion> {
        // Format: 7f1234000-7f1235000 r-xp 00000000 08:01 12345 /usr/lib/libc.so.6
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 5 { return None; }

        let mut addr_split = parts[0].split('-');
        let start = u64::from_str_radix(addr_split.next()?, 16).ok()?;
        let end = u64::from_str_radix(addr_split.next()?, 16).ok()?;

        let perms = parts[1].to_string();
        let is_rwx = perms.contains('r') && perms.contains('w') && perms.contains('x');
        let mapped_file = if parts.len() > 5 { Some(parts[5].to_string()) } else { None };
        let is_anonymous = mapped_file.is_none() || mapped_file.as_deref() == Some("[heap]")
            || mapped_file.as_deref() == Some("[stack]");

        Some(MemoryRegion {
            start_addr: start,
            end_addr: end,
            size: end.saturating_sub(start),
            permissions: perms,
            is_rwx,
            is_anonymous,
            mapped_file,
            entropy: 0.0,
        })
    }

    // ── Shellcode Detection ─────────────────────────────────────────────────

    fn scan_for_shellcode(&self, pid: u32, regions: &[MemoryRegion]) -> Vec<ShellcodeMatch> {
        let mut matches = Vec::new();

        // In detection-only mode, we analyze region metadata and use heuristics
        // rather than reading actual memory bytes (which requires task_for_pid)
        for region in regions {
            // Only check executable or RWX regions
            if !region.permissions.contains('x') && !region.is_rwx {
                continue;
            }

            // Anonymous executable regions are highly suspicious
            if region.is_anonymous && region.permissions.contains('x') {
                // Heuristic: anonymous executable regions > 4KB are suspicious
                if region.size >= SHELLCODE_MIN_LENGTH as u64 {
                    let confidence = if region.is_rwx { 0.85 } else { 0.65 };

                    // Size-based heuristic for common shellcode sizes
                    let pattern_name = match region.size {
                        0..=512 => "small_shellcode_stub",
                        513..=4096 => "standard_shellcode",
                        4097..=65536 => "staged_payload",
                        _ => "large_injected_code",
                    };

                    matches.push(ShellcodeMatch {
                        pattern_name: pattern_name.into(),
                        address: region.start_addr,
                        region_permissions: region.permissions.clone(),
                        confidence,
                    });
                }
            }
        }

        // Also try to read /proc/<pid>/mem on Linux for actual pattern matching
        #[cfg(target_os = "linux")]
        {
            let mem_path = format!("/proc/{}/mem", pid);
            if let Ok(mut file) = std::fs::File::open(&mem_path) {
                for region in regions.iter().filter(|r| r.is_rwx || (r.is_anonymous && r.permissions.contains('x'))) {
                    use std::io::{Read, Seek, SeekFrom};
                    if file.seek(SeekFrom::Start(region.start_addr)).is_ok() {
                        let read_size = (region.size as usize).min(4096);
                        let mut buf = vec![0u8; read_size];
                        if file.read_exact(&mut buf).is_ok() {
                            for (name, pattern) in SHELLCODE_PATTERNS {
                                if buf.windows(pattern.len()).any(|w| w == *pattern) {
                                    matches.push(ShellcodeMatch {
                                        pattern_name: name.to_string(),
                                        address: region.start_addr,
                                        region_permissions: region.permissions.clone(),
                                        confidence: 0.95,
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }

        matches
    }

    // ── Injected Header Detection ───────────────────────────────────────────

    fn detect_injected_headers(&self, regions: &[MemoryRegion]) -> Vec<InjectedHeader> {
        let mut headers = Vec::new();

        for region in regions {
            // PE/Mach-O/ELF headers in anonymous memory = reflective loading
            if region.is_anonymous && region.size >= 4096 {
                // In detection mode, flag anonymous executable regions that are
                // page-aligned (typical for loaded images)
                if region.start_addr % 4096 == 0 && region.permissions.contains('x') {
                    // Size heuristic: most injected images are 10KB-10MB
                    if region.size >= 10240 && region.size <= 10 * 1024 * 1024 {
                        headers.push(InjectedHeader {
                            header_type: "Possible reflective image".into(),
                            address: region.start_addr,
                            region_is_anonymous: true,
                            confidence: 0.7,
                        });
                    }
                }
            }

            // Non-image mapped files with execute permission
            if let Some(ref path) = region.mapped_file {
                if region.permissions.contains('x') && !path.ends_with(".dylib")
                    && !path.ends_with(".so") && !path.ends_with(".dll")
                    && !path.starts_with("/usr/lib") && !path.starts_with("/System")
                    && !path.contains("dyld_shared_cache")
                {
                    // Executable mapping of non-standard file
                    if !path.ends_with(".app") && !path.contains("/MacOS/") {
                        headers.push(InjectedHeader {
                            header_type: format!("Non-standard executable mapping: {}", path),
                            address: region.start_addr,
                            region_is_anonymous: false,
                            confidence: 0.5,
                        });
                    }
                }
            }
        }

        headers
    }

    // ── Suspicious String Detection ─────────────────────────────────────────

    fn scan_process_strings(&self, pid: u32, proc_info: &sysinfo::Process) -> Vec<String> {
        let mut found = Vec::new();

        // Check command line arguments
        let cmdline = proc_info.cmd().join(" ").to_lowercase();
        for &pattern in SUSPICIOUS_STRINGS {
            if cmdline.contains(&pattern.to_lowercase()) {
                found.push(format!("cmdline: {}", pattern));
            }
        }

        // Check environment variables for injection indicators
        let environ = proc_info.environ();
        for env in environ {
            let env_lower = env.to_lowercase();
            if env_lower.contains("ld_preload") || env_lower.contains("dyld_insert")
                || env_lower.contains("ld_library_path") && env_lower.contains("/tmp")
            {
                found.push(format!("env: {}", env));
            }
        }

        // On Linux, try to extract strings from /proc/<pid>/cmdline
        #[cfg(target_os = "linux")]
        {
            let cmdline_path = format!("/proc/{}/cmdline", pid);
            if let Ok(data) = std::fs::read(&cmdline_path) {
                let text = String::from_utf8_lossy(&data).to_lowercase();
                for &pattern in SUSPICIOUS_STRINGS {
                    if text.contains(&pattern.to_lowercase()) && !found.iter().any(|f| f.contains(pattern)) {
                        found.push(format!("proc_cmdline: {}", pattern));
                    }
                }
            }
        }

        found
    }

    // ── Heap Spray Detection ────────────────────────────────────────────────

    fn detect_heap_spray(&self, regions: &[MemoryRegion]) -> bool {
        // Heap spray: many large anonymous regions of similar size
        let large_anon: Vec<&MemoryRegion> = regions.iter()
            .filter(|r| r.is_anonymous && r.size >= HEAP_SPRAY_THRESHOLD as u64)
            .collect();

        if large_anon.len() < 10 { return false; }

        // Check if many regions have the same size (classic heap spray)
        let mut size_counts: HashMap<u64, usize> = HashMap::new();
        for r in &large_anon {
            // Round to nearest page
            let rounded = (r.size / 4096) * 4096;
            *size_counts.entry(rounded).or_default() += 1;
        }

        // If more than 50 regions of the same size, it's likely a heap spray
        size_counts.values().any(|&count| count >= 50)
    }

    // ── Function Hook Detection ─────────────────────────────────────────────

    fn detect_function_hooks(&self, pid: u32) -> Vec<HookDetection> {
        let mut hooks = Vec::new();

        // On macOS, use dyld info to detect hooks
        #[cfg(target_os = "macos")]
        {
            // Check DYLD_INSERT_LIBRARIES
            if let Ok(output) = std::process::Command::new("launchctl")
                .args(["print", &format!("pid/{}", pid)])
                .output()
            {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if stdout.contains("DYLD_INSERT_LIBRARIES") {
                    let lib = stdout.lines()
                        .find(|l| l.contains("DYLD_INSERT_LIBRARIES"))
                        .unwrap_or("unknown")
                        .trim()
                        .to_string();
                    hooks.push(HookDetection {
                        library: lib,
                        function: "DYLD_INSERT_LIBRARIES".into(),
                        hook_type: HookType::InlineHook,
                        confidence: 0.9,
                    });
                }
            }

            // Check for Objective-C method swizzling indicators
            if let Ok(output) = std::process::Command::new("otool")
                .args(["-l", &format!("/proc/{}/exe", pid)])
                .output()
            {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if stdout.contains("__interpose") {
                    hooks.push(HookDetection {
                        library: "dyld_interpose".into(),
                        function: "__interpose section".into(),
                        hook_type: HookType::ImportTableHook,
                        confidence: 0.8,
                    });
                }
            }
        }

        // On Linux, check LD_PRELOAD and /proc/<pid>/maps for preloaded libraries
        #[cfg(target_os = "linux")]
        {
            let environ_path = format!("/proc/{}/environ", pid);
            if let Ok(data) = std::fs::read(&environ_path) {
                let text = String::from_utf8_lossy(&data);
                if text.contains("LD_PRELOAD=") {
                    let preload = text.split("LD_PRELOAD=")
                        .nth(1)
                        .and_then(|s| s.split('\0').next())
                        .unwrap_or("unknown");
                    hooks.push(HookDetection {
                        library: preload.to_string(),
                        function: "LD_PRELOAD".into(),
                        hook_type: HookType::InlineHook,
                        confidence: 0.9,
                    });
                }
            }
        }

        hooks
    }

    // ── Utilities ───────────────────────────────────────────────────────────

    fn hash_process_identity(&self, proc_info: &sysinfo::Process) -> String {
        let exe = proc_info.exe()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_default();
        let name = proc_info.name().to_string();
        format!("{}:{}", name, exe)
    }

    fn build_process_profile(
        &self,
        pid: u32,
        proc_info: &sysinfo::Process,
        result: &MemoryScanResult,
    ) -> ProcessMemoryProfile {
        ProcessMemoryProfile {
            pid,
            name: proc_info.name().to_string(),
            exe_path: proc_info.exe().map(|p| p.to_string_lossy().to_string()).unwrap_or_default(),
            total_regions: 0,
            rwx_regions: result.findings.iter()
                .filter(|f| matches!(f.finding_type, MemoryFindingType::RwxRegion))
                .count(),
            anonymous_executable: result.findings.iter()
                .filter(|f| matches!(f.finding_type, MemoryFindingType::InjectedExecutable))
                .count(),
            total_memory_bytes: proc_info.memory(),
            highest_entropy: 0.0,
            suspicious_strings_found: result.findings.iter()
                .filter(|f| matches!(f.finding_type, MemoryFindingType::SuspiciousString))
                .map(|f| f.details.clone())
                .collect(),
            shellcode_matches: Vec::new(),
            injected_headers: Vec::new(),
            heap_spray_detected: result.findings.iter()
                .any(|f| matches!(f.finding_type, MemoryFindingType::HeapSpray)),
            hook_detections: Vec::new(),
            risk_score: result.risk_score,
            scanned_at: chrono::Utc::now().timestamp(),
        }
    }

    /// Add a process to the known-good whitelist (skip future scans).
    pub fn whitelist_process(&self, exe_identity: &str) {
        self.known_good.write().insert(exe_identity.to_string());
    }

    /// Get current scan statistics.
    pub fn stats(&self) -> MemoryScanStats {
        self.stats.read().clone()
    }

    /// Get all cached process profiles above a risk threshold.
    pub fn high_risk_processes(&self, min_score: f64) -> Vec<ProcessMemoryProfile> {
        let profiles = self.process_profiles.read();
        profiles.iter()
            .filter(|(_, v)| v.risk_score >= min_score)
            .map(|(_, v)| v.clone())
            .collect()
    }

    /// Get memory metrics.
    pub fn metrics(&self) -> &MemoryMetrics {
        &self.metrics
    }
}
