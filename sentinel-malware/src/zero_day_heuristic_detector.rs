//! Module 163: ZeroDayHeuristicDetector — Unknown Threat & Zero-Day Detection
//!
//! Detects previously unseen malware, zero-day exploits, and novel attack
//! techniques using heuristic analysis, behavioral anomaly detection, and
//! structural analysis rather than signature matching. Designed to catch
//! threats that evade all signature-based detection modules.
//!
//! ## Detection Capabilities
//!
//! ### Structural Heuristics
//! - **Mach-O anomaly analysis**: Unusual load commands, segment flags,
//!   entry point locations, section sizes, and header field combinations
//! - **Entropy profiling**: Per-section entropy analysis detecting packed,
//!   encrypted, or obfuscated code sections
//! - **Import/export anomalies**: Unusual API import patterns (e.g.,
//!   calculator app importing ptrace, mach_vm_write)
//! - **Code cave detection**: Unused code regions that could harbor injected
//!   payloads in otherwise legitimate binaries
//! - **Overlay detection**: Data appended after the legitimate binary end
//! - **Resource anomalies**: Embedded executables, scripts, or encoded
//!   payloads within application resources
//!
//! ### Behavioral Heuristics
//! - **Execution pattern analysis**: First-run behavior profiling — what
//!   a binary does in its first seconds of execution
//! - **API call sequencing**: Detecting suspicious API call sequences that
//!   match exploitation or malware patterns without exact signatures
//! - **Memory allocation patterns**: Unusual allocation sizes, RWX regions,
//!   or memory manipulation sequences
//! - **File system behavior**: Rapid file enumeration, sensitive directory
//!   access, or mass file modification on first run
//! - **Network behavior on first run**: Immediate outbound connections,
//!   DNS lookups to unusual domains, or beacon-like patterns
//!
//! ### Exploit Heuristics
//! - **ROP/JOP chain detection**: Detecting return-oriented or jump-oriented
//!   programming gadget chains without known exploit signatures
//! - **Heap manipulation patterns**: Heap feng shui, spray patterns, and
//!   use-after-free exploitation sequences
//! - **Stack pivot detection**: Unusual stack pointer modifications
//! - **Sandbox escape sequences**: API call patterns matching sandbox escape
//!   without known exploit signatures
//! - **Kernel exploit indicators**: Unusual IOKit/sysctl/mach patterns
//!
//! ### Evasion Detection
//! - **Anti-analysis techniques**: VM detection, debugger detection, timing
//!   checks, and environment fingerprinting
//! - **Obfuscation indicators**: String encryption, control flow flattening,
//!   opaque predicates, and dead code insertion
//! - **Polymorphic indicators**: Self-modifying code, runtime unpacking,
//!   and metamorphic engine signatures
//! - **Fileless indicators**: In-memory only execution, reflective loading,
//!   and script-based payload delivery
//!
//! ## MITRE ATT&CK: T1027, T1059, T1203, T1211
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const HIGH_ENTROPY_THRESHOLD: f64 = 7.5;
const SUSPICIOUS_IMPORT_THRESHOLD: u32 = 3;

// ── Structural Heuristic Rules ───────────────────────────────────────────────

const STRUCTURAL_HEURISTICS: &[(&str, &str, &str, f64)] = &[
    ("high_entropy_text", "__TEXT section entropy > 7.5 (packed/encrypted)", "T1027", 0.7),
    ("high_entropy_data", "__DATA section entropy > 7.5 (encrypted payload)", "T1027", 0.6),
    ("rwx_segment", "Segment with read-write-execute permissions", "T1027", 0.75),
    ("entry_point_outside_text", "Entry point outside __TEXT segment", "T1027", 0.85),
    ("no_code_signature", "Executable with no code signature at all", "T1027", 0.5),
    ("unusual_load_commands", "Unusual or rare Mach-O load commands", "T1027", 0.6),
    ("section_name_anomaly", "Non-standard section names (obfuscation)", "T1027", 0.5),
    ("overlay_data", "Data appended after Mach-O end", "T1027", 0.65),
    ("embedded_executable", "Executable embedded within resources", "T1027", 0.8),
    ("embedded_script", "Script file embedded in binary resources", "T1059", 0.7),
    ("code_cave_detected", "Unused code region suitable for injection", "T1027", 0.6),
    ("import_anomaly_ptrace", "Binary imports ptrace (anti-debug)", "T1027", 0.7),
    ("import_anomaly_vm_write", "Binary imports mach_vm_write (injection)", "T1055", 0.8),
    ("import_anomaly_task_for_pid", "Binary imports task_for_pid (process access)", "T1055", 0.8),
    ("import_anomaly_dlopen", "Excessive dlopen/dlsym imports (dynamic loading)", "T1027", 0.5),
    ("fat_binary_arch_mismatch", "Universal binary with suspicious architecture combo", "T1027", 0.5),
    ("stripped_debug_info", "All debug info stripped (common in malware)", "T1027", 0.3),
    ("dylib_hijack_candidate", "Binary loads dylib from writable path (@rpath abuse)", "T1574.004", 0.7),
];

// ── Behavioral Heuristic Rules ───────────────────────────────────────────────

const BEHAVIORAL_HEURISTICS: &[(&str, &str, &str, f64)] = &[
    ("first_run_network", "Immediate outbound network connection on first run", "T1071", 0.6),
    ("first_run_dns_unusual", "DNS query to unusual domain on first run", "T1071", 0.65),
    ("first_run_file_enum", "Rapid file/directory enumeration on first run", "T1083", 0.55),
    ("first_run_sensitive_access", "Accessing sensitive files on first run", "T1005", 0.7),
    ("first_run_keychain_access", "Keychain access attempt on first run", "T1555.001", 0.75),
    ("first_run_persistence", "Persistence mechanism creation on first run", "T1543", 0.8),
    ("api_sequence_exploit", "API call sequence matching exploitation pattern", "T1203", 0.8),
    ("api_sequence_injection", "API call sequence matching code injection", "T1055", 0.8),
    ("rapid_process_spawn", "Rapid spawning of child processes", "T1059", 0.6),
    ("stdin_to_shell", "stdin redirected to shell interpreter", "T1059", 0.85),
    ("memory_alloc_rwx", "Large RWX memory allocation (shellcode staging)", "T1055", 0.75),
    ("mass_file_modification", "Mass file modification (ransomware-like)", "T1486", 0.85),
    ("camera_mic_first_run", "Camera/microphone access on first run", "T1125", 0.7),
    ("screen_capture_first_run", "Screen capture on first run without UI", "T1113", 0.7),
    ("clipboard_harvest", "Clipboard monitoring on first run", "T1115", 0.6),
];

// ── Exploit Heuristic Rules ──────────────────────────────────────────────────

const EXPLOIT_HEURISTICS: &[(&str, &str, &str, f64)] = &[
    ("rop_gadget_chain", "ROP gadget chain pattern detected", "T1203", 0.8),
    ("jop_gadget_chain", "JOP gadget chain pattern detected", "T1203", 0.8),
    ("heap_spray_pattern", "Heap spray allocation pattern", "T1203", 0.75),
    ("heap_feng_shui", "Heap feng shui manipulation pattern", "T1203", 0.7),
    ("use_after_free_pattern", "Use-after-free exploitation pattern", "T1203", 0.8),
    ("stack_pivot", "Stack pivot detected (RSP manipulation)", "T1203", 0.85),
    ("sandbox_escape_api_seq", "Sandbox escape API call sequence", "T1211", 0.85),
    ("kernel_exploit_pattern", "Kernel exploitation API pattern", "T1068", 0.9),
    ("type_confusion_indicator", "Type confusion exploitation indicator", "T1203", 0.75),
    ("integer_overflow_exploit", "Integer overflow exploitation pattern", "T1203", 0.7),
];

// ── Evasion Heuristic Rules ──────────────────────────────────────────────────

const EVASION_HEURISTICS: &[(&str, &str, &str, f64)] = &[
    ("vm_detection_check", "Virtual machine detection check", "T1497.001", 0.6),
    ("debugger_detection", "Debugger detection (ptrace/sysctl)", "T1622", 0.65),
    ("timing_check", "Timing-based anti-analysis check", "T1497.003", 0.55),
    ("env_fingerprint", "Environment fingerprinting", "T1082", 0.5),
    ("string_encryption", "Encrypted/obfuscated strings in binary", "T1027", 0.5),
    ("control_flow_flattening", "Control flow flattening detected", "T1027", 0.7),
    ("opaque_predicates", "Opaque predicates (anti-decompilation)", "T1027", 0.6),
    ("self_modifying_code", "Self-modifying code detected", "T1027.002", 0.8),
    ("runtime_unpacking", "Runtime unpacking behavior", "T1027.002", 0.75),
    ("fileless_execution", "Fileless/in-memory-only execution", "T1059", 0.8),
    ("reflective_loading", "Reflective dylib loading", "T1620", 0.85),
    ("process_name_masquerade", "Process masquerading as system process", "T1036.005", 0.7),
    ("sleep_evasion", "Extended sleep before malicious activity", "T1497.003", 0.5),
    ("geofencing_check", "Geographic/locale-based execution gating", "T1497", 0.6),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ZeroDayThreatType {
    StructuralAnomaly, EntropyAnomaly, ImportAnomaly,
    CodeCave, OverlayData, EmbeddedPayload,
    BehavioralAnomaly, FirstRunSuspicious, APISequenceExploit,
    MassModification, ROPChain, HeapExploit,
    StackPivot, SandboxEscape, KernelExploit,
    AntiAnalysis, Obfuscation, SelfModifyingCode,
    FilelessExecution, ReflectiveLoading, ProcessMasquerade,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ZeroDayFinding {
    pub threat_type: ZeroDayThreatType,
    pub confidence: f64,
    pub description: String,
    pub heuristic_rule: String,
    pub entropy_value: Option<f64>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ZeroDayEvent {
    pub event_type: String,
    pub file_path: Option<String>,
    pub section_entropies: HashMap<String, f64>,
    pub suspicious_imports: Vec<String>,
    pub api_call_sequence: Vec<String>,
    pub memory_regions: Vec<String>,
    pub first_run: Option<bool>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ZeroDayAnalysisResult {
    pub is_suspicious: bool,
    pub findings: Vec<ZeroDayFinding>,
    pub heuristic_score: f64,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ZeroDayStats {
    pub total_events: u64,
    pub structural_detections: u64,
    pub behavioral_detections: u64,
    pub exploit_detections: u64,
    pub evasion_detections: u64,
    pub zero_day_candidates: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ZeroDaySigEntry { pub rule: String, pub severity: f64 }

pub struct ZeroDayHeuristicDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<ZeroDayStats>>,
    result_cache: TieredCache<String, ZeroDayAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    zeroday_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, ZeroDayStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, ZeroDayAnalysisResult>>,
    sig_db: PagedMemory<ZeroDaySigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<ZeroDayStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl ZeroDayHeuristicDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            zeroday_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, ZeroDayStats::default(),
                |acc: &mut ZeroDayStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(ZeroDayStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(128)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &ZeroDayEvent) -> Option<ZeroDayAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("zday:{}:{}", event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        let ind_text = format!("{} {}",
            event.event_type, event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // 1. Structural heuristics
        for &(rule, desc, mitre, conf) in STRUCTURAL_HEURISTICS {
            if ind_lower.contains(&rule.to_lowercase()) {
                let tt = if rule.contains("entropy") { ZeroDayThreatType::EntropyAnomaly }
                    else if rule.contains("import") { ZeroDayThreatType::ImportAnomaly }
                    else if rule.contains("cave") { ZeroDayThreatType::CodeCave }
                    else if rule.contains("overlay") { ZeroDayThreatType::OverlayData }
                    else if rule.contains("embedded") { ZeroDayThreatType::EmbeddedPayload }
                    else { ZeroDayThreatType::StructuralAnomaly };
                findings.push(ZeroDayFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    heuristic_rule: rule.to_string(), entropy_value: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // Entropy analysis
        for (section, &entropy) in &event.section_entropies {
            if entropy > HIGH_ENTROPY_THRESHOLD {
                findings.push(ZeroDayFinding {
                    threat_type: ZeroDayThreatType::EntropyAnomaly,
                    confidence: 0.5 + ((entropy - 7.0) * 0.3).min(0.4),
                    description: format!("Section {} has high entropy {:.3}", section, entropy),
                    heuristic_rule: "section_entropy".into(), entropy_value: Some(entropy),
                    mitre_id: "T1027".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1027".into());
            }
        }

        // Suspicious imports
        if event.suspicious_imports.len() >= SUSPICIOUS_IMPORT_THRESHOLD as usize {
            findings.push(ZeroDayFinding {
                threat_type: ZeroDayThreatType::ImportAnomaly,
                confidence: 0.6 + (event.suspicious_imports.len() as f64 * 0.05).min(0.3),
                description: format!("{} suspicious imports: {}", event.suspicious_imports.len(),
                    event.suspicious_imports.join(", ")),
                heuristic_rule: "import_cluster".into(), entropy_value: None,
                mitre_id: "T1027".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1027".into());
        }

        // 2. Behavioral heuristics
        for &(rule, desc, mitre, conf) in BEHAVIORAL_HEURISTICS {
            if ind_lower.contains(&rule.to_lowercase()) {
                let tt = if rule.contains("mass_file") { ZeroDayThreatType::MassModification }
                    else if rule.contains("first_run") { ZeroDayThreatType::FirstRunSuspicious }
                    else if rule.contains("api_sequence") { ZeroDayThreatType::APISequenceExploit }
                    else { ZeroDayThreatType::BehavioralAnomaly };
                findings.push(ZeroDayFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    heuristic_rule: rule.to_string(), entropy_value: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 3. Exploit heuristics
        for &(rule, desc, mitre, conf) in EXPLOIT_HEURISTICS {
            if ind_lower.contains(&rule.to_lowercase()) {
                let tt = match rule {
                    r if r.contains("rop") || r.contains("jop") => ZeroDayThreatType::ROPChain,
                    r if r.contains("heap") => ZeroDayThreatType::HeapExploit,
                    r if r.contains("stack_pivot") => ZeroDayThreatType::StackPivot,
                    r if r.contains("sandbox") => ZeroDayThreatType::SandboxEscape,
                    r if r.contains("kernel") => ZeroDayThreatType::KernelExploit,
                    _ => ZeroDayThreatType::APISequenceExploit,
                };
                findings.push(ZeroDayFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    heuristic_rule: rule.to_string(), entropy_value: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 4. Evasion heuristics
        for &(rule, desc, mitre, conf) in EVASION_HEURISTICS {
            if ind_lower.contains(&rule.to_lowercase()) {
                let tt = match rule {
                    r if r.contains("self_modifying") => ZeroDayThreatType::SelfModifyingCode,
                    r if r.contains("fileless") => ZeroDayThreatType::FilelessExecution,
                    r if r.contains("reflective") => ZeroDayThreatType::ReflectiveLoading,
                    r if r.contains("masquerade") => ZeroDayThreatType::ProcessMasquerade,
                    r if r.contains("obfuscat") || r.contains("control_flow") || r.contains("opaque") =>
                        ZeroDayThreatType::Obfuscation,
                    _ => ZeroDayThreatType::AntiAnalysis,
                };
                findings.push(ZeroDayFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    heuristic_rule: rule.to_string(), entropy_value: None,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        let heuristic_score = if findings.is_empty() { 0.0 } else {
            findings.iter().map(|f| f.confidence).sum::<f64>() / findings.len() as f64
        };
        let risk_score = if findings.is_empty() { 0.0 } else {
            let s: f64 = findings.iter().map(|f| f.confidence * match f.threat_type {
                ZeroDayThreatType::KernelExploit | ZeroDayThreatType::SandboxEscape => 1.6,
                ZeroDayThreatType::ROPChain | ZeroDayThreatType::StackPivot => 1.5,
                ZeroDayThreatType::MassModification => 1.5,
                ZeroDayThreatType::ReflectiveLoading | ZeroDayThreatType::SelfModifyingCode => 1.4,
                ZeroDayThreatType::EmbeddedPayload => 1.3,
                _ => 1.0,
            }).sum();
            (s / (findings.len() as f64 * 1.5)).min(1.0)
        };
        self.risk_computer.write().push(risk_score);
        let severity = if risk_score >= 0.85 { Severity::Critical } else if risk_score >= 0.65 { Severity::High }
            else if risk_score >= 0.45 { Severity::Medium } else if risk_score >= 0.25 { Severity::Low }
            else { Severity::Info };
        let is_suspicious = risk_score > 0.5;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = ZeroDayAnalysisResult {
            is_suspicious, findings, heuristic_score, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
          if is_suspicious { s.zero_day_candidates += 1;
            for f in &result.findings { match f.threat_type {
                ZeroDayThreatType::StructuralAnomaly | ZeroDayThreatType::EntropyAnomaly |
                ZeroDayThreatType::ImportAnomaly | ZeroDayThreatType::CodeCave |
                ZeroDayThreatType::OverlayData | ZeroDayThreatType::EmbeddedPayload => s.structural_detections += 1,
                ZeroDayThreatType::BehavioralAnomaly | ZeroDayThreatType::FirstRunSuspicious |
                ZeroDayThreatType::MassModification => s.behavioral_detections += 1,
                ZeroDayThreatType::ROPChain | ZeroDayThreatType::HeapExploit |
                ZeroDayThreatType::StackPivot | ZeroDayThreatType::SandboxEscape |
                ZeroDayThreatType::KernelExploit | ZeroDayThreatType::APISequenceExploit => s.exploit_detections += 1,
                _ => s.evasion_detections += 1,
            } } }
          let n = s.total_events as f64;
          s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_suspicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "zero_day_heuristic_detector".into(),
                title: format!("ZERO-DAY CANDIDATE: {} heuristic findings, score {:.0}%",
                    result.findings.len(), risk_score * 100.0),
                details: format!("Heuristic score {:.2}, path: {:?}, process: {:?}",
                    heuristic_score, event.file_path, event.process_name),
                path: event.file_path.clone(), process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None, mitre_ids: mitre_vec,
                remediation: vec![
                    "Quarantine the suspicious binary for analysis".into(),
                    "Submit to malware sandbox for dynamic analysis".into(),
                    "Submit to VirusTotal for multi-engine scan".into(),
                    "Perform manual reverse engineering if high confidence".into(),
                    "Check for similar binaries across the fleet".into(),
                ], confidence: risk_score,
            });
        }
        Some(result)
    }

    pub fn stats(&self) -> ZeroDayStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
