//! Module 11: ScriptEngine — Bash/AppleScript/Python/PowerShell Deobfuscation
//!
//! World-class script analysis and deobfuscation engine that detects malicious
//! scripts across all major scripting languages. Combines static analysis,
//! pattern matching, entropy analysis, and multi-layer deobfuscation.
//!
//! ## Features
//!
//! - **Language detection**: Auto-detects Bash, Zsh, Python, Ruby, Perl,
//!   PowerShell, AppleScript, JXA, JavaScript, VBScript, Batch, Lua, PHP
//! - **Multi-layer deobfuscation**: Iteratively decodes base64, hex, ROT13,
//!   XOR, gzip, URL encoding, string concatenation, variable substitution
//! - **Suspicious API detection**: Identifies dangerous function calls per
//!   language (eval, exec, system, curl, wget, nc, osascript, etc.)
//! - **URL/IP extraction**: Finds embedded URLs, IP addresses, domain names
//! - **Encoded payload detection**: Identifies base64/hex/gzip-encoded payloads
//!   and attempts automatic decoding
//! - **Control flow analysis**: Detects obfuscation via excessive variable
//!   indirection, string splitting, chr() chains, eval chains
//! - **Obfuscation scoring**: 0-100 score based on entropy, encoding layers,
//!   variable naming patterns, code complexity metrics
//! - **AppleScript/JXA specialization**: Detects osascript abuse, Finder
//!   manipulation, keychain access, camera/mic activation
//! - **PowerShell specialization**: Detects -EncodedCommand, IEX, Invoke-Expression,
//!   download cradles, AMSI bypass, reflection-based loading
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::HashSet;
use std::path::Path;
use std::sync::atomic::{AtomicU64, Ordering};
use parking_lot::RwLock;
use tracing::{info, warn, debug};
use std::collections::HashMap;

// ── Constants ───────────────────────────────────────────────────────────────

const MAX_SCRIPT_SIZE: u64 = 50 * 1024 * 1024; // 50 MB
const MAX_DEOBFUSCATION_ROUNDS: usize = 10;
const HIGH_OBFUSCATION_THRESHOLD: f64 = 60.0;
const SUSPICIOUS_THRESHOLD: f64 = 40.0;
const ANALYSIS_CACHE_MAX: usize = 10_000;
const HISTORY_LEVELS: u32 = 6;
const HISTORY_PER_LEVEL: usize = 32;

// ── Suspicious APIs per Language ────────────────────────────────────────────

const BASH_SUSPICIOUS: &[&str] = &[
    "eval ", "exec ", "curl ", "wget ", "nc ", "ncat ", "socat ",
    "/dev/tcp/", "bash -i", "sh -i", "mkfifo", "base64 -d",
    "openssl enc", "python -c", "perl -e", "ruby -e",
    "chmod +x", "chmod 777", "rm -rf /", "dd if=",
    "crontab", "at ", "nohup ", "disown", "setsid",
    "> /dev/null 2>&1", "history -c", "unset HISTFILE",
    "iptables -F", "ufw disable", "setenforce 0",
];

const PYTHON_SUSPICIOUS: &[&str] = &[
    "exec(", "eval(", "compile(", "__import__(",
    "os.system(", "os.popen(", "subprocess.", "Popen(",
    "socket.", "urllib.", "requests.", "http.client.",
    "ctypes.", "marshal.loads(", "pickle.loads(",
    "base64.b64decode(", "codecs.decode(",
    "__builtins__", "getattr(", "setattr(",
    "importlib.", "code.interact(",
];

const POWERSHELL_SUSPICIOUS: &[&str] = &[
    "Invoke-Expression", "IEX", "Invoke-Command",
    "-EncodedCommand", "-enc ", "FromBase64String",
    "New-Object Net.WebClient", "DownloadString(",
    "DownloadFile(", "Invoke-WebRequest", "iwr ",
    "Start-Process", "Add-Type", "[Reflection.Assembly]",
    "Set-MpPreference", "AmsiUtils", "amsiInitFailed",
    "Invoke-Mimikatz", "Get-Credential", "ConvertTo-SecureString",
    "New-Object System.Net.Sockets", "TCPClient(",
    "[System.Runtime.InteropServices.Marshal]",
];

const APPLESCRIPT_SUSPICIOUS: &[&str] = &[
    "do shell script", "osascript", "with administrator privileges",
    "keystroke", "key code", "System Events",
    "security find-generic-password", "security find-internet-password",
    "security dump-keychain", "login.keychain",
    "LaunchAgents", "LaunchDaemons", "com.apple.loginwindow",
    "curl", "wget", "open location",
    "AVCaptureDevice", "screencapture",
];

const JAVASCRIPT_SUSPICIOUS: &[&str] = &[
    "eval(", "Function(", "setTimeout(", "setInterval(",
    "document.write(", "innerHTML", "outerHTML",
    "XMLHttpRequest", "fetch(", "WebSocket(",
    "atob(", "btoa(", "String.fromCharCode(",
    "unescape(", "decodeURIComponent(",
    "ActiveXObject", "WScript.Shell", "Scripting.FileSystemObject",
    "child_process", "require('fs')", "execSync(",
];

const VBSCRIPT_SUSPICIOUS: &[&str] = &[
    "WScript.Shell", "Shell.Application", "Scripting.FileSystemObject",
    "ADODB.Stream", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP",
    "CreateObject(", "GetObject(", "Execute ", "ExecuteGlobal ",
    "Eval(", "Chr(", "ChrW(", "Shell(",
    "RegWrite", "RegRead", "Run ",
];

// ── Obfuscation Patterns ────────────────────────────────────────────────────

const BASE64_PATTERN: &str = r"[A-Za-z0-9+/]{20,}={0,2}";
const HEX_PATTERN: &str = r"(?:\\x[0-9a-fA-F]{2}){4,}";
const CHAR_CODE_PATTERN: &str = r"(?:chr\(\d+\)\s*[+&.]\s*){3,}";
const CONCAT_PATTERN: &str = r#"(?:["'][a-zA-Z0-9]{1,3}["']\s*[+&.]\s*){5,}"#;

// ── Script Engine Statistics ────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ScriptEngineStats {
    pub scripts_analyzed: u64,
    pub malicious_detected: u64,
    pub suspicious_detected: u64,
    pub deobfuscation_rounds: u64,
    pub payloads_extracted: u64,
    pub urls_extracted: u64,
    pub avg_obfuscation_score: f64,
    pub by_language: HashMap<String, u64>,
}

// ── Deobfuscation Result ────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DeobfuscationResult {
    pub rounds_performed: usize,
    pub techniques_found: Vec<String>,
    pub decoded_payloads: Vec<DecodedPayload>,
    pub final_content_preview: Option<String>,
    pub reduction_ratio: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DecodedPayload {
    pub encoding: String,
    pub decoded_preview: String,
    pub full_size: usize,
    pub contains_urls: bool,
    pub contains_ips: bool,
    pub contains_shell_commands: bool,
}

// ═══════════════════════════════════════════════════════════════════════════
// ScriptEngine — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct ScriptEngine {
    // ── Breakthrough #1: Hierarchical analysis history ──
    analysis_history: RwLock<HierarchicalState<ScriptEngineStats>>,

    // ── Breakthrough #2: Tiered analysis cache ──
    analysis_cache: TieredCache<String, ScriptAnalysis>,

    // ── Breakthrough #3: Reversible stats ──
    stats_computer: RwLock<ReversibleComputation<u64, ScriptEngineStats>>,

    // ── Breakthrough #5: Streaming metrics ──
    score_accumulator: RwLock<StreamAccumulator<f64, ScriptEngineStats>>,

    // ── Breakthrough #6: Memory bounds ──
    metrics: MemoryMetrics,

    // ── Breakthrough #461: Differential language patterns ──
    pattern_diff: RwLock<DifferentialStore<String, String>>,

    // ── Breakthrough #569: Pruning old analyses ──
    result_cache: RwLock<PruningMap<String, ScriptAnalysis>>,

    // ── Breakthrough #592: Dedup script hashes ──
    script_dedup: RwLock<DedupStore<String, String>>,

    // ── Breakthrough #627: Language × threat matrix ──
    language_matrix: RwLock<SparseMatrix<String, String, u64>>,

    // ── Stats ──
    stats: RwLock<ScriptEngineStats>,
    total_analyzed: AtomicU64,
}

impl ScriptEngine {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(16 * 1024 * 1024);

        let analysis_cache = TieredCache::new(ANALYSIS_CACHE_MAX)
            .with_metrics(metrics.clone(), "script_cache");

        let score_accumulator = StreamAccumulator::new(
            128,
            ScriptEngineStats::default(),
            |acc: &mut ScriptEngineStats, scores: &[f64]| {
                for &score in scores {
                    acc.scripts_analyzed += 1;
                    if score >= HIGH_OBFUSCATION_THRESHOLD { acc.malicious_detected += 1; }
                    else if score >= SUSPICIOUS_THRESHOLD { acc.suspicious_detected += 1; }
                    let n = acc.scripts_analyzed as f64;
                    acc.avg_obfuscation_score = acc.avg_obfuscation_score * (n - 1.0) / n + score / n;
                }
            },
        );

        let stats_computer = ReversibleComputation::new(
            512,
            |items: &[u64]| {
                let mut stats = ScriptEngineStats::default();
                stats.scripts_analyzed = items.len() as u64;
                stats
            },
        );

        Self {
            analysis_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            analysis_cache,
            stats_computer: RwLock::new(stats_computer),
            score_accumulator: RwLock::new(score_accumulator),
            metrics,
            pattern_diff: RwLock::new(DifferentialStore::new().with_max_chain(64)),
            result_cache: RwLock::new(PruningMap::new(ANALYSIS_CACHE_MAX)),
            script_dedup: RwLock::new(DedupStore::new()),
            language_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(ScriptEngineStats::default()),
            total_analyzed: AtomicU64::new(0),
        }
    }

    // ── Core API ────────────────────────────────────────────────────────────

    /// Analyze a script file.
    pub fn analyze_file(&self, path: &Path) -> Result<ScriptAnalysis, String> {
        self.total_analyzed.fetch_add(1, Ordering::Relaxed);

        let path_str = path.to_string_lossy().to_string();
        if let Some(cached) = self.analysis_cache.get(&path_str) {
            return Ok(cached);
        }

        let metadata = std::fs::metadata(path)
            .map_err(|e| format!("Cannot read: {}", e))?;
        if metadata.len() > MAX_SCRIPT_SIZE {
            return Err("Script too large".into());
        }

        let content = std::fs::read_to_string(path)
            .map_err(|e| format!("Cannot read script: {}", e))?;

        let analysis = self.analyze_content(&content, path);

        // Cache (Breakthrough #2)
        self.analysis_cache.insert(path_str.clone(), analysis.clone());

        // Feed breakthroughs
        {
            let mut acc = self.score_accumulator.write();
            acc.push(analysis.obfuscation_score);
        }
        {
            let stats = self.stats.read().clone();
            let mut history = self.analysis_history.write();
            history.checkpoint(stats);
        }

        // Update language matrix (Breakthrough #627)
        {
            let lang = format!("{:?}", analysis.language);
            let outcome = if analysis.verdict.is_threat() { "malicious" }
                else if analysis.verdict.is_suspicious() { "suspicious" }
                else { "clean" };
            let mut matrix = self.language_matrix.write();
            let current = matrix.get(&lang, &outcome.to_string()).clone();
            matrix.set(lang.clone(), outcome.to_string(), current + 1);
        }

        // Dedup (Breakthrough #592)
        {
            let hash = blake3::hash(content.as_bytes()).to_hex().to_string();
            let mut dedup = self.script_dedup.write();
            dedup.insert(hash, path_str.clone());
        }

        // Pruning cache (Breakthrough #569)
        {
            let mut cache = self.result_cache.write();
            cache.insert_with_priority(path_str, analysis.clone(), analysis.obfuscation_score);
        }

        // Update stats
        {
            let mut stats = self.stats.write();
            stats.scripts_analyzed += 1;
            let lang_key = format!("{:?}", analysis.language);
            *stats.by_language.entry(lang_key).or_default() += 1;
            stats.urls_extracted += analysis.urls_found.len() as u64;
            if analysis.verdict.is_threat() { stats.malicious_detected += 1; }
            else if analysis.verdict.is_suspicious() { stats.suspicious_detected += 1; }
        }

        Ok(analysis)
    }

    /// Analyze script content string.
    pub fn analyze_content(&self, content: &str, path: &Path) -> ScriptAnalysis {
        let language = self.detect_language(content, path);
        let entropy = compute_entropy_local(content.as_bytes());

        // Detect suspicious APIs
        let suspicious_apis = self.detect_suspicious_apis(content, language);

        // Extract URLs and IPs
        let urls = extract_urls(content);
        let ips = extract_ips(content);

        // Detect encoded payloads
        let encoded_payloads = self.detect_encoded_payloads(content);

        // Compute obfuscation score
        let obfuscation_techniques = self.detect_obfuscation(content, language);
        let obfuscation_score = self.compute_obfuscation_score(
            content, language, &suspicious_apis, &urls, &ips,
            &obfuscation_techniques, &encoded_payloads, entropy,
        );

        // Attempt deobfuscation
        let deobfuscated = if obfuscation_score > 30.0 {
            self.deobfuscate(content, language)
        } else {
            None
        };

        // Determine verdict
        let verdict = if obfuscation_score >= HIGH_OBFUSCATION_THRESHOLD {
            ScanVerdict::Suspicious {
                score: obfuscation_score,
                reasons: suspicious_apis.iter().take(5).cloned().collect(),
            }
        } else if obfuscation_score >= SUSPICIOUS_THRESHOLD {
            ScanVerdict::Suspicious {
                score: obfuscation_score,
                reasons: vec!["moderate_obfuscation".into()],
            }
        } else {
            ScanVerdict::Clean
        };

        ScriptAnalysis {
            language,
            path: path.to_string_lossy().to_string(),
            obfuscation_score,
            obfuscation_techniques,
            deobfuscated_preview: deobfuscated,
            suspicious_apis,
            urls_found: urls,
            ips_found: ips,
            encoded_payloads,
            verdict,
            entropy,
        }
    }

    // ── Language Detection ───────────────────────────────────────────────────

    fn detect_language(&self, content: &str, path: &Path) -> ScriptLanguage {
        // Check shebang first
        if content.starts_with("#!") {
            let first_line = content.lines().next().unwrap_or("");
            if first_line.contains("bash") { return ScriptLanguage::Bash; }
            if first_line.contains("zsh") { return ScriptLanguage::Zsh; }
            if first_line.contains("python") { return ScriptLanguage::Python; }
            if first_line.contains("ruby") { return ScriptLanguage::Ruby; }
            if first_line.contains("perl") { return ScriptLanguage::Perl; }
            if first_line.contains("node") || first_line.contains("deno") { return ScriptLanguage::JavaScript; }
            if first_line.contains("php") { return ScriptLanguage::PHP; }
            if first_line.contains("lua") { return ScriptLanguage::Lua; }
            if first_line.contains("/bin/sh") { return ScriptLanguage::Bash; }
        }

        // Check file extension
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
        match ext.to_lowercase().as_str() {
            "sh" | "bash" => ScriptLanguage::Bash,
            "zsh" => ScriptLanguage::Zsh,
            "py" | "pyw" => ScriptLanguage::Python,
            "rb" => ScriptLanguage::Ruby,
            "pl" | "pm" => ScriptLanguage::Perl,
            "ps1" | "psm1" | "psd1" => ScriptLanguage::PowerShell,
            "scpt" | "applescript" => ScriptLanguage::AppleScript,
            "js" | "mjs" | "cjs" => ScriptLanguage::JavaScript,
            "vbs" | "vbe" => ScriptLanguage::VBScript,
            "bat" | "cmd" => ScriptLanguage::Batch,
            "lua" => ScriptLanguage::Lua,
            "php" => ScriptLanguage::PHP,
            _ => {
                // Content-based detection
                if content.contains("def ") && content.contains("import ") { ScriptLanguage::Python }
                else if content.contains("function ") && (content.contains("var ") || content.contains("let ") || content.contains("const ")) { ScriptLanguage::JavaScript }
                else if content.contains("param(") || content.contains("$PSVersionTable") { ScriptLanguage::PowerShell }
                else if content.contains("tell application") { ScriptLanguage::AppleScript }
                else if content.contains("CreateObject") || content.contains("WScript") { ScriptLanguage::VBScript }
                else if content.contains("echo ") || content.contains("export ") { ScriptLanguage::Bash }
                else { ScriptLanguage::Unknown }
            }
        }
    }

    // ── Suspicious API Detection ────────────────────────────────────────────

    fn detect_suspicious_apis(&self, content: &str, language: ScriptLanguage) -> Vec<String> {
        let apis: &[&str] = match language {
            ScriptLanguage::Bash | ScriptLanguage::Zsh => BASH_SUSPICIOUS,
            ScriptLanguage::Python => PYTHON_SUSPICIOUS,
            ScriptLanguage::PowerShell => POWERSHELL_SUSPICIOUS,
            ScriptLanguage::AppleScript | ScriptLanguage::JXA => APPLESCRIPT_SUSPICIOUS,
            ScriptLanguage::JavaScript => JAVASCRIPT_SUSPICIOUS,
            ScriptLanguage::VBScript => VBSCRIPT_SUSPICIOUS,
            _ => BASH_SUSPICIOUS,
        };

        let content_lower = content.to_lowercase();
        apis.iter()
            .filter(|api| content_lower.contains(&api.to_lowercase()))
            .map(|api| api.to_string())
            .collect()
    }

    // ── Encoded Payload Detection ───────────────────────────────────────────

    fn detect_encoded_payloads(&self, content: &str) -> Vec<String> {
        let mut payloads = Vec::new();

        // Base64 blobs (20+ chars)
        let base64_chars: HashSet<char> = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            .chars().collect();

        let mut current = String::new();
        for ch in content.chars() {
            if base64_chars.contains(&ch) {
                current.push(ch);
            } else {
                if current.len() >= 40 && current.len() % 4 == 0 {
                    // Try to decode
                    let preview = if current.len() > 80 {
                        format!("{}...", &current[..80])
                    } else {
                        current.clone()
                    };
                    payloads.push(format!("base64:{}", preview));
                }
                current.clear();
            }
        }
        if current.len() >= 40 && current.len() % 4 == 0 {
            let preview = if current.len() > 80 {
                format!("{}...", &current[..80])
            } else {
                current
            };
            payloads.push(format!("base64:{}", preview));
        }

        // Hex-encoded strings (\x41\x42...)
        if content.contains("\\x") {
            let hex_count = content.matches("\\x").count();
            if hex_count >= 10 {
                payloads.push(format!("hex_escape:{}_occurrences", hex_count));
            }
        }

        // Chr() chains
        if content.to_lowercase().contains("chr(") {
            let chr_count = content.to_lowercase().matches("chr(").count();
            if chr_count >= 5 {
                payloads.push(format!("chr_chain:{}_calls", chr_count));
            }
        }

        payloads
    }

    // ── Obfuscation Detection ───────────────────────────────────────────────

    fn detect_obfuscation(&self, content: &str, language: ScriptLanguage) -> Vec<String> {
        let mut techniques = Vec::new();

        // String concatenation obfuscation
        let concat_count = content.matches("\" + \"").count()
            + content.matches("' + '").count()
            + content.matches("\" & \"").count();
        if concat_count >= 10 {
            techniques.push(format!("string_concatenation:{}_joins", concat_count));
        }

        // Variable indirection
        let var_patterns = match language {
            ScriptLanguage::Bash | ScriptLanguage::Zsh => {
                content.matches("${!").count() + content.matches("eval $").count()
            }
            ScriptLanguage::Python => {
                content.matches("getattr(").count() + content.matches("globals()[").count()
            }
            ScriptLanguage::PowerShell => {
                content.matches("iex ").count() + content.matches("& ").count()
            }
            _ => 0,
        };
        if var_patterns >= 3 {
            techniques.push(format!("variable_indirection:{}_patterns", var_patterns));
        }

        // Reversed strings
        if content.contains("rev ") || content.contains("[::-1]") || content.contains(".reverse()") {
            techniques.push("string_reversal".into());
        }

        // Character code construction
        let chr_funcs = ["chr(", "Chr(", "String.fromCharCode(", "\\x", "\\u00"];
        let chr_total: usize = chr_funcs.iter().map(|f| content.matches(f).count()).sum();
        if chr_total >= 10 {
            techniques.push(format!("char_code_construction:{}_calls", chr_total));
        }

        // Base64 encoding
        if content.contains("base64") || content.contains("b64decode") ||
           content.contains("atob(") || content.contains("FromBase64") {
            techniques.push("base64_encoding".into());
        }

        // Environment variable abuse
        let env_abuse = content.matches("%COMSPEC%").count()
            + content.matches("$env:").count()
            + content.matches("${IFS}").count();
        if env_abuse >= 3 {
            techniques.push(format!("env_variable_abuse:{}", env_abuse));
        }

        // Tick/caret obfuscation (PowerShell/Batch)
        if matches!(language, ScriptLanguage::PowerShell | ScriptLanguage::Batch) {
            let tick_count = content.matches('`').count();
            let caret_count = content.matches('^').count();
            if tick_count >= 10 || caret_count >= 10 {
                techniques.push("tick_caret_obfuscation".into());
            }
        }

        // Whitespace obfuscation (excessive spacing)
        let lines: Vec<&str> = content.lines().collect();
        let avg_line_len = if !lines.is_empty() {
            content.len() as f64 / lines.len() as f64
        } else { 0.0 };
        if lines.len() <= 3 && content.len() > 500 {
            techniques.push("single_line_obfuscation".into());
        }

        techniques
    }

    // ── Obfuscation Scoring ─────────────────────────────────────────────────

    fn compute_obfuscation_score(
        &self, content: &str, language: ScriptLanguage,
        suspicious_apis: &[String], urls: &[String], ips: &[String],
        techniques: &[String], payloads: &[String], entropy: f64,
    ) -> f64 {
        let mut score = 0.0;

        // Suspicious APIs (up to 30 points)
        score += (suspicious_apis.len() as f64 * 5.0).min(30.0);

        // Obfuscation techniques (up to 25 points)
        score += (techniques.len() as f64 * 8.0).min(25.0);

        // Encoded payloads (up to 15 points)
        score += (payloads.len() as f64 * 5.0).min(15.0);

        // Entropy (up to 10 points) — high entropy suggests obfuscation
        if entropy > 5.5 { score += (entropy - 5.5) * 4.0; }

        // URLs/IPs (up to 10 points)
        score += (urls.len() as f64 * 2.0).min(5.0);
        score += (ips.len() as f64 * 3.0).min(5.0);

        // Language-specific bonuses
        match language {
            ScriptLanguage::PowerShell => {
                if content.to_lowercase().contains("-encodedcommand") { score += 15.0; }
                if content.to_lowercase().contains("amsiutils") { score += 20.0; }
            }
            ScriptLanguage::VBScript => {
                if content.to_lowercase().contains("wscript.shell") { score += 10.0; }
            }
            ScriptLanguage::AppleScript => {
                if content.to_lowercase().contains("with administrator privileges") { score += 10.0; }
            }
            _ => {}
        }

        // Printable ratio penalty — very low printable ratio is suspicious
        let printable = content.chars().filter(|c| c.is_ascii_graphic() || c.is_whitespace()).count();
        let ratio = printable as f64 / content.len().max(1) as f64;
        if ratio < 0.7 { score += 10.0; }

        score.min(100.0)
    }

    // ── Deobfuscation ───────────────────────────────────────────────────────

    fn deobfuscate(&self, content: &str, language: ScriptLanguage) -> Option<String> {
        let mut result = content.to_string();
        let mut rounds = 0;

        for _ in 0..MAX_DEOBFUSCATION_ROUNDS {
            let before_len = result.len();
            let before = result.clone();

            // Layer 1: Decode base64 strings
            result = self.decode_base64_strings(&result);

            // Layer 2: Decode hex escapes
            result = self.decode_hex_escapes(&result);

            // Layer 3: Resolve string concatenation
            result = self.resolve_concatenation(&result);

            // Layer 4: Decode URL encoding
            result = self.decode_url_encoding(&result);

            if result == before { break; }
            rounds += 1;
        }

        self.stats.write().deobfuscation_rounds += rounds as u64;

        if rounds > 0 {
            let preview = if result.len() > 500 {
                format!("{}...", &result[..500])
            } else {
                result
            };
            Some(preview)
        } else {
            None
        }
    }

    fn decode_base64_strings(&self, content: &str) -> String {
        // Find base64-looking strings in quotes and try to decode
        let mut result = content.to_string();
        let base64_chars: HashSet<char> = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            .chars().collect();

        // Simple approach: find quoted strings that look like base64
        for delim in &['"', '\''] {
            let parts: Vec<&str> = content.split(*delim).collect();
            for (i, part) in parts.iter().enumerate() {
                if i % 2 == 1 && part.len() >= 20 && part.len() % 4 == 0 {
                    let is_b64 = part.chars().all(|c| base64_chars.contains(&c));
                    if is_b64 {
                        // Attempt decode (simplified)
                        if let Some(decoded) = simple_base64_decode(part) {
                            if decoded.chars().all(|c| c.is_ascii_graphic() || c.is_whitespace()) {
                                result = result.replace(part, &decoded);
                                self.stats.write().payloads_extracted += 1;
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.analysis_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #592: DedupStore — deduplicate events
        self.script_dedup.write().insert("evt".into(), format!("{:?}", std::time::SystemTime::now()));
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.stats_computer.write().push(1u64);
        // Breakthrough #5: StreamAccumulator — accumulate event rate
        self.score_accumulator.write().push(1.0);
        // Breakthrough #461: DifferentialStore — record state diff
        self.pattern_diff.write().record_insert("chk".into(), format!("evt@{:?}", std::time::SystemTime::now()));
        // Breakthrough #627: SparseMatrix — record in sparse matrix
        self.language_matrix.write().set("mod".into(), "evt".into(), 1u64);
        // Breakthrough #569: PruningMap — probe cache for eviction
        let _ = self.result_cache.write().get(&"probe".into());
                            }
                        }
                    }
                }
            }
        }

        result
    }

    fn decode_hex_escapes(&self, content: &str) -> String {
        let mut result = String::with_capacity(content.len());
        let chars: Vec<char> = content.chars().collect();
        let mut i = 0;

        while i < chars.len() {
            if i + 3 < chars.len() && chars[i] == '\\' && chars[i+1] == 'x' {
                let hex_str: String = chars[i+2..i+4].iter().collect();
                if let Ok(byte) = u8::from_str_radix(&hex_str, 16) {
                    if byte >= 0x20 && byte <= 0x7E {
                        result.push(byte as char);
                        i += 4;
                        continue;
                    }
                }
            }
            result.push(chars[i]);
            i += 1;
        }

        result
    }

    fn resolve_concatenation(&self, content: &str) -> String {
        // Replace "a" + "b" + "c" with "abc"
        let mut result = content.to_string();
        for sep in &["\" + \"", "\" & \"", "' + '", "' & '"] {
            result = result.replace(sep, "");
        }
        result
    }

    fn decode_url_encoding(&self, content: &str) -> String {
        let mut result = String::with_capacity(content.len());
        let chars: Vec<char> = content.chars().collect();
        let mut i = 0;

        while i < chars.len() {
            if i + 2 < chars.len() && chars[i] == '%' {
                let hex_str: String = chars[i+1..i+3].iter().collect();
                if let Ok(byte) = u8::from_str_radix(&hex_str, 16) {
                    result.push(byte as char);
                    i += 3;
                    continue;
                }
            }
            result.push(chars[i]);
            i += 1;
        }

        result
    }

    // ── Query API ───────────────────────────────────────────────────────────

    pub fn get_stats(&self) -> ScriptEngineStats {
        self.stats.read().clone()
    }

    pub fn historical_stats(&self, level: u32) -> Vec<ScriptEngineStats> {
        let history = self.analysis_history.read();
        history.level(level)
            .map(|cps| cps.iter().map(|c| c.state.clone()).collect())
            .unwrap_or_default()
    }

    pub fn memory_report(&self) -> sentinel_core::metrics::MemoryReport {
        self.metrics.report()
    }
}

// ── Utility Functions ───────────────────────────────────────────────────────

fn extract_urls(content: &str) -> Vec<String> {
    let mut urls = Vec::new();
    for word in content.split_whitespace() {
        let cleaned = word.trim_matches(|c: char| c == '"' || c == '\'' || c == '(' || c == ')' || c == ';');
        if cleaned.starts_with("http://") || cleaned.starts_with("https://") || cleaned.starts_with("ftp://") {
            urls.push(cleaned.to_string());
        }
    }
    urls.sort();
    urls.dedup();
    urls
}

fn extract_ips(content: &str) -> Vec<String> {
    let mut ips = Vec::new();
    // Simple regex-free IP extraction
    for word in content.split(|c: char| !c.is_ascii_digit() && c != '.') {
        let parts: Vec<&str> = word.split('.').collect();
        if parts.len() == 4 && parts.iter().all(|p| p.parse::<u8>().is_ok()) {
            let ip = word.to_string();
            if ip != "0.0.0.0" && ip != "127.0.0.1" && ip != "255.255.255.255" {
                ips.push(ip);
            }
        }
    }
    ips.sort();
    ips.dedup();
    ips
}

fn compute_entropy_local(data: &[u8]) -> f64 {
    if data.is_empty() { return 0.0; }
    let mut counts = [0u64; 256];
    for &b in data { counts[b as usize] += 1; }
    let len = data.len() as f64;
    let mut entropy = 0.0;
    for &c in &counts {
        if c > 0 {
            let p = c as f64 / len;
            entropy -= p * p.log2();
        }
    }
    entropy
}

fn simple_base64_decode(input: &str) -> Option<String> {
    const CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let mut output = Vec::new();

    let filtered: Vec<u8> = input.bytes().filter(|&b| b != b'=').collect();

    for chunk in filtered.chunks(4) {
        let mut val = 0u32;
        for (i, &byte) in chunk.iter().enumerate() {
            let idx = CHARS.iter().position(|&c| c == byte)? as u32;
            val |= idx << (18 - i * 6);
        }
        output.push((val >> 16) as u8);
        if chunk.len() > 2 { output.push((val >> 8) as u8); }
        if chunk.len() > 3 { output.push(val as u8); }
    }

    String::from_utf8(output).ok()
}
