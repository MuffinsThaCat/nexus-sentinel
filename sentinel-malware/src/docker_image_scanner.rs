//! Module 141: DockerImageScanner — Container Image & Docker Desktop Security
//!
//! Detects malicious Docker images, Dockerfile abuse, Docker Desktop exploitation,
//! container breakout preparations, and supply-chain attacks via container registries
//! on macOS developer environments.
//!
//! ## Detection Capabilities
//!
//! - **Malicious base images**: Typosquatted Docker Hub images, images with
//!   cryptominers, backdoors, or credential stealers pre-installed
//! - **Dockerfile abuse**: RUN commands that download/execute payloads, ADD/COPY
//!   from suspicious URLs, ENV with embedded credentials
//! - **Docker socket exposure**: /var/run/docker.sock mount (container escape)
//! - **Privileged container detection**: --privileged flag, excessive capabilities
//! - **Docker Desktop exploitation**: VM escape, hypervisor vulnerabilities,
//!   file sharing abuse, docker.raw disk access
//! - **Registry poisoning**: Push to unauthorized registries, image tag mutation
//! - **Layer analysis**: Hidden layers with malicious content, large unexplained
//!   layers, layers that modify /etc/shadow or install SSH keys
//! - **Secrets in images**: API keys, passwords, tokens baked into image layers
//! - **Network exposure**: Containers with host networking, exposed sensitive ports
//!
//! ## MITRE ATT&CK: T1610, T1611, T1525, T1552.001, T1059.004
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const DOCKERFILE_MALICIOUS_PATTERNS: &[(&str, &str, f64)] = &[
    ("curl.*|.*sh", "Pipe-to-shell in Dockerfile RUN", 0.85),
    ("curl.*|.*bash", "Pipe-to-bash in Dockerfile", 0.85),
    ("wget.*|.*sh", "wget pipe-to-shell", 0.85),
    ("apt-get install.*nmap", "Network scanner installation", 0.5),
    ("apt-get install.*netcat", "Netcat installation", 0.5),
    ("apk add.*nmap", "Alpine nmap installation", 0.5),
    ("chmod 4755", "SUID bit setting", 0.7),
    ("chmod u+s", "SUID bit setting", 0.7),
    ("/etc/shadow", "Shadow file access", 0.8),
    ("authorized_keys", "SSH key injection", 0.7),
    ("nc -l", "Netcat listener in container", 0.8),
    ("/dev/tcp/", "Bash TCP redirect", 0.9),
    ("base64 -d", "Base64 decode (obfuscation)", 0.5),
    ("eval $(", "Eval execution", 0.7),
    ("xmrig", "Cryptominer (XMRig)", 0.95),
    ("stratum+tcp", "Mining pool connection", 0.95),
    ("monero", "Monero mining reference", 0.8),
    ("nohup.*&", "Background persistent process", 0.5),
    ("crontab", "Cron installation in container", 0.5),
    ("ssh-keygen.*-t", "SSH key generation", 0.4),
    ("useradd.*-o.*-u 0", "Root-equivalent user creation", 0.85),
    ("echo.*>>.*passwd", "Passwd file modification", 0.85),
];

const DANGEROUS_DOCKER_FLAGS: &[(&str, &str, f64)] = &[
    ("--privileged", "Privileged container (full host access)", 0.85),
    ("--cap-add=ALL", "All capabilities added", 0.85),
    ("--cap-add=SYS_ADMIN", "SYS_ADMIN capability (escape vector)", 0.8),
    ("--cap-add=SYS_PTRACE", "SYS_PTRACE capability (process injection)", 0.7),
    ("--cap-add=NET_ADMIN", "NET_ADMIN capability (network manipulation)", 0.6),
    ("--cap-add=SYS_RAWIO", "SYS_RAWIO capability (raw I/O access)", 0.8),
    ("--cap-add=DAC_READ_SEARCH", "DAC_READ_SEARCH (file access bypass)", 0.7),
    ("-v /var/run/docker.sock", "Docker socket mount (escape)", 0.9),
    ("-v /:/host", "Root filesystem mount (full access)", 0.95),
    ("-v /etc:/", "Etc mount (credential access)", 0.8),
    ("--net=host", "Host network mode", 0.6),
    ("--pid=host", "Host PID namespace (process visibility)", 0.7),
    ("--ipc=host", "Host IPC namespace", 0.6),
    ("--security-opt=no-new-privileges:false", "New privileges allowed", 0.7),
    ("--security-opt apparmor=unconfined", "AppArmor disabled", 0.7),
    ("--security-opt seccomp=unconfined", "Seccomp disabled", 0.8),
    ("-p 0.0.0.0:", "Port bound to all interfaces", 0.4),
    ("-p.*:22", "SSH port exposed", 0.5),
    ("-p.*:3389", "RDP port exposed", 0.6),
    ("--userns=host", "Host user namespace", 0.7),
];

const SUSPICIOUS_BASE_IMAGES: &[(&str, &str, f64)] = &[
    ("latest", "Using :latest tag (mutable, supply chain risk)", 0.3),
    ("alpine:latest", "Alpine latest (prefer pinned)", 0.2),
    ("ubuntu:latest", "Ubuntu latest (prefer pinned)", 0.2),
    // Typosquatted image names
    ("ubuntuuu", "Typosquatted ubuntu", 0.9),
    ("alphine", "Typosquatted alpine", 0.9),
    ("ngingx", "Typosquatted nginx", 0.9),
    ("nodee", "Typosquatted node", 0.85),
    ("pythonn", "Typosquatted python", 0.85),
];

const DOCKER_DESKTOP_MACOS_CONCERNS: &[(&str, &str, f64)] = &[
    ("docker.raw", "Docker Desktop VM disk access", 0.5),
    ("com.docker.vmnetd", "Docker VM networking daemon", 0.3),
    ("Docker.app/Contents", "Docker.app bundle modification", 0.6),
    ("com.docker.hyperkit", "HyperKit hypervisor access", 0.4),
    ("~/Library/Containers/com.docker", "Docker Desktop container data", 0.3),
    ("com.docker.backend", "Docker backend process", 0.3),
    ("vz-rosetta", "Rosetta translation in Docker (ARM)", 0.2),
];

const SECRETS_IN_IMAGE_PATTERNS: &[(&str, &str, f64)] = &[
    ("ENV.*PASSWORD=", "Password in ENV instruction", 0.8),
    ("ENV.*SECRET=", "Secret in ENV instruction", 0.8),
    ("ENV.*API_KEY=", "API key in ENV instruction", 0.8),
    ("ENV.*TOKEN=", "Token in ENV instruction", 0.7),
    ("ENV.*AWS_ACCESS_KEY", "AWS key in ENV instruction", 0.9),
    ("ENV.*AWS_SECRET", "AWS secret in ENV instruction", 0.9),
    ("COPY.*\\.env", ".env file copied into image", 0.7),
    ("COPY.*id_rsa", "SSH private key copied into image", 0.9),
    ("ADD.*\\.pem", "PEM file added to image", 0.7),
    ("COPY.*credentials", "Credentials file copied", 0.7),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DockerThreatType {
    MaliciousDockerfile,
    DownloadAndExecute,
    CryptominerImage,
    PrivilegedContainer,
    DockerSocketExposure,
    RootFilesystemMount,
    HostNetworking,
    CapabilityAbuse,
    SecretInImage,
    TyposquattedImage,
    LatestTagUsage,
    SSHKeyInjection,
    SUIDBinary,
    PasswdModification,
    ContainerEscapePrep,
    DockerDesktopExploit,
    RegistryPoisoning,
    SecurityOptDisabled,
    SensitivePortExposure,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DockerThreatFinding {
    pub threat_type: DockerThreatType,
    pub confidence: f64,
    pub description: String,
    pub image_name: Option<String>,
    pub dockerfile_line: Option<String>,
    pub docker_flag: Option<String>,
    pub layer_hash: Option<String>,
    pub mitre_id: String,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DockerEvent {
    pub event_type: String,    // "build", "run", "pull", "push", "inspect", "file_modify"
    pub image_name: Option<String>,
    pub image_tag: Option<String>,
    pub dockerfile_content: Option<String>,
    pub run_flags: Option<String>,
    pub container_id: Option<String>,
    pub registry: Option<String>,
    pub file_path: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DockerAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<DockerThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct DockerScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub privileged_detections: u64,
    pub secret_detections: u64,
    pub cryptominer_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DockerSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

pub struct DockerImageScanner {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<DockerScanStats>>,
    result_cache: TieredCache<String, DockerAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    image_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, DockerScanStats>>,
    metrics: MemoryMetrics,
    image_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, DockerAnalysisResult>>,
    sig_db: PagedMemory<DockerSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<DockerScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl DockerImageScanner {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            image_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, DockerScanStats::default(),
                |acc: &mut DockerScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            image_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(DockerScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &DockerEvent) -> Option<DockerAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("docker:{}:{}:{}", event.event_type, event.image_name.as_deref().unwrap_or(""), event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // ── 1. Dockerfile content analysis ──────────────────────────────
        if let Some(ref content) = event.dockerfile_content {
            let content_lower = content.to_lowercase();
            for &(pattern, desc, conf) in DOCKERFILE_MALICIOUS_PATTERNS {
                if content_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("xmrig") || pattern.contains("stratum") || pattern.contains("monero") {
                        DockerThreatType::CryptominerImage
                    } else if pattern.contains("curl") && pattern.contains("sh") {
                        DockerThreatType::DownloadAndExecute
                    } else if pattern.contains("4755") || pattern.contains("u+s") {
                        DockerThreatType::SUIDBinary
                    } else if pattern.contains("shadow") || pattern.contains("passwd") {
                        DockerThreatType::PasswdModification
                    } else if pattern.contains("authorized_keys") || pattern.contains("ssh-keygen") {
                        DockerThreatType::SSHKeyInjection
                    } else { DockerThreatType::MaliciousDockerfile };
                    findings.push(DockerThreatFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        image_name: event.image_name.clone(), dockerfile_line: None,
                        docker_flag: None, layer_hash: None,
                        mitre_id: "T1610".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1610".into());
                }
            }

            // Secrets in image
            for &(pattern, desc, conf) in SECRETS_IN_IMAGE_PATTERNS {
                if content_lower.contains(&pattern.to_lowercase()) {
                    findings.push(DockerThreatFinding {
                        threat_type: DockerThreatType::SecretInImage, confidence: conf,
                        description: desc.to_string(),
                        image_name: event.image_name.clone(), dockerfile_line: None,
                        docker_flag: None, layer_hash: None,
                        mitre_id: "T1552.001".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1552.001".into());
                }
            }
        }

        // ── 2. Docker run flags analysis ────────────────────────────────
        if let Some(ref flags) = event.run_flags {
            let flags_lower = flags.to_lowercase();
            for &(flag, desc, conf) in DANGEROUS_DOCKER_FLAGS {
                if flags_lower.contains(&flag.to_lowercase()) {
                    let tt = if flag.contains("privileged") { DockerThreatType::PrivilegedContainer }
                        else if flag.contains("docker.sock") { DockerThreatType::DockerSocketExposure }
                        else if flag.contains("/:/host") { DockerThreatType::RootFilesystemMount }
                        else if flag.contains("net=host") { DockerThreatType::HostNetworking }
                        else if flag.contains("cap-add") { DockerThreatType::CapabilityAbuse }
                        else if flag.contains("security-opt") { DockerThreatType::SecurityOptDisabled }
                        else if flag.contains(":22") || flag.contains(":3389") { DockerThreatType::SensitivePortExposure }
                        else { DockerThreatType::ContainerEscapePrep };
                    findings.push(DockerThreatFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        image_name: event.image_name.clone(), dockerfile_line: None,
                        docker_flag: Some(flag.to_string()), layer_hash: None,
                        mitre_id: "T1611".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1611".into());
                }
            }
        }

        // ── 3. Image name analysis ──────────────────────────────────────
        if let Some(ref name) = event.image_name {
            let name_lower = name.to_lowercase();
            for &(pattern, desc, conf) in SUSPICIOUS_BASE_IMAGES {
                if name_lower.contains(pattern) {
                    let tt = if pattern == "latest" { DockerThreatType::LatestTagUsage }
                        else { DockerThreatType::TyposquattedImage };
                    findings.push(DockerThreatFinding {
                        threat_type: tt, confidence: conf, description: format!("{}: {}", desc, name),
                        image_name: Some(name.clone()), dockerfile_line: None,
                        docker_flag: None, layer_hash: None,
                        mitre_id: "T1525".into(), file_path: event.file_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1525".into());
                }
            }
        }

        // ── 4. Docker Desktop macOS concerns ────────────────────────────
        if let Some(ref path) = event.file_path {
            for &(pattern, desc, conf) in DOCKER_DESKTOP_MACOS_CONCERNS {
                if path.to_lowercase().contains(&pattern.to_lowercase()) {
                    if event.event_type == "file_modify" {
                        findings.push(DockerThreatFinding {
                            threat_type: DockerThreatType::DockerDesktopExploit, confidence: conf,
                            description: format!("{}: modified", desc),
                            image_name: None, dockerfile_line: None, docker_flag: None, layer_hash: None,
                            mitre_id: "T1611".into(), file_path: Some(path.clone()), timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1611".into());
                    }
                }
            }
        }

        self.image_diffs.write().record_insert(cache_key.clone(),
            format!("type={},image={:?},findings={}", event.event_type, event.image_name, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = DockerAnalysisResult {
            is_malicious, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_malicious { s.malicious_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "docker_image_scanner".into(),
                title: format!("Docker threat: {:?}", event.image_name),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Never run containers with --privileged".into(),
                    "Pin image tags to digests (sha256)".into(),
                    "Use Docker Content Trust (DOCKER_CONTENT_TRUST=1)".into(),
                    "Scan images with trivy/grype before running".into(),
                    "Never mount Docker socket into containers".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[DockerThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                DockerThreatType::RootFilesystemMount => 1.6,
                DockerThreatType::DockerSocketExposure => 1.5,
                DockerThreatType::CryptominerImage => 1.5,
                DockerThreatType::PrivilegedContainer => 1.4,
                DockerThreatType::DownloadAndExecute => 1.4,
                DockerThreatType::SecretInImage => 1.3,
                DockerThreatType::SSHKeyInjection => 1.3,
                DockerThreatType::CapabilityAbuse => 1.2,
                DockerThreatType::PasswdModification => 1.2,
                DockerThreatType::TyposquattedImage => 1.3,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> DockerScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
