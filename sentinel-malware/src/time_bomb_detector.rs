//! Module 43: TimeBombDetector — Time-Based Trigger & Logic Bomb Detection
//!
//! Detects malware that uses time-based triggers, date checks, or conditional
//! logic bombs to delay malicious execution past sandbox analysis windows.
//!
//! ## Features
//!
//! - **Time API hooking detection**: Monitors calls to time/date APIs that malware
//!   uses to check if it's past an activation date
//! - **Sleep acceleration detection**: Identifies sandbox evasion via long sleeps
//!   (Sleep(86400000), usleep(), nanosleep() with large values)
//! - **Date string analysis**: Finds hardcoded dates in binary strings
//! - **NTP query detection**: Identifies malware verifying time via network
//! - **Conditional execution analysis**: Detects if-date-then-execute patterns
//! - **Environment time checks**: Identifies timezone, locale, and uptime checks
//! - **Countdown timer detection**: Finds countdown-to-activation mechanisms
//! - **Calendar event triggers**: Detects activation tied to holidays/events
//! - **File timestamp manipulation**: Detects timestomping and anti-forensic timing
//! - **Process scheduling analysis**: Identifies at/cron-based delayed execution
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 6;
const HISTORY_PER_LEVEL: usize = 32;
const DETECTION_CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 128;
const LONG_SLEEP_THRESHOLD_MS: u64 = 300_000; // 5 minutes
const SUSPICIOUS_YEAR_MIN: u32 = 2020;
const SUSPICIOUS_YEAR_MAX: u32 = 2035;

// Time-related API names to search for in binaries
const TIME_APIS: &[&str] = &[
    "GetSystemTime", "GetLocalTime", "GetTickCount", "GetTickCount64",
    "QueryPerformanceCounter", "NtQuerySystemTime", "time", "gettimeofday",
    "clock_gettime", "localtime", "gmtime", "mktime", "strftime",
    "CFAbsoluteTimeGetCurrent", "NSDate", "mach_absolute_time",
    "GetSystemTimeAsFileTime", "SystemTimeToFileTime",
];

const SLEEP_APIS: &[&str] = &[
    "Sleep", "SleepEx", "NtDelayExecution", "sleep", "usleep",
    "nanosleep", "select", "poll", "WaitForSingleObject",
    "dispatch_after", "performSelector:withObject:afterDelay:",
];

const SCHEDULER_APIS: &[&str] = &[
    "at", "crontab", "launchctl", "schtasks", "CreateTimerQueueTimer",
    "SetWaitableTimer", "dispatch_source_create", "NSTimer",
    "CFRunLoopTimerCreate",
];

// Date patterns to search for (regex-free)
const DATE_PATTERNS: &[&str] = &[
    "2024-", "2025-", "2026-", "2027-", "2028-",
    "/01/2024", "/01/2025", "/01/2026",
    "January", "February", "March", "April",
    "Monday", "Tuesday",
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum TimeBombType {
    DateCheck,
    LongSleep,
    ActivationDate,
    Countdown,
    UptimeCheck,
    TimezoneCheck,
    NtpVerification,
    ScheduledExecution,
    Timestomping,
    CalendarTrigger,
    SandboxEvasionSleep,
    EnvironmentTimeCheck,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimeBombAnalysis {
    pub path: String,
    pub file_hash: String,
    pub has_time_bomb: bool,
    pub bomb_types: Vec<TimeBombType>,
    pub confidence: f64,
    pub time_api_usage: Vec<TimeApiUsage>,
    pub sleep_calls: Vec<SleepCall>,
    pub hardcoded_dates: Vec<HardcodedDate>,
    pub scheduler_usage: Vec<SchedulerUsage>,
    pub indicators: Vec<TimeBombIndicator>,
    pub risk_score: f64,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimeApiUsage {
    pub api_name: String,
    pub offset: u64,
    pub context: String,
    pub suspicious: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SleepCall {
    pub api_name: String,
    pub duration_ms: u64,
    pub offset: u64,
    pub is_evasion: bool,
    pub details: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HardcodedDate {
    pub date_string: String,
    pub offset: u64,
    pub parsed_date: Option<String>,
    pub is_future: bool,
    pub context: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SchedulerUsage {
    pub scheduler_type: String,
    pub api_name: String,
    pub details: String,
    pub offset: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TimeBombIndicator {
    pub bomb_type: TimeBombType,
    pub description: String,
    pub weight: f64,
    pub evidence: String,
    pub mitre_id: Option<String>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct TimeBombStats {
    pub files_analyzed: u64,
    pub time_bombs_detected: u64,
    pub sleep_evasions_found: u64,
    pub hardcoded_dates_found: u64,
    pub scheduler_usage_found: u64,
    pub avg_analysis_ms: u64,
}

// ═══════════════════════════════════════════════════════════════════════════

pub struct TimeBombDetector {
    detection_history: RwLock<HierarchicalState<TimeBombStats>>,
    result_cache: TieredCache<String, TimeBombAnalysis>,
    score_computer: RwLock<ReversibleComputation<u64, u64>>,
    analysis_rate: RwLock<StreamAccumulator<f64, f64>>,
    metrics: MemoryMetrics,
    hash_diffs: RwLock<DifferentialStore<String, String>>,
    recent_detections: RwLock<PruningMap<String, TimeBombAnalysis>>,
    sample_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    type_file_matrix: RwLock<SparseMatrix<String, String, u64>>,

    stats: RwLock<TimeBombStats>,
    total_analyses: AtomicU64,
}

impl TimeBombDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(16 * 1024 * 1024);
        let result_cache = TieredCache::new(DETECTION_CACHE_MAX)
            .with_metrics(metrics.clone(), "time_bomb_detector_cache");

        let score_computer = ReversibleComputation::new(
            512, |items: &[u64]| items.iter().sum::<u64>(),
        );
        let analysis_rate = StreamAccumulator::new(
            STATS_WINDOW, 0.0_f64,
            |acc: &mut f64, items: &[f64]| {
                if !items.is_empty() { *acc = items.iter().sum::<f64>() / items.len() as f64; }
            },
        );

        Self {
            detection_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache,
            score_computer: RwLock::new(score_computer),
            analysis_rate: RwLock::new(analysis_rate),
            metrics,
            hash_diffs: RwLock::new(DifferentialStore::new().with_max_chain(64)),
            recent_detections: RwLock::new(PruningMap::new(DETECTION_CACHE_MAX)),
            sample_dedup: RwLock::new(DedupStore::new()),
            type_file_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(TimeBombStats::default()),
            total_analyses: AtomicU64::new(0),
        }
    }

    /// Analyze a binary for time-bomb / logic-bomb indicators.
    pub fn analyze(&self, path: &str) -> TimeBombAnalysis {
        let start = std::time::Instant::now();
        self.total_analyses.fetch_add(1, Ordering::Relaxed);

        if let Some(cached) = self.result_cache.get(&path.to_string()) {
            return cached.clone();
        }

        let data = match std::fs::read(path) {
            Ok(d) => d,
            Err(_) => return self.empty_result(path, start),
        };

        let file_hash = blake3::hash(&data).to_hex().to_string();
        self.sample_dedup.write().insert(file_hash.clone(), vec![]);

        let mut indicators = Vec::new();
        let mut bomb_types = Vec::new();

        // 1. Scan for time API references
        let time_apis = self.find_api_references(&data, TIME_APIS);
        let time_api_count = time_apis.len();

        // 2. Scan for sleep API references
        let sleep_apis = self.find_api_references(&data, SLEEP_APIS);
        let mut sleep_calls = Vec::new();

        for api in &sleep_apis {
            // Look for large sleep values near the API reference
            let large_value = self.find_nearby_large_value(&data, api.offset as usize, 32);
            if let Some(val) = large_value {
                if val >= LONG_SLEEP_THRESHOLD_MS {
                    sleep_calls.push(SleepCall {
                        api_name: api.api_name.clone(),
                        duration_ms: val,
                        offset: api.offset,
                        is_evasion: val >= 60_000, // > 1 minute
                        details: format!("{}({}) — {} seconds", api.api_name, val, val / 1000),
                    });
                }
            }
        }

        if !sleep_calls.is_empty() {
            let max_sleep = sleep_calls.iter().map(|s| s.duration_ms).max().unwrap_or(0);
            bomb_types.push(TimeBombType::SandboxEvasionSleep);
            indicators.push(TimeBombIndicator {
                bomb_type: TimeBombType::SandboxEvasionSleep,
                description: format!("{} long sleep calls (max: {}s)", sleep_calls.len(), max_sleep / 1000),
                weight: if max_sleep > 600_000 { 0.8 } else { 0.5 },
                evidence: format!("Longest sleep: {} ms", max_sleep),
                mitre_id: Some("T1497.003".into()),
            });
            self.stats.write().sleep_evasions_found += sleep_calls.len() as u64;
        }

        // 3. Find hardcoded dates
        let hardcoded_dates = self.find_hardcoded_dates(&data);
        if !hardcoded_dates.is_empty() {
            let future_dates = hardcoded_dates.iter().filter(|d| d.is_future).count();
            if future_dates > 0 {
                bomb_types.push(TimeBombType::ActivationDate);
                indicators.push(TimeBombIndicator {
                    bomb_type: TimeBombType::ActivationDate,
                    description: format!("{} future dates found (possible activation dates)", future_dates),
                    weight: 0.6,
                    evidence: hardcoded_dates.iter()
                        .filter(|d| d.is_future)
                        .map(|d| d.date_string.clone())
                        .collect::<Vec<_>>().join(", "),
                    mitre_id: Some("T1480.001".into()),
                });
            }
            if hardcoded_dates.len() > 3 {
                bomb_types.push(TimeBombType::DateCheck);
                indicators.push(TimeBombIndicator {
                    bomb_type: TimeBombType::DateCheck,
                    description: format!("{} date references — heavy time-dependent logic", hardcoded_dates.len()),
                    weight: 0.4,
                    evidence: format!("{} dates", hardcoded_dates.len()),
                    mitre_id: Some("T1480.001".into()),
                });
            }
            self.stats.write().hardcoded_dates_found += hardcoded_dates.len() as u64;
        }

        // 4. Find scheduler API usage
        let scheduler_refs = self.find_api_references(&data, SCHEDULER_APIS);
        let mut scheduler_usage = Vec::new();
        for api in &scheduler_refs {
            scheduler_usage.push(SchedulerUsage {
                scheduler_type: "system".into(),
                api_name: api.api_name.clone(),
                details: format!("{} at offset 0x{:x}", api.api_name, api.offset),
                offset: api.offset,
            });
        }

        if !scheduler_usage.is_empty() {
            bomb_types.push(TimeBombType::ScheduledExecution);
            indicators.push(TimeBombIndicator {
                bomb_type: TimeBombType::ScheduledExecution,
                description: format!("{} scheduler API references", scheduler_usage.len()),
                weight: 0.3,
                evidence: scheduler_usage.iter().map(|s| s.api_name.clone()).collect::<Vec<_>>().join(", "),
                mitre_id: Some("T1053".into()),
            });
            self.stats.write().scheduler_usage_found += scheduler_usage.len() as u64;
        }

        // 5. Combined analysis: time APIs + conditionals = likely time bomb
        if time_api_count > 3 && !sleep_calls.is_empty() {
            indicators.push(TimeBombIndicator {
                bomb_type: TimeBombType::EnvironmentTimeCheck,
                description: "Multiple time APIs combined with sleep — sandbox evasion pattern".into(),
                weight: 0.7,
                evidence: format!("{} time APIs + {} sleep calls", time_api_count, sleep_calls.len()),
                mitre_id: Some("T1497.003".into()),
            });
        }

        // Compute results
        let risk_score: f64 = indicators.iter().map(|i| i.weight).sum::<f64>().min(1.0);
        let has_time_bomb = risk_score >= 0.4;
        let confidence = if risk_score >= 0.8 { 0.9 }
            else if risk_score >= 0.5 { 0.7 }
            else if risk_score >= 0.3 { 0.5 }
            else { 0.2 };

        let duration_ms = start.elapsed().as_millis() as u64;

        let result = TimeBombAnalysis {
            path: path.to_string(),
            file_hash: file_hash.clone(),
            has_time_bomb,
            bomb_types: bomb_types.clone(),
            confidence,
            time_api_usage: time_apis,
            sleep_calls,
            hardcoded_dates,
            scheduler_usage,
            indicators,
            risk_score,
            analysis_time_ms: duration_ms,
        };

        // Cache & track
        self.result_cache.insert(path.to_string(), result.clone());
        if has_time_bomb {
            self.recent_detections.write().insert_with_priority(
                path.to_string(), result.clone(), confidence,
            );
            for bt in &bomb_types {
                let bt_str = format!("{:?}", bt);
                let current = *self.type_file_matrix.read().get(&bt_str, &file_hash);
                self.type_file_matrix.write().set(bt_str, file_hash.clone(), current + 1);
            }
            self.stats.write().time_bombs_detected += 1;
        }

        self.hash_diffs.write().record_insert(file_hash, path.to_string());
        self.stats.write().files_analyzed += 1;
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.detection_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.score_computer.write().push(1u64);
        // Breakthrough #5: StreamAccumulator — accumulate event rate
        self.analysis_rate.write().push(1.0);
        self.stats.write().avg_analysis_ms = (self.stats.read().avg_analysis_ms + duration_ms) / 2;
        self.analysis_rate.write().push(duration_ms as f64);

        result
    }

    fn find_api_references(&self, data: &[u8], apis: &[&str]) -> Vec<TimeApiUsage> {
        let mut found = Vec::new();
        for api in apis {
            let api_bytes = api.as_bytes();
            for (i, window) in data.windows(api_bytes.len()).enumerate() {
                if window == api_bytes {
                    found.push(TimeApiUsage {
                        api_name: api.to_string(),
                        offset: i as u64,
                        context: format!("Found at offset 0x{:x}", i),
                        suspicious: SLEEP_APIS.contains(api) || api.contains("Timer"),
                    });
                    break; // One per API
                }
            }
        }
        found
    }

    fn find_nearby_large_value(&self, data: &[u8], offset: usize, range: usize) -> Option<u64> {
        let start = offset.saturating_sub(range);
        let end = (offset + range).min(data.len().saturating_sub(4));

        for i in start..end {
            if i + 4 <= data.len() {
                let val = u32::from_le_bytes([data[i], data[i+1], data[i+2], data[i+3]]) as u64;
                if val >= LONG_SLEEP_THRESHOLD_MS && val <= 86_400_000 * 30 {
                    return Some(val);
                }
            }
        }
        None
    }

    fn find_hardcoded_dates(&self, data: &[u8]) -> Vec<HardcodedDate> {
        let mut dates = Vec::new();
        let content = String::from_utf8_lossy(data);
        let now_year = 2026u32;

        for pattern in DATE_PATTERNS {
            if let Some(pos) = content.find(pattern) {
                let is_future = pattern.starts_with("202") && {
                    pattern[..4].parse::<u32>().map(|y| y > now_year).unwrap_or(false)
                };

                dates.push(HardcodedDate {
                    date_string: pattern.to_string(),
                    offset: pos as u64,
                    parsed_date: Some(pattern.to_string()),
                    is_future,
                    context: format!("Found '{}' at offset 0x{:x}", pattern, pos),
                });
            }
        }

        // Also search for Unix timestamps that represent future dates
        for i in 0..data.len().saturating_sub(4) {
            let val = u32::from_le_bytes([data[i], data[i+1], data[i+2], data[i+3]]);
            // Future timestamp range: 2026-2030
            if val >= 1_767_225_600 && val <= 1_893_456_000 {
                dates.push(HardcodedDate {
                    date_string: format!("unix:{}", val),
                    offset: i as u64,
                    parsed_date: Some(format!("Unix timestamp {}", val)),
                    is_future: true,
                    context: format!("Future Unix timestamp at 0x{:x}", i),
                });
                if dates.len() > 20 { break; }
            }
        }

        dates.truncate(30);
        dates
    }

    fn empty_result(&self, path: &str, start: std::time::Instant) -> TimeBombAnalysis {
        TimeBombAnalysis {
            path: path.to_string(), file_hash: String::new(), has_time_bomb: false,
            bomb_types: vec![], confidence: 0.0, time_api_usage: vec![],
            sleep_calls: vec![], hardcoded_dates: vec![], scheduler_usage: vec![],
            indicators: vec![], risk_score: 0.0,
            analysis_time_ms: start.elapsed().as_millis() as u64,
        }
    }

    pub fn stats(&self) -> TimeBombStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
