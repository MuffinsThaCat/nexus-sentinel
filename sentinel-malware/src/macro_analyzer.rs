//! Module 88: MacroAnalyzer — Office Macro Malware Analysis & Detection
//!
//! World-class analysis engine for Microsoft Office VBA macros, XLM (Excel 4.0)
//! macros, and embedded scripts. Detects obfuscated macro malware, auto-execute
//! triggers, PowerShell downloaders, WMI abuse, and sandbox evasion techniques.
//!
//! ## Features
//!
//! - **VBA macro extraction**: Parses OLE compound documents to extract VBA project
//!   streams, modules, and forms from DOC/XLS/PPT files
//! - **Auto-execute detection**: Identifies AutoOpen, AutoClose, Document_Open,
//!   Workbook_Open, Auto_Open, and other auto-trigger macros
//! - **Obfuscation analysis**: Detects string concatenation, Chr() construction,
//!   StrReverse, Replace chains, and variable indirection
//! - **Shell command detection**: Identifies Shell(), WScript.Shell, Process.Start,
//!   cmd.exe, powershell.exe invocations from macros
//! - **Network indicator detection**: Finds URLDownloadToFile, XMLHTTP, WinHTTPRequest,
//!   Msxml2.ServerXMLHTTP calls for payload downloading
//! - **WMI abuse detection**: Identifies Win32_Process.Create, ExecQuery for
//!   process execution and system enumeration
//! - **Registry manipulation**: Detects RegWrite, RegRead, RegDelete for persistence
//! - **XLM (Excel 4.0) macro detection**: Identifies legacy EXEC, CALL, RUN
//!   functions in named ranges and hidden sheets
//! - **Sandbox evasion**: Detects Application.Wait, Timer checks, mouse movement
//!   checks, and environment fingerprinting
//! - **DDE exploitation**: Identifies Dynamic Data Exchange formulas in documents
//! - **Stomped macros**: Detects VBA stomping (p-code vs source mismatch)
//! - **Template injection**: Identifies remote template URLs in document relationships
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) macro analysis history
//! - **#2  TieredCache** — Hot cache for recent macro analyses
//! - **#3  ReversibleComputation** — Recompute macro risk scores
//! - **#5  StreamAccumulator** — Streaming analysis rate
//! - **#6  MemoryMetrics** — Bounded memory for analysis data
//! - **#461 DifferentialStore** — Track macro variant diffs
//! - **#569 PruningMap** — Auto-expire old analysis events
//! - **#592 DedupStore** — Deduplicate identical macro hashes
//! - **#627 SparseMatrix** — Document × technique frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1059.005 — Command and Scripting Interpreter: Visual Basic
//! - T1137 — Office Application Startup
//! - T1204.002 — User Execution: Malicious File
//! - T1221 — Template Injection
//! - T1047 — Windows Management Instrumentation

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const MACRO_CACHE_MAX: usize = 8_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 20 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────

/// Minimum Chr() calls to flag obfuscation
const MIN_CHR_CALLS_OBFUSCATION: usize = 5;
/// Minimum string concatenation (&) per line for obfuscation
const MIN_CONCAT_PER_LINE: usize = 8;
/// Maximum macro code size before flagging (bytes)
const MAX_MACRO_CODE_SIZE: usize = 500_000;
/// Entropy threshold for encrypted/encoded macro content
const MACRO_ENTROPY_THRESHOLD: f64 = 6.5;
/// OLE compound document magic
const OLE_MAGIC: &[u8] = &[0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];
/// VBA project stream identifier
const VBA_PROJECT_STREAM: &str = "_VBA_PROJECT";
/// Attribute VB_Name pattern
const VB_ATTRIBUTE_NAME: &str = "Attribute VB_Name";

/// Auto-execute macro triggers: (name, risk, description)
const AUTO_EXEC_TRIGGERS: &[(&str, f64, &str)] = &[
    ("AutoOpen",          0.85, "Word AutoOpen — runs on document open"),
    ("AutoClose",         0.75, "Word AutoClose — runs on document close"),
    ("AutoExec",          0.85, "Word AutoExec — runs on startup"),
    ("AutoExit",          0.70, "Word AutoExit — runs on exit"),
    ("AutoNew",           0.60, "Word AutoNew — runs on new document"),
    ("Document_Open",     0.85, "Word Document_Open event"),
    ("Document_Close",    0.70, "Word Document_Close event"),
    ("DocumentBeforeSave",0.60, "Word DocumentBeforeSave event"),
    ("Workbook_Open",     0.85, "Excel Workbook_Open event"),
    ("Workbook_Activate", 0.70, "Excel Workbook_Activate event"),
    ("Workbook_BeforeClose",0.65,"Excel Workbook_BeforeClose event"),
    ("Auto_Open",         0.85, "Excel Auto_Open — legacy macro"),
    ("Auto_Close",        0.70, "Excel Auto_Close — legacy macro"),
    ("Worksheet_Change",  0.50, "Excel Worksheet_Change event"),
    ("Worksheet_Activate",0.45, "Excel Worksheet_Activate event"),
    ("UserForm_Initialize",0.55,"VBA UserForm initialization"),
    ("Class_Initialize",  0.50, "VBA Class initialization"),
    ("Presentation_Open", 0.80, "PowerPoint Presentation_Open event"),
    ("Slide_Show_Begin",  0.60, "PowerPoint SlideShow begin"),
];

/// Dangerous VBA functions and objects: (pattern, risk, description, mitre)
const DANGEROUS_VBA_PATTERNS: &[(&str, f64, &str, &str)] = &[
    ("Shell(",            0.90, "VBA Shell — OS command execution",       "T1059.005"),
    ("Shell ",            0.85, "VBA Shell statement",                    "T1059.005"),
    ("CreateObject(",     0.70, "VBA CreateObject — COM instantiation",   "T1559.001"),
    ("GetObject(",        0.65, "VBA GetObject — COM binding",            "T1559.001"),
    ("WScript.Shell",     0.95, "Windows Script Host shell",              "T1059.005"),
    ("Scripting.FileSystemObject", 0.75, "File system access object",    "T1059.005"),
    ("Process.Start",     0.90, "Process.Start — command execution",      "T1059.005"),
    ("Win32_Process",     0.90, "WMI process creation",                   "T1047"),
    ("ExecQuery",         0.70, "WMI query execution",                    "T1047"),
    ("powershell",        0.90, "PowerShell invocation from macro",       "T1059.001"),
    ("cmd.exe",           0.80, "Command prompt invocation",              "T1059.003"),
    ("cmd /c",            0.85, "Command with /c flag",                   "T1059.003"),
    ("URLDownloadToFile", 0.95, "URL download to file — payload dropper", "T1105"),
    ("XMLHTTP",           0.80, "XMLHTTP — network request",              "T1071.001"),
    ("WinHTTPRequest",    0.80, "WinHTTP request — network access",       "T1071.001"),
    ("ServerXMLHTTP",     0.85, "Server XMLHTTP — network request",       "T1071.001"),
    ("ADODB.Stream",      0.75, "ADODB binary stream — file operations",  "T1105"),
    ("Environ(",          0.50, "Environment variable access",            "T1082"),
    ("RegWrite",          0.75, "Registry write — persistence",           "T1547.001"),
    ("RegRead",           0.50, "Registry read — enumeration",            "T1012"),
    ("RegDelete",         0.65, "Registry delete",                        "T1112"),
    ("CallByName(",       0.70, "Dynamic function call by name",          "T1059.005"),
    ("Lib \"kernel32\"",  0.80, "Kernel32 API declaration",               "T1106"),
    ("Lib \"user32\"",    0.70, "User32 API declaration",                 "T1106"),
    ("Lib \"urlmon\"",    0.85, "URLMon API (download)",                  "T1105"),
    ("VirtualAlloc",      0.90, "Virtual memory allocation — shellcode",  "T1055"),
    ("RtlMoveMemory",     0.85, "Memory copy — shellcode injection",      "T1055"),
    ("WriteProcessMemory",0.95, "Process memory write — injection",       "T1055"),
    ("CreateThread",      0.85, "Thread creation — shellcode execution",  "T1055"),
    ("NtCreateThread",    0.90, "NT thread creation — injection",         "T1055"),
];

/// VBA obfuscation indicators
const OBFUSCATION_PATTERNS: &[(&str, f64, &str)] = &[
    ("Chr(",           0.50, "Character construction — obfuscation"),
    ("ChrW(",          0.55, "Wide character construction"),
    ("ChrB(",          0.55, "Byte character construction"),
    ("StrReverse(",    0.70, "String reversal — obfuscation"),
    ("Replace(",       0.30, "String replacement (may be obfuscation)"),
    ("Mid(",           0.20, "String mid extraction"),
    ("Join(",          0.25, "Array join (may reconstruct strings)"),
    ("Split(",         0.25, "String split"),
    ("Hex$(",          0.45, "Hex conversion"),
    ("Oct$(",          0.45, "Octal conversion"),
    ("CLng(",          0.30, "Type conversion"),
    ("CByte(",         0.30, "Byte conversion"),
    ("Xor",            0.40, "XOR operation — possible decryption"),
];

/// Sandbox evasion patterns
const SANDBOX_EVASION: &[(&str, f64, &str)] = &[
    ("Application.Wait",    0.70, "Timer delay — sandbox evasion"),
    ("Sleep",               0.50, "Sleep — delay execution"),
    ("Timer",               0.40, "Timer check"),
    ("GetCursorPos",        0.65, "Mouse position check — VM detection"),
    ("GetAsyncKeyState",    0.60, "Keyboard state — user interaction check"),
    ("CountA(",             0.30, "Cell count (may check for data)"),
    ("Application.UserName",0.55, "Username check — environment fingerprint"),
    ("Application.Name",    0.50, "Application name check"),
    ("Environ(\"COMPUTERNAME\")", 0.60, "Computer name check"),
    ("Environ(\"USERNAME\")",     0.55, "Username env check"),
    ("Application.RecentFiles",   0.50, "Recent files — sandbox detection"),
    ("Application.Documents.Count",0.45, "Document count check"),
];

/// DDE (Dynamic Data Exchange) exploit patterns
const DDE_PATTERNS: &[(&str, f64, &str)] = &[
    ("DDE(",               0.90, "DDE function call — command execution"),
    ("DDEAUTO(",            0.95, "DDE auto-execute — runs without prompt"),
    ("{DDEAUTO",            0.95, "DDE auto field code"),
    ("{DDE ",               0.85, "DDE field code in document"),
    ("\"cmd\"",           0.90, "DDE with cmd.exe reference"),
    ("\"powershell\"",   0.95, "DDE with PowerShell reference"),
    ("\"mshta\"",        0.95, "DDE with mshta reference"),
    ("\"certutil\"",     0.85, "DDE with certutil reference"),
];

/// Template injection URL patterns
const TEMPLATE_INJECTION_PATTERNS: &[(&str, f64, &str)] = &[
    ("http://",              0.70, "HTTP template URL — insecure remote template"),
    ("https://",             0.60, "HTTPS template URL — remote template"),
    ("ftp://",               0.80, "FTP template URL — legacy protocol"),
    ("\\\\\\\\.",    0.75, "UNC path template — file share"),
    (".dotm",                0.65, "Macro-enabled template reference"),
    (".doc?",                0.50, "Dynamic document template"),
    ("raw.githubusercontent",0.85, "GitHub raw URL — payload hosting"),
    ("pastebin.com",         0.80, "Pastebin URL — payload hosting"),
    ("bit.ly",               0.75, "URL shortener — obfuscated destination"),
];

/// VBA stomping indicators (p-code vs source mismatch)
const VBA_STOMPING_INDICATORS: &[(&str, f64, &str)] = &[
    ("_VBA_PROJECT",          0.40, "VBA project stream present"),
    ("dir",                   0.30, "VBA dir stream"),
    ("MODULE",                0.25, "Module stream reference"),
    ("ThisDocument",          0.20, "ThisDocument module"),
    ("NewMacros",             0.20, "NewMacros module"),
];

/// Known macro malware family indicators
const KNOWN_MALWARE_FAMILIES: &[(&str, f64, &str)] = &[
    ("emotet",       0.95, "Emotet — banking trojan dropper"),
    ("trickbot",     0.95, "TrickBot — modular trojan dropper"),
    ("dridex",       0.95, "Dridex — banking trojan dropper"),
    ("hancitor",     0.90, "Hancitor — MaaS dropper"),
    ("qakbot",       0.95, "QakBot — banking trojan via macro"),
    ("icedid",       0.90, "IcedID — banking trojan dropper"),
    ("ursnif",       0.90, "Ursnif/Gozi — banking trojan"),
    ("zloader",      0.90, "ZLoader — banking trojan"),
    ("bazaloader",   0.90, "BazaLoader — backdoor dropper"),
    ("agent_tesla",  0.90, "Agent Tesla — info stealer"),
    ("formbook",     0.85, "FormBook — form grabber"),
    ("lokibot",      0.85, "LokiBot — credential stealer"),
];

/// Suspicious VBA string patterns (base64, hex encoding)
const SUSPICIOUS_STRING_PATTERNS: &[(&str, f64, &str)] = &[
    ("TVqQAAMAAAA",     0.95, "Base64-encoded MZ header (PE executable)"),
    ("AAAAAAAAAA",      0.40, "Repeated A's — possible NOP sled in base64"),
    ("4d5a",            0.85, "Hex-encoded MZ header"),
    ("0x4d, 0x5a",      0.85, "Byte array MZ header"),
    ("powershell -e",   0.90, "PowerShell encoded command"),
    ("FromBase64String",0.80, "Base64 decode in VBA"),
    ("Convert.FromBase64",0.80, ".NET base64 decode via VBA"),
    ("MSXML2.DOMDocument",0.65, "XML DOM for base64 decode"),
    ("transformNode",   0.70, "XSLT transform — code execution"),
];

/// XLM (Excel 4.0) macro functions
const XLM_FUNCTIONS: &[(&str, f64, &str)] = &[
    ("=EXEC(",      0.95, "XLM EXEC — command execution"),
    ("=CALL(",      0.80, "XLM CALL — function call"),
    ("=RUN(",       0.85, "XLM RUN — macro execution"),
    ("=HALT(",      0.40, "XLM HALT — execution stop"),
    ("=REGISTER(",  0.75, "XLM REGISTER — DLL function registration"),
    ("=FOPEN(",     0.65, "XLM FOPEN — file open"),
    ("=FWRITE(",    0.70, "XLM FWRITE — file write"),
    ("=CHAR(",      0.40, "XLM CHAR — character conversion"),
    ("=FORMULA(",   0.50, "XLM FORMULA — cell formula injection"),
    ("=GET.WORKSPACE(",0.60,"XLM GET.WORKSPACE — environment check"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum MacroThreatType {
    AutoExecTrigger, ShellExecution, NetworkDownload, WMIAbuse,
    RegistryManipulation, ProcessInjection, APICall, Obfuscation,
    SandboxEvasion, XLMMacro, DDE, TemplateInjection, VBAStomping,
    EnvironmentFingerprint,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MacroAnalysisResult {
    pub id: String,
    pub timestamp: i64,
    pub file_path: String,
    pub file_hash: String,
    pub severity: Severity,
    pub confidence: f64,
    pub threat_types: Vec<MacroThreatType>,
    pub auto_exec_triggers: Vec<String>,
    pub dangerous_functions: Vec<String>,
    pub obfuscation_layers: u32,
    pub sandbox_evasion_techniques: Vec<String>,
    pub xlm_functions: Vec<String>,
    pub network_indicators: Vec<String>,
    pub api_declarations: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct MacroStats {
    pub documents_analyzed: u64,
    pub threats_detected: u64,
    pub auto_exec_found: u64,
    pub shell_executions: u64,
    pub network_downloads: u64,
    pub wmi_abuse: u64,
    pub registry_ops: u64,
    pub process_injections: u64,
    pub obfuscated_macros: u64,
    pub sandbox_evasion: u64,
    pub xlm_macros: u64,
    pub dde_exploits: u64,
    pub template_injections: u64,
    pub vba_stomping: u64,
    pub known_families: u64,
    pub suspicious_strings: u64,
    pub blocked_documents: u64,
    pub safe_documents: u64,
    pub total_bytes_analyzed: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MacroAnalyzerConfig {
    pub block_auto_exec: bool,
    pub block_shell_execution: bool,
    pub block_network_access: bool,
    pub block_process_injection: bool,
    pub scan_xlm_macros: bool,
    pub scan_dde: bool,
    pub scan_template_injection: bool,
    pub detect_vba_stomping: bool,
    pub max_macro_size: usize,
    pub entropy_threshold: f64,
    pub block_on_high_severity: bool,
}

impl MacroAnalyzerConfig {
    pub fn default_config() -> Self {
        Self {
            block_auto_exec: true,
            block_shell_execution: true,
            block_network_access: true,
            block_process_injection: true,
            scan_xlm_macros: true,
            scan_dde: true,
            scan_template_injection: true,
            detect_vba_stomping: true,
            max_macro_size: MAX_MACRO_CODE_SIZE,
            entropy_threshold: MACRO_ENTROPY_THRESHOLD,
            block_on_high_severity: true,
        }
    }
}

pub struct MacroAnalyzer {
    // Breakthrough #1: HierarchicalState — O(log n) analysis history rollup
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<MacroStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold analysis cache
    event_cache: TieredCache<String, MacroAnalysisResult>,
    // Breakthrough #3: ReversibleComputation — recompute risk on demand
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed analysis rate
    event_rate: RwLock<StreamAccumulator<f64, MacroStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory verification
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — macro variant diffs
    variant_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted priority eviction
    recent_events: RwLock<PruningMap<String, MacroAnalysisResult>>,
    // Breakthrough #592: DedupStore — BLAKE3 content dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — document × technique matrix
    doc_technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<MacroAnalyzerConfig>,
    stats: RwLock<MacroStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl MacroAnalyzer {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(MACRO_CACHE_MAX)
            .with_metrics(metrics.clone(), "macro_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, MacroStats::default(),
            |acc: &mut MacroStats, rates: &[f64]| {
                for &r in rates { acc.documents_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            variant_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(MACRO_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            doc_technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(MacroAnalyzerConfig::default_config()),
            stats: RwLock::new(MacroStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("macro_analyzer", MEMORY_BUDGET / 2);
        info!("MacroAnalyzer started — {} auto-exec, {} dangerous, {} obfuscation, {} XLM patterns",
            AUTO_EXEC_TRIGGERS.len(), DANGEROUS_VBA_PATTERNS.len(),
            OBFUSCATION_PATTERNS.len(), XLM_FUNCTIONS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("MacroAnalyzer stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Analyze VBA/XLM macro code extracted from a document.
    pub fn analyze_macro(
        &self, file_path: &str, macro_code: &str, file_hash: &str,
    ) -> MacroAnalysisResult {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().documents_analyzed += 1;

        let code_lower = macro_code.to_lowercase();
        let mut threat_types = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut auto_exec = Vec::new();
        let mut dangerous_funcs = Vec::new();
        let mut sandbox_evade = Vec::new();
        let mut xlm_funcs = Vec::new();
        let mut network_inds = Vec::new();
        let mut api_decls = Vec::new();
        let mut obfuscation_layers = 0u32;
        let mut max_risk: f64 = 0.0;

        // ── 1. Auto-execute triggers ──
        for &(trigger, risk, desc) in AUTO_EXEC_TRIGGERS {
            if macro_code.contains(trigger) {
                auto_exec.push(trigger.to_string());
                indicators.push(format!("Auto-exec: {} — {}", trigger, desc));
                threat_types.push(MacroThreatType::AutoExecTrigger);
                max_risk = max_risk.max(risk);
            }
        }
        if !auto_exec.is_empty() {
            self.stats.write().auto_exec_found += 1;
            mitre_techniques.push("T1137".to_string());
        }

        // ── 2. Dangerous VBA functions ──
        for &(pattern, risk, desc, mitre) in DANGEROUS_VBA_PATTERNS {
            if code_lower.contains(&pattern.to_lowercase()) {
                dangerous_funcs.push(pattern.to_string());
                indicators.push(format!("Dangerous: {} — {}", pattern, desc));
                max_risk = max_risk.max(risk);

                if !mitre_techniques.contains(&mitre.to_string()) {
                    mitre_techniques.push(mitre.to_string());
                }

                if pattern.contains("Shell") || pattern.contains("cmd") || pattern.contains("powershell") {
                    threat_types.push(MacroThreatType::ShellExecution);
                    self.stats.write().shell_executions += 1;
                }
                if pattern.contains("URL") || pattern.contains("HTTP") || pattern.contains("XMLHTTP") {
                    threat_types.push(MacroThreatType::NetworkDownload);
                    network_inds.push(pattern.to_string());
                    self.stats.write().network_downloads += 1;
                }
                if pattern.contains("Win32_Process") || pattern.contains("ExecQuery") {
                    threat_types.push(MacroThreatType::WMIAbuse);
                    self.stats.write().wmi_abuse += 1;
                }
                if pattern.contains("Reg") {
                    threat_types.push(MacroThreatType::RegistryManipulation);
                    self.stats.write().registry_ops += 1;
                }
                if pattern.contains("VirtualAlloc") || pattern.contains("WriteProcess") || pattern.contains("CreateThread") {
                    threat_types.push(MacroThreatType::ProcessInjection);
                    self.stats.write().process_injections += 1;
                }
                if pattern.contains("Lib \"") {
                    threat_types.push(MacroThreatType::APICall);
                    api_decls.push(pattern.to_string());
                }
            }
        }

        // ── 3. Obfuscation analysis ──
        for &(pattern, risk, desc) in OBFUSCATION_PATTERNS {
            let count = code_lower.matches(&pattern.to_lowercase()).count();
            if count > 3 {
                obfuscation_layers += 1;
                indicators.push(format!("Obfuscation: {} × {} — {}", pattern, count, desc));
                max_risk = max_risk.max(risk);
            }
        }
        if obfuscation_layers >= 2 {
            threat_types.push(MacroThreatType::Obfuscation);
            self.stats.write().obfuscated_macros += 1;
        }

        // ── 4. Sandbox evasion ──
        for &(pattern, risk, desc) in SANDBOX_EVASION {
            if code_lower.contains(&pattern.to_lowercase()) {
                sandbox_evade.push(desc.to_string());
                indicators.push(format!("Sandbox evasion: {} — {}", pattern, desc));
                threat_types.push(MacroThreatType::SandboxEvasion);
                max_risk = max_risk.max(risk);
            }
        }
        if !sandbox_evade.is_empty() {
            self.stats.write().sandbox_evasion += 1;
        }

        // ── 5. XLM (Excel 4.0) macros ──
        let config = self.config.read().clone();
        if config.scan_xlm_macros {
            for &(func, risk, desc) in XLM_FUNCTIONS {
                if macro_code.contains(func) {
                    xlm_funcs.push(func.to_string());
                    indicators.push(format!("XLM: {} — {}", func, desc));
                    threat_types.push(MacroThreatType::XLMMacro);
                    max_risk = max_risk.max(risk);
                }
            }
            if !xlm_funcs.is_empty() {
                self.stats.write().xlm_macros += 1;
            }
        }

        // ── 6. DDE exploit detection ──
        if config.scan_dde {
            let mut dde_found = false;
            for &(pattern, risk, desc) in DDE_PATTERNS {
                if code_lower.contains(&pattern.to_lowercase()) {
                    indicators.push(format!("DDE exploit: {} — {}", pattern, desc));
                    threat_types.push(MacroThreatType::DDE);
                    max_risk = max_risk.max(risk);
                    dde_found = true;
                }
            }
            if dde_found {
                self.stats.write().dde_exploits += 1;
                mitre_techniques.push("T1559.002".to_string());
            }
        }

        // ── 7. Template injection detection ──
        if config.scan_template_injection {
            let mut template_found = false;
            for &(pattern, risk, desc) in TEMPLATE_INJECTION_PATTERNS {
                if code_lower.contains(&pattern.to_lowercase()) {
                    indicators.push(format!("Template injection: {} — {}", pattern, desc));
                    max_risk = max_risk.max(risk);
                    template_found = true;
                }
            }
            if template_found {
                threat_types.push(MacroThreatType::TemplateInjection);
                self.stats.write().template_injections += 1;
                mitre_techniques.push("T1221".to_string());
            }
        }

        // ── 8. Known malware family indicators ──
        for &(family, risk, desc) in KNOWN_MALWARE_FAMILIES {
            if code_lower.contains(family) {
                indicators.push(format!("Known malware family: {} — {}", family, desc));
                max_risk = max_risk.max(risk);
                self.stats.write().known_families += 1;
            }
        }

        // ── 9. Suspicious string patterns (base64/hex encoded payloads) ──
        for &(pattern, risk, desc) in SUSPICIOUS_STRING_PATTERNS {
            if code_lower.contains(&pattern.to_lowercase()) {
                indicators.push(format!("Suspicious string: {} — {}", pattern, desc));
                max_risk = max_risk.max(risk);
                self.stats.write().suspicious_strings += 1;
            }
        }

        // ── 10. Macro code entropy analysis ──
        let macro_entropy = Self::shannon_entropy(macro_code.as_bytes());
        if macro_entropy > config.entropy_threshold {
            indicators.push(format!(
                "High macro entropy: {:.3} bits/byte — encrypted or heavily obfuscated",
                macro_entropy));
            obfuscation_layers += 1;
            max_risk = max_risk.max(0.60);
        }

        // ── 11. Code size analysis ──
        if macro_code.len() > config.max_macro_size {
            indicators.push(format!(
                "Oversized macro: {} KB (limit {} KB)",
                macro_code.len() / 1024, config.max_macro_size / 1024));
            max_risk = max_risk.max(0.35);
        }

        // ── 12. String concatenation density analysis ──
        let concat_count = macro_code.matches(" & ").count() + macro_code.matches("& \"").count();
        let chr_count = code_lower.matches("chr(").count() + code_lower.matches("chrw(").count();
        if chr_count >= MIN_CHR_CALLS_OBFUSCATION {
            indicators.push(format!(
                "Heavy Chr() usage: {} calls — string construction obfuscation", chr_count));
            obfuscation_layers += 1;
            max_risk = max_risk.max(0.65);
        }
        if concat_count > 20 {
            indicators.push(format!(
                "Heavy concatenation: {} '&' operators — string reassembly", concat_count));
            obfuscation_layers += 1;
            max_risk = max_risk.max(0.55);
        }

        // ── 13. VBA stomping detection ──
        if config.detect_vba_stomping {
            let has_vba_project = code_lower.contains("_vba_project");
            let has_source = code_lower.contains("attribute vb_name");
            if has_vba_project && !has_source {
                indicators.push("VBA stomping suspected: p-code present but no source code".to_string());
                threat_types.push(MacroThreatType::VBAStomping);
                self.stats.write().vba_stomping += 1;
                max_risk = max_risk.max(0.80);
            }
        }

        // ── 14. Environment fingerprinting analysis ──
        let env_checks: usize = SANDBOX_EVASION.iter()
            .filter(|(p, _, _)| code_lower.contains(&p.to_lowercase()))
            .count();
        if env_checks >= 3 {
            indicators.push(format!(
                "Heavy environment fingerprinting: {} checks — likely sandbox evasion",
                env_checks));
            threat_types.push(MacroThreatType::EnvironmentFingerprint);
            max_risk = max_risk.max(0.75);
        }

        // ── Finalize ──
        threat_types.sort();
        threat_types.dedup();
        if !threat_types.is_empty() && mitre_techniques.is_empty() {
            mitre_techniques.push("T1059.005".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        self.stats.write().total_bytes_analyzed += macro_code.len() as u64;

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.55 + threat_types.len() as f64 * 0.05
            + auto_exec.len() as f64 * 0.04
            + obfuscation_layers as f64 * 0.03).min(0.99);
        let blocked = config.block_on_high_severity
            && matches!(severity, Severity::Critical | Severity::High)
            && !auto_exec.is_empty();

        if threat_types.is_empty() { self.stats.write().safe_documents += 1; }
        else { self.stats.write().threats_detected += 1; }
        if blocked { self.stats.write().blocked_documents += 1; }

        // Breakthrough #627: SparseMatrix
        for tt in &threat_types {
            let c = *self.doc_technique_matrix.read()
                .get(&file_path.to_string(), &format!("{:?}", tt));
            self.doc_technique_matrix.write()
                .set(file_path.to_string(), format!("{:?}", tt), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let result = MacroAnalysisResult {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, file_path: file_path.to_string(),
            file_hash: file_hash.to_string(),
            severity, confidence, threat_types, auto_exec_triggers: auto_exec,
            dangerous_functions: dangerous_funcs, obfuscation_layers,
            sandbox_evasion_techniques: sandbox_evade, xlm_functions: xlm_funcs,
            network_indicators: network_inds, api_declarations: api_decls,
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(result.id.clone(), result.clone());
        self.recent_events.write().insert_with_priority(result.id.clone(), result.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.doc_technique_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.variant_diffs.write().record_insert(
            result.id.clone(),
            format!("{:?}", result),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            result.id.clone(),
            format!("{:?}", result).into_bytes(),
        );
        if blocked { warn!("MACRO MALWARE BLOCKED: {} — {:?} (confidence {:.2})", file_path, result.threat_types, confidence); }
        result
    }

    /// Shannon entropy for macro code analysis
    fn shannon_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        let mut entropy = 0.0f64;
        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }
        entropy
    }

    /// Count obfuscation layers based on pattern density analysis
    fn count_obfuscation_layers(code: &str) -> u32 {
        let code_lower = code.to_lowercase();
        let mut layers = 0u32;
        let chr_count = code_lower.matches("chr(").count();
        let strrev_count = code_lower.matches("strreverse(").count();
        let replace_count = code_lower.matches("replace(").count();
        let concat_count = code.matches(" & ").count();
        let xor_count = code_lower.matches(" xor ").count();
        if chr_count >= MIN_CHR_CALLS_OBFUSCATION { layers += 1; }
        if strrev_count >= 2 { layers += 1; }
        if replace_count >= 5 { layers += 1; }
        if concat_count >= 15 { layers += 1; }
        if xor_count >= 3 { layers += 1; }
        layers
    }

    /// Extract VBA module names from macro code
    fn extract_module_names(code: &str) -> Vec<String> {
        let mut modules = Vec::new();
        for line in code.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("Attribute VB_Name") {
                if let Some(start) = trimmed.find('"') {
                    if let Some(end) = trimmed[start + 1..].find('"') {
                        modules.push(trimmed[start + 1..start + 1 + end].to_string());
                    }
                }
            }
        }
        modules
    }

    /// Check if macro contains network download capability
    fn has_network_capability(code: &str) -> bool {
        let code_lower = code.to_lowercase();
        let net_patterns = ["urldownloadtofile", "xmlhttp", "winhttprequest",
            "serverxmlhttp", "adodb.stream", "inet", "msxml2",
            "winhttp.winhttprequest", "downloadstring", "webclient"];
        net_patterns.iter().any(|p| code_lower.contains(p))
    }

    /// Check if macro contains process execution capability
    fn has_exec_capability(code: &str) -> bool {
        let code_lower = code.to_lowercase();
        let exec_patterns = ["shell(", "shell ", "wscript.shell",
            "process.start", "win32_process", "createprocess",
            "shellexecute", "cmd.exe", "powershell"];
        exec_patterns.iter().any(|p| code_lower.contains(p))
    }

    /// Determine if macro is a dropper (downloads + executes)
    pub fn is_dropper(&self, code: &str) -> bool {
        Self::has_network_capability(code) && Self::has_exec_capability(code)
    }

    pub fn update_config(&self, config: MacroAnalyzerConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> MacroStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
