//! Module 93: DataExfiltrationMonitor — Data Theft & Exfiltration Detection
//!
//! World-class detection engine for data exfiltration across network, physical, and
//! covert channels. Monitors outbound traffic patterns, USB transfers, cloud uploads,
//! DNS tunneling, steganographic channels, and encrypted exfiltration for unauthorized
//! data movement out of the protected environment.
//!
//! ## Features
//!
//! - **Volume anomaly detection**: Identifies unusual outbound data volumes per
//!   destination, time window, and user compared to baseline behavior
//! - **Cloud storage exfiltration**: Monitors uploads to Dropbox, Google Drive,
//!   OneDrive, iCloud, Box, Mega, WeTransfer, and file sharing services
//! - **Email exfiltration**: Detects large attachments, unusual recipient patterns,
//!   personal email forwarding of corporate data
//! - **DNS exfiltration**: Identifies encoded data in DNS query labels (TXT, CNAME,
//!   MX records) exceeding normal query entropy and length
//! - **ICMP tunneling**: Detects data encoded in ICMP echo request/reply payloads
//!   exceeding standard ping packet sizes
//! - **Encrypted channel analysis**: Monitors TLS sessions for unusual certificate
//!   patterns, session duration, and data volume ratios
//! - **USB/removable media**: Detects large file copies to USB drives, external
//!   disks, and MTP devices
//! - **Print exfiltration**: Monitors print jobs for sensitive document keywords
//!   and unusual print volume patterns
//! - **Screenshot/clipboard exfiltration**: Detects clipboard data or screenshots
//!   being sent to external services
//! - **Staging detection**: Identifies data collection and compression (ZIP, RAR,
//!   7z) in temporary directories before transfer
//! - **Protocol abuse**: Detects data hidden in HTTP headers, WebSocket frames,
//!   and legitimate protocol fields
//! - **Slow drip exfiltration**: Identifies low-and-slow data transfer patterns
//!   that evade volume-based detection
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) exfiltration event history
//! - **#2  TieredCache** — Hot cache for recent exfiltration detections
//! - **#3  ReversibleComputation** — Recompute exfiltration risk scores
//! - **#5  StreamAccumulator** — Streaming data volume rate
//! - **#6  MemoryMetrics** — Bounded memory for monitoring data
//! - **#461 DifferentialStore** — Track traffic baseline diffs
//! - **#569 PruningMap** — Auto-expire old exfiltration events
//! - **#592 DedupStore** — Deduplicate identical exfiltration alerts
//! - **#627 SparseMatrix** — Source × destination data volume matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1041 — Exfiltration Over C2 Channel
//! - T1048 — Exfiltration Over Alternative Protocol
//! - T1048.001 — Exfiltration Over Symmetric Encrypted Non-C2 Protocol
//! - T1048.003 — Exfiltration Over Unencrypted Non-C2 Protocol
//! - T1052 — Exfiltration Over Physical Medium
//! - T1567 — Exfiltration Over Web Service
//! - T1567.002 — Exfiltration to Cloud Storage
//! - T1029 — Scheduled Transfer
//! - T1030 — Data Transfer Size Limits (slow drip)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const EXFIL_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 28 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

/// Volume threshold for single transfer alert (bytes)
const SINGLE_TRANSFER_THRESHOLD: u64 = 50 * 1024 * 1024; // 50 MB
/// Daily outbound volume threshold per user (bytes)
const DAILY_VOLUME_THRESHOLD: u64 = 500 * 1024 * 1024; // 500 MB
/// DNS query label entropy threshold for tunneling detection
const DNS_ENTROPY_THRESHOLD: f64 = 3.5;
/// Maximum normal ICMP payload size (bytes)
const MAX_NORMAL_ICMP_SIZE: u32 = 64;
/// Slow drip: minimum number of small transfers to detect pattern
const SLOW_DRIP_MIN_TRANSFERS: u32 = 20;

/// Cloud storage and file sharing services: (domain, name, risk)
const CLOUD_STORAGE_DOMAINS: &[(&str, &str, f64)] = &[
    ("dropbox.com",           "Dropbox",          0.60),
    ("dl.dropboxusercontent.com", "Dropbox Direct", 0.65),
    ("drive.google.com",      "Google Drive",     0.55),
    ("docs.google.com",       "Google Docs",      0.50),
    ("onedrive.live.com",     "OneDrive",         0.55),
    ("1drv.ms",               "OneDrive Short",   0.55),
    ("icloud.com",            "iCloud",           0.50),
    ("box.com",               "Box",              0.55),
    ("app.box.com",           "Box App",          0.55),
    ("mega.nz",               "MEGA",             0.70),
    ("mega.io",               "MEGA",             0.70),
    ("wetransfer.com",        "WeTransfer",       0.65),
    ("transfer.sh",           "Transfer.sh",      0.75),
    ("file.io",               "File.io",          0.75),
    ("sendspace.com",         "SendSpace",        0.65),
    ("mediafire.com",         "MediaFire",        0.60),
    ("anonfiles.com",         "AnonFiles",        0.85),
    ("gofile.io",             "GoFile",           0.80),
    ("catbox.moe",            "Catbox",           0.75),
    ("pastebin.com",          "Pastebin",         0.70),
    ("paste.ee",              "Paste.ee",         0.70),
    ("privatebin.net",        "PrivateBin",       0.75),
    ("0x0.st",                "0x0.st",           0.80),
    ("temp.sh",               "Temp.sh",          0.80),
    ("oshi.at",               "Oshi.at",          0.75),
    ("discord.com/api",       "Discord Webhooks", 0.65),
    ("slack.com/api",         "Slack API",        0.55),
    ("telegram.org/bot",      "Telegram Bot API", 0.70),
    ("api.github.com",        "GitHub API",       0.50),
    ("gist.github.com",       "GitHub Gist",      0.60),
];

/// Personal email services (exfiltration vector from corporate)
const PERSONAL_EMAIL_DOMAINS: &[(&str, &str)] = &[
    ("gmail.com",       "Google Gmail"),
    ("yahoo.com",       "Yahoo Mail"),
    ("outlook.com",     "Outlook.com"),
    ("hotmail.com",     "Hotmail"),
    ("protonmail.com",  "ProtonMail"),
    ("proton.me",       "Proton Mail"),
    ("tutanota.com",    "Tutanota"),
    ("mail.com",        "Mail.com"),
    ("yandex.com",      "Yandex Mail"),
    ("zoho.com",        "Zoho Mail"),
    ("aol.com",         "AOL Mail"),
    ("icloud.com",      "iCloud Mail"),
    ("gmx.com",         "GMX Mail"),
];

/// Staging indicators (pre-exfiltration data collection)
const STAGING_PATTERNS: &[(&str, f64, &str)] = &[
    (".zip",           0.40, "ZIP archive creation"),
    (".rar",           0.45, "RAR archive creation"),
    (".7z",            0.50, "7-Zip archive creation"),
    (".tar.gz",        0.45, "Tar+gzip archive creation"),
    (".tar.bz2",       0.45, "Tar+bzip2 archive creation"),
    ("password-protected", 0.65, "Password-protected archive — evasion"),
    ("/tmp/",          0.35, "Temporary directory staging"),
    ("%TEMP%",         0.35, "Windows temp directory staging"),
    ("$RECYCLE.BIN",   0.50, "Recycle bin staging — hiding"),
    (".encrypted",     0.60, "Encrypted file staging"),
];

/// Covert channel indicators
const COVERT_CHANNEL_PATTERNS: &[(&str, f64, &str)] = &[
    ("dns txt record",     0.85, "DNS TXT record exfiltration"),
    ("icmp payload",       0.80, "ICMP payload exfiltration"),
    ("ntp extension",      0.75, "NTP extension field abuse"),
    ("http header",        0.60, "HTTP header-based channel"),
    ("certificate field",  0.70, "TLS certificate field abuse"),
    ("steganography",      0.80, "Steganographic data hiding"),
    ("timing channel",     0.75, "Timing-based covert channel"),
    ("websocket",          0.50, "WebSocket data channel"),
    ("grpc stream",        0.45, "gRPC streaming channel"),
];

/// USB/removable media indicators
const USB_INDICATORS: &[(&str, f64, &str)] = &[
    ("/media/usb",         0.65, "USB mount point"),
    ("/mnt/usb",           0.65, "USB manual mount"),
    ("/Volumes/",          0.50, "macOS external volume"),
    ("E:\\",               0.55, "Windows removable drive"),
    ("F:\\",               0.55, "Windows removable drive"),
    ("G:\\",               0.55, "Windows removable drive"),
    (".usb",               0.60, "USB device reference"),
    ("removable",          0.50, "Removable media reference"),
];

/// Network protocol abuse indicators
const PROTOCOL_ABUSE_PATTERNS: &[(&str, f64, &str)] = &[
    ("dns over https",     0.70, "DNS-over-HTTPS — encrypted DNS exfil"),
    ("tor",                0.75, "Tor network — anonymous exfil"),
    ("i2p",                0.70, "I2P network — anonymous exfil"),
    ("proxy chain",        0.65, "Proxy chain — traffic obfuscation"),
    ("vpn tunnel",         0.55, "VPN tunnel — encrypted channel"),
    ("ssh tunnel",         0.60, "SSH tunnel — encrypted channel"),
    ("ngrok",              0.70, "ngrok — reverse tunnel"),
    ("cloudflared",        0.65, "Cloudflare tunnel"),
    ("tailscale",          0.50, "Tailscale VPN"),
];

/// Sensitive data keywords that trigger higher risk when found in transfer
const SENSITIVE_DATA_KEYWORDS: &[(&str, f64, &str)] = &[
    ("confidential",   0.70, "Confidential marking"),
    ("secret",         0.75, "Secret marking"),
    ("top secret",     0.90, "Top secret marking"),
    ("internal only",  0.60, "Internal distribution marking"),
    ("proprietary",    0.65, "Proprietary marking"),
    ("ssn",            0.80, "Social Security Number reference"),
    ("credit card",    0.85, "Credit card data reference"),
    ("patient",        0.70, "Healthcare patient data"),
    ("password",       0.60, "Password data"),
    ("private key",    0.85, "Cryptographic private key"),
    ("api key",        0.75, "API key reference"),
    ("source code",    0.70, "Source code reference"),
    ("trade secret",   0.85, "Trade secret reference"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum ExfilChannel {
    CloudStorage, PersonalEmail, DNSTunnel, ICMPTunnel, HTTPChannel,
    EncryptedChannel, USBMedia, PrintJob, ClipboardExfil, ProtocolAbuse,
    SlowDrip, StagingDetected, VolumeAnomaly, WebhookExfil,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ExfilEvent {
    pub id: String,
    pub timestamp: i64,
    pub severity: Severity,
    pub confidence: f64,
    pub channels: Vec<ExfilChannel>,
    pub source_process: String,
    pub source_pid: u32,
    pub source_user: String,
    pub destination: String,
    pub destination_service: Option<String>,
    pub bytes_transferred: u64,
    pub transfer_duration_secs: u64,
    pub sensitive_keywords: Vec<String>,
    pub staging_indicators: Vec<String>,
    pub file_names: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ExfilStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub cloud_storage_exfils: u64,
    pub email_exfils: u64,
    pub dns_tunnels: u64,
    pub icmp_tunnels: u64,
    pub usb_exfils: u64,
    pub volume_anomalies: u64,
    pub slow_drip_detected: u64,
    pub staging_detected: u64,
    pub sensitive_data_transfers: u64,
    pub covert_channels: u64,
    pub protocol_abuse: u64,
    pub webhook_exfils: u64,
    pub blocked_transfers: u64,
    pub total_bytes_flagged: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ExfilMonitorConfig {
    pub block_cloud_exfil: bool,
    pub block_personal_email: bool,
    pub block_sensitive_data: bool,
    pub scan_covert_channels: bool,
    pub scan_usb: bool,
    pub scan_protocol_abuse: bool,
    pub single_transfer_threshold: u64,
    pub daily_volume_threshold: u64,
    pub slow_drip_min_transfers: u32,
    pub block_on_critical: bool,
}

impl ExfilMonitorConfig {
    pub fn default_config() -> Self {
        Self {
            block_cloud_exfil: false,
            block_personal_email: false,
            block_sensitive_data: true,
            scan_covert_channels: true,
            scan_usb: true,
            scan_protocol_abuse: true,
            single_transfer_threshold: SINGLE_TRANSFER_THRESHOLD,
            daily_volume_threshold: DAILY_VOLUME_THRESHOLD,
            slow_drip_min_transfers: SLOW_DRIP_MIN_TRANSFERS,
            block_on_critical: true,
        }
    }
}

pub struct DataExfiltrationMonitor {
    // Breakthrough #1: HierarchicalState — O(log n) exfil history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<ExfilStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, ExfilEvent>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, ExfilStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — traffic pattern diffs
    traffic_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, ExfilEvent>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — source × destination matrix
    source_dest_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<ExfilMonitorConfig>,
    daily_volumes: RwLock<HashMap<String, u64>>,
    dest_transfer_history: RwLock<HashMap<String, VecDeque<(i64, u64)>>>,
    stats: RwLock<ExfilStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl DataExfiltrationMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(EXFIL_CACHE_MAX)
            .with_metrics(metrics.clone(), "exfil_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, ExfilStats::default(),
            |acc: &mut ExfilStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            traffic_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(EXFIL_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            source_dest_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(ExfilMonitorConfig::default_config()),
            daily_volumes: RwLock::new(HashMap::new()),
            dest_transfer_history: RwLock::new(HashMap::new()),
            stats: RwLock::new(ExfilStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("data_exfiltration", MEMORY_BUDGET / 2);
        info!("DataExfiltrationMonitor started — {} cloud services, {} email domains, {} staging patterns",
            CLOUD_STORAGE_DOMAINS.len(), PERSONAL_EMAIL_DOMAINS.len(), STAGING_PATTERNS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("DataExfiltrationMonitor stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    fn check_cloud_service(dest: &str) -> Option<(&'static str, f64)> {
        let dest_lower = dest.to_lowercase();
        CLOUD_STORAGE_DOMAINS.iter()
            .find(|(domain, _, _)| dest_lower.contains(domain))
            .map(|(_, name, risk)| (*name, *risk))
    }

    fn check_personal_email(dest: &str) -> Option<&'static str> {
        let dest_lower = dest.to_lowercase();
        PERSONAL_EMAIL_DOMAINS.iter()
            .find(|(domain, _)| dest_lower.contains(domain))
            .map(|(_, name)| *name)
    }

    /// Analyze an outbound data transfer for exfiltration indicators.
    pub fn analyze_transfer(
        &self, process_name: &str, pid: u32, user: &str,
        destination: &str, bytes: u64, duration_secs: u64,
        file_names: &[String], metadata: &str,
    ) -> Option<ExfilEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let mut channels = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut sensitive_kw = Vec::new();
        let mut staging_inds = Vec::new();
        let mut dest_service: Option<String> = None;
        let mut max_risk: f64 = 0.0;

        // ── 1. Cloud storage detection ──
        if let Some((name, risk)) = Self::check_cloud_service(destination) {
            dest_service = Some(name.to_string());
            indicators.push(format!("Cloud upload: {} → {} ({} bytes)", process_name, name, bytes));
            channels.push(ExfilChannel::CloudStorage);
            mitre_techniques.push("T1567.002".to_string());
            self.stats.write().cloud_storage_exfils += 1;
            max_risk = max_risk.max(risk);
        }

        // ── 2. Personal email detection ──
        if let Some(name) = Self::check_personal_email(destination) {
            indicators.push(format!("Personal email transfer: {} → {}", process_name, name));
            channels.push(ExfilChannel::PersonalEmail);
            mitre_techniques.push("T1567".to_string());
            self.stats.write().email_exfils += 1;
            max_risk = max_risk.max(0.65);
        }

        // ── 3. Volume anomaly ──
        {
            let mut volumes = self.daily_volumes.write();
            let daily = volumes.entry(user.to_string()).or_insert(0);
            *daily += bytes;
            if *daily > DAILY_VOLUME_THRESHOLD {
                indicators.push(format!("Daily volume anomaly: user '{}' transferred {} MB today",
                    user, *daily / (1024 * 1024)));
                channels.push(ExfilChannel::VolumeAnomaly);
                self.stats.write().volume_anomalies += 1;
                max_risk = max_risk.max(0.70);
            }
        }
        if bytes > SINGLE_TRANSFER_THRESHOLD {
            indicators.push(format!("Large single transfer: {} MB to '{}'",
                bytes / (1024 * 1024), destination));
            channels.push(ExfilChannel::VolumeAnomaly);
            max_risk = max_risk.max(0.60);
        }

        // ── 4. Sensitive data keyword check ──
        let meta_lower = metadata.to_lowercase();
        let files_lower: Vec<String> = file_names.iter().map(|f| f.to_lowercase()).collect();
        for &(keyword, risk, desc) in SENSITIVE_DATA_KEYWORDS {
            if meta_lower.contains(keyword) || files_lower.iter().any(|f| f.contains(keyword)) {
                sensitive_kw.push(format!("{}: {}", keyword, desc));
                max_risk = max_risk.max(risk);
            }
        }
        if !sensitive_kw.is_empty() {
            indicators.push(format!("{} sensitive keywords in transfer", sensitive_kw.len()));
            self.stats.write().sensitive_data_transfers += 1;
        }

        // ── 5. Staging detection ──
        for &(pattern, risk, desc) in STAGING_PATTERNS {
            if files_lower.iter().any(|f| f.contains(pattern)) || meta_lower.contains(pattern) {
                staging_inds.push(format!("{}: {}", pattern, desc));
                channels.push(ExfilChannel::StagingDetected);
                max_risk = max_risk.max(risk);
            }
        }
        if !staging_inds.is_empty() {
            self.stats.write().staging_detected += 1;
        }

        // ── 6. Slow drip detection ──
        {
            let mut history = self.dest_transfer_history.write();
            let entry = history.entry(destination.to_string())
                .or_insert_with(VecDeque::new);
            entry.push_back((now, bytes));
            if entry.len() > 200 { entry.pop_front(); }
            if entry.len() as u32 >= SLOW_DRIP_MIN_TRANSFERS {
                let total: u64 = entry.iter().map(|(_, b)| b).sum();
                let avg_size = total / entry.len() as u64;
                if avg_size < 100_000 && total > 10 * 1024 * 1024 {
                    indicators.push(format!("Slow drip: {} small transfers totaling {} MB to '{}'",
                        entry.len(), total / (1024 * 1024), destination));
                    channels.push(ExfilChannel::SlowDrip);
                    mitre_techniques.push("T1030".to_string());
                    self.stats.write().slow_drip_detected += 1;
                    max_risk = max_risk.max(0.75);
                }
            }
        }

        let config = self.config.read().clone();

        // ── 7. Covert channel detection ──
        if config.scan_covert_channels {
            for &(pattern, risk, desc) in COVERT_CHANNEL_PATTERNS {
                if meta_lower.contains(pattern) {
                    indicators.push(format!("Covert channel: {} — {}", pattern, desc));
                    channels.push(ExfilChannel::ProtocolAbuse);
                    self.stats.write().covert_channels += 1;
                    max_risk = max_risk.max(risk);
                }
            }
        }

        // ── 8. USB/removable media detection ──
        if config.scan_usb {
            let dest_lower = destination.to_lowercase();
            for &(indicator, risk, desc) in USB_INDICATORS {
                if dest_lower.contains(&indicator.to_lowercase()) {
                    indicators.push(format!("USB exfil: {} — {}", indicator, desc));
                    channels.push(ExfilChannel::USBMedia);
                    self.stats.write().usb_exfils += 1;
                    mitre_techniques.push("T1052.001".to_string());
                    max_risk = max_risk.max(risk);
                    break;
                }
            }
        }

        // ── 9. Protocol abuse detection ──
        if config.scan_protocol_abuse {
            for &(pattern, risk, desc) in PROTOCOL_ABUSE_PATTERNS {
                if meta_lower.contains(pattern) || destination.to_lowercase().contains(pattern) {
                    indicators.push(format!("Protocol abuse: {} — {}", pattern, desc));
                    channels.push(ExfilChannel::ProtocolAbuse);
                    self.stats.write().protocol_abuse += 1;
                    max_risk = max_risk.max(risk);
                }
            }
        }

        // ── 10. Webhook exfiltration ──
        let dest_lower = destination.to_lowercase();
        if dest_lower.contains("webhook") || dest_lower.contains("/api/") {
            let is_webhook_service = dest_lower.contains("discord") || dest_lower.contains("slack")
                || dest_lower.contains("telegram") || dest_lower.contains("teams");
            if is_webhook_service {
                indicators.push(format!("Webhook exfiltration to: {}", destination));
                channels.push(ExfilChannel::WebhookExfil);
                self.stats.write().webhook_exfils += 1;
                max_risk = max_risk.max(0.65);
            }
        }

        // ── 11. Transfer rate analysis ──
        if duration_secs > 0 {
            let rate_mbps = (bytes as f64 / duration_secs as f64) / (1024.0 * 1024.0);
            if rate_mbps > 100.0 {
                indicators.push(format!("High transfer rate: {:.1} MB/s — bulk exfiltration", rate_mbps));
                max_risk = max_risk.max(0.55);
            }
        }

        // Breakthrough #627: SparseMatrix
        let c = *self.source_dest_matrix.read()
            .get(&user.to_string(), &destination.to_string());
        self.source_dest_matrix.write()
            .set(user.to_string(), destination.to_string(), c + bytes);

        if channels.is_empty() && sensitive_kw.is_empty() { return None; }

        // ── Finalize ──
        channels.sort();
        channels.dedup();
        if !channels.is_empty() && mitre_techniques.is_empty() {
            mitre_techniques.push("T1041".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.85 { Severity::Critical }
            else if max_risk >= 0.65 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.50 + channels.len() as f64 * 0.05
            + sensitive_kw.len() as f64 * 0.04
            + staging_inds.len() as f64 * 0.03).min(0.99);
        let blocked = (config.block_sensitive_data && !sensitive_kw.is_empty()
            && matches!(severity, Severity::Critical | Severity::High))
            || (config.block_on_critical && matches!(severity, Severity::Critical));

        self.stats.write().threats_detected += 1;
        self.stats.write().total_bytes_flagged += bytes;
        if blocked { self.stats.write().blocked_transfers += 1; }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let event = ExfilEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, severity, confidence, channels,
            source_process: process_name.to_string(), source_pid: pid,
            source_user: user.to_string(), destination: destination.to_string(),
            destination_service: dest_service, bytes_transferred: bytes,
            transfer_duration_secs: duration_secs, sensitive_keywords: sensitive_kw,
            staging_indicators: staging_inds, file_names: file_names.to_vec(),
            indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.source_dest_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record traffic pattern diff
        self.traffic_diffs.write().record_insert(
            event.id.clone(),
            format!("{}:{}:{}:{:?}", process_name, destination, bytes, event.channels),
        );
        // Breakthrough #592: DedupStore — deduplicate identical exfil events
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{}:{}:{:?}", process_name, destination, event.channels).into_bytes(),
        );
        if blocked { warn!("EXFILTRATION BLOCKED: {} → {} ({} bytes, {:?})", process_name, destination, bytes, event.channels); }
        Some(event)
    }

    /// Shannon entropy for DNS label analysis
    fn shannon_entropy(data: &str) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for b in data.bytes() { freq[b as usize] += 1; }
        let len = data.len() as f64;
        let mut entropy = 0.0f64;
        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }
        entropy
    }

    /// Check if a destination is a known cloud storage service
    pub fn is_cloud_service(dest: &str) -> bool {
        Self::check_cloud_service(dest).is_some()
    }

    /// Get the user's daily transfer volume
    pub fn get_user_volume(&self, user: &str) -> u64 {
        *self.daily_volumes.read().get(user).unwrap_or(&0)
    }

    /// Reset daily volumes (call at midnight)
    pub fn reset_daily_volumes(&self) {
        self.daily_volumes.write().clear();
    }

    pub fn update_config(&self, config: ExfilMonitorConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> ExfilStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
