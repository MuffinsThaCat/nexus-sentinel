//! Module 58: ShellProfileMonitor — Shell Profile & RC File Persistence Detection
//!
//! Monitors shell profile files (.bashrc, .zshrc, .profile, .bash_profile, etc.)
//! for unauthorized modifications that establish persistence via shell initialization.
//!
//! ## Features
//!
//! - **Profile file monitoring**: Watches .bashrc, .zshrc, .profile, .bash_profile, etc.
//! - **Malicious payload detection**: Identifies reverse shells, downloaders, env hijacking
//! - **PATH manipulation**: Detects PATH prepending for binary masquerading
//! - **Alias hijacking**: Identifies malicious alias overrides (sudo, ssh, etc.)
//! - **Function injection**: Detects injected shell functions that override commands
//! - **Environment variable poisoning**: Monitors LD_PRELOAD, DYLD_INSERT_LIBRARIES
//! - **Source chain analysis**: Tracks sourced files for indirect persistence
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) detection history
//! - **#2  TieredCache** — Hot cache for recent events
//! - **#3  ReversibleComputation** — Recompute risk aggregates
//! - **#5  StreamAccumulator** — Streaming event rate
//! - **#6  MemoryMetrics** — Bounded memory
//! - **#461 DifferentialStore** — Modification state tracking
//! - **#569 PruningMap** — Auto-expire old events
//! - **#592 DedupStore** — Deduplicate modifications
//! - **#627 SparseMatrix** — Threat × file frequency
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1546.004 — Unix Shell Configuration Modification
//! - T1574.006 — Dynamic Linker Hijacking

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const PROFILE_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 32 * 1024 * 1024;

const SHELL_PROFILE_FILES: &[&str] = &[
    ".bashrc", ".bash_profile", ".bash_login", ".bash_logout",
    ".zshrc", ".zprofile", ".zshenv", ".zlogin", ".zlogout",
    ".profile", ".login", ".cshrc", ".tcshrc",
    ".config/fish/config.fish", ".config/fish/fish_variables",
];

const DANGEROUS_ENV_VARS: &[&str] = &[
    "LD_PRELOAD", "DYLD_INSERT_LIBRARIES", "DYLD_FRAMEWORK_PATH",
    "DYLD_LIBRARY_PATH", "LD_LIBRARY_PATH", "BASH_ENV",
    "ENV", "PROMPT_COMMAND", "HISTFILE", "HISTCONTROL",
];

const SUSPICIOUS_PATTERNS: &[&str] = &[
    "/dev/tcp/", "/dev/udp/", "bash -i", "nc -e", "ncat",
    "python -c", "perl -e", "ruby -e", "curl | bash", "wget -O-",
    "base64 --decode", "eval $(", "exec 5<>", "0<&196",
];

const HIJACKABLE_COMMANDS: &[&str] = &[
    "sudo", "ssh", "su", "passwd", "login", "gpg", "git",
    "docker", "kubectl", "aws", "gcloud", "az",
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ProfileThreatType {
    ReverseShell, Downloader, PathManipulation, AliasHijack,
    FunctionInjection, EnvPoisoning, SourceChainAttack,
    HistoryTampering, PromptCommandAbuse, GenericPersistence,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ProfileModEvent {
    pub id: String,
    pub timestamp: i64,
    pub threat_type: ProfileThreatType,
    pub severity: Severity,
    pub confidence: f64,
    pub file_path: String,
    pub file_name: String,
    pub modifying_process: String,
    pub modifying_pid: u32,
    pub modifying_user: String,
    pub added_content: Option<String>,
    pub indicators: Vec<String>,
    pub mitre_technique: String,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ShellProfileStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub threats_blocked: u64,
    pub reverse_shells: u64,
    pub alias_hijacks: u64,
    pub env_poisoning: u64,
    pub path_manipulations: u64,
    pub threat_types: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// ShellProfileMonitor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct ShellProfileMonitor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical history ──
    monitor_history: RwLock<HierarchicalState<ShellProfileStats>>,
    // ── Breakthrough #2: Tiered event cache ──
    event_cache: TieredCache<String, ProfileModEvent>,
    // ── Breakthrough #3: Reversible risk computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming event rate ──
    event_rate: RwLock<StreamAccumulator<f64, ShellProfileStats>>,
    // ── Breakthrough #6: Memory bounds ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Modification state tracking ──
    mod_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Pruning old events ──
    recent_events: RwLock<PruningMap<String, ProfileModEvent>>,
    // ── Breakthrough #592: Deduplicate modifications ──
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Threat × file frequency ──
    threat_file_matrix: RwLock<SparseMatrix<String, String, u64>>,

    known_hashes: RwLock<HashMap<String, String>>,
    stats: RwLock<ShellProfileStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl ShellProfileMonitor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(PROFILE_CACHE_MAX)
            .with_metrics(metrics.clone(), "shell_profile_events");
        let risk_computer = ReversibleComputation::new(512,
            |risks: &[f64]| if risks.is_empty() { 0.0 } else { risks.iter().sum::<f64>() / risks.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, ShellProfileStats::default(),
            |acc: &mut ShellProfileStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            mod_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(PROFILE_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            threat_file_matrix: RwLock::new(SparseMatrix::new(0u64)),
            known_hashes: RwLock::new(HashMap::new()),
            stats: RwLock::new(ShellProfileStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("shell_profile", MEMORY_BUDGET / 2);
        info!("ShellProfileMonitor started");
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("ShellProfileMonitor stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Check if a file path is a shell profile file.
    fn is_profile_file(path: &str) -> bool {
        let filename = path.rsplit('/').next().unwrap_or(path);
        SHELL_PROFILE_FILES.iter().any(|f| {
            let f_name = f.rsplit('/').next().unwrap_or(f);
            filename == f_name
        }) || path.contains(".config/fish/")
    }

    /// Analyze content added to a shell profile for threats.
    pub fn analyze_modification(&self, file_path: &str, added_content: &str,
        process_name: &str, pid: u32, user: &str) -> Option<ProfileModEvent>
    {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        if !Self::is_profile_file(file_path) { return None; }

        let filename = file_path.rsplit('/').next().unwrap_or(file_path).to_string();
        let content_lower = added_content.to_lowercase();
        let mut indicators = Vec::new();
        let mut threat_type = None;

        // Reverse shell detection
        for pattern in SUSPICIOUS_PATTERNS {
            if content_lower.contains(pattern) {
                indicators.push(format!("Suspicious pattern: '{}'", pattern));
                if threat_type.is_none() {
                    threat_type = Some(ProfileThreatType::ReverseShell);
                    self.stats.write().reverse_shells += 1;
                }
            }
        }

        // Alias hijacking
        for cmd in HIJACKABLE_COMMANDS {
            let alias_pattern = format!("alias {}=", cmd);
            let alias_pattern2 = format!("alias {}=", cmd);
            if content_lower.contains(&alias_pattern) || content_lower.contains(&alias_pattern2) {
                indicators.push(format!("Alias hijack of '{}' command", cmd));
                threat_type = Some(ProfileThreatType::AliasHijack);
                self.stats.write().alias_hijacks += 1;
            }
        }

        // Environment variable poisoning
        for env_var in DANGEROUS_ENV_VARS {
            if content_lower.contains(&env_var.to_lowercase()) {
                indicators.push(format!("Dangerous env var set: {}", env_var));
                if threat_type.is_none() {
                    threat_type = Some(ProfileThreatType::EnvPoisoning);
                    self.stats.write().env_poisoning += 1;
                }
            }
        }

        // PATH manipulation
        if content_lower.contains("export path=") || content_lower.contains("path=") {
            if content_lower.contains("/tmp") || content_lower.contains("/var/tmp")
                || content_lower.contains("$home/.")
            {
                indicators.push("PATH prepended with suspicious directory".into());
                if threat_type.is_none() {
                    threat_type = Some(ProfileThreatType::PathManipulation);
                    self.stats.write().path_manipulations += 1;
                }
            }
        }

        // Function injection
        if (content_lower.contains("function ") || content_lower.contains("() {"))
            && HIJACKABLE_COMMANDS.iter().any(|cmd| content_lower.contains(&format!("function {}", cmd))
                || content_lower.contains(&format!("{} ()", cmd)))
        {
            indicators.push("Shell function overriding system command".into());
            threat_type = Some(ProfileThreatType::FunctionInjection);
        }

        // History tampering
        if content_lower.contains("histfile=/dev/null") || content_lower.contains("unset histfile")
            || content_lower.contains("histcontrol=ignoreboth") || content_lower.contains("histsize=0")
        {
            indicators.push("Shell history tampering".into());
            if threat_type.is_none() {
                threat_type = Some(ProfileThreatType::HistoryTampering);
            }
        }

        // PROMPT_COMMAND abuse
        if content_lower.contains("prompt_command") {
            indicators.push("PROMPT_COMMAND modification".into());
            if threat_type.is_none() {
                threat_type = Some(ProfileThreatType::PromptCommandAbuse);
            }
        }

        if indicators.is_empty() { return None; }

        let threat_type = threat_type.unwrap_or(ProfileThreatType::GenericPersistence);
        let confidence = (0.5 + indicators.len() as f64 * 0.15).min(0.95);
        let severity = match threat_type {
            ProfileThreatType::ReverseShell => Severity::Critical,
            ProfileThreatType::EnvPoisoning | ProfileThreatType::AliasHijack => Severity::High,
            _ => Severity::Medium,
        };

        let event = ProfileModEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, threat_type, severity, confidence,
            file_path: file_path.to_string(), file_name: filename.clone(),
            modifying_process: process_name.to_string(), modifying_pid: pid,
            modifying_user: user.to_string(),
            added_content: Some(added_content.chars().take(1000).collect()),
            indicators,
            mitre_technique: "T1546.004".to_string(),
            blocked: false,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.mod_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.event_dedup.write().insert(format!("{}:{}", file_path, now / 60), vec![]);

        let type_str = format!("{:?}", threat_type);
        let current = *self.threat_file_matrix.read().get(&type_str, &filename);
        self.threat_file_matrix.write().set(type_str.clone(), filename, current + 1);

        self.stats.write().threats_detected += 1;
        *self.stats.write().threat_types.entry(type_str).or_insert(0) += 1;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.risk_computer.write().push(1.0f64);
        // Breakthrough #461: DifferentialStore — record state diff
        self.mod_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.event_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );

        warn!("Shell profile persistence: {:?} in {} by {} (pid {})",
            threat_type, file_path, process_name, pid);
        Some(event)
    }

    pub fn stats(&self) -> ShellProfileStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
