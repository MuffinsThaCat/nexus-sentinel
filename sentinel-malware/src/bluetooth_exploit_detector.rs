//! Module 135: BluetoothExploitDetector — Bluetooth/BLE Proximity Attack Detection
//!
//! Detects attacks targeting macOS Bluetooth and BLE subsystems including device
//! impersonation, KNOB attacks, BlueBorne exploits, BLE tracking, AirTag abuse,
//! and Bluetooth-based reconnaissance and data exfiltration.
//!
//! ## Detection Capabilities
//!
//! - **BlueBorne exploitation**: Remote code execution via Bluetooth stack
//!   vulnerabilities without pairing (CVE-2017-14315, CVE-2020-3848)
//! - **KNOB attack**: Key Negotiation of Bluetooth (entropy reduction to 1 byte)
//! - **BIAS attack**: Bluetooth Impersonation AttackS (authentication bypass)
//! - **BLURtooth**: Cross-transport key derivation attack
//! - **BrakTooth**: Protocol-level DoS and code execution
//! - **Device impersonation**: Spoofed Bluetooth device names/addresses to
//!   trick users into pairing with malicious devices
//! - **BLE beacon tracking**: Unauthorized BLE beacons for physical tracking
//! - **AirTag stalking detection**: Rogue AirTag/SmartTag following detection
//! - **BLE data exfiltration**: Covert data transfer via BLE advertisements
//! - **Bluetooth keyboard/mouse injection**: BadBT, KeySniffer attacks —
//!   injecting keystrokes via spoofed HID devices
//! - **Bluetooth stack crashes**: blued/bluetoothd crash analysis
//! - **Pairing abuse**: Unauthorized pairing attempts, pin brute force
//! - **Audio eavesdropping**: Unauthorized audio routing via Bluetooth
//! - **Bluetooth reconnaissance**: Device discovery scanning for targets
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1011.001 — Exfiltration Over Bluetooth
//! - T1200 — Hardware Additions
//! - T1056.001 — Keylogging (via BT keyboard injection)
//! - T1040 — Network Sniffing
//! - T1018 — Remote System Discovery
//! - T1499 — Endpoint Denial of Service
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const PAIRING_ATTEMPT_THRESHOLD: u32 = 5;
const PAIRING_WINDOW_SECS: u64 = 60;
const DISCOVERY_SCAN_THRESHOLD: u32 = 50;
const BLE_EXFIL_THRESHOLD_BYTES: u64 = 10_000;

const BLUETOOTH_CVES: &[(&str, &str, &str, f64)] = &[
    ("CVE-2017-14315", "BlueBorne: Apple BLE RCE (stack buffer overflow)", "blueborne", 0.95),
    ("CVE-2020-3848", "macOS Bluetooth memory corruption", "stack_overflow", 0.9),
    ("CVE-2020-3847", "macOS Bluetooth heap overflow", "heap_overflow", 0.9),
    ("CVE-2020-9838", "Bluetooth Classic authentication bypass", "auth_bypass", 0.85),
    ("CVE-2019-2215", "KNOB attack (key entropy reduction)", "knob", 0.9),
    ("CVE-2020-10135", "BIAS impersonation attack", "bias", 0.9),
    ("CVE-2020-15802", "BLURtooth cross-transport attack", "blurtooth", 0.85),
    ("CVE-2021-28139", "ESP32 BLE RCE (affects macOS peripherals)", "braktooth", 0.7),
    ("CVE-2022-42855", "macOS Bluetooth kernel information leak", "info_leak", 0.8),
    ("CVE-2023-27963", "AirDrop/Bluetooth device tracking", "tracking", 0.7),
    ("CVE-2023-23531", "Bluetooth Foundation framework exploit", "framework", 0.85),
];

const SUSPICIOUS_BT_DEVICE_NAMES: &[(&str, &str, f64)] = &[
    ("O.MG", "O.MG Cable (hardware implant)", 0.95),
    ("BadUSB", "BadUSB device identifier", 0.95),
    ("Flipper", "Flipper Zero device", 0.7),
    ("HackRF", "HackRF SDR device", 0.6),
    ("Ubertooth", "Ubertooth Bluetooth sniffer", 0.9),
    ("btlejack", "BtleJack BLE hijack device", 0.9),
    ("Pineapple", "WiFi Pineapple (multi-radio)", 0.7),
    ("KeySweeper", "KeySweeper wireless keyboard sniffer", 0.95),
    ("null", "Null device name (evasion)", 0.5),
    ("", "Empty device name (evasion)", 0.5),
    ("Apple Keyboard", "Spoofed Apple Keyboard name", 0.4),
    ("Magic Mouse", "Spoofed Magic Mouse name", 0.4),
    ("AirPods", "Potentially spoofed AirPods", 0.3),
];

const BT_HID_PROFILES: &[(&str, &str, f64)] = &[
    ("0x1124", "HID profile (keyboard/mouse — injection risk)", 0.6),
    ("0x1112", "Headset profile", 0.2),
    ("0x111E", "Handsfree profile", 0.2),
    ("0x110A", "A2DP Source (audio streaming)", 0.2),
    ("0x110B", "A2DP Sink (audio receive)", 0.2),
    ("0x1105", "OBEX Object Push (file transfer)", 0.5),
    ("0x1106", "OBEX File Transfer", 0.5),
    ("0x1115", "PAN User", 0.4),
    ("0x1116", "PAN NAP (network bridging)", 0.6),
    ("0x1103", "Dial-up Networking", 0.5),
    ("0x1101", "Serial Port Profile (data channel)", 0.5),
];

const MACOS_BT_PROCESSES: &[(&str, &str)] = &[
    ("blued", "Bluetooth daemon"),
    ("bluetoothd", "Bluetooth daemon (modern)"),
    ("bluetoothaudiod", "Bluetooth audio daemon"),
    ("BTLEServerAgent", "BLE server agent"),
    ("IOBluetoothUSBDFU", "Bluetooth USB DFU"),
    ("com.apple.bluetoothuserd", "Bluetooth user-space daemon"),
    ("sharingd", "Sharing daemon (Handoff/AirDrop over BT)"),
    ("rapportd", "Rapport daemon (proximity/Handoff)"),
    ("LocationMenu", "Location menu (BT location)"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum BTThreatType {
    BlueBorneExploit,
    KNOBAttack,
    BIASAttack,
    BLURtoothAttack,
    BrakToothAttack,
    DeviceImpersonation,
    HIDInjection,
    KeyboardSpoofing,
    BLETracking,
    AirTagStalking,
    BLEDataExfiltration,
    PairingBruteForce,
    UnauthorizedPairing,
    AudioEavesdropping,
    BluetoothReconnaissance,
    StackCrash,
    KnownCVEExploit,
    SuspiciousDevice,
    RogueAccessory,
    OBEXAbuse,
    NetworkBridging,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BTThreatFinding {
    pub threat_type: BTThreatType,
    pub confidence: f64,
    pub description: String,
    pub device_name: Option<String>,
    pub device_address: Option<String>,
    pub device_class: Option<String>,
    pub bt_profile: Option<String>,
    pub cve_id: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub rssi: Option<i32>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BluetoothEvent {
    pub event_type: String,          // "discover", "pair_request", "connect", "disconnect", "crash", "data_transfer", "ble_advert"
    pub device_name: Option<String>,
    pub device_address: Option<String>,
    pub device_class: Option<u32>,
    pub device_profiles: Vec<String>,
    pub rssi: Option<i32>,
    pub is_paired: bool,
    pub is_ble: bool,
    pub data_bytes_transferred: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub crash_report: Option<String>,
    pub pairing_method: Option<String>,  // "just_works", "pin", "numeric_comparison", "oob"
    pub encryption_key_size: Option<u8>,
    pub ble_service_uuids: Vec<String>,
    pub manufacturer_data: Option<Vec<u8>>,
    pub is_apple_device: bool,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BTAnalysisResult {
    pub is_threat: bool,
    pub events_analyzed: u32,
    pub findings: Vec<BTThreatFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct BTScanStats {
    pub total_events: u64,
    pub threat_detections: u64,
    pub hid_injection_detections: u64,
    pub tracking_detections: u64,
    pub exploit_detections: u64,
    pub pairing_abuse_detections: u64,
    pub crash_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BTSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

#[derive(Debug, Clone, Default)]
struct DeviceTracker {
    seen_count: u64,
    timestamps: Vec<u64>,
    pairing_attempts: u32,
    data_bytes: u64,
    rssi_values: Vec<i32>,
    names_seen: HashSet<String>,
    first_seen: u64,
    last_seen: u64,
}

pub struct BluetoothExploitDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<BTScanStats>>,
    result_cache: TieredCache<String, BTAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, BTScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, BTAnalysisResult>>,
    sig_db: PagedMemory<BTSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<BTScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    device_tracker: RwLock<HashMap<String, DeviceTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl BluetoothExploitDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, BTScanStats::default(),
                |acc: &mut BTScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(BTScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            device_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &BluetoothEvent) -> Option<BTAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let device_id = event.device_address.as_deref().unwrap_or("unknown");
        let cache_key = format!("bt:{}:{}:{}", device_id, event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // ── Update device tracker ───────────────────────────────────────
        {
            let mut tracker = self.device_tracker.write();
            let dt = tracker.entry(device_id.to_string()).or_default();
            dt.seen_count += 1;
            dt.timestamps.push(event.timestamp);
            if event.event_type == "pair_request" { dt.pairing_attempts += 1; }
            if let Some(bytes) = event.data_bytes_transferred { dt.data_bytes += bytes; }
            if let Some(rssi) = event.rssi { dt.rssi_values.push(rssi); }
            if let Some(ref name) = event.device_name { dt.names_seen.insert(name.clone()); }
            if dt.first_seen == 0 { dt.first_seen = event.timestamp; }
            dt.last_seen = event.timestamp;
            if dt.timestamps.len() > 500 { dt.timestamps.drain(..250); }
            if dt.rssi_values.len() > 200 { dt.rssi_values.drain(..100); }
        }

        // ── 1. Suspicious device name matching ──────────────────────────
        if let Some(ref name) = event.device_name {
            for &(pattern, desc, conf) in SUSPICIOUS_BT_DEVICE_NAMES {
                if name.to_lowercase().contains(&pattern.to_lowercase()) || (pattern.is_empty() && name.is_empty()) {
                    findings.push(BTThreatFinding {
                        threat_type: BTThreatType::SuspiciousDevice,
                        confidence: conf, description: format!("{}: '{}'", desc, name),
                        device_name: Some(name.clone()),
                        device_address: event.device_address.clone(),
                        device_class: event.device_class.map(|c| format!("0x{:06x}", c)),
                        bt_profile: None, cve_id: None,
                        mitre_id: "T1200".into(),
                        process_name: event.process_name.clone(),
                        rssi: event.rssi, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1200".into());
                    break;
                }
            }
        }

        // ── 2. HID profile injection detection ──────────────────────────
        for profile in &event.device_profiles {
            for &(profile_id, desc, conf) in BT_HID_PROFILES {
                if profile.contains(profile_id) {
                    let is_hid = profile_id == "0x1124";
                    if is_hid && !event.is_paired {
                        findings.push(BTThreatFinding {
                            threat_type: BTThreatType::HIDInjection,
                            confidence: (conf + 0.2).min(0.9),
                            description: format!("Unpaired HID device attempting connection: {:?}", event.device_name),
                            device_name: event.device_name.clone(),
                            device_address: event.device_address.clone(),
                            device_class: event.device_class.map(|c| format!("0x{:06x}", c)),
                            bt_profile: Some(profile.clone()), cve_id: None,
                            mitre_id: "T1056.001".into(),
                            process_name: event.process_name.clone(),
                            rssi: event.rssi, timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1056.001".into());
                    }

                    // OBEX file transfer from unknown device
                    if (profile_id == "0x1105" || profile_id == "0x1106") && !event.is_paired {
                        findings.push(BTThreatFinding {
                            threat_type: BTThreatType::OBEXAbuse,
                            confidence: conf,
                            description: format!("{} from unpaired device: {:?}", desc, event.device_name),
                            device_name: event.device_name.clone(),
                            device_address: event.device_address.clone(),
                            device_class: None, bt_profile: Some(profile.clone()),
                            cve_id: None, mitre_id: "T1105".into(),
                            process_name: event.process_name.clone(),
                            rssi: event.rssi, timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1105".into());
                    }

                    // Network bridging
                    if profile_id == "0x1116" && !event.is_paired {
                        findings.push(BTThreatFinding {
                            threat_type: BTThreatType::NetworkBridging,
                            confidence: conf,
                            description: format!("PAN NAP (network bridging) from unpaired: {:?}", event.device_name),
                            device_name: event.device_name.clone(),
                            device_address: event.device_address.clone(),
                            device_class: None, bt_profile: Some(profile.clone()),
                            cve_id: None, mitre_id: "T1040".into(),
                            process_name: event.process_name.clone(),
                            rssi: event.rssi, timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1040".into());
                    }
                }
            }
        }

        // ── 3. KNOB attack detection (weak encryption key) ─────────────
        if let Some(key_size) = event.encryption_key_size {
            if key_size <= 7 {
                let conf = if key_size == 1 { 0.95 } else if key_size <= 4 { 0.85 } else { 0.6 };
                findings.push(BTThreatFinding {
                    threat_type: BTThreatType::KNOBAttack,
                    confidence: conf,
                    description: format!("Weak encryption key: {} bytes (KNOB attack indicator)", key_size),
                    device_name: event.device_name.clone(),
                    device_address: event.device_address.clone(),
                    device_class: None, bt_profile: None,
                    cve_id: Some("CVE-2019-2215".into()),
                    mitre_id: "T1040".into(),
                    process_name: event.process_name.clone(),
                    rssi: event.rssi, timestamp: event.timestamp,
                });
                mitre_ids.insert("T1040".into());
            }
        }

        // ── 4. Pairing brute force detection ────────────────────────────
        {
            let tracker = self.device_tracker.read();
            if let Some(dt) = tracker.get(device_id) {
                let recent_pairs = dt.timestamps.iter()
                    .filter(|&&t| event.timestamp.saturating_sub(PAIRING_WINDOW_SECS) <= t)
                    .count() as u32;
                if dt.pairing_attempts >= PAIRING_ATTEMPT_THRESHOLD {
                    findings.push(BTThreatFinding {
                        threat_type: BTThreatType::PairingBruteForce,
                        confidence: (0.7 + (dt.pairing_attempts as f64 / 20.0).min(0.25)),
                        description: format!("{} pairing attempts from {}", dt.pairing_attempts, device_id),
                        device_name: event.device_name.clone(),
                        device_address: event.device_address.clone(),
                        device_class: None, bt_profile: None, cve_id: None,
                        mitre_id: "T1110".into(),
                        process_name: event.process_name.clone(),
                        rssi: event.rssi, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1110".into());
                }

                // BLE data exfiltration
                if dt.data_bytes > BLE_EXFIL_THRESHOLD_BYTES && event.is_ble && !event.is_paired {
                    findings.push(BTThreatFinding {
                        threat_type: BTThreatType::BLEDataExfiltration,
                        confidence: 0.7,
                        description: format!("{} bytes transferred via BLE to unpaired {}", dt.data_bytes, device_id),
                        device_name: event.device_name.clone(),
                        device_address: event.device_address.clone(),
                        device_class: None, bt_profile: None, cve_id: None,
                        mitre_id: "T1011.001".into(),
                        process_name: event.process_name.clone(),
                        rssi: event.rssi, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1011.001".into());
                }

                // Name change (device trying to evade)
                if dt.names_seen.len() > 2 {
                    findings.push(BTThreatFinding {
                        threat_type: BTThreatType::DeviceImpersonation,
                        confidence: 0.6,
                        description: format!("Device {} changed names {} times: {:?}",
                            device_id, dt.names_seen.len(), dt.names_seen),
                        device_name: event.device_name.clone(),
                        device_address: event.device_address.clone(),
                        device_class: None, bt_profile: None, cve_id: None,
                        mitre_id: "T1036".into(),
                        process_name: event.process_name.clone(),
                        rssi: event.rssi, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1036".into());
                }
            }
        }

        // ── 5. Bluetooth daemon crash analysis ──────────────────────────
        if event.event_type == "crash" {
            if let Some(ref proc) = event.process_name {
                let is_bt_proc = MACOS_BT_PROCESSES.iter().any(|&(p, _)| proc.contains(p));
                if is_bt_proc {
                    findings.push(BTThreatFinding {
                        threat_type: BTThreatType::StackCrash,
                        confidence: 0.75,
                        description: format!("Bluetooth daemon crash: {} (potential exploit attempt)", proc),
                        device_name: event.device_name.clone(),
                        device_address: event.device_address.clone(),
                        device_class: None, bt_profile: None, cve_id: None,
                        mitre_id: "T1499".into(),
                        process_name: Some(proc.clone()),
                        rssi: event.rssi, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1499".into());
                }
            }
        }

        // ── 6. Just Works pairing (no authentication) ───────────────────
        if event.event_type == "pair_request" {
            if let Some(ref method) = event.pairing_method {
                if method == "just_works" && !event.is_apple_device {
                    findings.push(BTThreatFinding {
                        threat_type: BTThreatType::UnauthorizedPairing,
                        confidence: 0.5,
                        description: format!("Just Works pairing (no user confirmation) from non-Apple device: {:?}", event.device_name),
                        device_name: event.device_name.clone(),
                        device_address: event.device_address.clone(),
                        device_class: None, bt_profile: None, cve_id: None,
                        mitre_id: "T1200".into(),
                        process_name: event.process_name.clone(),
                        rssi: event.rssi, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1200".into());
                }
            }
        }

        // ── 7. BLE tracking detection ───────────────────────────────────
        if event.is_ble && event.event_type == "ble_advert" {
            // Check for non-Apple BLE devices advertising persistently at close range
            if let Some(rssi) = event.rssi {
                if rssi > -50 && !event.is_apple_device { // Very close range
                    let tracker = self.device_tracker.read();
                    if let Some(dt) = tracker.get(device_id) {
                        let duration = dt.last_seen.saturating_sub(dt.first_seen);
                        if duration > 3600 && dt.seen_count > 100 { // Seen for >1 hour, frequently
                            findings.push(BTThreatFinding {
                                threat_type: BTThreatType::BLETracking,
                                confidence: 0.65,
                                description: format!("Persistent BLE device at close range for {}s, {} sightings",
                                    duration, dt.seen_count),
                                device_name: event.device_name.clone(),
                                device_address: event.device_address.clone(),
                                device_class: None, bt_profile: None, cve_id: None,
                                mitre_id: "T1018".into(),
                                process_name: event.process_name.clone(),
                                rssi: event.rssi, timestamp: event.timestamp,
                            });
                            mitre_ids.insert("T1018".into());
                        }
                    }
                }
            }
        }

        // ── Store & finalize ────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("device={},type={},ble={}", device_id, event.event_type, event.is_ble));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_threat = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = BTAnalysisResult {
            is_threat, events_analyzed: 1, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_threat {
                s.threat_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        BTThreatType::HIDInjection | BTThreatType::KeyboardSpoofing => s.hid_injection_detections += 1,
                        BTThreatType::BLETracking | BTThreatType::AirTagStalking => s.tracking_detections += 1,
                        BTThreatType::KNOBAttack | BTThreatType::BIASAttack | BTThreatType::BlueBorneExploit |
                        BTThreatType::KnownCVEExploit => s.exploit_detections += 1,
                        BTThreatType::PairingBruteForce | BTThreatType::UnauthorizedPairing => s.pairing_abuse_detections += 1,
                        BTThreatType::StackCrash => s.crash_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_threat {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "bluetooth_exploit_detector".into(),
                title: format!("BT threat: {:?} from {}", 
                    result.findings.first().map(|f| f.threat_type).unwrap_or(BTThreatType::SuspiciousDevice),
                    event.device_name.as_deref().unwrap_or(device_id)),
                details: format!("Risk: {:.1}%, {} findings, device: {} (RSSI: {:?})",
                    risk_score * 100.0, result.findings.len(), device_id, event.rssi),
                path: None,
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Turn off Bluetooth if not needed".into(),
                    "Remove unknown paired devices".into(),
                    "Set Bluetooth to non-discoverable".into(),
                    "Update macOS to latest version for BT security patches".into(),
                    "If HID injection suspected, unpair all BT keyboards/mice".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[BTThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                BTThreatType::BlueBorneExploit => 1.6,
                BTThreatType::KnownCVEExploit => 1.5,
                BTThreatType::HIDInjection | BTThreatType::KeyboardSpoofing => 1.5,
                BTThreatType::KNOBAttack | BTThreatType::BIASAttack => 1.4,
                BTThreatType::BLURtoothAttack => 1.3,
                BTThreatType::PairingBruteForce => 1.3,
                BTThreatType::BLEDataExfiltration => 1.3,
                BTThreatType::NetworkBridging => 1.2,
                BTThreatType::DeviceImpersonation => 1.1,
                BTThreatType::StackCrash => 1.1,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> BTScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
