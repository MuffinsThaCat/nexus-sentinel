//! Module 144: VirtualMemoryExploitDetector — VM Subsystem & Memory Corruption Detection
//!
//! Comprehensive detection of memory corruption exploits, virtual memory manipulation,
//! heap/stack attacks, and advanced memory-based exploitation techniques targeting
//! the macOS XNU Mach VM subsystem and userspace memory management.
//!
//! ## Detection Capabilities
//!
//! ### Heap Exploitation
//! - **Heap overflow detection**: Out-of-bounds writes to heap allocations in
//!   libmalloc zones (nano, tiny, small, large), magazine malloc, and custom
//!   allocators
//! - **Use-after-free detection**: Dangling pointer access patterns, zone
//!   poisoning bypass, quarantine escape
//! - **Double-free detection**: Duplicate free() calls indicating memory
//!   corruption exploitation
//! - **Heap spray detection**: Large numbers of identical allocations used to
//!   place shellcode or ROP gadgets at predictable addresses
//! - **Type confusion**: Objects cast to incorrect types enabling vtable
//!   corruption or field overlap exploitation
//!
//! ### Stack Exploitation
//! - **Stack buffer overflow**: Classic stack smashing with canary bypass
//! - **Stack pivot**: RSP/SP manipulation to redirect execution flow to
//!   attacker-controlled memory
//! - **Return-oriented programming (ROP)**: Chain of gadgets detected via
//!   return address analysis and gadget catalog matching
//! - **Jump-oriented programming (JOP)**: Indirect jump/call chain detection
//! - **Sigreturn-oriented programming (SROP)**: Fake sigcontext frames for
//!   register control
//!
//! ### Mach VM Manipulation
//! - **vm_remap abuse**: Remapping memory regions to bypass ASLR or create
//!   writable copies of read-only pages
//! - **vm_protect changes**: Making executable pages writable (W^X violation)
//!   or writable pages executable
//! - **vm_allocate at fixed addresses**: Allocating at known addresses to
//!   defeat ASLR (null page mapping, stack guard bypass)
//! - **task_for_pid abuse**: Obtaining task ports for cross-process memory
//!   manipulation
//! - **mach_vm_read/write**: Cross-process memory access for injection or
//!   credential theft
//! - **Shared memory abuse**: POSIX shm and Mach shared regions for IPC
//!   exploitation
//!
//! ### ASLR & Mitigation Bypass
//! - **ASLR information leak**: Side-channel or direct disclosure of ASLR
//!   slide values
//! - **Stack guard bypass**: Techniques to read or predict stack canary values
//! - **W^X bypass**: Creating memory regions that are both writable and
//!   executable simultaneously
//! - **PAC bypass**: Pointer Authentication Code forgery on ARM64e
//! - **MTE bypass**: Memory Tagging Extension evasion (future Apple Silicon)
//! - **CFI bypass**: Control Flow Integrity circumvention
//!
//! ### macOS-Specific Memory Attacks
//! - **IOKit shared memory exploitation**: IOKit kernel-userspace shared
//!   memory regions used for privilege escalation
//! - **Mach message OOL data**: Out-of-line Mach message data for kernel
//!   heap manipulation
//! - **Zone allocator abuse**: Targeting specific XNU zones (ipc.ports,
//!   ipc.kmsg, pipe_zone) for kernel exploitation
//! - **Kernel slide leak**: Techniques to determine the kernel ASLR slide
//! - **KTRR/PPL bypass via memory**: Memory-based bypasses of kernel
//!   text protection
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1203 — Exploitation for Client Execution
//! - T1068 — Exploitation for Privilege Escalation
//! - T1055 — Process Injection
//! - T1055.012 — Process Hollowing
//! - T1574 — Hijack Execution Flow
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs integrated with elevated parameters
//! for kernel-level threat detection workloads.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const HEAP_SPRAY_THRESHOLD: u64 = 1000;
const HEAP_SPRAY_IDENTICAL_THRESHOLD: f64 = 0.9;
const ROP_CHAIN_MIN_LENGTH: u32 = 4;

// ── Heap Exploitation Indicators ─────────────────────────────────────────────

const HEAP_EXPLOIT_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("heap_overflow", "Heap buffer overflow (out-of-bounds write)", "T1203", 0.9),
    ("heap_underflow", "Heap buffer underflow (backward OOB write)", "T1203", 0.9),
    ("use_after_free", "Use-after-free (dangling pointer dereference)", "T1203", 0.95),
    ("double_free", "Double-free (duplicate deallocation)", "T1203", 0.9),
    ("heap_spray_detected", "Heap spray pattern (predictable allocation)", "T1203", 0.85),
    ("type_confusion", "Type confusion (incorrect object type cast)", "T1203", 0.9),
    ("integer_overflow_alloc", "Integer overflow in allocation size", "T1203", 0.85),
    ("zone_corruption", "Malloc zone metadata corruption", "T1203", 0.9),
    ("nano_zone_abuse", "Nano zone exploitation (small allocations)", "T1203", 0.8),
    ("magazine_corruption", "Magazine malloc magazine corruption", "T1203", 0.85),
    ("quarantine_bypass", "Malloc quarantine bypass (UAF exploitation)", "T1203", 0.9),
    ("free_list_poison", "Free list pointer poisoning", "T1203", 0.9),
    ("chunk_overlap", "Heap chunk overlap (corrupted metadata)", "T1203", 0.9),
    ("uninitialized_use", "Use of uninitialized heap memory", "T1203", 0.7),
    ("out_of_bounds_read", "Out-of-bounds heap read (info leak)", "T1203", 0.7),
    ("wild_pointer", "Wild pointer dereference (corrupted pointer)", "T1203", 0.85),
    ("tcache_poison", "Thread cache poisoning (glibc-style on cross-platform)", "T1203", 0.85),
    ("fastbin_dup", "Fastbin duplicate (double-free variant)", "T1203", 0.85),
];

// ── Stack Exploitation Indicators ────────────────────────────────────────────

const STACK_EXPLOIT_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("stack_overflow", "Stack buffer overflow detected", "T1203", 0.9),
    ("stack_canary_corrupt", "Stack canary/cookie corrupted (smash detected)", "T1203", 0.95),
    ("stack_pivot", "Stack pivot detected (RSP/SP manipulation)", "T1203", 0.95),
    ("rop_chain_detected", "Return-Oriented Programming chain detected", "T1203", 0.95),
    ("jop_chain_detected", "Jump-Oriented Programming chain detected", "T1203", 0.9),
    ("srop_detected", "Sigreturn-Oriented Programming (fake sigframe)", "T1203", 0.95),
    ("ret2libc", "Return-to-libc attack (classic control flow hijack)", "T1203", 0.85),
    ("ret2dlresolve", "Return-to-dl_resolve (lazy binding exploit)", "T1203", 0.9),
    ("format_string", "Format string vulnerability exploitation", "T1203", 0.85),
    ("stack_guard_bypass", "Stack guard page bypass", "T1203", 0.9),
    ("shadow_stack_mismatch", "Shadow stack return address mismatch", "T1203", 0.95),
    ("cfi_violation", "Control Flow Integrity violation", "T1203", 0.9),
];

// ── Mach VM Manipulation Indicators ──────────────────────────────────────────

const MACH_VM_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("vm_remap_rx_to_rw", "vm_remap: remapping RX page to RW (W^X bypass)", "T1055", 0.95),
    ("vm_protect_wx", "vm_protect: creating W+X memory region", "T1055", 0.95),
    ("vm_allocate_fixed_null", "vm_allocate at NULL page (null deref exploit)", "T1068", 0.9),
    ("vm_allocate_fixed_stack", "vm_allocate at stack region (stack guard bypass)", "T1068", 0.9),
    ("vm_allocate_fixed_heap", "vm_allocate at heap prediction address", "T1068", 0.7),
    ("task_for_pid_nonself", "task_for_pid for non-self process (injection)", "T1055", 0.85),
    ("mach_vm_read_remote", "mach_vm_read on remote process (memory theft)", "T1055", 0.8),
    ("mach_vm_write_remote", "mach_vm_write to remote process (injection)", "T1055", 0.9),
    ("vm_copy_crossproc", "vm_copy across process boundaries", "T1055", 0.8),
    ("thread_create_remote", "Remote thread creation in target process", "T1055", 0.9),
    ("shm_open_world_rw", "World-readable/writable shared memory", "T1055", 0.6),
    ("mach_port_insert", "Mach port inserted into target task", "T1055", 0.8),
    ("exception_port_swap", "Exception port swapped (execution hijack)", "T1055", 0.9),
    ("mach_msg_ool_spray", "Mach OOL message spray (kernel heap control)", "T1068", 0.85),
    ("ipc_kmsg_spray", "IPC kmsg zone spray (kernel exploitation)", "T1068", 0.9),
    ("pipe_buffer_spray", "Pipe buffer spray (pipe_zone kernel exploit)", "T1068", 0.85),
    ("iokit_shared_memory", "IOKit shared memory mapping (kernel data access)", "T1068", 0.7),
    ("mach_voucher_abuse", "Mach voucher manipulation (kernel exploit)", "T1068", 0.9),
];

// ── ASLR & Mitigation Bypass Indicators ──────────────────────────────────────

const MITIGATION_BYPASS_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("aslr_leak_stack", "ASLR leak: stack address disclosed", "T1203", 0.85),
    ("aslr_leak_heap", "ASLR leak: heap address disclosed", "T1203", 0.8),
    ("aslr_leak_libc", "ASLR leak: libc/dyld base disclosed", "T1203", 0.85),
    ("aslr_leak_kernel", "Kernel ASLR slide leaked to userspace", "T1068", 0.95),
    ("kaslr_oracle", "Kernel ASLR oracle (timing/error side channel)", "T1068", 0.85),
    ("wx_jit_abuse", "JIT memory region abuse (W^X exception)", "T1203", 0.8),
    ("pac_forge_a", "PAC A-key forgery detected (ARM64e)", "T1203", 0.95),
    ("pac_forge_b", "PAC B-key forgery detected (ARM64e)", "T1203", 0.95),
    ("pac_signing_gadget", "PAC signing gadget found and used", "T1203", 0.9),
    ("pac_strip", "PAC stripped from pointer (XPACI/XPACD)", "T1203", 0.6),
    ("canary_leak", "Stack canary value leaked (info disclosure)", "T1203", 0.85),
    ("thread_local_canary", "Thread-local canary accessed directly", "T1203", 0.7),
    ("mte_bypass", "Memory Tagging Extension bypass attempt", "T1203", 0.85),
    ("cfi_shadow_corrupt", "CFI shadow table corrupted", "T1203", 0.9),
    ("btcfi_bypass", "Branch Target CFI bypass (ARM BTI)", "T1203", 0.85),
];

// ── Known Memory Exploitation CVEs ───────────────────────────────────────────

const MEMORY_EXPLOIT_CVES: &[(&str, &str, &str, f64)] = &[
    ("CVE-2023-41064", "ImageIO heap overflow (BLASTPASS)", "heap_overflow", 0.95),
    ("CVE-2023-32434", "XNU integer overflow (Triangulation kernel exploit)", "integer_overflow", 0.95),
    ("CVE-2023-38606", "XNU kernel memory corruption", "kernel_memory", 0.95),
    ("CVE-2023-32373", "WebKit UAF (in-the-wild exploitation)", "use_after_free", 0.9),
    ("CVE-2022-46689", "XNU race condition (MacDirtyCow)", "race_condition", 0.9),
    ("CVE-2022-32917", "XNU kernel UAF", "use_after_free", 0.9),
    ("CVE-2021-30883", "IOMobileFrameBuffer UAF (kernel exploit)", "iokit_uaf", 0.95),
    ("CVE-2021-1782", "XNU kernel race condition", "race_condition", 0.9),
    ("CVE-2021-30807", "IOMobileFrameBuffer heap overflow", "heap_overflow", 0.9),
    ("CVE-2020-27950", "XNU kernel memory disclosure", "info_leak", 0.85),
    ("CVE-2020-9839", "IOKit type confusion (kernel exploit)", "type_confusion", 0.9),
    ("CVE-2019-8605", "XNU UAF (SockPuppet)", "use_after_free", 0.9),
    ("CVE-2019-6225", "XNU kernel heap overflow", "heap_overflow", 0.9),
    ("CVE-2023-42824", "XNU local privilege escalation", "privesc", 0.9),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum MemExploitType {
    // Heap
    HeapOverflow,
    HeapUnderflow,
    UseAfterFree,
    DoubleFree,
    HeapSpray,
    TypeConfusion,
    IntegerOverflowAlloc,
    ZoneCorruption,
    FreeListPoison,
    ChunkOverlap,
    // Stack
    StackOverflow,
    StackCanaryCorrupt,
    StackPivot,
    ROPChain,
    JOPChain,
    SROP,
    FormatString,
    CFIViolation,
    ShadowStackMismatch,
    // Mach VM
    VMRemapWXBypass,
    VMProtectWX,
    VMAllocateFixed,
    TaskForPidAbuse,
    MachVMReadRemote,
    MachVMWriteRemote,
    RemoteThreadCreate,
    MachOOLSpray,
    IPCKmsgSpray,
    PipeBufferSpray,
    IOKitSharedMemory,
    MachVoucherAbuse,
    ExceptionPortSwap,
    // Mitigation bypass
    ASLRLeak,
    KASLRLeak,
    WXBypass,
    PACForge,
    PACSigningGadget,
    CanaryLeak,
    MTEBypass,
    CFIShadowCorrupt,
    // Known CVE
    KnownCVEExploit,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MemExploitFinding {
    pub exploit_type: MemExploitType,
    pub confidence: f64,
    pub description: String,
    pub memory_address: Option<String>,
    pub memory_region: Option<String>,
    pub allocation_size: Option<u64>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub target_process: Option<String>,
    pub target_pid: Option<u32>,
    pub cve_id: Option<String>,
    pub mitre_id: String,
    pub gadget_count: Option<u32>,
    pub spray_count: Option<u64>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MemoryEvent {
    pub event_type: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub target_process: Option<String>,
    pub target_pid: Option<u32>,
    pub memory_address: Option<u64>,
    pub memory_size: Option<u64>,
    pub memory_protection: Option<String>,
    pub new_protection: Option<String>,
    pub allocation_count: Option<u64>,
    pub identical_allocation_ratio: Option<f64>,
    pub syscall_name: Option<String>,
    pub mach_trap_name: Option<String>,
    pub integrity_check: Option<String>,
    pub crash_report: Option<String>,
    pub rop_gadget_count: Option<u32>,
    pub return_addresses: Vec<u64>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MemExploitAnalysisResult {
    pub is_exploit: bool,
    pub events_analyzed: u32,
    pub findings: Vec<MemExploitFinding>,
    pub exploit_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct MemExploitScanStats {
    pub total_events: u64,
    pub exploit_detections: u64,
    pub heap_exploit_detections: u64,
    pub stack_exploit_detections: u64,
    pub vm_manipulation_detections: u64,
    pub mitigation_bypass_detections: u64,
    pub cve_match_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MemSigEntry { pub pattern: String, pub exploit_class: String, pub severity: f64 }

pub struct VirtualMemoryExploitDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<MemExploitScanStats>>,
    result_cache: TieredCache<String, MemExploitAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    mem_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, MemExploitScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, MemExploitAnalysisResult>>,
    sig_db: PagedMemory<MemSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<MemExploitScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl VirtualMemoryExploitDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            mem_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, MemExploitScanStats::default(),
                |acc: &mut MemExploitScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(MemExploitScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(512)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &MemoryEvent) -> Option<MemExploitAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("memexploit:{}:{}:{}",
            event.event_type, event.process_pid.unwrap_or(0), event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        // Combine all text-based indicators for matching
        let indicator_text = format!("{} {} {}",
            event.integrity_check.as_deref().unwrap_or(""),
            event.crash_report.as_deref().unwrap_or(""),
            event.event_type);
        let ind_lower = indicator_text.to_lowercase();

        // ── 1. Heap exploitation detection ──────────────────────────────
        for &(pattern, desc, mitre, conf) in HEAP_EXPLOIT_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "heap_overflow" | "heap_underflow" => MemExploitType::HeapOverflow,
                    "use_after_free" | "quarantine_bypass" => MemExploitType::UseAfterFree,
                    "double_free" | "fastbin_dup" => MemExploitType::DoubleFree,
                    "heap_spray_detected" => MemExploitType::HeapSpray,
                    "type_confusion" => MemExploitType::TypeConfusion,
                    "integer_overflow_alloc" => MemExploitType::IntegerOverflowAlloc,
                    "zone_corruption" | "magazine_corruption" | "nano_zone_abuse" => MemExploitType::ZoneCorruption,
                    "free_list_poison" | "tcache_poison" => MemExploitType::FreeListPoison,
                    "chunk_overlap" => MemExploitType::ChunkOverlap,
                    _ => MemExploitType::HeapOverflow,
                };
                findings.push(MemExploitFinding {
                    exploit_type: tt, confidence: conf, description: desc.to_string(),
                    memory_address: event.memory_address.map(|a| format!("0x{:016x}", a)),
                    memory_region: Some("heap".into()),
                    allocation_size: event.memory_size,
                    process_name: event.process_name.clone(),
                    process_pid: event.process_pid,
                    target_process: event.target_process.clone(),
                    target_pid: event.target_pid,
                    cve_id: None, mitre_id: mitre.into(),
                    gadget_count: None, spray_count: event.allocation_count,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("HeapExploit".to_string());
            }
        }

        // Heap spray heuristic
        if let (Some(count), Some(ratio)) = (event.allocation_count, event.identical_allocation_ratio) {
            if count > HEAP_SPRAY_THRESHOLD && ratio > HEAP_SPRAY_IDENTICAL_THRESHOLD {
                findings.push(MemExploitFinding {
                    exploit_type: MemExploitType::HeapSpray,
                    confidence: 0.85,
                    description: format!("Heap spray: {} identical allocations ({:.0}% identical)",
                        count, ratio * 100.0),
                    memory_address: None, memory_region: Some("heap".into()),
                    allocation_size: event.memory_size,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_process: None, target_pid: None, cve_id: None,
                    mitre_id: "T1203".into(), gadget_count: None, spray_count: Some(count),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("HeapExploit".to_string());
            }
        }

        // ── 2. Stack exploitation detection ─────────────────────────────
        for &(pattern, desc, mitre, conf) in STACK_EXPLOIT_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "stack_overflow" => MemExploitType::StackOverflow,
                    "stack_canary_corrupt" => MemExploitType::StackCanaryCorrupt,
                    "stack_pivot" => MemExploitType::StackPivot,
                    "rop_chain_detected" | "ret2libc" | "ret2dlresolve" => MemExploitType::ROPChain,
                    "jop_chain_detected" => MemExploitType::JOPChain,
                    "srop_detected" => MemExploitType::SROP,
                    "format_string" => MemExploitType::FormatString,
                    "cfi_violation" => MemExploitType::CFIViolation,
                    "shadow_stack_mismatch" => MemExploitType::ShadowStackMismatch,
                    _ => MemExploitType::StackOverflow,
                };
                findings.push(MemExploitFinding {
                    exploit_type: tt, confidence: conf, description: desc.to_string(),
                    memory_address: event.memory_address.map(|a| format!("0x{:016x}", a)),
                    memory_region: Some("stack".into()),
                    allocation_size: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_process: event.target_process.clone(), target_pid: event.target_pid,
                    cve_id: None, mitre_id: mitre.into(),
                    gadget_count: event.rop_gadget_count, spray_count: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("StackExploit".to_string());
            }
        }

        // ROP chain heuristic from return addresses
        if event.return_addresses.len() >= ROP_CHAIN_MIN_LENGTH as usize {
            // Check if return addresses are suspiciously close together (gadget chain)
            let mut consecutive_close = 0u32;
            for i in 1..event.return_addresses.len() {
                let diff = if event.return_addresses[i] > event.return_addresses[i-1] {
                    event.return_addresses[i] - event.return_addresses[i-1]
                } else {
                    event.return_addresses[i-1] - event.return_addresses[i]
                };
                if diff < 0x100 { consecutive_close += 1; }
            }
            if consecutive_close >= ROP_CHAIN_MIN_LENGTH {
                findings.push(MemExploitFinding {
                    exploit_type: MemExploitType::ROPChain,
                    confidence: 0.85,
                    description: format!("ROP chain: {} closely-spaced return addresses detected",
                        consecutive_close),
                    memory_address: event.return_addresses.first().map(|a| format!("0x{:016x}", a)),
                    memory_region: Some("stack".into()), allocation_size: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_process: None, target_pid: None, cve_id: None,
                    mitre_id: "T1203".into(),
                    gadget_count: Some(consecutive_close), spray_count: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1203".into());
                categories.insert("StackExploit".to_string());
            }
        }

        // ── 3. Mach VM manipulation detection ───────────────────────────
        for &(pattern, desc, mitre, conf) in MACH_VM_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "vm_remap_rx_to_rw" => MemExploitType::VMRemapWXBypass,
                    "vm_protect_wx" => MemExploitType::VMProtectWX,
                    p if p.starts_with("vm_allocate_fixed") => MemExploitType::VMAllocateFixed,
                    "task_for_pid_nonself" => MemExploitType::TaskForPidAbuse,
                    "mach_vm_read_remote" => MemExploitType::MachVMReadRemote,
                    "mach_vm_write_remote" => MemExploitType::MachVMWriteRemote,
                    "thread_create_remote" => MemExploitType::RemoteThreadCreate,
                    "mach_msg_ool_spray" => MemExploitType::MachOOLSpray,
                    "ipc_kmsg_spray" => MemExploitType::IPCKmsgSpray,
                    "pipe_buffer_spray" => MemExploitType::PipeBufferSpray,
                    "iokit_shared_memory" => MemExploitType::IOKitSharedMemory,
                    "mach_voucher_abuse" => MemExploitType::MachVoucherAbuse,
                    "exception_port_swap" => MemExploitType::ExceptionPortSwap,
                    _ => MemExploitType::VMProtectWX,
                };
                findings.push(MemExploitFinding {
                    exploit_type: tt, confidence: conf, description: desc.to_string(),
                    memory_address: event.memory_address.map(|a| format!("0x{:016x}", a)),
                    memory_region: Some("mach_vm".into()),
                    allocation_size: event.memory_size,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_process: event.target_process.clone(), target_pid: event.target_pid,
                    cve_id: None, mitre_id: mitre.into(),
                    gadget_count: None, spray_count: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("MachVMManipulation".to_string());
            }
        }

        // W^X violation heuristic
        if let (Some(ref prot), Some(ref new_prot)) = (&event.memory_protection, &event.new_protection) {
            let is_wx = (new_prot.contains('w') || new_prot.contains('W')) &&
                        (new_prot.contains('x') || new_prot.contains('X'));
            if is_wx {
                findings.push(MemExploitFinding {
                    exploit_type: MemExploitType::WXBypass,
                    confidence: 0.9,
                    description: format!("W^X violation: {} -> {} (writable+executable)", prot, new_prot),
                    memory_address: event.memory_address.map(|a| format!("0x{:016x}", a)),
                    memory_region: None, allocation_size: event.memory_size,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_process: None, target_pid: None, cve_id: None,
                    mitre_id: "T1055".into(), gadget_count: None, spray_count: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1055".into());
                categories.insert("MitigationBypass".to_string());
            }
        }

        // ── 4. Mitigation bypass detection ──────────────────────────────
        for &(pattern, desc, mitre, conf) in MITIGATION_BYPASS_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.starts_with("aslr_leak") => MemExploitType::ASLRLeak,
                    p if p.contains("kaslr") => MemExploitType::KASLRLeak,
                    p if p.contains("pac_forge") => MemExploitType::PACForge,
                    "pac_signing_gadget" => MemExploitType::PACSigningGadget,
                    "canary_leak" | "thread_local_canary" => MemExploitType::CanaryLeak,
                    "mte_bypass" => MemExploitType::MTEBypass,
                    "cfi_shadow_corrupt" | "btcfi_bypass" => MemExploitType::CFIShadowCorrupt,
                    "wx_jit_abuse" => MemExploitType::WXBypass,
                    _ => MemExploitType::ASLRLeak,
                };
                findings.push(MemExploitFinding {
                    exploit_type: tt, confidence: conf, description: desc.to_string(),
                    memory_address: event.memory_address.map(|a| format!("0x{:016x}", a)),
                    memory_region: None, allocation_size: None,
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    target_process: None, target_pid: None, cve_id: None,
                    mitre_id: mitre.into(), gadget_count: None, spray_count: None,
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                categories.insert("MitigationBypass".to_string());
            }
        }

        // ── 5. Known CVE matching ───────────────────────────────────────
        if let Some(ref crash) = event.crash_report {
            let crash_lower = crash.to_lowercase();
            for &(cve, desc, exploit_class, conf) in MEMORY_EXPLOIT_CVES {
                if crash_lower.contains(&cve.to_lowercase()) || crash_lower.contains(&exploit_class.to_lowercase()) {
                    findings.push(MemExploitFinding {
                        exploit_type: MemExploitType::KnownCVEExploit,
                        confidence: conf, description: format!("{}: {}", cve, desc),
                        memory_address: None, memory_region: None, allocation_size: None,
                        process_name: event.process_name.clone(), process_pid: event.process_pid,
                        target_process: None, target_pid: None,
                        cve_id: Some(cve.to_string()),
                        mitre_id: "T1203".into(), gadget_count: None, spray_count: None,
                        timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1203".into());
                    categories.insert("KnownCVE".to_string());
                }
            }
        }

        // ── Finalize ────────────────────────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},pid={:?},findings={}",
                event.event_type, event.process_pid, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_exploit = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = MemExploitAnalysisResult {
            is_exploit, events_analyzed: 1, findings,
            exploit_categories: cats_vec, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_exploit {
                s.exploit_detections += 1;
                for f in &result.findings {
                    match f.exploit_type {
                        MemExploitType::HeapOverflow | MemExploitType::UseAfterFree |
                        MemExploitType::DoubleFree | MemExploitType::HeapSpray |
                        MemExploitType::TypeConfusion | MemExploitType::ZoneCorruption |
                        MemExploitType::FreeListPoison | MemExploitType::ChunkOverlap |
                        MemExploitType::HeapUnderflow | MemExploitType::IntegerOverflowAlloc =>
                            s.heap_exploit_detections += 1,
                        MemExploitType::StackOverflow | MemExploitType::StackCanaryCorrupt |
                        MemExploitType::StackPivot | MemExploitType::ROPChain |
                        MemExploitType::JOPChain | MemExploitType::SROP |
                        MemExploitType::FormatString | MemExploitType::CFIViolation |
                        MemExploitType::ShadowStackMismatch =>
                            s.stack_exploit_detections += 1,
                        MemExploitType::VMRemapWXBypass | MemExploitType::VMProtectWX |
                        MemExploitType::VMAllocateFixed | MemExploitType::TaskForPidAbuse |
                        MemExploitType::MachVMReadRemote | MemExploitType::MachVMWriteRemote |
                        MemExploitType::RemoteThreadCreate | MemExploitType::MachOOLSpray |
                        MemExploitType::IPCKmsgSpray | MemExploitType::PipeBufferSpray |
                        MemExploitType::IOKitSharedMemory | MemExploitType::MachVoucherAbuse |
                        MemExploitType::ExceptionPortSwap =>
                            s.vm_manipulation_detections += 1,
                        MemExploitType::ASLRLeak | MemExploitType::KASLRLeak |
                        MemExploitType::WXBypass | MemExploitType::PACForge |
                        MemExploitType::PACSigningGadget | MemExploitType::CanaryLeak |
                        MemExploitType::MTEBypass | MemExploitType::CFIShadowCorrupt =>
                            s.mitigation_bypass_detections += 1,
                        MemExploitType::KnownCVEExploit => s.cve_match_detections += 1,
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_exploit {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "virtual_memory_exploit_detector".into(),
                title: format!("MEMORY EXPLOIT: {} ({})",
                    result.exploit_categories.join(", "),
                    event.process_name.as_deref().unwrap_or("unknown")),
                details: format!("Risk {:.1}%, {} findings, categories: {}. Process: {:?} (pid {:?}), target: {:?} (pid {:?})",
                    risk_score * 100.0, result.findings.len(),
                    result.exploit_categories.join(", "),
                    event.process_name, event.process_pid,
                    event.target_process, event.target_pid),
                path: event.file_path.clone(),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the suspicious process immediately".into(),
                    "Check for other compromised processes: ps aux".into(),
                    "Verify system integrity: sudo /usr/libexec/makewhatis".into(),
                    "Update macOS to latest security patches".into(),
                    "If kernel exploit suspected, reboot immediately".into(),
                    "Collect crash reports from ~/Library/Logs/DiagnosticReports/".into(),
                    "Report to Apple Product Security if 0-day suspected".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[MemExploitFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.exploit_type {
                MemExploitType::KnownCVEExploit => 1.8,
                MemExploitType::ROPChain | MemExploitType::JOPChain | MemExploitType::SROP => 1.7,
                MemExploitType::PACForge => 1.7,
                MemExploitType::KASLRLeak => 1.6,
                MemExploitType::UseAfterFree => 1.6,
                MemExploitType::StackPivot => 1.6,
                MemExploitType::MachVMWriteRemote | MemExploitType::RemoteThreadCreate => 1.6,
                MemExploitType::MachOOLSpray | MemExploitType::IPCKmsgSpray => 1.5,
                MemExploitType::VMProtectWX | MemExploitType::VMRemapWXBypass => 1.5,
                MemExploitType::HeapOverflow | MemExploitType::DoubleFree => 1.4,
                MemExploitType::StackCanaryCorrupt | MemExploitType::CFIViolation => 1.4,
                MemExploitType::TypeConfusion => 1.4,
                MemExploitType::TaskForPidAbuse => 1.3,
                MemExploitType::HeapSpray => 1.2,
                MemExploitType::ASLRLeak => 1.1,
                _ => 1.0,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> MemExploitScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
