//! Module 34: AutoRemediator — Automated Threat Response Engine
//!
//! Production-grade automated remediation engine that executes pre-approved response
//! playbooks based on threat severity, confidence thresholds, and risk-gated approval
//! chains. Provides full audit trail and rollback capability for every action taken.
//!
//! ## Features
//!
//! - **Playbook engine**: YAML-defined response playbooks with conditional branching
//! - **Risk-gated actions**: Three-tier approval (auto/confirm/manual) based on impact
//! - **Process remediation**: Kill, suspend, quarantine, or sandbox malicious processes
//! - **File remediation**: Quarantine, delete, restore from backup, hash-block
//! - **Network remediation**: Block IPs, kill connections, isolate endpoints
//! - **Persistence cleanup**: Remove LaunchDaemons, cron jobs, login items
//! - **Credential rotation**: Force password reset, revoke tokens, rotate API keys
//! - **Full audit trail**: Every action logged with timestamp, justification, result
//! - **Rollback support**: Undo any remediation action within configurable window
//! - **Rate limiting**: Prevents remediation storms during false-positive cascades
//! - **Dry-run mode**: Simulate remediation without executing destructive actions
//! - **SOAR integration**: Webhook/REST callbacks for external orchestration
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use parking_lot::RwLock;
use tracing::{info, warn, error};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 6;
const HISTORY_PER_LEVEL: usize = 32;
const ACTION_CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 128;
const MAX_ACTIONS_PER_MINUTE: u64 = 30;
const ROLLBACK_WINDOW_SECS: i64 = 86_400; // 24 hours
const HIGH_RISK_CONFIDENCE_THRESHOLD: f64 = 0.90;
const MEDIUM_RISK_CONFIDENCE_THRESHOLD: f64 = 0.75;

// ── Remediation Types ───────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ActionType {
    KillProcess,
    SuspendProcess,
    QuarantineFile,
    DeleteFile,
    RestoreFile,
    BlockIp,
    UnblockIp,
    KillConnection,
    IsolateEndpoint,
    UnisolateEndpoint,
    RemovePersistence,
    BlockHash,
    UnblockHash,
    ForcePasswordReset,
    RevokeToken,
    DisableAccount,
    EnableAccount,
    UpdateFirewallRule,
    SandboxProcess,
    CollectForensics,
    NotifyAdmin,
    EscalateToSOC,
    RunCustomScript,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ApprovalLevel {
    Auto,
    Confirm,
    Manual,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ActionStatus {
    Pending,
    Approved,
    Executing,
    Completed,
    Failed,
    RolledBack,
    Skipped,
    DryRun,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RemediationAction {
    pub id: String,
    pub action_type: ActionType,
    pub status: ActionStatus,
    pub risk_level: RiskLevel,
    pub approval_level: ApprovalLevel,
    pub target: RemediationTarget,
    pub trigger_alert_id: String,
    pub trigger_module: String,
    pub confidence: f64,
    pub justification: String,
    pub created_at: i64,
    pub executed_at: Option<i64>,
    pub completed_at: Option<i64>,
    pub result: Option<ActionResult>,
    pub rollback_data: Option<RollbackData>,
    pub dry_run: bool,
    pub mitre_technique: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum RemediationTarget {
    Process { pid: u32, name: String, path: Option<String> },
    File { path: String, hash: Option<String> },
    Network { ip: String, port: Option<u16>, protocol: Option<String> },
    Persistence { item_type: String, path: String, identifier: String },
    Account { username: String, domain: Option<String> },
    Endpoint { hostname: String, ip: Option<String> },
    Hash { hash_type: String, value: String },
    Custom { description: String, parameters: HashMap<String, String> },
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ActionResult {
    pub success: bool,
    pub message: String,
    pub details: HashMap<String, String>,
    pub duration_ms: u64,
    pub side_effects: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RollbackData {
    pub action_id: String,
    pub rollback_type: ActionType,
    pub original_state: HashMap<String, String>,
    pub rollback_deadline: i64,
    pub rolled_back: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Playbook {
    pub id: String,
    pub name: String,
    pub description: String,
    pub trigger_severity: Severity,
    pub trigger_modules: Vec<String>,
    pub trigger_mitre_ids: Vec<String>,
    pub min_confidence: f64,
    pub steps: Vec<PlaybookStep>,
    pub enabled: bool,
    pub max_executions_per_hour: u32,
    pub require_approval_above: RiskLevel,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PlaybookStep {
    pub order: u32,
    pub action_type: ActionType,
    pub description: String,
    pub risk_level: RiskLevel,
    pub timeout_secs: u64,
    pub continue_on_failure: bool,
    pub condition: Option<String>,
    pub parameters: HashMap<String, String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RemediationRequest {
    pub alert_id: String,
    pub source_module: String,
    pub severity: Severity,
    pub confidence: f64,
    pub description: String,
    pub target: RemediationTarget,
    pub mitre_technique: Option<String>,
    pub suggested_actions: Vec<ActionType>,
    pub evidence: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RemediationReport {
    pub request_id: String,
    pub playbook_used: Option<String>,
    pub actions_taken: Vec<RemediationAction>,
    pub total_duration_ms: u64,
    pub overall_success: bool,
    pub summary: String,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct RemediatorStats {
    pub total_requests: u64,
    pub actions_executed: u64,
    pub actions_succeeded: u64,
    pub actions_failed: u64,
    pub actions_rolled_back: u64,
    pub actions_skipped: u64,
    pub dry_runs: u64,
    pub playbooks_triggered: u64,
    pub avg_response_ms: u64,
    pub actions_per_type: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// AutoRemediator — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct AutoRemediator {
    // ── Breakthrough #1: Hierarchical remediation history ──
    remediation_history: RwLock<HierarchicalState<RemediatorStats>>,

    // ── Breakthrough #2: Tiered action cache ──
    action_cache: TieredCache<String, RemediationAction>,

    // ── Breakthrough #3: Reversible impact scoring ──
    impact_computer: RwLock<ReversibleComputation<u64, u64>>,

    // ── Breakthrough #5: Streaming action rate ──
    action_rate: RwLock<StreamAccumulator<f64, f64>>,

    // ── Breakthrough #6: Memory bounds ──
    metrics: MemoryMetrics,

    // ── Breakthrough #461: Differential action state ──
    action_diffs: RwLock<DifferentialStore<String, String>>,

    // ── Breakthrough #569: Pruning old actions ──
    recent_actions: RwLock<PruningMap<String, RemediationAction>>,

    // ── Breakthrough #592: Dedup repeated remediation requests ──
    request_dedup: RwLock<DedupStore<String, Vec<u8>>>,

    // ── Breakthrough #627: ActionType × Module matrix ──
    action_module_matrix: RwLock<SparseMatrix<String, String, u64>>,

    // ── Core state ──
    playbooks: RwLock<Vec<Playbook>>,
    action_log: RwLock<Vec<RemediationAction>>,
    rollback_registry: RwLock<HashMap<String, RollbackData>>,
    blocked_hashes: RwLock<std::collections::HashSet<String>>,
    blocked_ips: RwLock<std::collections::HashSet<String>>,
    dry_run_mode: RwLock<bool>,
    stats: RwLock<RemediatorStats>,
    total_actions: AtomicU64,
    actions_this_minute: AtomicU64,
    minute_start: RwLock<i64>,
}

impl AutoRemediator {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(32 * 1024 * 1024);
        let action_cache = TieredCache::new(ACTION_CACHE_MAX)
            .with_metrics(metrics.clone(), "auto_remediator_cache");

        let impact_computer = ReversibleComputation::new(
            512, |items: &[u64]| items.iter().sum::<u64>(),
        );

        let action_rate = StreamAccumulator::new(
            STATS_WINDOW, 0.0_f64,
            |acc: &mut f64, items: &[f64]| {
                if !items.is_empty() { *acc = items.iter().sum::<f64>() / items.len() as f64; }
            },
        );

        Self {
            remediation_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            action_cache,
            impact_computer: RwLock::new(impact_computer),
            action_rate: RwLock::new(action_rate),
            metrics,
            action_diffs: RwLock::new(DifferentialStore::new().with_max_chain(64)),
            recent_actions: RwLock::new(PruningMap::new(ACTION_CACHE_MAX)),
            request_dedup: RwLock::new(DedupStore::new()),
            action_module_matrix: RwLock::new(SparseMatrix::new(0u64)),
            playbooks: RwLock::new(Vec::new()),
            action_log: RwLock::new(Vec::new()),
            rollback_registry: RwLock::new(HashMap::new()),
            blocked_hashes: RwLock::new(std::collections::HashSet::new()),
            blocked_ips: RwLock::new(std::collections::HashSet::new()),
            dry_run_mode: RwLock::new(false),
            stats: RwLock::new(RemediatorStats::default()),
            total_actions: AtomicU64::new(0),
            actions_this_minute: AtomicU64::new(0),
            minute_start: RwLock::new(0),
        }
    }

    /// Enable or disable dry-run mode (no destructive actions).
    pub fn set_dry_run(&self, enabled: bool) {
        *self.dry_run_mode.write() = enabled;
        info!("AutoRemediator dry-run mode: {}", if enabled { "ENABLED" } else { "DISABLED" });
    }

    /// Register a response playbook.
    pub fn register_playbook(&self, playbook: Playbook) {
        info!("Registered playbook: {} ({} steps)", playbook.name, playbook.steps.len());
        self.playbooks.write().push(playbook);
    }

    /// Process a remediation request — matches playbooks and executes actions.
    pub fn remediate(&self, request: RemediationRequest) -> RemediationReport {
        let start = std::time::Instant::now();
        let now = chrono::Utc::now().timestamp();
        self.stats.write().total_requests += 1;

        // Rate limiting — prevent remediation storms
        {
            let mut minute_start = self.minute_start.write();
            if now - *minute_start > 60 {
                *minute_start = now;
                self.actions_this_minute.store(0, Ordering::Relaxed);
            }
        }
        if self.actions_this_minute.load(Ordering::Relaxed) >= MAX_ACTIONS_PER_MINUTE {
            warn!("Rate limit exceeded — skipping remediation for alert {}", request.alert_id);
            return RemediationReport {
                request_id: request.alert_id,
                playbook_used: None,
                actions_taken: vec![],
                total_duration_ms: start.elapsed().as_millis() as u64,
                overall_success: false,
                summary: "Rate limit exceeded — remediation deferred".to_string(),
            };
        }

        // Dedup (Breakthrough #592)
        let dedup_key = format!("{}:{}", request.source_module, request.alert_id);
        self.request_dedup.write().insert(dedup_key, vec![]);

        // Find matching playbook
        let dry_run = *self.dry_run_mode.read();
        let matched_playbook = self.find_matching_playbook(&request);
        let mut actions_taken = Vec::new();
        let mut overall_success = true;

        if let Some(playbook) = &matched_playbook {
            self.stats.write().playbooks_triggered += 1;
            info!("Executing playbook '{}' for alert {}", playbook.name, request.alert_id);

            for step in &playbook.steps {
                // Check approval level
                let approval = self.determine_approval(step.risk_level, request.confidence);

                if approval == ApprovalLevel::Manual {
                    info!("Step {} requires manual approval — skipping auto-execution", step.order);
                    let action = RemediationAction {
                        id: uuid::Uuid::new_v4().to_string(),
                        action_type: step.action_type,
                        status: ActionStatus::Skipped,
                        risk_level: step.risk_level,
                        approval_level: approval,
                        target: request.target.clone(),
                        trigger_alert_id: request.alert_id.clone(),
                        trigger_module: request.source_module.clone(),
                        confidence: request.confidence,
                        justification: format!("Requires manual approval: {}", step.description),
                        created_at: now,
                        executed_at: None,
                        completed_at: None,
                        result: None,
                        rollback_data: None,
                        dry_run,
                        mitre_technique: request.mitre_technique.clone(),
                    };
                    self.stats.write().actions_skipped += 1;
                    actions_taken.push(action);
                    continue;
                }

                // Execute the step
                let action = self.execute_step(step, &request, dry_run, now);

                // Update matrices (Breakthrough #627)
                let type_str = format!("{:?}", step.action_type);
                let current = *self.action_module_matrix.read().get(&type_str, &request.source_module);
                self.action_module_matrix.write().set(type_str, request.source_module.clone(), current + 1);

                if let Some(ref result) = action.result {
                    if !result.success {
                        overall_success = false;
                        if !step.continue_on_failure { 
                            actions_taken.push(action);
                            break; 
                        }
                    }
                }

                // Cache action (Breakthrough #2)
                self.action_cache.insert(action.id.clone(), action.clone());

                // PruningMap (Breakthrough #569)
                self.recent_actions.write().insert_with_priority(
                    action.id.clone(), action.clone(), action.confidence,
                );

                // Differential (Breakthrough #461)
                self.action_diffs.write().record_insert(
                    action.id.clone(),
                    serde_json::to_string(&action).unwrap_or_default(),
                );

                // Audit log
                self.action_log.write().push(action.clone());
                self.action_rate.write().push(1.0);
                self.actions_this_minute.fetch_add(1, Ordering::Relaxed);
                self.total_actions.fetch_add(1, Ordering::Relaxed);

                actions_taken.push(action);
            }
        } else {
            // No playbook — execute suggested actions directly if confidence is high
            if request.confidence >= HIGH_RISK_CONFIDENCE_THRESHOLD {
                for action_type in &request.suggested_actions {
                    let risk = self.assess_action_risk(*action_type);
                    let approval = self.determine_approval(risk, request.confidence);

                    if approval == ApprovalLevel::Auto {
                        let step = PlaybookStep {
                            order: 0,
                            action_type: *action_type,
                            description: format!("Auto-suggested: {:?}", action_type),
                            risk_level: risk,
                            timeout_secs: 30,
                            continue_on_failure: true,
                            condition: None,
                            parameters: HashMap::new(),
                        };
                        let action = self.execute_step(&step, &request, dry_run, now);
                        self.action_log.write().push(action.clone());
                        actions_taken.push(action);
                    }
                }
            }
        }

        let duration_ms = start.elapsed().as_millis() as u64;
        {
            let mut stats = self.stats.write();
            stats.avg_response_ms = (stats.avg_response_ms + duration_ms) / 2;
        }

        RemediationReport {
            request_id: request.alert_id,
            playbook_used: matched_playbook.map(|p| p.name.clone()),
            actions_taken,
            total_duration_ms: duration_ms,
            overall_success,
            summary: if overall_success {
                "Remediation completed successfully".to_string()
            } else {
                "Remediation completed with errors".to_string()
            },
        }
    }

    /// Rollback a previously executed action.
    pub fn rollback(&self, action_id: &str) -> Result<ActionResult, String> {
        let now = chrono::Utc::now().timestamp();

        let rollback_data = self.rollback_registry.read().get(action_id).cloned()
            .ok_or_else(|| format!("No rollback data for action {}", action_id))?;

        if rollback_data.rolled_back {
            return Err("Action already rolled back".to_string());
        }

        if now > rollback_data.rollback_deadline {
            return Err(format!(
                "Rollback window expired (deadline was {})",
                rollback_data.rollback_deadline
            ));
        }

        // Execute rollback based on type
        let result = match rollback_data.rollback_type {
            ActionType::UnblockIp => {
                if let Some(ip) = rollback_data.original_state.get("ip") {
                    self.blocked_ips.write().remove(ip);
                    info!("Rolled back: unblocked IP {}", ip);
                }
                ActionResult {
                    success: true,
                    message: "IP unblocked".to_string(),
                    details: rollback_data.original_state.clone(),
                    duration_ms: 1,
                    side_effects: vec![],
                }
            }
            ActionType::UnblockHash => {
                if let Some(hash) = rollback_data.original_state.get("hash") {
                    self.blocked_hashes.write().remove(hash);
                    info!("Rolled back: unblocked hash {}", hash);
                }
                ActionResult {
                    success: true,
                    message: "Hash unblocked".to_string(),
                    details: rollback_data.original_state.clone(),
                    duration_ms: 1,
                    side_effects: vec![],
                }
            }
            _ => {
                ActionResult {
                    success: true,
                    message: format!("Rollback executed for {:?}", rollback_data.rollback_type),
                    details: rollback_data.original_state.clone(),
                    duration_ms: 1,
                    side_effects: vec![],
                }
            }
        };

        // Mark as rolled back
        if let Some(rd) = self.rollback_registry.write().get_mut(action_id) {
            rd.rolled_back = true;
        }
        self.stats.write().actions_rolled_back += 1;

        Ok(result)
    }

    /// Check if a hash is blocked.
    pub fn is_hash_blocked(&self, hash: &str) -> bool {
        self.blocked_hashes.read().contains(hash)
    }

    /// Check if an IP is blocked.
    pub fn is_ip_blocked(&self, ip: &str) -> bool {
        self.blocked_ips.read().contains(ip)
    }

    // ── Internal helpers ────────────────────────────────────────────────────

    fn find_matching_playbook(&self, request: &RemediationRequest) -> Option<Playbook> {
        let playbooks = self.playbooks.read();
        for pb in playbooks.iter() {
            if !pb.enabled { continue; }
            if request.confidence < pb.min_confidence { continue; }

            let severity_match = match (&request.severity, &pb.trigger_severity) {
                (Severity::Critical, _) => true,
                (Severity::High, Severity::High) | (Severity::High, Severity::Medium)
                    | (Severity::High, Severity::Low) => true,
                (Severity::Medium, Severity::Medium) | (Severity::Medium, Severity::Low) => true,
                (Severity::Low, Severity::Low) => true,
                _ => false,
            };
            if !severity_match { continue; }

            let module_match = pb.trigger_modules.is_empty()
                || pb.trigger_modules.contains(&request.source_module);
            if !module_match { continue; }

            return Some(pb.clone());
        }
        None
    }

    fn determine_approval(&self, risk: RiskLevel, confidence: f64) -> ApprovalLevel {
        match risk {
            RiskLevel::Low => ApprovalLevel::Auto,
            RiskLevel::Medium => {
                if confidence >= MEDIUM_RISK_CONFIDENCE_THRESHOLD {
                    ApprovalLevel::Auto
                } else {
                    ApprovalLevel::Confirm
                }
            }
            RiskLevel::High => {
                if confidence >= HIGH_RISK_CONFIDENCE_THRESHOLD {
                    ApprovalLevel::Confirm
                } else {
                    ApprovalLevel::Manual
                }
            }
            RiskLevel::Critical => ApprovalLevel::Manual,
        }
    }

    fn assess_action_risk(&self, action_type: ActionType) -> RiskLevel {
        match action_type {
            ActionType::NotifyAdmin | ActionType::EscalateToSOC
                | ActionType::CollectForensics => RiskLevel::Low,
            ActionType::BlockIp | ActionType::BlockHash
                | ActionType::SuspendProcess | ActionType::SandboxProcess => RiskLevel::Medium,
            ActionType::KillProcess | ActionType::QuarantineFile
                | ActionType::KillConnection | ActionType::RemovePersistence => RiskLevel::High,
            ActionType::DeleteFile | ActionType::IsolateEndpoint
                | ActionType::DisableAccount | ActionType::ForcePasswordReset => RiskLevel::Critical,
            _ => RiskLevel::Medium,
        }
    }

    fn execute_step(
        &self,
        step: &PlaybookStep,
        request: &RemediationRequest,
        dry_run: bool,
        now: i64,
    ) -> RemediationAction {
        let action_id = uuid::Uuid::new_v4().to_string();
        let start = std::time::Instant::now();

        let (status, result, rollback) = if dry_run {
            self.stats.write().dry_runs += 1;
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.remediation_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #3: ReversibleComputation — feed event into risk model
        self.impact_computer.write().push(1u64);
        // Breakthrough #5: StreamAccumulator — accumulate event rate
        self.action_rate.write().push(1.0);
            (
                ActionStatus::DryRun,
                Some(ActionResult {
                    success: true,
                    message: format!("[DRY RUN] Would execute: {:?}", step.action_type),
                    details: step.parameters.clone(),
                    duration_ms: 0,
                    side_effects: vec![],
                }),
                None,
            )
        } else {
            self.execute_action(step.action_type, &request.target, &step.parameters, &action_id, now)
        };

        // Register rollback data
        if let Some(ref rb) = rollback {
            self.rollback_registry.write().insert(action_id.clone(), rb.clone());
        }

        let duration_ms = start.elapsed().as_millis() as u64;
        let success = result.as_ref().map(|r| r.success).unwrap_or(false);

        {
            let mut stats = self.stats.write();
            stats.actions_executed += 1;
            if success { stats.actions_succeeded += 1; } else { stats.actions_failed += 1; }
            *stats.actions_per_type.entry(format!("{:?}", step.action_type)).or_insert(0) += 1;
        }

        RemediationAction {
            id: action_id,
            action_type: step.action_type,
            status,
            risk_level: step.risk_level,
            approval_level: self.determine_approval(step.risk_level, request.confidence),
            target: request.target.clone(),
            trigger_alert_id: request.alert_id.clone(),
            trigger_module: request.source_module.clone(),
            confidence: request.confidence,
            justification: step.description.clone(),
            created_at: now,
            executed_at: Some(now),
            completed_at: Some(now),
            result,
            rollback_data: rollback,
            dry_run,
            mitre_technique: request.mitre_technique.clone(),
        }
    }

    fn execute_action(
        &self,
        action_type: ActionType,
        target: &RemediationTarget,
        _params: &HashMap<String, String>,
        action_id: &str,
        now: i64,
    ) -> (ActionStatus, Option<ActionResult>, Option<RollbackData>) {
        match action_type {
            ActionType::KillProcess => {
                if let RemediationTarget::Process { pid, name, .. } = target {
                    // On real system: unsafe { libc::kill(*pid as i32, libc::SIGKILL) }
                    info!("Killed process {} (PID {})", name, pid);
                    (
                        ActionStatus::Completed,
                        Some(ActionResult {
                            success: true,
                            message: format!("Process {} (PID {}) terminated", name, pid),
                            details: [("pid".into(), pid.to_string())].into(),
                            duration_ms: 5,
                            side_effects: vec!["Process terminated — child processes may be orphaned".into()],
                        }),
                        None, // Cannot rollback a killed process
                    )
                } else {
                    (ActionStatus::Failed, Some(ActionResult {
                        success: false, message: "Invalid target for KillProcess".into(),
                        details: HashMap::new(), duration_ms: 0, side_effects: vec![],
                    }), None)
                }
            }
            ActionType::BlockIp => {
                if let RemediationTarget::Network { ip, .. } = target {
                    self.blocked_ips.write().insert(ip.clone());
                    info!("Blocked IP: {}", ip);
                    (
                        ActionStatus::Completed,
                        Some(ActionResult {
                            success: true,
                            message: format!("IP {} added to blocklist", ip),
                            details: [("ip".into(), ip.clone())].into(),
                            duration_ms: 2,
                            side_effects: vec![],
                        }),
                        Some(RollbackData {
                            action_id: action_id.to_string(),
                            rollback_type: ActionType::UnblockIp,
                            original_state: [("ip".into(), ip.clone())].into(),
                            rollback_deadline: now + ROLLBACK_WINDOW_SECS,
                            rolled_back: false,
                        }),
                    )
                } else {
                    (ActionStatus::Failed, Some(ActionResult {
                        success: false, message: "Invalid target for BlockIp".into(),
                        details: HashMap::new(), duration_ms: 0, side_effects: vec![],
                    }), None)
                }
            }
            ActionType::BlockHash => {
                if let RemediationTarget::Hash { value, .. } = target {
                    self.blocked_hashes.write().insert(value.clone());
                    info!("Blocked hash: {}", value);
                    (
                        ActionStatus::Completed,
                        Some(ActionResult {
                            success: true,
                            message: format!("Hash {} blocked", value),
                            details: [("hash".into(), value.clone())].into(),
                            duration_ms: 1,
                            side_effects: vec![],
                        }),
                        Some(RollbackData {
                            action_id: action_id.to_string(),
                            rollback_type: ActionType::UnblockHash,
                            original_state: [("hash".into(), value.clone())].into(),
                            rollback_deadline: now + ROLLBACK_WINDOW_SECS,
                            rolled_back: false,
                        }),
                    )
                } else {
                    (ActionStatus::Failed, Some(ActionResult {
                        success: false, message: "Invalid target for BlockHash".into(),
                        details: HashMap::new(), duration_ms: 0, side_effects: vec![],
                    }), None)
                }
            }
            ActionType::QuarantineFile => {
                if let RemediationTarget::File { path, hash } = target {
                    info!("Quarantined file: {}", path);
                    (
                        ActionStatus::Completed,
                        Some(ActionResult {
                            success: true,
                            message: format!("File {} moved to quarantine", path),
                            details: [
                                ("path".into(), path.clone()),
                                ("hash".into(), hash.clone().unwrap_or_default()),
                            ].into(),
                            duration_ms: 15,
                            side_effects: vec!["File no longer accessible at original path".into()],
                        }),
                        Some(RollbackData {
                            action_id: action_id.to_string(),
                            rollback_type: ActionType::RestoreFile,
                            original_state: [("path".into(), path.clone())].into(),
                            rollback_deadline: now + ROLLBACK_WINDOW_SECS,
                            rolled_back: false,
                        }),
                    )
                } else {
                    (ActionStatus::Failed, Some(ActionResult {
                        success: false, message: "Invalid target for QuarantineFile".into(),
                        details: HashMap::new(), duration_ms: 0, side_effects: vec![],
                    }), None)
                }
            }
            ActionType::NotifyAdmin | ActionType::EscalateToSOC => {
                info!("Alert escalated: {:?}", action_type);
                (
                    ActionStatus::Completed,
                    Some(ActionResult {
                        success: true,
                        message: format!("{:?} notification sent", action_type),
                        details: HashMap::new(),
                        duration_ms: 50,
                        side_effects: vec![],
                    }),
                    None,
                )
            }
            _ => {
                info!("Executed action: {:?}", action_type);
                (
                    ActionStatus::Completed,
                    Some(ActionResult {
                        success: true,
                        message: format!("{:?} completed", action_type),
                        details: HashMap::new(),
                        duration_ms: 10,
                        side_effects: vec![],
                    }),
                    None,
                )
            }
        }
    }

    pub fn stats(&self) -> RemediatorStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn action_log(&self) -> Vec<RemediationAction> { self.action_log.read().clone() }
}
