//! Module 120: ICMPCovertChannel — ICMP Tunneling & Covert Channel Detection
//!
//! Detects data exfiltration and C2 communication hidden in ICMP echo
//! request/reply payloads. ICMP tunneling bypasses firewalls that allow
//! ping traffic, making it a favorite APT exfiltration channel.
//!
//! ## Detection Capabilities
//!
//! - **ICMP payload analysis**: Detect non-standard payload sizes, high entropy
//!   payloads, structured data in echo payloads
//! - **ICMP tunneling tools**: ptunnel, icmpsh, icmptunnel, Hans, Ping Tunnel,
//!   ICMP-TransferTools detection
//! - **Payload frequency analysis**: Detect periodic ICMP with consistent payload
//!   sizes indicating tunneled protocol traffic
//! - **Entropy detection**: High Shannon entropy in ICMP payloads indicates
//!   encrypted/compressed data exfiltration
//! - **Volume anomaly**: Excessive ICMP traffic volume for single destinations
//! - **Type/code abuse**: Non-echo ICMP types carrying data (type 8/0 abuse,
//!   timestamp, information requests)
//! - **Fragmentation abuse**: Large ICMP packets fragmented to carry more data
//! - **Bidirectional analysis**: Correlate request/reply for command-response C2
//! - **Protocol deviation**: Payloads not matching standard ping patterns
//!   (Windows/Linux/macOS default ping payloads)
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const NORMAL_ICMP_PAYLOAD_MAX: usize = 64;
const HIGH_ENTROPY_THRESHOLD: f64 = 6.5;
const VOLUME_THRESHOLD_PER_MIN: u64 = 100;
const TUNNEL_DETECTION_WINDOW_SECS: u64 = 60;

const STANDARD_PING_PATTERNS: &[(&str, &[u8], usize)] = &[
    ("macOS", b"\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f", 56),
    ("Linux", b"\x10\x11\x12\x13\x14\x15\x16\x17", 56),
    ("Windows", b"abcdefghijklmnop", 32),
];

const ICMP_TUNNEL_TOOLS: &[(&str, &str, f64)] = &[
    ("ptunnel", "Ptunnel — ICMP tunnel proxy", 0.95),
    ("icmpsh", "ICMPsh — ICMP reverse shell", 0.95),
    ("icmptunnel", "ICMP Tunnel — IP over ICMP", 0.9),
    ("hans", "Hans — IP over ICMP VPN", 0.9),
    ("pingtunnel", "PingTunnel — TCP/UDP over ICMP", 0.9),
    ("icmp-transfer", "ICMP-TransferTools — file exfil", 0.85),
    ("nping", "Nping — advanced ICMP crafting", 0.5),
    ("hping", "Hping — ICMP packet crafting", 0.5),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ICMPThreatType {
    HighEntropyPayload,
    OversizedPayload,
    TunnelToolDetected,
    PeriodicTraffic,
    VolumeAnomaly,
    NonEchoDataCarrier,
    FragmentationAbuse,
    BidirectionalC2,
    NonStandardPayload,
    StructuredDataPayload,
    EncryptedPayload,
    Base64Payload,
    ShellCommandPayload,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ICMPThreatFinding {
    pub threat_type: ICMPThreatType,
    pub source_ip: String,
    pub dest_ip: String,
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub payload_size: usize,
    pub entropy: f64,
    pub confidence: f64,
    pub description: String,
    pub tool_name: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ICMPPacket {
    pub source_ip: String,
    pub dest_ip: String,
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub sequence: u16,
    pub identifier: u16,
    pub payload: Vec<u8>,
    pub total_size: usize,
    pub is_fragmented: bool,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ICMPAnalysisResult {
    pub is_covert: bool,
    pub packets_analyzed: u32,
    pub findings: Vec<ICMPThreatFinding>,
    pub tunnel_sessions: Vec<(String, String)>,
    pub estimated_data_volume: u64,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ICMPScanStats {
    pub total_packets: u64,
    pub covert_detections: u64,
    pub tunnel_detections: u64,
    pub high_entropy_count: u64,
    pub oversized_count: u64,
    pub volume_anomalies: u64,
    pub estimated_exfil_bytes: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ICMPDetectorConfig {
    pub enabled: bool,
    pub max_normal_payload: usize,
    pub entropy_threshold: f64,
    pub volume_threshold_per_min: u64,
    pub detect_tunnels: bool,
    pub detect_entropy: bool,
    pub detect_volume: bool,
    pub detect_periodicity: bool,
    pub min_confidence: f64,
    pub memory_budget_bytes: usize,
}

impl Default for ICMPDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_normal_payload: NORMAL_ICMP_PAYLOAD_MAX,
            entropy_threshold: HIGH_ENTROPY_THRESHOLD,
            volume_threshold_per_min: VOLUME_THRESHOLD_PER_MIN,
            detect_tunnels: true,
            detect_entropy: true,
            detect_volume: true,
            detect_periodicity: true,
            min_confidence: 0.5,
            memory_budget_bytes: 32 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ICMPToolSig {
    pub name: String,
    pub pattern: String,
    pub severity: f64,
}

#[derive(Debug, Clone, Default)]
struct FlowTracker {
    packet_count: u64,
    total_bytes: u64,
    payload_sizes: Vec<usize>,
    timestamps: Vec<u64>,
    entropies: Vec<f64>,
    first_seen: u64,
    last_seen: u64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct ICMPCovertChannelDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<ICMPScanStats>>,
    result_cache: TieredCache<String, ICMPAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    packet_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, ICMPScanStats>>,
    metrics: MemoryMetrics,
    flow_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, ICMPAnalysisResult>>,
    tool_sig_db: PagedMemory<ICMPToolSig>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    config: RwLock<ICMPDetectorConfig>,
    stats: RwLock<ICMPScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_packets: AtomicU64,
    flow_tracker: RwLock<HashMap<String, FlowTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl ICMPCovertChannelDetector {
    pub fn new() -> Self {
        let cfg = ICMPDetectorConfig::default();
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            packet_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, ICMPScanStats::default(),
                |acc: &mut ICMPScanStats, vals: &[f64]| { acc.total_packets += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(cfg.memory_budget_bytes),
            flow_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            tool_sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(cfg),
            stats: RwLock::new(ICMPScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_packets: AtomicU64::new(0),
            flow_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_packet(&self, pkt: &ICMPPacket) -> Option<ICMPAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let cfg = self.config.read().clone();
        if !cfg.enabled { return None; }
        let start = std::time::Instant::now();
        self.total_packets.fetch_add(1, Ordering::Relaxed);

        let flow_key = format!("{}→{}", pkt.source_ip, pkt.dest_ip);
        let entropy = Self::shannon_entropy(&pkt.payload);

        // Update flow tracker
        {
            let mut tracker = self.flow_tracker.write();
            let flow = tracker.entry(flow_key.clone()).or_default();
            flow.packet_count += 1;
            flow.total_bytes += pkt.payload.len() as u64;
            flow.payload_sizes.push(pkt.payload.len());
            flow.timestamps.push(pkt.timestamp);
            flow.entropies.push(entropy);
            if flow.first_seen == 0 { flow.first_seen = pkt.timestamp; }
            flow.last_seen = pkt.timestamp;
            // Keep bounded
            if flow.payload_sizes.len() > 1000 {
                flow.payload_sizes.drain(..500);
                flow.timestamps.drain(..500);
                flow.entropies.drain(..500);
            }
        }

        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        // Check payload size
        if pkt.payload.len() > cfg.max_normal_payload {
            findings.push(ICMPThreatFinding {
                threat_type: ICMPThreatType::OversizedPayload,
                source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                payload_size: pkt.payload.len(), entropy,
                confidence: (0.5 + (pkt.payload.len() as f64 / 1024.0).min(0.4)),
                description: format!("Oversized ICMP payload: {} bytes (max normal: {})",
                    pkt.payload.len(), cfg.max_normal_payload),
                tool_name: None, mitre_id: "T1095".into(), timestamp: pkt.timestamp,
            });
            mitre_ids.insert("T1095".into());
        }

        // Check entropy
        if cfg.detect_entropy && entropy > cfg.entropy_threshold && pkt.payload.len() > 16 {
            let tt = if entropy > 7.5 { ICMPThreatType::EncryptedPayload }
                else { ICMPThreatType::HighEntropyPayload };
            findings.push(ICMPThreatFinding {
                threat_type: tt,
                source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                payload_size: pkt.payload.len(), entropy,
                confidence: (0.5 + (entropy - cfg.entropy_threshold) * 0.3).min(0.95),
                description: format!("High entropy ICMP payload: {:.2} bits/byte ({} bytes)",
                    entropy, pkt.payload.len()),
                tool_name: None, mitre_id: "T1048".into(), timestamp: pkt.timestamp,
            });
            mitre_ids.insert("T1048".into());
        }

        // Check for non-standard payload patterns
        if !pkt.payload.is_empty() && !Self::is_standard_ping_payload(&pkt.payload) {
            // Check for ASCII/shell commands
            let ascii_ratio = pkt.payload.iter().filter(|&&b| b >= 0x20 && b < 0x7f).count() as f64
                / pkt.payload.len() as f64;
            if ascii_ratio > 0.8 && pkt.payload.len() > 8 {
                let text = String::from_utf8_lossy(&pkt.payload);
                let has_shell = text.contains("sh ") || text.contains("cmd") || text.contains("exec")
                    || text.contains("bash") || text.contains("whoami") || text.contains("pwd");
                if has_shell {
                    findings.push(ICMPThreatFinding {
                        threat_type: ICMPThreatType::ShellCommandPayload,
                        source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                        icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                        payload_size: pkt.payload.len(), entropy,
                        confidence: 0.9,
                        description: "Shell command detected in ICMP payload".into(),
                        tool_name: None, mitre_id: "T1095".into(), timestamp: pkt.timestamp,
                    });
                    mitre_ids.insert("T1095".into());
                } else if pkt.payload.len() > 32 {
                    findings.push(ICMPThreatFinding {
                        threat_type: ICMPThreatType::NonStandardPayload,
                        source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                        icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                        payload_size: pkt.payload.len(), entropy,
                        confidence: 0.55,
                        description: format!("Non-standard ASCII payload in ICMP ({:.0}% printable)",
                            ascii_ratio * 100.0),
                        tool_name: None, mitre_id: "T1095".into(), timestamp: pkt.timestamp,
                    });
                    mitre_ids.insert("T1095".into());
                }
            }

            // Check for base64-encoded data
            let b64_ratio = pkt.payload.iter()
                .filter(|&&b| b.is_ascii_alphanumeric() || b == b'+' || b == b'/' || b == b'=')
                .count() as f64 / pkt.payload.len() as f64;
            if b64_ratio > 0.95 && pkt.payload.len() > 32 {
                findings.push(ICMPThreatFinding {
                    threat_type: ICMPThreatType::Base64Payload,
                    source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                    icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                    payload_size: pkt.payload.len(), entropy,
                    confidence: 0.7,
                    description: format!("Base64-encoded data in ICMP ({} bytes)", pkt.payload.len()),
                    tool_name: None, mitre_id: "T1048".into(), timestamp: pkt.timestamp,
                });
                mitre_ids.insert("T1048".into());
            }
        }

        // Check fragmentation abuse
        if pkt.is_fragmented && pkt.total_size > 1500 {
            findings.push(ICMPThreatFinding {
                threat_type: ICMPThreatType::FragmentationAbuse,
                source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                payload_size: pkt.total_size, entropy,
                confidence: 0.7,
                description: format!("Fragmented ICMP: {} bytes total", pkt.total_size),
                tool_name: None, mitre_id: "T1048".into(), timestamp: pkt.timestamp,
            });
            mitre_ids.insert("T1048".into());
        }

        // Check non-echo ICMP carrying data
        if pkt.icmp_type != 0 && pkt.icmp_type != 8 && pkt.payload.len() > 16 {
            findings.push(ICMPThreatFinding {
                threat_type: ICMPThreatType::NonEchoDataCarrier,
                source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                payload_size: pkt.payload.len(), entropy,
                confidence: 0.65,
                description: format!("Non-echo ICMP type {} with {} byte payload",
                    pkt.icmp_type, pkt.payload.len()),
                tool_name: None, mitre_id: "T1095".into(), timestamp: pkt.timestamp,
            });
            mitre_ids.insert("T1095".into());
        }

        // Check flow-level anomalies
        if cfg.detect_volume || cfg.detect_periodicity {
            let tracker = self.flow_tracker.read();
            if let Some(flow) = tracker.get(&flow_key) {
                // Volume check
                if cfg.detect_volume && flow.packet_count > cfg.volume_threshold_per_min {
                    let duration = (flow.last_seen - flow.first_seen).max(1);
                    let rate = flow.packet_count as f64 / (duration as f64 / 60.0);
                    if rate > cfg.volume_threshold_per_min as f64 {
                        findings.push(ICMPThreatFinding {
                            threat_type: ICMPThreatType::VolumeAnomaly,
                            source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                            icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                            payload_size: pkt.payload.len(), entropy,
                            confidence: (0.6 + (rate / 500.0).min(0.3)),
                            description: format!("ICMP volume anomaly: {:.0} pkt/min, {} total bytes",
                                rate, flow.total_bytes),
                            tool_name: None, mitre_id: "T1048".into(), timestamp: pkt.timestamp,
                        });
                        mitre_ids.insert("T1048".into());
                    }
                }

                // Periodicity check
                if cfg.detect_periodicity && flow.timestamps.len() >= 10 {
                    let intervals: Vec<f64> = flow.timestamps.windows(2)
                        .map(|w| (w[1] - w[0]) as f64)
                        .collect();
                    if !intervals.is_empty() {
                        let mean = intervals.iter().sum::<f64>() / intervals.len() as f64;
                        let variance = intervals.iter().map(|&i| (i - mean).powi(2)).sum::<f64>()
                            / intervals.len() as f64;
                        let cv = if mean > 0.0 { variance.sqrt() / mean } else { 1.0 };
                        if cv < 0.3 && mean > 0.0 { // Very regular intervals
                            findings.push(ICMPThreatFinding {
                                threat_type: ICMPThreatType::PeriodicTraffic,
                                source_ip: pkt.source_ip.clone(), dest_ip: pkt.dest_ip.clone(),
                                icmp_type: pkt.icmp_type, icmp_code: pkt.icmp_code,
                                payload_size: pkt.payload.len(), entropy,
                                confidence: (0.7 + (1.0 - cv) * 0.2).min(0.95),
                                description: format!("Periodic ICMP: {:.1}s interval (CV={:.2})",
                                    mean, cv),
                                tool_name: None, mitre_id: "T1095".into(), timestamp: pkt.timestamp,
                            });
                            mitre_ids.insert("T1095".into());
                        }
                    }
                }
            }
        }

        self.flow_diffs.write().record_insert(
            flow_key.clone(),
            format!("type={},size={},ent={:.2}", pkt.icmp_type, pkt.payload.len(), entropy),
        );

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_covert = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let tunnel_sessions = if is_covert {
            vec![(pkt.source_ip.clone(), pkt.dest_ip.clone())]
        } else { Vec::new() };

        let result = ICMPAnalysisResult {
            is_covert,
            packets_analyzed: 1,
            findings,
            tunnel_sessions,
            estimated_data_volume: pkt.payload.len() as u64,
            risk_score,
            severity: severity.clone(),
            mitre_ids: mitre_vec.clone(),
            analysis_time_ms: elapsed,
        };

        self.result_cache.insert(flow_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(flow_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &flow_key);
                m.set(k, flow_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(flow_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut stats = self.stats.write();
            stats.total_packets += 1;
            if is_covert {
                stats.covert_detections += 1;
                stats.estimated_exfil_bytes += pkt.payload.len() as u64;
            }
            let n = stats.total_packets as f64;
            stats.avg_analysis_time_ms = stats.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_covert {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "icmp_covert_channel".into(),
                title: format!("ICMP covert channel: {} → {}", pkt.source_ip, pkt.dest_ip),
                details: format!("Risk: {:.1}%, {} findings, payload: {} bytes, entropy: {:.2}",
                    risk_score * 100.0, result.findings.len(), pkt.payload.len(), entropy),
                path: None,
                process_name: None, process_pid: None, verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Block ICMP echo at perimeter firewall".into(),
                    "Rate-limit ICMP traffic".into(),
                    "Inspect ICMP payload content at IDS/IPS".into(),
                    "Restrict ICMP payload sizes".into(),
                ],
                confidence: risk_score,
            });
        }

        Some(result)
    }

    fn is_standard_ping_payload(payload: &[u8]) -> bool {
        for &(_, pattern, expected_size) in STANDARD_PING_PATTERNS {
            if payload.len() == expected_size && payload.windows(pattern.len()).any(|w| w == pattern) {
                return true;
            }
        }
        // Also check for sequential byte patterns (common in default ping)
        if payload.len() >= 8 {
            let sequential = payload.windows(2).filter(|w| w[1] == w[0].wrapping_add(1)).count();
            if sequential > payload.len() / 2 { return true; }
        }
        false
    }

    fn shannon_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        freq.iter().filter(|&&f| f > 0).map(|&f| {
            let p = f as f64 / len;
            -p * p.log2()
        }).sum()
    }

    fn calculate_risk_score(&self, findings: &[ICMPThreatFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                ICMPThreatType::ShellCommandPayload => 1.5,
                ICMPThreatType::TunnelToolDetected => 1.5,
                ICMPThreatType::EncryptedPayload => 1.4,
                ICMPThreatType::BidirectionalC2 => 1.4,
                ICMPThreatType::StructuredDataPayload => 1.2,
                ICMPThreatType::PeriodicTraffic => 1.2,
                ICMPThreatType::VolumeAnomaly => 1.1,
                ICMPThreatType::HighEntropyPayload => 1.1,
                _ => 0.8,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> ICMPScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
