//! Module 160: QuantumThreatDetector — Post-Quantum Cryptographic Vulnerability Detection
//!
//! Detects vulnerabilities related to quantum computing threats, including
//! harvest-now-decrypt-later attacks, weak cryptographic algorithms susceptible
//! to quantum attacks, and monitors post-quantum cryptography migration status.
//!
//! ## Detection Capabilities
//!
//! ### Cryptographic Algorithm Vulnerability
//! - **RSA key weakness**: RSA keys < 4096 bits vulnerable to Shor's algorithm
//! - **ECC vulnerability**: ECDSA/ECDH curves vulnerable to quantum factoring
//! - **DH key exchange**: Classic Diffie-Hellman vulnerable to discrete log
//! - **DSA signatures**: DSA vulnerable to quantum period finding
//! - **SHA-1/MD5 in signatures**: Weakened hash algorithms
//!
//! ### Harvest-Now-Decrypt-Later (HNDL)
//! - **Long-lived encrypted data**: Identifying data encrypted with quantum-
//!   vulnerable algorithms that has long secrecy requirements
//! - **TLS session capture**: Detection of passive TLS recording that could
//!   be decrypted when quantum computers arrive
//! - **VPN traffic recording**: Detection of VPN traffic harvesting
//! - **Encrypted archive targeting**: Monitoring for targeted collection of
//!   encrypted archives for future quantum decryption
//!
//! ### Post-Quantum Migration Status
//! - **PQC algorithm adoption**: Monitoring adoption of NIST PQC standards
//!   (CRYSTALS-Kyber, CRYSTALS-Dilithium, FALCON, SPHINCS+)
//! - **Hybrid mode verification**: Checking for hybrid classical+PQC modes
//! - **Certificate chain PQC readiness**: X.509 certificate PQC compatibility
//! - **Application crypto inventory**: Cataloging all cryptographic usage
//!
//! ## MITRE ATT&CK: T1557, T1040, T1552, T1588.004
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

const VULNERABLE_ALGORITHMS: &[(&str, &str, &str, f64)] = &[
    ("RSA-1024", "RSA 1024-bit key — critically vulnerable to Shor's algorithm", "T1552", 0.9),
    ("RSA-2048", "RSA 2048-bit key — vulnerable to future quantum computers", "T1552", 0.7),
    ("RSA-3072", "RSA 3072-bit key — moderate quantum risk", "T1552", 0.5),
    ("ECDSA-P256", "ECDSA P-256 — vulnerable to quantum period finding", "T1552", 0.7),
    ("ECDSA-P384", "ECDSA P-384 — vulnerable to quantum attacks", "T1552", 0.6),
    ("ECDH-P256", "ECDH P-256 key exchange — quantum vulnerable", "T1557", 0.7),
    ("ECDH-X25519", "ECDH X25519 — quantum vulnerable (still classical best)", "T1557", 0.6),
    ("DH-2048", "Diffie-Hellman 2048-bit — quantum vulnerable", "T1557", 0.7),
    ("DSA-2048", "DSA 2048-bit — quantum vulnerable via discrete log", "T1552", 0.7),
    ("Ed25519", "Ed25519 signatures — quantum vulnerable", "T1552", 0.5),
    ("SHA1-signature", "SHA-1 used in digital signature (weak + quantum)", "T1552", 0.8),
    ("MD5-signature", "MD5 used in signature (broken + quantum)", "T1552", 0.9),
    ("3DES", "3DES encryption — deprecated and quantum-weakened", "T1552", 0.6),
    ("RC4", "RC4 stream cipher — broken, quantum amplifies weakness", "T1552", 0.8),
    ("AES-128", "AES-128 — reduced to ~64-bit security under Grover's", "T1552", 0.4),
];

const HNDL_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("passive_tls_recording", "Passive TLS session recording (HNDL attack)", "T1040", 0.8),
    ("vpn_traffic_capture", "VPN tunnel traffic being captured", "T1040", 0.75),
    ("encrypted_archive_collection", "Systematic collection of encrypted archives", "T1119", 0.7),
    ("long_lived_rsa_encrypted", "Long-lived data encrypted with RSA (HNDL risk)", "T1552", 0.6),
    ("state_actor_harvesting", "Pattern consistent with state-actor HNDL campaign", "T1040", 0.85),
    ("bulk_tls_intercept", "Bulk TLS interception infrastructure detected", "T1557", 0.8),
    ("certificate_downgrade", "Certificate downgrade forcing weaker crypto", "T1557", 0.8),
];

const PQC_ALGORITHMS: &[(&str, &str, &str)] = &[
    ("CRYSTALS-Kyber", "NIST PQC KEM standard (ML-KEM)", "key_exchange"),
    ("CRYSTALS-Dilithium", "NIST PQC signature standard (ML-DSA)", "signature"),
    ("FALCON", "NIST PQC signature (compact, lattice-based)", "signature"),
    ("SPHINCS+", "NIST PQC signature (hash-based, conservative)", "signature"),
    ("BIKE", "PQC KEM candidate (code-based)", "key_exchange"),
    ("HQC", "PQC KEM candidate (code-based)", "key_exchange"),
    ("Classic-McEliece", "PQC KEM (code-based, large keys)", "key_exchange"),
    ("X-Wing", "Hybrid X25519+ML-KEM-768 key exchange", "hybrid"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum QuantumThreatType {
    VulnerableAlgorithm, HarvestNowDecryptLater, WeakKeySize,
    MissingPQCMigration, CertificateDowngrade, PassiveTLSCapture,
    BulkInterception, LongLivedWeakCrypto, PQCAdoptionGap,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct QuantumFinding {
    pub threat_type: QuantumThreatType,
    pub confidence: f64,
    pub description: String,
    pub algorithm: Option<String>,
    pub key_size: Option<u32>,
    pub pqc_alternative: Option<String>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct QuantumEvent {
    pub event_type: String,
    pub algorithm: Option<String>,
    pub key_size: Option<u32>,
    pub protocol: Option<String>,
    pub certificate_chain: Vec<String>,
    pub pqc_support: Vec<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct QuantumAnalysisResult {
    pub has_vulnerabilities: bool,
    pub findings: Vec<QuantumFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct QuantumScanStats {
    pub total_events: u64,
    pub vulnerable_algorithms: u64,
    pub hndl_detections: u64,
    pub pqc_gaps: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct QuantumSigEntry { pub algo: String, pub severity: f64 }

pub struct QuantumThreatDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<QuantumScanStats>>,
    result_cache: TieredCache<String, QuantumAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    quantum_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, QuantumScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, QuantumAnalysisResult>>,
    sig_db: PagedMemory<QuantumSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<QuantumScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl QuantumThreatDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            quantum_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, QuantumScanStats::default(),
                |acc: &mut QuantumScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(QuantumScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(128)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &QuantumEvent) -> Option<QuantumAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("quantum:{}:{}", event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();

        let ind_text = format!("{} {} {}",
            event.event_type, event.algorithm.as_deref().unwrap_or(""),
            event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // 1. Vulnerable algorithm detection
        for &(algo, desc, mitre, conf) in VULNERABLE_ALGORITHMS {
            if ind_lower.contains(&algo.to_lowercase()) {
                findings.push(QuantumFinding {
                    threat_type: QuantumThreatType::VulnerableAlgorithm,
                    confidence: conf, description: desc.to_string(),
                    algorithm: Some(algo.to_string()), key_size: event.key_size,
                    pqc_alternative: Some(if algo.contains("RSA") || algo.contains("DH") || algo.contains("ECDH") {
                        "CRYSTALS-Kyber (ML-KEM)".into()
                    } else { "CRYSTALS-Dilithium (ML-DSA)".into() }),
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 2. HNDL indicators
        for &(pattern, desc, mitre, conf) in HNDL_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                findings.push(QuantumFinding {
                    threat_type: QuantumThreatType::HarvestNowDecryptLater,
                    confidence: conf, description: desc.to_string(),
                    algorithm: event.algorithm.clone(), key_size: None,
                    pqc_alternative: None, mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // 3. PQC adoption gap
        if event.pqc_support.is_empty() && !findings.is_empty() {
            findings.push(QuantumFinding {
                threat_type: QuantumThreatType::PQCAdoptionGap,
                confidence: 0.5,
                description: "No post-quantum cryptographic algorithms in use".into(),
                algorithm: None, key_size: None,
                pqc_alternative: Some("Migrate to CRYSTALS-Kyber + CRYSTALS-Dilithium".into()),
                mitre_id: "T1552".into(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1552".into());
        }

        let risk_score = if findings.is_empty() { 0.0 } else {
            let s: f64 = findings.iter().map(|f| f.confidence).sum();
            (s / (findings.len() as f64 * 1.5)).min(1.0)
        };
        self.risk_computer.write().push(risk_score);
        let severity = if risk_score >= 0.85 { Severity::Critical } else if risk_score >= 0.65 { Severity::High }
            else if risk_score >= 0.45 { Severity::Medium } else if risk_score >= 0.25 { Severity::Low }
            else { Severity::Info };
        let has_vulns = risk_score > 0.4;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = QuantumAnalysisResult {
            has_vulnerabilities: has_vulns, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
          if has_vulns { for f in &result.findings { match f.threat_type {
              QuantumThreatType::VulnerableAlgorithm => s.vulnerable_algorithms += 1,
              QuantumThreatType::HarvestNowDecryptLater => s.hndl_detections += 1,
              QuantumThreatType::PQCAdoptionGap => s.pqc_gaps += 1, _ => {} } } }
          let n = s.total_events as f64;
          s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if has_vulns {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "quantum_threat_detector".into(),
                title: format!("QUANTUM THREAT: {} findings", result.findings.len()),
                details: format!("Risk {:.1}%, algo: {:?}", risk_score*100.0, event.algorithm),
                path: event.file_path.clone(), process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None, mitre_ids: mitre_vec,
                remediation: vec![
                    "Migrate to NIST PQC standards (ML-KEM, ML-DSA)".into(),
                    "Use hybrid classical+PQC modes during transition".into(),
                    "Inventory all cryptographic usage for migration planning".into(),
                ], confidence: risk_score,
            });
        }
        Some(result)
    }

    pub fn stats(&self) -> QuantumScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
