//! Module 127: EndpointSecurityBypass — ES Framework Tampering Detection
//!
//! Detects attempts to bypass, disable, or tamper with macOS Endpoint Security
//! framework (ESF) clients. ESF is the primary security event notification
//! system that security tools depend on for visibility.
//!
//! ## Detection Capabilities
//!
//! - **ES client unloading**: Attempts to unload ES client system extensions
//! - **System extension removal**: systemextensionsctl uninstall abuse
//! - **ES event suppression**: Muting ES events for specific processes
//! - **Process hiding**: Techniques to hide from ES process monitoring
//! - **KEXT vs SystemExtension migration abuse**: Loading legacy KEXTs
//! - **MDM profile removal**: Removing MDM profiles that enforce ES clients
//! - **Full Disk Access revocation**: Revoking FDA from security tools
//! - **LaunchDaemon tampering**: Modifying security tool launch daemons
//! - **Code injection into ES clients**: Dylib injection into security tools
//! - **Network extension bypass**: Circumventing content filter extensions
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;

const ES_BYPASS_TECHNIQUES: &[(&str, &str, &str, f64)] = &[
    ("systemextensionsctl uninstall", "System extension removal", "T1562.001", 0.9),
    ("systemextensionsctl reset", "System extension reset", "T1562.001", 0.85),
    ("kextunload", "KEXT unloading (security driver)", "T1562.001", 0.8),
    ("kextload", "KEXT loading (potential rootkit)", "T1547.006", 0.7),
    ("kmutil load", "Kernel module loading", "T1547.006", 0.7),
    ("kmutil unload", "Kernel module unloading", "T1562.001", 0.8),
    ("launchctl remove", "LaunchDaemon/Agent removal", "T1562.001", 0.6),
    ("launchctl unload", "LaunchDaemon/Agent unloading", "T1562.001", 0.6),
    ("launchctl bootout", "LaunchDaemon boot-out", "T1562.001", 0.7),
    ("pkill -9", "Force kill (security process)", "T1562.001", 0.5),
    ("kill -9", "Force kill signal", "T1562.001", 0.4),
    ("killall", "Kill all instances", "T1562.001", 0.4),
    ("profiles remove", "MDM profile removal", "T1562.001", 0.7),
    ("profiles -R", "MDM profile removal flag", "T1562.001", 0.7),
    ("tccutil reset", "TCC permission reset for security tool", "T1562.001", 0.6),
    ("csrutil disable", "SIP disable (enables ES bypass)", "T1553.006", 0.95),
    ("nvram boot-args", "Boot arguments modification", "T1542.001", 0.8),
    ("bputil", "Boot policy utility (security downgrade)", "T1553.006", 0.8),
    ("DYLD_INSERT_LIBRARIES", "Dylib injection env var", "T1574.006", 0.8),
    ("DYLD_FRAMEWORK_PATH", "Framework path override", "T1574.006", 0.6),
];

const SECURITY_TOOL_PROCESSES: &[(&str, &str)] = &[
    ("com.apple.endpointsecurityd", "Apple Endpoint Security daemon"),
    ("syspolicyd", "System policy daemon"),
    ("XProtect", "Apple XProtect"),
    ("MRT", "Apple Malware Removal Tool"),
    ("com.crowdstrike", "CrowdStrike Falcon"),
    ("com.sentinelone", "SentinelOne"),
    ("com.carbonblack", "VMware Carbon Black"),
    ("com.microsoft.wdav", "Microsoft Defender"),
    ("com.sophos", "Sophos"),
    ("com.malwarebytes", "Malwarebytes"),
    ("com.jamf", "Jamf Protect"),
    ("osqueryd", "osquery daemon"),
    ("com.elastic.endpoint", "Elastic Endpoint"),
];

const SECURITY_LAUNCH_DAEMONS: &[(&str, &str, f64)] = &[
    ("/Library/LaunchDaemons/com.crowdstrike", "CrowdStrike daemon plist", 0.9),
    ("/Library/LaunchDaemons/com.sentinelone", "SentinelOne daemon plist", 0.9),
    ("/Library/LaunchDaemons/com.carbonblack", "Carbon Black daemon plist", 0.9),
    ("/Library/LaunchDaemons/com.microsoft.wdav", "Defender daemon plist", 0.9),
    ("/Library/SystemExtensions", "System extensions directory", 0.7),
    ("/Library/LaunchDaemons/com.apple.endpoint", "Apple ES daemon", 0.85),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ESBypassType {
    SystemExtensionRemoval,
    KEXTManipulation,
    LaunchDaemonTampering,
    SecurityProcessKill,
    MDMProfileRemoval,
    SIPDisable,
    TCCRevocation,
    DylibInjection,
    BootPolicyChange,
    NVRAMModification,
    SecurityToolUninstall,
    EventSuppression,
    NetworkExtensionBypass,
    FDARevocation,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ESBypassFinding {
    pub bypass_type: ESBypassType,
    pub confidence: f64,
    pub description: String,
    pub target_tool: Option<String>,
    pub command_line: Option<String>,
    pub mitre_id: String,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ESEvent {
    pub event_type: String,
    pub process_name: String,
    pub process_pid: u32,
    pub command_line: Option<String>,
    pub file_path: Option<String>,
    pub target_process: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ESAnalysisResult {
    pub is_bypass: bool,
    pub events_analyzed: u32,
    pub findings: Vec<ESBypassFinding>,
    pub targeted_tools: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ESScanStats {
    pub total_events: u64,
    pub bypass_detections: u64,
    pub tool_kill_detections: u64,
    pub extension_removals: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ESSigEntry { pub pattern: String, pub description: String, pub severity: f64 }

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct EndpointSecurityBypassDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<ESScanStats>>,
    result_cache: TieredCache<String, ESAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    event_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, ESScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, ESAnalysisResult>>,
    sig_db: PagedMemory<ESSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<ESScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl EndpointSecurityBypassDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            event_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, ESScanStats::default(),
                |acc: &mut ESScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(ESScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &ESEvent) -> Option<ESAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.process_name, event.process_pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut targeted_tools = Vec::new();

        let event_text = format!("{} {} {}",
            event.command_line.as_deref().unwrap_or(""),
            event.file_path.as_deref().unwrap_or(""),
            event.target_process.as_deref().unwrap_or(""));

        // Check bypass techniques
        for &(pattern, desc, mitre, conf) in ES_BYPASS_TECHNIQUES {
            if event_text.to_lowercase().contains(&pattern.to_lowercase()) {
                let bt = if pattern.contains("systemextensionsctl") { ESBypassType::SystemExtensionRemoval }
                    else if pattern.contains("kext") || pattern.contains("kmutil") { ESBypassType::KEXTManipulation }
                    else if pattern.contains("launchctl") { ESBypassType::LaunchDaemonTampering }
                    else if pattern.contains("kill") { ESBypassType::SecurityProcessKill }
                    else if pattern.contains("profiles") { ESBypassType::MDMProfileRemoval }
                    else if pattern.contains("csrutil") { ESBypassType::SIPDisable }
                    else if pattern.contains("tccutil") { ESBypassType::TCCRevocation }
                    else if pattern.contains("DYLD") { ESBypassType::DylibInjection }
                    else if pattern.contains("nvram") { ESBypassType::NVRAMModification }
                    else if pattern.contains("bputil") { ESBypassType::BootPolicyChange }
                    else { ESBypassType::SecurityToolUninstall };

                // Check if targeting a known security tool
                let mut is_targeting_security = false;
                for &(tool_id, tool_name) in SECURITY_TOOL_PROCESSES {
                    if event_text.to_lowercase().contains(&tool_id.to_lowercase()) {
                        is_targeting_security = true;
                        targeted_tools.push(tool_name.to_string());
                    }
                }

                let final_conf = if is_targeting_security { (conf + 0.15).min(0.99) } else { conf };

                findings.push(ESBypassFinding {
                    bypass_type: bt, confidence: final_conf,
                    description: if is_targeting_security {
                        format!("{} (targeting security tool)", desc)
                    } else { desc.to_string() },
                    target_tool: targeted_tools.last().cloned(),
                    command_line: event.command_line.clone(),
                    mitre_id: mitre.into(),
                    process_name: Some(event.process_name.clone()),
                    process_pid: Some(event.process_pid),
                    file_path: event.file_path.clone(),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        // Check file access to security launch daemons
        if let Some(ref path) = event.file_path {
            for &(daemon_path, desc, conf) in SECURITY_LAUNCH_DAEMONS {
                if path.to_lowercase().contains(&daemon_path.to_lowercase()) {
                    let is_modify = event.event_type.contains("write") || event.event_type.contains("delete")
                        || event.event_type.contains("rename") || event.event_type.contains("unlink");
                    if is_modify {
                        findings.push(ESBypassFinding {
                            bypass_type: ESBypassType::LaunchDaemonTampering,
                            confidence: conf,
                            description: format!("{} modification: {}", desc, path),
                            target_tool: Some(desc.to_string()),
                            command_line: event.command_line.clone(),
                            mitre_id: "T1562.001".into(),
                            process_name: Some(event.process_name.clone()),
                            process_pid: Some(event.process_pid),
                            file_path: Some(path.clone()),
                            timestamp: event.timestamp,
                        });
                        mitre_ids.insert("T1562.001".into());
                        targeted_tools.push(desc.to_string());
                    }
                }
            }
        }

        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("proc={},type={}", event.process_name, event.event_type));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_bypass = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = ESAnalysisResult {
            is_bypass, events_analyzed: 1, findings, targeted_tools,
            risk_score, severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_events += 1;
            if is_bypass { s.bypass_detections += 1; }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if is_bypass {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "endpoint_security_bypass".into(),
                title: format!("ES bypass: {} (pid {})", event.process_name, event.process_pid),
                details: format!("Risk: {:.1}%, {} findings", risk_score * 100.0, result.findings.len()),
                path: event.file_path.clone(),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid), verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Verify SIP status: csrutil status".into(),
                    "Check system extensions: systemextensionsctl list".into(),
                    "Verify security tool daemons are running".into(),
                    "Review MDM profile status".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[ESBypassFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.bypass_type {
                ESBypassType::SIPDisable => 1.5,
                ESBypassType::SystemExtensionRemoval => 1.4,
                ESBypassType::KEXTManipulation => 1.3,
                ESBypassType::SecurityProcessKill => 1.3,
                ESBypassType::DylibInjection => 1.3,
                ESBypassType::LaunchDaemonTampering => 1.2,
                ESBypassType::BootPolicyChange => 1.2,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> ESScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
