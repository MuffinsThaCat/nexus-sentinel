//! Module 129: AppleScriptAbuseDetector — osascript/JXA Malicious Automation Detection
//!
//! Detects malicious use of AppleScript (osascript), JavaScript for Automation
//! (JXA), and Automator workflows. These are native macOS scripting technologies
//! frequently abused by threat actors because they are signed by Apple, bypass
//! many security controls, and can perform privileged operations via Apple Events.
//!
//! ## Detection Capabilities
//!
//! - **Credential harvesting**: Fake dialog boxes requesting passwords, admin
//!   credential phishing via `display dialog` with hidden answers
//! - **System reconnaissance**: AppleScript gathering system info, network
//!   config, installed apps, running processes, user accounts
//! - **File staging & exfiltration**: AppleScript reading sensitive files,
//!   creating archives, uploading via curl/wget
//! - **Persistence installation**: AppleScript creating LaunchAgents/Daemons,
//!   login items, cron jobs, Folder Actions
//! - **Application control**: Scripting Safari, Mail, Terminal, Finder for
//!   data theft, backdoor installation, browser manipulation
//! - **JXA-specific abuse**: ObjC bridge for direct framework access,
//!   $.NSTask for shell command execution, WebKit exploitation
//! - **Process injection via Apple Events**: Sending Apple Events to privileged
//!   processes to execute code in their context
//! - **Automator workflow abuse**: Malicious .workflow bundles, Quick Actions
//! - **Shell command execution**: `do shell script` with privilege escalation
//! - **Obfuscated scripts**: Compiled .scpt, encoded strings, run-only scripts
//! - **Known malware families**: Shlayer, XCSSET, Silver Sparrow, OSAMiner,
//!   DazzleSpy, Atomic Stealer patterns
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1059.002 — AppleScript
//! - T1059.007 — JavaScript (JXA)
//! - T1106 — Native API
//! - T1056.002 — GUI Input Capture
//! - T1547.001 — Registry Run Keys / Startup Folder (LaunchAgent analogy)
//! - T1071.001 — Web Protocols (data exfil)
//! - T1082 — System Information Discovery
//! - T1033 — System Owner/User Discovery
//! - T1057 — Process Discovery
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Constants ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 7;
const HISTORY_PER_LEVEL: usize = 48;
const CACHE_MAX: usize = 30_000;
const STATS_WINDOW: usize = 256;
const VQ_CODEBOOK_SIZE: usize = 64;
const VQ_VECTOR_DIM: usize = 12;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 128;
const MMAP_CHUNK_SIZE: usize = 64 * 1024;
const RAPID_EXECUTION_THRESHOLD: u32 = 5;
const RAPID_EXECUTION_WINDOW_SECS: u64 = 30;

// ── Credential Harvesting Patterns ───────────────────────────────────────────

const CREDENTIAL_HARVEST_PATTERNS: &[(&str, &str, f64)] = &[
    ("display dialog.*password", "Password prompt via dialog", 0.9),
    ("display dialog.*with hidden answer", "Hidden-answer dialog (password phishing)", 0.92),
    ("display dialog.*keychain", "Keychain unlock phishing dialog", 0.95),
    ("display dialog.*administrator", "Admin privilege phishing", 0.88),
    ("display dialog.*System Preferences", "System Preferences impersonation", 0.9),
    ("display dialog.*macOS needs", "OS update impersonation phishing", 0.9),
    ("display dialog.*Apple ID", "Apple ID phishing", 0.92),
    ("display dialog.*iCloud", "iCloud credential phishing", 0.88),
    ("display dialog.*WiFi", "WiFi password phishing", 0.7),
    ("display dialog.*with icon caution", "Caution icon urgency dialog", 0.5),
    ("display dialog.*with icon stop", "Stop icon scare dialog", 0.55),
    ("text returned of.*display dialog", "Capturing dialog text return", 0.85),
    ("display alert.*password", "Password alert dialog", 0.85),
    ("choose from list.*password", "Password list chooser", 0.7),
];

// ── Reconnaissance Patterns ──────────────────────────────────────────────────

const RECON_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("system info", "System information gathering", "T1082", 0.5),
    ("system version", "OS version enumeration", "T1082", 0.4),
    ("computer name", "Computer name discovery", "T1082", 0.4),
    ("do shell script.*whoami", "User identity discovery", "T1033", 0.6),
    ("do shell script.*id", "User ID/group discovery", "T1033", 0.5),
    ("do shell script.*ifconfig", "Network config discovery", "T1016", 0.5),
    ("do shell script.*networksetup", "Network setup enumeration", "T1016", 0.5),
    ("do shell script.*sw_vers", "Software version enumeration", "T1082", 0.4),
    ("do shell script.*system_profiler", "System profiler enumeration", "T1082", 0.6),
    ("do shell script.*sysctl", "Kernel parameter enumeration", "T1082", 0.5),
    ("do shell script.*ps aux", "Process listing", "T1057", 0.6),
    ("do shell script.*launchctl list", "Service enumeration", "T1057", 0.5),
    ("do shell script.*defaults read", "Defaults/preferences reading", "T1082", 0.4),
    ("every process", "AppleScript process enumeration", "T1057", 0.5),
    ("name of every application process", "Application process listing", "T1057", 0.55),
    ("path to applications folder", "Applications directory discovery", "T1083", 0.4),
    ("do shell script.*ls /Applications", "Application listing via shell", "T1083", 0.5),
    ("do shell script.*dscl", "Directory Services query (user enum)", "T1087.001", 0.7),
    ("do shell script.*scutil", "System config utility query", "T1082", 0.5),
    ("do shell script.*ioreg", "I/O Registry enumeration (hardware)", "T1082", 0.5),
];

// ── Persistence Patterns ─────────────────────────────────────────────────────

const PERSISTENCE_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("do shell script.*LaunchAgents", "LaunchAgent persistence", "T1543.001", 0.85),
    ("do shell script.*LaunchDaemons", "LaunchDaemon persistence", "T1543.004", 0.9),
    ("do shell script.*launchctl load", "Loading LaunchAgent/Daemon", "T1543.001", 0.8),
    ("do shell script.*launchctl bootstrap", "Bootstrapping launch service", "T1543.001", 0.8),
    ("do shell script.*crontab", "Cron job persistence", "T1053.003", 0.75),
    ("do shell script.*at ", "At job scheduling", "T1053.003", 0.65),
    ("login item", "Login item persistence", "T1547.015", 0.7),
    ("make new login item", "Creating login item", "T1547.015", 0.8),
    ("Folder Actions", "Folder Action persistence", "T1546.015", 0.8),
    ("attach action to", "Attaching Folder Action", "T1546.015", 0.85),
    ("do shell script.*plist", "Plist manipulation (persistence)", "T1543.001", 0.6),
    ("do shell script.*defaults write.*LoginHook", "Login hook persistence", "T1037.002", 0.9),
    ("do shell script.*defaults write.*LogoutHook", "Logout hook persistence", "T1037.002", 0.85),
];

// ── Data Theft / Exfiltration Patterns ───────────────────────────────────────

const EXFIL_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("do shell script.*curl.*-d", "Data exfiltration via curl POST", "T1048", 0.8),
    ("do shell script.*curl.*-F", "File upload via curl", "T1048", 0.8),
    ("do shell script.*curl.*-X POST", "HTTP POST exfiltration", "T1048", 0.75),
    ("do shell script.*wget", "wget download/exfil", "T1105", 0.6),
    ("do shell script.*scp", "SCP file transfer", "T1048", 0.7),
    ("do shell script.*rsync", "Rsync file transfer", "T1048", 0.6),
    ("do shell script.*base64", "Base64 encoding (data staging)", "T1132.001", 0.6),
    ("do shell script.*zip.*-P", "Password-protected ZIP creation", "T1560.001", 0.8),
    ("do shell script.*openssl.*enc", "OpenSSL encryption (staging)", "T1560.001", 0.7),
    ("do shell script.*pbcopy", "Clipboard data capture", "T1115", 0.5),
    ("the clipboard", "AppleScript clipboard access", "T1115", 0.5),
    ("read.*of file", "File content reading", "T1005", 0.5),
    ("do shell script.*cat ", "File content reading via cat", "T1005", 0.5),
    ("do shell script.*find.*-name", "File search (sensitive data)", "T1083", 0.5),
    ("do shell script.*mdfind", "Spotlight search for files", "T1083", 0.5),
    ("do shell script.*sqlite3", "SQLite database query", "T1005", 0.6),
    ("do shell script.*security find", "Keychain credential theft", "T1555.001", 0.85),
    ("do shell script.*screencapture", "Screenshot capture", "T1113", 0.7),
];

// ── JXA-Specific Patterns ────────────────────────────────────────────────────

const JXA_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("ObjC.import", "JXA ObjC bridge import", "T1059.007", 0.6),
    ("$.NSTask", "JXA NSTask execution", "T1059.007", 0.75),
    ("$.NSPipe", "JXA NSPipe for I/O", "T1059.007", 0.6),
    ("$.NSString", "JXA Foundation string manipulation", "T1059.007", 0.4),
    ("$.NSData", "JXA NSData handling", "T1059.007", 0.4),
    ("$.NSURL", "JXA URL handling", "T1059.007", 0.5),
    ("$.NSMutableURLRequest", "JXA HTTP request creation", "T1071.001", 0.7),
    ("$.NSURLSession", "JXA URL session (network)", "T1071.001", 0.65),
    ("$.NSAppleScript", "JXA nested AppleScript execution", "T1059.002", 0.7),
    ("$.NSFileManager", "JXA file system operations", "T1083", 0.5),
    ("$.NSProcessInfo", "JXA process information", "T1082", 0.5),
    ("$.NSHost", "JXA host information", "T1082", 0.5),
    ("eval(", "JXA eval execution (code injection)", "T1059.007", 0.7),
    ("Function(", "JXA Function constructor (obfuscation)", "T1027", 0.7),
    ("Automation.getDisplayString", "JXA display string manipulation", "T1059.007", 0.4),
    ("currentApplication()", "JXA current app context", "T1059.007", 0.3),
];

// ── Shell Execution Patterns ─────────────────────────────────────────────────

const SHELL_EXEC_PATTERNS: &[(&str, &str, f64)] = &[
    ("do shell script.*with administrator privileges", "Privileged shell execution", 0.85),
    ("do shell script.*password", "Shell with password parameter", 0.8),
    ("do shell script.*sudo", "Sudo execution via AppleScript", 0.8),
    ("do shell script.*chmod +x", "Making file executable", 0.6),
    ("do shell script.*bash -c", "Bash command execution", 0.5),
    ("do shell script.*sh -c", "Shell command execution", 0.5),
    ("do shell script.*python", "Python execution via AppleScript", 0.6),
    ("do shell script.*ruby", "Ruby execution via AppleScript", 0.55),
    ("do shell script.*perl", "Perl execution via AppleScript", 0.55),
    ("do shell script.*osascript", "Nested osascript (evasion)", 0.75),
    ("do shell script.*open -a Terminal", "Opening Terminal programmatically", 0.5),
    ("do shell script.*mktemp", "Temp file creation (staging)", 0.5),
    ("do shell script.*nohup", "Background persistent execution", 0.7),
    ("do shell script.*disown", "Disowning process (persistence)", 0.65),
    ("do shell script.*&\"", "Background execution (&)", 0.5),
];

// ── Known Malware Patterns ───────────────────────────────────────────────────

const KNOWN_MALWARE_AS_PATTERNS: &[(&str, &str, &str, f64)] = &[
    ("Shlayer", "Shlayer adware installer", "T1059.002", 0.95),
    ("XCSSET", "XCSSET malware (Xcode project infection)", "T1059.002", 0.95),
    ("OSAMiner", "OSAMiner cryptominer (run-only AppleScript)", "T1059.002", 0.95),
    ("Silver Sparrow", "Silver Sparrow malware", "T1059.007", 0.95),
    ("DazzleSpy", "DazzleSpy macOS backdoor", "T1059.007", 0.95),
    ("UpdateAgent", "UpdateAgent trojan", "T1059.002", 0.9),
    ("Bundlore", "Bundlore adware", "T1059.002", 0.85),
    ("CrescentCore", "CrescentCore malware", "T1059.002", 0.9),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ASAbuseType {
    CredentialHarvesting,
    FakePromptDialog,
    SystemReconnaissance,
    PersistenceInstallation,
    DataExfiltration,
    FileStaging,
    ShellExecution,
    PrivilegeEscalation,
    JXAObjCBridge,
    JXANetworkRequest,
    JXACodeInjection,
    ApplicationControl,
    ProcessInjectionViaAppleEvents,
    ObfuscatedScript,
    CompiledRunOnlyScript,
    AutomatorAbuse,
    NestedExecution,
    ClipboardTheft,
    ScreenCapture,
    KnownMalwarePattern,
    RapidExecution,
    KeychainTheft,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ASAbuseFinding {
    pub abuse_type: ASAbuseType,
    pub confidence: f64,
    pub description: String,
    pub script_type: String,   // "applescript", "jxa", "automator"
    pub command_line: Option<String>,
    pub script_content_preview: Option<String>,
    pub malware_family: Option<String>,
    pub mitre_id: String,
    pub process_name: String,
    pub process_pid: u32,
    pub parent_process: Option<String>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppleScriptEvent {
    pub event_type: String,        // "exec", "compile", "run"
    pub process_name: String,
    pub process_pid: u32,
    pub parent_process: Option<String>,
    pub parent_pid: Option<u32>,
    pub command_line: Option<String>,
    pub script_path: Option<String>,
    pub script_content: Option<String>,
    pub script_type: String,       // "applescript", "jxa", "automator"
    pub is_compiled: bool,
    pub is_run_only: bool,
    pub bundle_id: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ASAnalysisResult {
    pub is_malicious: bool,
    pub events_analyzed: u32,
    pub findings: Vec<ASAbuseFinding>,
    pub attack_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ASScanStats {
    pub total_events: u64,
    pub malicious_detections: u64,
    pub credential_harvest_detections: u64,
    pub persistence_detections: u64,
    pub exfil_detections: u64,
    pub jxa_detections: u64,
    pub known_malware_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ASSigEntry { pub pattern: String, pub family: String, pub severity: f64 }

#[derive(Debug, Clone, Default)]
struct ScriptExecTracker {
    exec_count: u64,
    timestamps: Vec<u64>,
    script_hashes: HashSet<String>,
    attack_types: HashSet<String>,
    first_seen: u64,
    last_seen: u64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct AppleScriptAbuseDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<ASScanStats>>,
    result_cache: TieredCache<String, ASAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    script_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, ASScanStats>>,
    metrics: MemoryMetrics,
    script_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, ASAnalysisResult>>,
    sig_db: PagedMemory<ASSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<ASScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    exec_tracker: RwLock<HashMap<String, ScriptExecTracker>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl AppleScriptAbuseDetector {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            script_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, ASScanStats::default(),
                |acc: &mut ASScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(32 * 1024 * 1024),
            script_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(ASScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(256)),
            total_events: AtomicU64::new(0),
            exec_tracker: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &AppleScriptEvent) -> Option<ASAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("{}:{}:{}", event.process_name, event.process_pid, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut attack_categories = HashSet::new();

        // Combine command line and script content for analysis
        let analysis_text = format!("{} {}",
            event.command_line.as_deref().unwrap_or(""),
            event.script_content.as_deref().unwrap_or(""));
        let analysis_lower = analysis_text.to_lowercase();

        // ── 1. Credential harvesting detection ──────────────────────────
        for &(pattern, desc, conf) in CREDENTIAL_HARVEST_PATTERNS {
            if analysis_lower.contains(&pattern.to_lowercase()) {
                findings.push(ASAbuseFinding {
                    abuse_type: ASAbuseType::CredentialHarvesting,
                    confidence: conf,
                    description: desc.to_string(),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: event.script_content.as_ref().map(|s| s.chars().take(200).collect()),
                    malware_family: None,
                    mitre_id: "T1056.002".into(),
                    process_name: event.process_name.clone(),
                    process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(),
                    timestamp: event.timestamp,
                });
                mitre_ids.insert("T1056.002".into());
                attack_categories.insert("credential_harvesting".to_string());
            }
        }

        // ── 2. Reconnaissance detection ─────────────────────────────────
        for &(pattern, desc, mitre, conf) in RECON_PATTERNS {
            if analysis_lower.contains(&pattern.to_lowercase()) {
                findings.push(ASAbuseFinding {
                    abuse_type: ASAbuseType::SystemReconnaissance,
                    confidence: conf, description: desc.to_string(),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: None, malware_family: None,
                    mitre_id: mitre.into(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                attack_categories.insert("reconnaissance".to_string());
            }
        }

        // ── 3. Persistence detection ────────────────────────────────────
        for &(pattern, desc, mitre, conf) in PERSISTENCE_PATTERNS {
            if analysis_lower.contains(&pattern.to_lowercase()) {
                findings.push(ASAbuseFinding {
                    abuse_type: ASAbuseType::PersistenceInstallation,
                    confidence: conf, description: desc.to_string(),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: None, malware_family: None,
                    mitre_id: mitre.into(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                attack_categories.insert("persistence".to_string());
            }
        }

        // ── 4. Exfiltration detection ───────────────────────────────────
        for &(pattern, desc, mitre, conf) in EXFIL_PATTERNS {
            if analysis_lower.contains(&pattern.to_lowercase()) {
                let abuse_type = if pattern.contains("security find") {
                    ASAbuseType::KeychainTheft
                } else if pattern.contains("screencapture") {
                    ASAbuseType::ScreenCapture
                } else if pattern.contains("clipboard") || pattern.contains("pbcopy") {
                    ASAbuseType::ClipboardTheft
                } else if pattern.contains("curl") || pattern.contains("scp") || pattern.contains("rsync") {
                    ASAbuseType::DataExfiltration
                } else {
                    ASAbuseType::FileStaging
                };

                findings.push(ASAbuseFinding {
                    abuse_type, confidence: conf, description: desc.to_string(),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: None, malware_family: None,
                    mitre_id: mitre.into(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                attack_categories.insert("exfiltration".to_string());
            }
        }

        // ── 5. JXA-specific detection ───────────────────────────────────
        if event.script_type == "jxa" || analysis_lower.contains("objc.import") || analysis_lower.contains("$.ns") {
            for &(pattern, desc, mitre, conf) in JXA_PATTERNS {
                if analysis_lower.contains(&pattern.to_lowercase()) {
                    let abuse_type = if pattern.contains("NSURLRequest") || pattern.contains("NSURLSession") {
                        ASAbuseType::JXANetworkRequest
                    } else if pattern.contains("eval") || pattern.contains("Function(") {
                        ASAbuseType::JXACodeInjection
                    } else {
                        ASAbuseType::JXAObjCBridge
                    };

                    findings.push(ASAbuseFinding {
                        abuse_type, confidence: conf, description: desc.to_string(),
                        script_type: "jxa".to_string(),
                        command_line: event.command_line.clone(),
                        script_content_preview: None, malware_family: None,
                        mitre_id: mitre.into(),
                        process_name: event.process_name.clone(), process_pid: event.process_pid,
                        parent_process: event.parent_process.clone(),
                        file_path: event.script_path.clone(), timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                    attack_categories.insert("jxa_abuse".to_string());
                }
            }
        }

        // ── 6. Shell execution detection ────────────────────────────────
        for &(pattern, desc, conf) in SHELL_EXEC_PATTERNS {
            if analysis_lower.contains(&pattern.to_lowercase()) {
                let abuse_type = if pattern.contains("administrator privileges") || pattern.contains("sudo") {
                    ASAbuseType::PrivilegeEscalation
                } else if pattern.contains("nested") || pattern.contains("osascript") {
                    ASAbuseType::NestedExecution
                } else {
                    ASAbuseType::ShellExecution
                };

                findings.push(ASAbuseFinding {
                    abuse_type, confidence: conf, description: desc.to_string(),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: None, malware_family: None,
                    mitre_id: "T1059.002".into(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1059.002".into());
                attack_categories.insert("shell_execution".to_string());
            }
        }

        // ── 7. Compiled/run-only script detection ───────────────────────
        if event.is_run_only {
            findings.push(ASAbuseFinding {
                abuse_type: ASAbuseType::CompiledRunOnlyScript,
                confidence: 0.65,
                description: "Run-only AppleScript (source code hidden, common in malware)".into(),
                script_type: event.script_type.clone(),
                command_line: event.command_line.clone(),
                script_content_preview: None, malware_family: None,
                mitre_id: "T1027".into(),
                process_name: event.process_name.clone(), process_pid: event.process_pid,
                parent_process: event.parent_process.clone(),
                file_path: event.script_path.clone(), timestamp: event.timestamp,
            });
            mitre_ids.insert("T1027".into());
            attack_categories.insert("obfuscation".to_string());
        }

        // ── 8. Known malware family matching ────────────────────────────
        for &(name, desc, mitre, conf) in KNOWN_MALWARE_AS_PATTERNS {
            if analysis_lower.contains(&name.to_lowercase()) {
                findings.push(ASAbuseFinding {
                    abuse_type: ASAbuseType::KnownMalwarePattern,
                    confidence: conf, description: desc.to_string(),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: None,
                    malware_family: Some(name.to_string()),
                    mitre_id: mitre.into(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                attack_categories.insert("known_malware".to_string());
            }
        }

        // ── 9. Rapid execution tracking ─────────────────────────────────
        {
            let proc_key = format!("{}:{}", event.process_name, event.process_pid);
            let mut tracker = self.exec_tracker.write();
            let et = tracker.entry(proc_key).or_default();
            et.exec_count += 1;
            et.timestamps.push(event.timestamp);
            for cat in &attack_categories { et.attack_types.insert(cat.clone()); }
            if et.first_seen == 0 { et.first_seen = event.timestamp; }
            et.last_seen = event.timestamp;
            if et.timestamps.len() > 200 { et.timestamps.drain(..100); }

            let recent = et.timestamps.iter()
                .filter(|&&t| event.timestamp.saturating_sub(RAPID_EXECUTION_WINDOW_SECS) <= t)
                .count() as u32;
            if recent >= RAPID_EXECUTION_THRESHOLD {
                findings.push(ASAbuseFinding {
                    abuse_type: ASAbuseType::RapidExecution,
                    confidence: (0.6 + (recent as f64 / 20.0).min(0.3)),
                    description: format!("{} AppleScript executions in {}s", recent, RAPID_EXECUTION_WINDOW_SECS),
                    script_type: event.script_type.clone(),
                    command_line: event.command_line.clone(),
                    script_content_preview: None, malware_family: None,
                    mitre_id: "T1059.002".into(),
                    process_name: event.process_name.clone(), process_pid: event.process_pid,
                    parent_process: event.parent_process.clone(),
                    file_path: event.script_path.clone(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1059.002".into());
            }
        }

        // ── Store state ─────────────────────────────────────────────────
        self.script_diffs.write().record_insert(cache_key.clone(),
            format!("type={},findings={},cats={}", event.script_type, findings.len(), attack_categories.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_malicious = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = attack_categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = ASAnalysisResult {
            is_malicious, events_analyzed: 1, findings, attack_categories: cats_vec,
            risk_score, severity: severity.clone(), mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.abuse_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_malicious {
                s.malicious_detections += 1;
                for f in &result.findings {
                    match f.abuse_type {
                        ASAbuseType::CredentialHarvesting | ASAbuseType::FakePromptDialog => s.credential_harvest_detections += 1,
                        ASAbuseType::PersistenceInstallation => s.persistence_detections += 1,
                        ASAbuseType::DataExfiltration | ASAbuseType::FileStaging => s.exfil_detections += 1,
                        ASAbuseType::JXAObjCBridge | ASAbuseType::JXANetworkRequest | ASAbuseType::JXACodeInjection => s.jxa_detections += 1,
                        ASAbuseType::KnownMalwarePattern => s.known_malware_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_malicious {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "applescript_abuse_detector".into(),
                title: format!("{} abuse: {} (pid {})", event.script_type.to_uppercase(), event.process_name, event.process_pid),
                details: format!("Risk: {:.1}%, {} findings, categories: {}",
                    risk_score * 100.0, result.findings.len(), result.attack_categories.join(", ")),
                path: event.script_path.clone(),
                process_name: Some(event.process_name.clone()),
                process_pid: Some(event.process_pid), verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "Kill the osascript process immediately".into(),
                    "Block osascript execution via MDM/profile".into(),
                    "Review and remove unauthorized LaunchAgents".into(),
                    "Change passwords if credential harvesting detected".into(),
                    "Check for Folder Actions and login items".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[ASAbuseFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.abuse_type {
                ASAbuseType::KnownMalwarePattern => 1.6,
                ASAbuseType::CredentialHarvesting | ASAbuseType::FakePromptDialog => 1.5,
                ASAbuseType::KeychainTheft => 1.5,
                ASAbuseType::PrivilegeEscalation => 1.4,
                ASAbuseType::PersistenceInstallation => 1.4,
                ASAbuseType::DataExfiltration => 1.3,
                ASAbuseType::JXACodeInjection => 1.3,
                ASAbuseType::JXANetworkRequest => 1.2,
                ASAbuseType::CompiledRunOnlyScript => 1.1,
                ASAbuseType::ShellExecution => 1.0,
                ASAbuseType::SystemReconnaissance => 0.8,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        (score / (findings.len() as f64 * 1.5)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical } else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium } else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn stats(&self) -> ASScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
