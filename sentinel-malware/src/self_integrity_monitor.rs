//! Module 169: SelfIntegrityMonitor — Sentinel Self-Protection & Tamper Detection
//!
//! Monitors the integrity of the Nexus Sentinel system itself, detecting
//! attempts to disable, tamper with, or evade the security agent. Ensures
//! continuous protection even against sophisticated adversaries who target
//! the endpoint security product directly.
//!
//! ## Detection Capabilities
//!
//! ### Agent Binary Integrity
//! - **Binary hash verification**: Continuous SHA-256 verification of all
//!   Sentinel binary components against known-good hashes
//! - **Code signing verification**: Verifying Sentinel's own code signature
//!   hasn't been tampered with or re-signed
//! - **Library integrity**: Monitoring loaded dylibs for unauthorized
//!   modifications or injection into Sentinel processes
//! - **Configuration integrity**: Detecting unauthorized changes to
//!   Sentinel configuration files and policies
//! - **Database integrity**: Verifying signature database and rule file
//!   integrity via hash chains
//!
//! ### Process Protection
//! - **Anti-kill protection**: Detecting attempts to terminate Sentinel
//!   processes (kill, SIGKILL, task_terminate)
//! - **Anti-suspend**: Detecting SIGSTOP/SIGTSTP attempts to freeze agent
//! - **Anti-debug**: Detecting ptrace/debugger attachment to Sentinel
//! - **Priority manipulation**: Detecting renice/setpriority attacks to
//!   starve Sentinel of CPU time
//! - **Memory tampering**: Detecting writes to Sentinel process memory
//!   via mach_vm_write or similar APIs
//!
//! ### Service Continuity
//! - **LaunchDaemon monitoring**: Verifying Sentinel LaunchDaemon hasn't
//!   been unloaded, modified, or replaced
//! - **Watchdog heartbeat**: Internal heartbeat monitoring to detect if
//!   any Sentinel component has stopped responding
//! - **Communication channel integrity**: Verifying IPC channels between
//!   Sentinel components haven't been intercepted
//! - **Update channel security**: Protecting the agent update mechanism
//!   from hijacking or rollback attacks
//!
//! ### Evasion Detection
//! - **Log tampering**: Detecting attempts to modify or delete Sentinel
//!   log files
//! - **Rule disabling**: Detecting attempts to disable detection rules
//!   or lower sensitivity without authorization
//! - **Exclusion abuse**: Detecting suspicious exclusion additions that
//!   would blind Sentinel to specific paths/processes
//! - **Network blocking**: Detecting firewall rules that block Sentinel's
//!   cloud communication or update channels
//! - **Time manipulation**: Detecting system time changes that could
//!   affect Sentinel's time-based logic
//!
//! ## MITRE ATT&CK: T1562.001, T1562.002, T1562.004, T1562.006
//! All 13 sentinel-core breakthroughs integrated.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;
const HEARTBEAT_INTERVAL_SECS: u64 = 30;
const MAX_MISSED_HEARTBEATS: u32 = 3;

// ── Binary Integrity Indicators ──────────────────────────────────────────────

const BINARY_INTEGRITY_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("binary_hash_mismatch", "Sentinel binary hash differs from known-good", "T1562.001", 0.95),
    ("code_sign_invalid", "Sentinel code signature invalid or tampered", "T1562.001", 0.95),
    ("dylib_injected", "Unauthorized dylib injected into Sentinel process", "T1562.001", 0.9),
    ("config_modified", "Sentinel configuration modified without authorization", "T1562.001", 0.8),
    ("sig_db_corrupted", "Signature database integrity check failed", "T1562.001", 0.85),
    ("rule_file_modified", "Detection rule file modified", "T1562.001", 0.85),
    ("policy_downgraded", "Security policy downgraded without authorization", "T1562.001", 0.9),
    ("binary_replaced", "Sentinel binary replaced with different version", "T1562.001", 0.95),
    ("resource_tampered", "Sentinel resource files tampered", "T1562.001", 0.8),
];

// ── Process Protection Indicators ────────────────────────────────────────────

const PROCESS_PROTECTION_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("kill_attempt", "Attempt to kill Sentinel process detected", "T1562.001", 0.9),
    ("sigkill_received", "SIGKILL sent to Sentinel process", "T1562.001", 0.95),
    ("sigstop_received", "SIGSTOP sent to Sentinel (freeze attempt)", "T1562.001", 0.9),
    ("ptrace_attach", "ptrace attach to Sentinel (debugger attempt)", "T1562.001", 0.9),
    ("task_terminate_call", "task_terminate called on Sentinel task port", "T1562.001", 0.95),
    ("renice_attack", "Sentinel process priority lowered (CPU starvation)", "T1562.001", 0.7),
    ("memory_write_attempt", "mach_vm_write to Sentinel process memory", "T1562.001", 0.95),
    ("thread_injection", "Thread injected into Sentinel process", "T1562.001", 0.95),
    ("resource_limit_attack", "Resource limits set on Sentinel (rlimit)", "T1562.001", 0.8),
];

// ── Service Continuity Indicators ────────────────────────────────────────────

const SERVICE_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("launchdaemon_unloaded", "Sentinel LaunchDaemon unloaded", "T1562.004", 0.95),
    ("launchdaemon_modified", "Sentinel LaunchDaemon plist modified", "T1562.004", 0.9),
    ("launchdaemon_replaced", "Sentinel LaunchDaemon replaced", "T1562.004", 0.95),
    ("heartbeat_missed", "Sentinel component missed heartbeat", "T1562.001", 0.7),
    ("heartbeat_timeout", "Sentinel component heartbeat timeout", "T1562.001", 0.85),
    ("ipc_channel_tampered", "IPC channel between Sentinel components tampered", "T1562.001", 0.9),
    ("update_channel_hijacked", "Sentinel update channel redirected", "T1562.001", 0.9),
    ("update_rollback", "Sentinel rolled back to older version", "T1562.001", 0.8),
    ("kext_unloaded", "Sentinel kernel extension unloaded", "T1562.001", 0.9),
    ("sysext_deactivated", "Sentinel system extension deactivated", "T1562.001", 0.9),
];

// ── Evasion Indicators ───────────────────────────────────────────────────────

const EVASION_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("log_deleted", "Sentinel log files deleted", "T1562.002", 0.85),
    ("log_truncated", "Sentinel log files truncated", "T1562.002", 0.8),
    ("rule_disabled", "Detection rule disabled without authorization", "T1562.001", 0.85),
    ("sensitivity_lowered", "Detection sensitivity lowered", "T1562.001", 0.8),
    ("exclusion_added_suspicious", "Suspicious path/process exclusion added", "T1562.001", 0.8),
    ("exclusion_wildcard", "Overly broad wildcard exclusion added", "T1562.001", 0.85),
    ("firewall_block_sentinel", "Firewall rule blocking Sentinel communication", "T1562.004", 0.9),
    ("dns_block_sentinel", "DNS resolution blocked for Sentinel domains", "T1562.004", 0.85),
    ("hosts_file_redirect", "Sentinel domains redirected via /etc/hosts", "T1562.004", 0.85),
    ("time_manipulation", "System time manipulation affecting Sentinel", "T1562.001", 0.7),
    ("quarantine_bypass", "Quarantine directory permissions changed", "T1562.001", 0.8),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SelfIntegrityThreatType {
    BinaryTampered, CodeSignInvalid, DylibInjected,
    ConfigModified, SigDBCorrupted, PolicyDowngraded,
    KillAttempt, DebuggerAttach, MemoryWrite,
    CPUStarvation, ThreadInjection,
    LaunchDaemonTampered, HeartbeatMissed, IPCTampered,
    UpdateHijacked, ExtensionDeactivated,
    LogTampered, RuleDisabled, SensitivityLowered,
    SuspiciousExclusion, NetworkBlocked, TimeManipulation,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SelfIntegrityFinding {
    pub threat_type: SelfIntegrityThreatType,
    pub confidence: f64,
    pub description: String,
    pub component: Option<String>,
    pub expected_hash: Option<String>,
    pub actual_hash: Option<String>,
    pub attacker_pid: Option<u32>,
    pub mitre_id: String,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SelfIntegrityEvent {
    pub event_type: String,
    pub component: Option<String>,
    pub expected_hash: Option<String>,
    pub actual_hash: Option<String>,
    pub attacker_pid: Option<u32>,
    pub attacker_name: Option<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SelfIntegrityResult {
    pub integrity_compromised: bool,
    pub findings: Vec<SelfIntegrityFinding>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub recovery_actions: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SelfIntegrityStats {
    pub total_checks: u64,
    pub binary_tampering: u64,
    pub process_attacks: u64,
    pub service_disruptions: u64,
    pub evasion_attempts: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SelfIntegritySigEntry { pub component: String, pub hash: String }

pub struct SelfIntegrityMonitor {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<SelfIntegrityStats>>,
    result_cache: TieredCache<String, SelfIntegrityResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    integrity_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, SelfIntegrityStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_checks: RwLock<PruningMap<String, SelfIntegrityResult>>,
    sig_db: PagedMemory<SelfIntegritySigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    integrity_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<SelfIntegrityStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_checks: AtomicU64,
    component_hashes: RwLock<HashMap<String, String>>,
    last_heartbeats: RwLock<HashMap<String, u64>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl SelfIntegrityMonitor {
    pub fn new() -> Self {
        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            integrity_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, SelfIntegrityStats::default(),
                |acc: &mut SelfIntegrityStats, vals: &[f64]| { acc.total_checks += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_checks: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            integrity_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(SelfIntegrityStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(128)),
            total_checks: AtomicU64::new(0),
            component_hashes: RwLock::new(HashMap::new()),
            last_heartbeats: RwLock::new(HashMap::new()),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn check_event(&self, event: &SelfIntegrityEvent) -> Option<SelfIntegrityResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_checks.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("selfint:{}:{}", event.event_type, event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut recovery_actions = Vec::new();

        let ind_text = format!("{} {}",
            event.event_type, event.integrity_check.as_deref().unwrap_or(""));
        let ind_lower = ind_text.to_lowercase();

        // 1. Binary integrity
        for &(pattern, desc, mitre, conf) in BINARY_INTEGRITY_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    "binary_hash_mismatch" | "binary_replaced" => SelfIntegrityThreatType::BinaryTampered,
                    "code_sign_invalid" => SelfIntegrityThreatType::CodeSignInvalid,
                    "dylib_injected" => SelfIntegrityThreatType::DylibInjected,
                    "config_modified" | "resource_tampered" => SelfIntegrityThreatType::ConfigModified,
                    "sig_db_corrupted" | "rule_file_modified" => SelfIntegrityThreatType::SigDBCorrupted,
                    "policy_downgraded" => SelfIntegrityThreatType::PolicyDowngraded,
                    _ => SelfIntegrityThreatType::BinaryTampered,
                };
                findings.push(SelfIntegrityFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    component: event.component.clone(),
                    expected_hash: event.expected_hash.clone(), actual_hash: event.actual_hash.clone(),
                    attacker_pid: event.attacker_pid, mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                recovery_actions.push("Restore Sentinel binaries from secure backup".into());
            }
        }

        // Hash mismatch check
        if let (Some(ref exp), Some(ref act)) = (&event.expected_hash, &event.actual_hash) {
            if exp != act {
                findings.push(SelfIntegrityFinding {
                    threat_type: SelfIntegrityThreatType::BinaryTampered, confidence: 0.95,
                    description: format!("Component hash mismatch: {:?}", event.component),
                    component: event.component.clone(),
                    expected_hash: Some(exp.clone()), actual_hash: Some(act.clone()),
                    attacker_pid: event.attacker_pid,
                    mitre_id: "T1562.001".into(), timestamp: event.timestamp,
                });
                mitre_ids.insert("T1562.001".into());
            }
        }

        // 2. Process protection
        for &(pattern, desc, mitre, conf) in PROCESS_PROTECTION_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("kill") || p.contains("sigkill") || p.contains("task_terminate") =>
                        SelfIntegrityThreatType::KillAttempt,
                    p if p.contains("ptrace") => SelfIntegrityThreatType::DebuggerAttach,
                    p if p.contains("memory_write") => SelfIntegrityThreatType::MemoryWrite,
                    p if p.contains("renice") || p.contains("resource_limit") =>
                        SelfIntegrityThreatType::CPUStarvation,
                    p if p.contains("thread_injection") => SelfIntegrityThreatType::ThreadInjection,
                    _ => SelfIntegrityThreatType::KillAttempt,
                };
                findings.push(SelfIntegrityFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    component: event.component.clone(),
                    expected_hash: None, actual_hash: None,
                    attacker_pid: event.attacker_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                recovery_actions.push(format!("Investigate attacker process (pid: {:?})", event.attacker_pid));
            }
        }

        // 3. Service continuity
        for &(pattern, desc, mitre, conf) in SERVICE_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("launchdaemon") => SelfIntegrityThreatType::LaunchDaemonTampered,
                    p if p.contains("heartbeat") => SelfIntegrityThreatType::HeartbeatMissed,
                    p if p.contains("ipc") => SelfIntegrityThreatType::IPCTampered,
                    p if p.contains("update") => SelfIntegrityThreatType::UpdateHijacked,
                    p if p.contains("kext") || p.contains("sysext") => SelfIntegrityThreatType::ExtensionDeactivated,
                    _ => SelfIntegrityThreatType::HeartbeatMissed,
                };
                findings.push(SelfIntegrityFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    component: event.component.clone(),
                    expected_hash: None, actual_hash: None, attacker_pid: event.attacker_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
                recovery_actions.push("Re-register Sentinel LaunchDaemon and restart services".into());
            }
        }

        // 4. Evasion
        for &(pattern, desc, mitre, conf) in EVASION_INDICATORS {
            if ind_lower.contains(&pattern.to_lowercase()) {
                let tt = match pattern {
                    p if p.contains("log") => SelfIntegrityThreatType::LogTampered,
                    p if p.contains("rule_disabled") => SelfIntegrityThreatType::RuleDisabled,
                    p if p.contains("sensitivity") => SelfIntegrityThreatType::SensitivityLowered,
                    p if p.contains("exclusion") => SelfIntegrityThreatType::SuspiciousExclusion,
                    p if p.contains("firewall") || p.contains("dns") || p.contains("hosts") =>
                        SelfIntegrityThreatType::NetworkBlocked,
                    p if p.contains("time") => SelfIntegrityThreatType::TimeManipulation,
                    _ => SelfIntegrityThreatType::LogTampered,
                };
                findings.push(SelfIntegrityFinding {
                    threat_type: tt, confidence: conf, description: desc.to_string(),
                    component: event.component.clone(),
                    expected_hash: None, actual_hash: None, attacker_pid: event.attacker_pid,
                    mitre_id: mitre.into(), timestamp: event.timestamp,
                });
                mitre_ids.insert(mitre.into());
            }
        }

        let risk_score = if findings.is_empty() { 0.0 } else {
            let s: f64 = findings.iter().map(|f| f.confidence * match f.threat_type {
                SelfIntegrityThreatType::BinaryTampered | SelfIntegrityThreatType::CodeSignInvalid => 1.8,
                SelfIntegrityThreatType::MemoryWrite | SelfIntegrityThreatType::ThreadInjection => 1.7,
                SelfIntegrityThreatType::LaunchDaemonTampered | SelfIntegrityThreatType::UpdateHijacked => 1.6,
                SelfIntegrityThreatType::KillAttempt | SelfIntegrityThreatType::DebuggerAttach => 1.5,
                SelfIntegrityThreatType::NetworkBlocked => 1.4,
                _ => 1.0,
            }).sum();
            (s / (findings.len() as f64 * 1.7)).min(1.0)
        };
        self.risk_computer.write().push(risk_score);
        let severity = if risk_score >= 0.85 { Severity::Critical } else if risk_score >= 0.65 { Severity::High }
            else if risk_score >= 0.45 { Severity::Medium } else if risk_score >= 0.25 { Severity::Low }
            else { Severity::Info };
        let compromised = risk_score > 0.5;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        recovery_actions.dedup();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = SelfIntegrityResult {
            integrity_compromised: compromised, findings, risk_score,
            severity: severity.clone(), mitre_ids: mitre_vec.clone(),
            recovery_actions: recovery_actions.clone(), analysis_time_ms: elapsed,
        };
        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_checks.write().insert_with_priority(cache_key, result.clone(), risk_score);
        self.rate_accumulator.write().push(risk_score);

        { let mut s = self.stats.write(); s.total_checks += 1;
          if compromised { for f in &result.findings { match f.threat_type {
              SelfIntegrityThreatType::BinaryTampered | SelfIntegrityThreatType::CodeSignInvalid |
              SelfIntegrityThreatType::DylibInjected | SelfIntegrityThreatType::ConfigModified |
              SelfIntegrityThreatType::SigDBCorrupted | SelfIntegrityThreatType::PolicyDowngraded =>
                  s.binary_tampering += 1,
              SelfIntegrityThreatType::KillAttempt | SelfIntegrityThreatType::DebuggerAttach |
              SelfIntegrityThreatType::MemoryWrite | SelfIntegrityThreatType::CPUStarvation |
              SelfIntegrityThreatType::ThreadInjection => s.process_attacks += 1,
              SelfIntegrityThreatType::LaunchDaemonTampered | SelfIntegrityThreatType::HeartbeatMissed |
              SelfIntegrityThreatType::IPCTampered | SelfIntegrityThreatType::UpdateHijacked |
              SelfIntegrityThreatType::ExtensionDeactivated => s.service_disruptions += 1,
              _ => s.evasion_attempts += 1,
          } } }
          let n = s.total_checks as f64;
          s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n-1.0)/n) + elapsed as f64 / n;
        }

        if compromised {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(), timestamp: chrono::Utc::now().timestamp(), severity,
                module: "self_integrity_monitor".into(),
                title: format!("SELF-PROTECTION: {} integrity findings, attacker pid {:?}",
                    result.findings.len(), event.attacker_pid),
                details: format!("Risk {:.1}%, component: {:?}", risk_score*100.0, event.component),
                path: event.file_path.clone(), process_name: event.process_name.clone(),
                process_pid: event.process_pid, verdict: None, mitre_ids: mitre_vec,
                remediation: recovery_actions, confidence: risk_score,
            });
        }
        Some(result)
    }

    pub fn register_heartbeat(&self, component: &str, timestamp: u64) {
        self.last_heartbeats.write().insert(component.to_string(), timestamp);
    }

    pub fn stats(&self) -> SelfIntegrityStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
