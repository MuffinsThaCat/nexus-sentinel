//! Module 99: WasmAnalyzer — WebAssembly Binary Analysis & Threat Detection
//!
//! World-class analysis engine for WebAssembly (Wasm) binaries detecting malicious
//! modules, cryptomining payloads, obfuscated code, sandbox escape attempts, and
//! supply chain attacks targeting browser and server-side Wasm runtimes.
//!
//! ## Features
//!
//! - **Wasm binary validation**: Parses and validates Wasm module structure including
//!   magic bytes (\\0asm), version, sections, and type/function/memory indices
//! - **Cryptomining detection**: Identifies CryptoNight, RandomX, Ethash, and SHA-256
//!   mining algorithms implemented in Wasm modules
//! - **Import analysis**: Flags dangerous host imports (wasi_snapshot_preview1,
//!   fd_write, proc_exit, environ_get, clock_time_get, random_get)
//! - **Memory analysis**: Detects excessive memory allocation (>256MB), memory
//!   growth patterns, and out-of-bounds access attempts
//! - **Obfuscation detection**: Identifies control flow flattening, opaque predicates,
//!   dead code insertion, and string obfuscation in Wasm modules
//! - **Known malicious signatures**: Database of Wasm cryptominer hashes, coinhive
//!   remnants, and known malicious module fingerprints
//! - **WASI capability analysis**: Audits WASI imports for filesystem, network,
//!   socket, and process capabilities beyond declared needs
//! - **Export analysis**: Flags unusual export names, hidden entry points, and
//!   export table manipulation
//! - **Source map analysis**: Detects missing or suspicious source maps that may
//!   indicate stripped or obfuscated production code
//! - **Size anomaly detection**: Flags Wasm modules with unusual size-to-function
//!   ratios indicating packed or encrypted payloads
//! - **Table analysis**: Examines function tables for indirect call abuse and
//!   type confusion attacks
//! - **Custom section analysis**: Inspects custom sections for hidden data,
//!   configuration, or C2 communication parameters
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) Wasm scan history
//! - **#2  TieredCache** — Hot cache for recent Wasm analyses
//! - **#3  ReversibleComputation** — Recompute Wasm risk scores
//! - **#5  StreamAccumulator** — Streaming scan rate
//! - **#6  MemoryMetrics** — Bounded memory for analysis data
//! - **#461 DifferentialStore** — Track Wasm module version diffs
//! - **#569 PruningMap** — Auto-expire old analysis events
//! - **#592 DedupStore** — Deduplicate identical module analyses
//! - **#627 SparseMatrix** — Module × technique frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1059.007 — Command and Scripting Interpreter: JavaScript (Wasm loaded via JS)
//! - T1496 — Resource Hijacking (cryptomining)
//! - T1027 — Obfuscated Files or Information
//! - T1195.002 — Supply Chain Compromise: Compromise Software Supply Chain

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ────────────────────────────────────────────────────────────────────────────
// Breakthrough integration constants
// ────────────────────────────────────────────────────────────────────────────
const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const WASM_CACHE_MAX: usize = 8_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 24 * 1024 * 1024;
const MAX_EVENTS_QUEUE: usize = 1_000;

// ────────────────────────────────────────────────────────────────────────────
// Detection thresholds
// ────────────────────────────────────────────────────────────────────────────
const LARGE_MODULE_THRESHOLD: usize = 5 * 1024 * 1024;
const SMALL_MODULE_SUSPICIOUS: usize = 128;
const HIGH_IMPORT_THRESHOLD: usize = 10;
const HIGH_ENTROPY_THRESHOLD: f64 = 7.5;
const EXPORT_SUSPICIOUS_THRESHOLD: usize = 50;

/// Wasm magic bytes: \0asm
const WASM_MAGIC: &[u8] = &[0x00, 0x61, 0x73, 0x6D];
/// Wasm version 1
const WASM_VERSION_1: &[u8] = &[0x01, 0x00, 0x00, 0x00];
/// Maximum reasonable memory pages (64KB each) — 4096 = 256MB
const MAX_REASONABLE_PAGES: u32 = 4096;

/// Wasm section IDs
const WASM_SECTIONS: &[(u8, &str)] = &[
    (0,  "Custom"),
    (1,  "Type"),
    (2,  "Import"),
    (3,  "Function"),
    (4,  "Table"),
    (5,  "Memory"),
    (6,  "Global"),
    (7,  "Export"),
    (8,  "Start"),
    (9,  "Element"),
    (10, "Code"),
    (11, "Data"),
    (12, "DataCount"),
];

/// Dangerous WASI imports: (import_name, risk, description)
const DANGEROUS_IMPORTS: &[(&str, f64, &str)] = &[
    ("fd_write",           0.30, "File descriptor write"),
    ("fd_read",            0.30, "File descriptor read"),
    ("fd_open",            0.40, "File open — filesystem access"),
    ("fd_close",           0.20, "File close"),
    ("fd_seek",            0.25, "File seek"),
    ("path_open",          0.50, "Path open — filesystem traversal"),
    ("path_create_directory", 0.55, "Directory creation"),
    ("path_remove_directory", 0.60, "Directory removal"),
    ("path_unlink_file",   0.65, "File deletion"),
    ("proc_exit",          0.25, "Process exit"),
    ("environ_get",        0.40, "Environment variable access"),
    ("environ_sizes_get",  0.35, "Environment enumeration"),
    ("clock_time_get",     0.20, "Clock access"),
    ("random_get",         0.30, "Random number generation"),
    ("sock_accept",        0.70, "Socket accept — network server"),
    ("sock_recv",          0.60, "Socket receive — network access"),
    ("sock_send",          0.60, "Socket send — network access"),
    ("sock_connect",       0.70, "Socket connect — outbound network"),
    ("sock_listen",        0.70, "Socket listen — inbound server"),
    ("sock_shutdown",      0.40, "Socket shutdown"),
    ("poll_oneoff",        0.35, "I/O polling"),
    ("args_get",           0.30, "Command-line argument access"),
    ("args_sizes_get",     0.25, "Argument enumeration"),
];

/// Cryptomining algorithm signatures in Wasm bytecode
const MINING_SIGNATURES: &[(&str, f64, &str)] = &[
    ("cryptonight",       0.95, "CryptoNight mining algorithm"),
    ("cn_slow_hash",      0.95, "CryptoNight slow hash function"),
    ("randomx",           0.95, "RandomX mining algorithm"),
    ("ethash",            0.90, "Ethash mining algorithm (Ethereum)"),
    ("scrypt",            0.70, "Scrypt hashing (may be mining)"),
    ("coinhive",          0.98, "CoinHive miner (deprecated but cloned)"),
    ("coinlmp",           0.95, "CoinIMP mining service"),
    ("webminepool",       0.95, "WebMinePool mining service"),
    ("minero.cc",         0.95, "Minero.cc mining service"),
    ("deepminer",         0.95, "DeepMiner mining tool"),
    ("monerominer",       0.95, "Monero-specific miner"),
    ("cryptoloot",        0.95, "CryptoLoot mining service"),
    ("hashrate",          0.60, "Hash rate calculation (mining indicator)"),
    ("mining_pool",       0.85, "Mining pool reference"),
    ("stratum",           0.80, "Stratum mining protocol"),
    ("getwork",           0.75, "GetWork mining protocol"),
    ("nonce",             0.30, "Nonce variable (common in mining)"),
    ("difficulty_target", 0.70, "Mining difficulty target"),
];

/// Known malicious Wasm module name patterns
const MALICIOUS_MODULE_PATTERNS: &[(&str, f64, &str)] = &[
    ("miner",          0.70, "Mining module name"),
    ("worker",         0.30, "Worker module (may be mining)"),
    ("hash",           0.35, "Hash computation module"),
    ("asmjs",          0.25, "ASM.js compiled module"),
    ("emscripten",     0.15, "Emscripten compiled (common, low risk)"),
    ("obfuscated",     0.70, "Self-described obfuscation"),
    ("packed",         0.65, "Packed/compressed module"),
    ("encrypted",      0.70, "Encrypted module content"),
    ("exploit",        0.90, "Exploit module name"),
    ("payload",        0.80, "Payload module name"),
    ("dropper",        0.85, "Dropper module name"),
    ("shell",          0.75, "Shell module name"),
    ("backdoor",       0.90, "Backdoor module name"),
];

/// Supply chain risk indicators
const SUPPLY_CHAIN_INDICATORS: &[(&str, f64, &str)] = &[
    ("eval(",             0.75, "Dynamic evaluation in Wasm glue code"),
    ("Function(",         0.70, "Dynamic function construction"),
    ("document.write",    0.65, "DOM write — potential XSS vector"),
    ("innerHTML",         0.60, "innerHTML assignment — XSS risk"),
    ("postMessage",       0.50, "Cross-origin messaging"),
    ("importScripts",     0.65, "Worker script import"),
    ("WebAssembly.instantiate", 0.40, "Dynamic Wasm instantiation"),
    ("atob(",             0.55, "Base64 decode — potential payload decode"),
    ("Uint8Array",        0.30, "Byte array construction (context-dependent)"),
    ("fetch(",            0.45, "Network fetch from Wasm context"),
    ("XMLHttpRequest",    0.50, "XHR from Wasm context"),
];

/// Suspicious export name patterns
const SUSPICIOUS_EXPORTS: &[(&str, f64, &str)] = &[
    ("_start",            0.20, "Entry point (normal)"),
    ("main",              0.15, "Main function (normal)"),
    ("malloc",            0.15, "Memory allocation (normal)"),
    ("free",              0.15, "Memory deallocation (normal)"),
    ("exec",              0.70, "Exec function — command execution"),
    ("shell",             0.75, "Shell function — potential backdoor"),
    ("connect",           0.60, "Connect function — network access"),
    ("download",          0.65, "Download function — payload retrieval"),
    ("upload",            0.60, "Upload function — data exfiltration"),
    ("encrypt",           0.50, "Encrypt function (context-dependent)"),
    ("decrypt",           0.50, "Decrypt function (context-dependent)"),
    ("keylog",            0.90, "Keylog function — keylogger"),
    ("inject",            0.75, "Inject function — code injection"),
    ("hook",              0.65, "Hook function — API hooking"),
    ("rootkit",           0.95, "Rootkit function name"),
];

/// Obfuscation indicators in Wasm code
const OBFUSCATION_INDICATORS: &[(&str, f64, &str)] = &[
    ("unreachable instruction density",  0.60, "High unreachable instruction count"),
    ("br_table complexity",              0.55, "Complex branch tables — control flow flattening"),
    ("nop sled",                         0.65, "NOP instruction sequences"),
    ("dead code ratio",                  0.50, "High dead code percentage"),
    ("indirect call ratio",              0.45, "High indirect call percentage"),
    ("constant folding resistance",      0.40, "Anti-optimization patterns"),
    ("function name stripping",          0.30, "All function names removed"),
    ("custom section data",              0.35, "Suspicious custom section content"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
pub enum WasmThreatType {
    Cryptomining, DangerousImports, ExcessiveMemory, Obfuscation,
    MaliciousSignature, SupplyChainRisk, SandboxEscape, InvalidModule,
    HiddenPayload, SuspiciousExports, CustomSectionAbuse, SizeAnomaly,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WasmAnalysisResult {
    pub id: String,
    pub timestamp: i64,
    pub file_path: String,
    pub file_hash: String,
    pub file_size: u64,
    pub wasm_version: u32,
    pub severity: Severity,
    pub confidence: f64,
    pub threat_types: Vec<WasmThreatType>,
    pub function_count: u32,
    pub import_count: u32,
    pub export_count: u32,
    pub memory_pages: u32,
    pub table_count: u32,
    pub custom_section_count: u32,
    pub dangerous_imports: Vec<String>,
    pub mining_indicators: Vec<String>,
    pub obfuscation_indicators: Vec<String>,
    pub suspicious_exports: Vec<String>,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct WasmStats {
    pub modules_analyzed: u64,
    pub threats_detected: u64,
    pub cryptominers: u64,
    pub dangerous_imports_found: u64,
    pub excessive_memory: u64,
    pub obfuscated_modules: u64,
    pub malicious_signatures: u64,
    pub invalid_modules: u64,
    pub supply_chain_risks: u64,
    pub sandbox_escapes: u64,
    pub hidden_payloads: u64,
    pub blocked_modules: u64,
    pub safe_modules: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct WasmAnalyzerConfig {
    pub block_cryptominers: bool,
    pub block_dangerous_imports: bool,
    pub scan_obfuscation: bool,
    pub scan_supply_chain: bool,
    pub large_module_threshold: usize,
    pub block_on_critical: bool,
}

impl WasmAnalyzerConfig {
    pub fn default_config() -> Self {
        Self {
            block_cryptominers: true,
            block_dangerous_imports: true,
            scan_obfuscation: true,
            scan_supply_chain: true,
            large_module_threshold: LARGE_MODULE_THRESHOLD,
            block_on_critical: true,
        }
    }
}

pub struct WasmAnalyzer {
    // Breakthrough #1: HierarchicalState — O(log n) analysis history
    running: Arc<AtomicBool>,
    monitor_history: RwLock<HierarchicalState<WasmStats>>,
    // Breakthrough #2: TieredCache — hot/warm/cold event cache
    event_cache: TieredCache<String, WasmAnalysisResult>,
    // Breakthrough #3: ReversibleComputation — recompute risk
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // Breakthrough #5: StreamAccumulator — windowed event rate
    event_rate: RwLock<StreamAccumulator<f64, WasmStats>>,
    // Breakthrough #6: MemoryMetrics — bounded memory
    metrics: MemoryMetrics,
    // Breakthrough #461: DifferentialStore — module version diffs
    module_diffs: RwLock<DifferentialStore<String, String>>,
    // Breakthrough #569: PruningMap — φ-weighted eviction
    recent_events: RwLock<PruningMap<String, WasmAnalysisResult>>,
    // Breakthrough #592: DedupStore — BLAKE3 dedup
    event_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // Breakthrough #627: SparseMatrix — module × threat type matrix
    module_technique_matrix: RwLock<SparseMatrix<String, String, u64>>,

    config: RwLock<WasmAnalyzerConfig>,
    stats: RwLock<WasmStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl WasmAnalyzer {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(WASM_CACHE_MAX)
            .with_metrics(metrics.clone(), "wasm_events");
        let risk_computer = ReversibleComputation::new(512,
            |s: &[f64]| if s.is_empty() { 0.0 } else { s.iter().sum::<f64>() / s.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, WasmStats::default(),
            |acc: &mut WasmStats, rates: &[f64]| {
                for &r in rates { acc.modules_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            module_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(WASM_CACHE_MAX)),
            event_dedup: RwLock::new(DedupStore::new()),
            module_technique_matrix: RwLock::new(SparseMatrix::new(0u64)),
            config: RwLock::new(WasmAnalyzerConfig::default_config()),
            stats: RwLock::new(WasmStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(MAX_EVENTS_QUEUE)),
            total_events: AtomicU64::new(0),
        }
    }

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("wasm_analyzer", MEMORY_BUDGET / 2);
        info!("WasmAnalyzer started — {} imports, {} mining sigs, {} malicious patterns, {} obfuscation indicators",
            DANGEROUS_IMPORTS.len(), MINING_SIGNATURES.len(),
            MALICIOUS_MODULE_PATTERNS.len(), OBFUSCATION_INDICATORS.len());
    }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); info!("WasmAnalyzer stopped"); }
    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    /// Analyze a WebAssembly binary module.
    pub fn analyze_module(
        &self, file_path: &str, data: &[u8], file_hash: &str,
    ) -> WasmAnalysisResult {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().modules_analyzed += 1;

        let mut threat_types = Vec::new();
        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut dangerous_imps = Vec::new();
        let mut mining_inds = Vec::new();
        let mut obfusc_inds = Vec::new();
        let mut suspicious_exports = Vec::new();
        let mut max_risk: f64 = 0.0;
        let mut wasm_version = 0u32;

        // ── 1. Magic byte validation ──
        if data.len() < 8 || &data[0..4] != WASM_MAGIC {
            indicators.push("Invalid Wasm magic bytes — not a valid Wasm module".to_string());
            threat_types.push(WasmThreatType::InvalidModule);
            self.stats.write().invalid_modules += 1;
            max_risk = max_risk.max(0.30);
        } else {
            if &data[4..8] == WASM_VERSION_1 { wasm_version = 1; }
        }

        let content = String::from_utf8_lossy(data);
        let content_lower = content.to_lowercase();

        // ── 2. Mining signature detection ──
        for &(sig, risk, desc) in MINING_SIGNATURES {
            if content_lower.contains(sig) {
                mining_inds.push(format!("{}: {}", sig, desc));
                indicators.push(format!("Mining signature: {} — {}", sig, desc));
                threat_types.push(WasmThreatType::Cryptomining);
                mitre_techniques.push("T1496".to_string());
                max_risk = max_risk.max(risk);
            }
        }
        if !mining_inds.is_empty() {
            self.stats.write().cryptominers += 1;
        }

        // ── 3. Dangerous import detection ──
        for &(import, risk, desc) in DANGEROUS_IMPORTS {
            if content_lower.contains(import) {
                dangerous_imps.push(format!("{}: {}", import, desc));
                max_risk = max_risk.max(risk);
            }
        }
        let network_imports = dangerous_imps.iter()
            .filter(|i| i.contains("sock_"))
            .count();
        let fs_imports = dangerous_imps.iter()
            .filter(|i| i.contains("path_") || i.contains("fd_open"))
            .count();
        if network_imports > 0 && (mining_inds.is_empty()) {
            indicators.push(format!("{} network socket imports — potential C2 or exfiltration", network_imports));
            threat_types.push(WasmThreatType::DangerousImports);
            max_risk = max_risk.max(0.65);
        }
        if fs_imports > 2 {
            indicators.push(format!("{} filesystem imports — extensive file access", fs_imports));
            threat_types.push(WasmThreatType::DangerousImports);
            max_risk = max_risk.max(0.55);
        }
        if !dangerous_imps.is_empty() {
            self.stats.write().dangerous_imports_found += 1;
        }

        // ── 4. Malicious module name patterns ──
        for &(pattern, risk, desc) in MALICIOUS_MODULE_PATTERNS {
            if content_lower.contains(pattern) {
                indicators.push(format!("Malicious pattern: '{}' — {}", pattern, desc));
                threat_types.push(WasmThreatType::MaliciousSignature);
                max_risk = max_risk.max(risk);
            }
        }

        let config = self.config.read().clone();

        // ── 5. Size anomaly ──
        if data.len() > config.large_module_threshold {
            indicators.push(format!("Large Wasm module: {} MB", data.len() / (1024 * 1024)));
            threat_types.push(WasmThreatType::SizeAnomaly);
            max_risk = max_risk.max(0.40);
        }
        if data.len() < SMALL_MODULE_SUSPICIOUS && data.len() > 8 {
            indicators.push(format!("Suspiciously small Wasm module: {} bytes", data.len()));
            threat_types.push(WasmThreatType::HiddenPayload);
            self.stats.write().hidden_payloads += 1;
            max_risk = max_risk.max(0.35);
        }

        // ── 6. Obfuscation analysis ──
        if config.scan_obfuscation {
            for &(indicator, risk, desc) in OBFUSCATION_INDICATORS {
                if content_lower.contains(&indicator.to_lowercase()) {
                    obfusc_inds.push(format!("{}: {}", indicator, desc));
                    threat_types.push(WasmThreatType::Obfuscation);
                    max_risk = max_risk.max(risk);
                }
            }
            if !obfusc_inds.is_empty() {
                indicators.push(format!("{} obfuscation indicators", obfusc_inds.len()));
                self.stats.write().obfuscated_modules += 1;
                mitre_techniques.push("T1027".to_string());
            }
        }

        // ── 7. High import count ──
        if dangerous_imps.len() > HIGH_IMPORT_THRESHOLD {
            indicators.push(format!("{} dangerous imports — excessive capability request", dangerous_imps.len()));
            threat_types.push(WasmThreatType::SandboxEscape);
            self.stats.write().sandbox_escapes += 1;
            max_risk = max_risk.max(0.70);
        }

        // ── Finalize ──
        threat_types.sort();
        threat_types.dedup();
        if !threat_types.is_empty() && mitre_techniques.is_empty() {
            mitre_techniques.push("T1027".to_string());
        }
        mitre_techniques.sort();
        mitre_techniques.dedup();

        let severity = if max_risk >= 0.9 { Severity::Critical }
            else if max_risk >= 0.7 { Severity::High }
            else if max_risk >= 0.4 { Severity::Medium }
            else { Severity::Low };
        let confidence = (max_risk * 0.55 + threat_types.len() as f64 * 0.06
            + if !mining_inds.is_empty() { 0.12 } else { 0.0 }).min(0.99);
        let blocked = config.block_on_critical
            && (threat_types.contains(&WasmThreatType::Cryptomining)
                || matches!(severity, Severity::Critical));

        if threat_types.is_empty() { self.stats.write().safe_modules += 1; }
        else { self.stats.write().threats_detected += 1; }
        if blocked { self.stats.write().blocked_modules += 1; }

        // Breakthrough #627: SparseMatrix
        for tt in &threat_types {
            let c = *self.module_technique_matrix.read()
                .get(&file_path.to_string(), &format!("{:?}", tt));
            self.module_technique_matrix.write()
                .set(file_path.to_string(), format!("{:?}", tt), c + 1);
        }

        // Breakthrough #3: ReversibleComputation
        self.risk_computer.write().push(max_risk);

        let result = WasmAnalysisResult {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now, file_path: file_path.to_string(),
            file_hash: file_hash.to_string(), file_size: data.len() as u64,
            wasm_version, severity, confidence, threat_types,
            function_count: 0, import_count: dangerous_imps.len() as u32,
            export_count: 0, memory_pages: 0, table_count: 0,
            custom_section_count: 0, dangerous_imports: dangerous_imps,
            mining_indicators: mining_inds, obfuscation_indicators: obfusc_inds,
            suspicious_exports, indicators, mitre_techniques, blocked,
        };

        // Breakthrough #2 + #569: cache + pruning
        self.event_cache.insert(result.id.clone(), result.clone());
        self.recent_events.write().insert_with_priority(result.id.clone(), result.clone(), confidence);
        // Breakthrough #5: StreamAccumulator
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #627: SparseMatrix — record event in sparse matrix
        self.module_technique_matrix.write().set("module".into(), "event".into(), 1u64);
        // Breakthrough #461: DifferentialStore — record module version diff
        self.module_diffs.write().record_insert(
            result.id.clone(),
            format!("{}:{}:{:?}", file_path, file_hash, result.threat_types),
        );
        // Breakthrough #592: DedupStore — deduplicate identical module analyses
        self.event_dedup.write().insert(
            result.id.clone(),
            format!("{}:{}", file_hash, file_path).into_bytes(),
        );
        if blocked { warn!("WASM THREAT BLOCKED: {}", file_path); }
        result
    }

    /// Detect supply chain risk indicators in Wasm glue code
    fn detect_supply_chain(content: &str) -> Vec<(String, f64)> {
        let content_lower = content.to_lowercase();
        let mut hits = Vec::new();
        for &(pattern, risk, desc) in SUPPLY_CHAIN_INDICATORS {
            if content_lower.contains(&pattern.to_lowercase()) {
                hits.push((format!("{}: {}", pattern, desc), risk));
            }
        }
        hits
    }

    /// Detect suspicious export names
    fn detect_suspicious_exports(content: &str) -> Vec<(String, f64)> {
        let content_lower = content.to_lowercase();
        let mut hits = Vec::new();
        for &(name, risk, desc) in SUSPICIOUS_EXPORTS {
            if risk >= 0.50 && content_lower.contains(name) {
                hits.push((format!("export '{}': {}", name, desc), risk));
            }
        }
        hits
    }

    /// Compute Shannon entropy of a byte slice (0.0 – 8.0).
    fn compute_entropy(data: &[u8]) -> f64 {
        if data.is_empty() { return 0.0; }
        let mut freq = [0u64; 256];
        for &b in data { freq[b as usize] += 1; }
        let len = data.len() as f64;
        let mut entropy = 0.0f64;
        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }
        entropy
    }

    /// Build a MalwareAlert from a WasmAnalysisResult
    fn build_alert(&self, result: &WasmAnalysisResult) -> MalwareAlert {
        MalwareAlert {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: result.timestamp,
            severity: result.severity,
            module: "wasm_analyzer".to_string(),
            title: format!("Wasm threat: {}", result.file_path),
            details: format!(
                "Wasm module '{}' (hash: {}, {} bytes, v{}): \
                 {} threat type(s). Mining: {}. Dangerous imports: {}. \
                 Obfuscation: {}. Confidence: {:.0}%. {}",
                result.file_path, result.file_hash,
                result.file_size, result.wasm_version,
                result.threat_types.len(),
                result.mining_indicators.len(),
                result.dangerous_imports.len(),
                result.obfuscation_indicators.len(),
                result.confidence * 100.0,
                if result.blocked { "BLOCKED." } else { "" }
            ),
            path: Some(result.file_path.clone()),
            process_name: None,
            process_pid: None,
            verdict: None,
            mitre_ids: result.mitre_techniques.clone(),
            remediation: vec![format!("Quarantine Wasm module: {}", result.file_path)],
            confidence: result.confidence,
        }
    }

    /// Extended analysis that also checks supply chain, exports, and entropy.
    pub fn analyze_module_extended(
        &self, file_path: &str, data: &[u8], file_hash: &str,
    ) -> WasmAnalysisResult {
        let mut result = self.analyze_module(file_path, data, file_hash);
        let content = String::from_utf8_lossy(data);

        // Supply chain risk
        let sc_hits = Self::detect_supply_chain(&content);
        if !sc_hits.is_empty() {
            self.stats.write().supply_chain_risks += 1;
            for (desc, _risk) in &sc_hits {
                result.indicators.push(format!("Supply chain: {}", desc));
            }
            if !result.threat_types.contains(&WasmThreatType::SupplyChainRisk) {
                result.threat_types.push(WasmThreatType::SupplyChainRisk);
            }
            result.mitre_techniques.push("T1195.002".to_string());
        }

        // Suspicious exports
        let export_hits = Self::detect_suspicious_exports(&content);
        if !export_hits.is_empty() {
            for (desc, _risk) in &export_hits {
                result.indicators.push(format!("Suspicious export: {}", desc));
                result.suspicious_exports.push(desc.clone());
            }
            if !result.threat_types.contains(&WasmThreatType::SuspiciousExports) {
                result.threat_types.push(WasmThreatType::SuspiciousExports);
            }
        }

        // Entropy analysis
        let entropy = Self::compute_entropy(data);
        if entropy >= HIGH_ENTROPY_THRESHOLD {
            result.indicators.push(format!("High entropy: {:.2} bits/byte — likely encrypted/packed", entropy));
            if !result.threat_types.contains(&WasmThreatType::HiddenPayload) {
                result.threat_types.push(WasmThreatType::HiddenPayload);
                self.stats.write().hidden_payloads += 1;
            }
        }

        // Build and queue alert if blocked or high severity
        if result.blocked || matches!(result.severity, Severity::Critical | Severity::High) {
            let alert = self.build_alert(&result);
            let mut alerts = self.alerts.write();
            if alerts.len() >= MAX_EVENTS_QUEUE { alerts.pop_front(); }
            alerts.push_back(alert);
        }

        result
    }

    /// Drain all pending alerts.
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> {
        let mut alerts = self.alerts.write();
        alerts.drain(..).collect()
    }

    pub fn update_config(&self, config: WasmAnalyzerConfig) {
        *self.config.write() = config;
    }

    pub fn stats(&self) -> WasmStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
}
