//! Module 143: IOKitRootkitDetector — macOS IOKit & Kernel-Level Rootkit Detection
//!
//! Comprehensive detection of rootkits and kernel-level threats targeting macOS
//! through the IOKit framework, kernel extensions (KEXTs), DriverKit extensions,
//! and XNU kernel manipulation. This module performs deep analysis of IOKit
//! driver behavior, kernel memory artifacts, system call hooking, and boot-level
//! persistence to detect the most sophisticated macOS rootkits.
//!
//! ## Detection Capabilities
//!
//! ### IOKit Driver Analysis
//! - **Malicious IOKit drivers**: Drivers that register unexpected IOService
//!   classes, intercept I/O operations, or modify kernel data structures
//! - **IOKit user client abuse**: Unauthorized IOUserClient connections enabling
//!   userland-to-kernel communication for exploit chains
//! - **IOKit registry manipulation**: Hiding devices, modifying IORegistry
//!   properties, spoofing device characteristics
//! - **Driver entitlement bypass**: Drivers loaded without proper entitlements
//!   or with excessive kernel permissions
//! - **IOKit memory mapping abuse**: Shared memory regions used for kernel
//!   data exfiltration or code injection
//!
//! ### Kernel Extension (KEXT) Analysis
//! - **Unsigned/ad-hoc signed KEXTs**: Extensions without Apple or proper
//!   developer team code signatures
//! - **Known rootkit KEXT families**: Hacking Team, FinFisher, Rubilyn,
//!   Mokes, Keydnap, and other known macOS rootkit KEXTs
//! - **KEXT loading from unusual paths**: Extensions loaded from /tmp,
//!   user directories, or other non-standard locations
//! - **KEXT dependency chain analysis**: KEXTs that depend on suspicious
//!   or private kernel interfaces
//! - **KEXT version spoofing**: KEXTs that claim Apple bundle IDs or
//!   spoof version numbers to evade detection
//!
//! ### System Call & Kernel Hook Detection
//! - **System call table (sysent) modification**: Detection of hooked
//!   system calls by comparing against known-good sysent addresses
//! - **Mach trap table hooks**: Modified mach_trap_table entries
//! - **TrustCache manipulation**: Attempts to add unauthorized binaries
//!   to the static or runtime trust caches
//! - **MACF policy hooks**: Malicious Mandatory Access Control Framework
//!   policy modules that intercept security decisions
//! - **Kernel function pointer corruption**: Modified vtable entries,
//!   IOKit method dispatch hooks, kauth callback hijacking
//!
//! ### Boot-Level & Firmware Persistence
//! - **Boot argument manipulation**: Modified boot-args in NVRAM for
//!   SIP disable, kernel debug, etc.
//! - **EFI/UEFI firmware rootkits**: Persistent firmware implants in
//!   the EFI System Partition
//! - **iBoot exploitation artifacts**: Signs of bootloader-level
//!   compromise on Apple Silicon Macs
//! - **Sealed System Volume (SSV) bypass**: Attempts to modify the
//!   signed system volume on macOS Big Sur+
//! - **Auxiliary Kernel Collection (AuxKC) tampering**: Modified
//!   kernel collections that include unauthorized extensions
//!
//! ### XNU Kernel Integrity
//! - **Kernel text segment modification**: Self-modifying kernel code
//!   or injected kernel patches
//! - **Kernel zone corruption**: Heap-based attacks on kernel memory
//!   zones (kalloc, zalloc abuse)
//! - **KPP/KTRR bypass detection**: Attempts to bypass Kernel Patch
//!   Protection or Kernel Text Readonly Region
//! - **PPL (Page Protection Layer) violation**: Code attempting to
//!   modify PPL-protected pages on Apple Silicon
//! - **PAC (Pointer Authentication) bypass**: Techniques to forge
//!   pointer authentication codes on ARM64e
//!
//! ### Process & Task Hiding
//! - **Process list manipulation**: Rootkits that unlink processes
//!   from the allproc list or manipulate proc structures
//! - **Task port manipulation**: Stealing or forging task ports for
//!   unauthorized process control
//! - **PID spoofing**: Processes that modify their own PID or PPID
//!   to evade monitoring
//! - **Credential manipulation**: Kernel-level privilege escalation
//!   via direct credential structure modification
//!
//! ## MITRE ATT&CK Mapping
//!
//! - T1014 — Rootkit
//! - T1547.006 — Kernel Modules and Extensions
//! - T1556 — Modify Authentication Process
//! - T1601 — Modify System Image
//! - T1542.003 — Bootkit
//! - T1055.001 — DLL Injection (kernel equivalent)
//! - T1562.001 — Disable or Modify Tools
//! - T1134 — Access Token Manipulation
//!
//! ## Memory Breakthroughs Used
//!
//! All 13 sentinel-core breakthroughs are integrated for world-class
//! hierarchical state tracking, tiered caching, reversible risk computation,
//! vector quantization of kernel event features, streaming accumulation,
//! memory metrics, differential storage, priority-based pruning, paged
//! signature storage, streaming file processing, content deduplication,
//! LZ4 compression, and sparse threat matrices.

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::vq_codec::VqCodec;
use sentinel_core::paged::PagedMemory;
use sentinel_core::mmap_stream::StreamingFileProcessor;
use sentinel_core::compression;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn, debug};

// ── Memory Breakthrough Constants ────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const CACHE_MAX: usize = 50_000;
const STATS_WINDOW: usize = 512;
const VQ_CODEBOOK_SIZE: usize = 128;
const VQ_VECTOR_DIM: usize = 16;
const PAGE_SIZE: usize = 4096;
const MAX_RESIDENT_PAGES: usize = 256;
const MMAP_CHUNK_SIZE: usize = 128 * 1024;

// ── Known Rootkit KEXT Identifiers ───────────────────────────────────────────

const KNOWN_ROOTKIT_KEXTS: &[(&str, &str, &str, f64)] = &[
    ("com.hacking-team.driver", "Hacking Team RCS rootkit KEXT", "HackingTeam", 0.99),
    ("com.gamma.fishkernel", "FinFisher/FinSpy kernel module", "FinFisher", 0.99),
    ("com.apple.iokit.IOUSBMassStorage", "Fake USB mass storage (rootkit disguise)", "Generic", 0.7),
    ("com.apple.driver.DiskImages.ReadWriteDiskImage", "Spoofed Apple driver", "Generic", 0.6),
    ("com.rubilyn.driver", "Rubilyn macOS rootkit", "Rubilyn", 0.99),
    ("com.crisis.kext", "Crisis/Morcut rootkit KEXT", "Crisis", 0.99),
    ("com.keydnap.driver", "Keydnap rootkit component", "Keydnap", 0.95),
    ("com.mokes.kext", "Mokes/Ekoms rootkit KEXT", "Mokes", 0.95),
    ("com.vsearch.helper.kext", "VSearch adware KEXT", "VSearch", 0.85),
    ("com.symantec.kext.SymAPComm", "Legitimate but commonly spoofed", "Spoof", 0.3),
    ("it.hackingteam.driver", "Hacking Team alt identifier", "HackingTeam", 0.99),
    ("com.eset.kext.esets_agent", "Legitimate ESET but verify signature", "Verify", 0.2),
    ("com.apple.iokit.IONetworkingFamily", "Core networking (verify not tampered)", "CoreVerify", 0.1),
];

// ── Suspicious IOKit Service Classes ─────────────────────────────────────────

const SUSPICIOUS_IOKIT_CLASSES: &[(&str, &str, f64)] = &[
    ("IOBluetoothHCIUserClient", "Bluetooth HCI user client (direct BT access)", 0.5),
    ("IOHIDResourceDeviceUserClient", "HID resource client (input injection)", 0.6),
    ("IOFramebufferSharedUserClient", "Framebuffer shared client (screen capture)", 0.5),
    ("AppleKeyStoreUserClient", "Keystore user client (key access)", 0.7),
    ("IOSurfaceRootUserClient", "IOSurface root client (GPU memory access)", 0.4),
    ("AGXDeviceUserClient", "GPU device user client (compute access)", 0.3),
    ("IOAccelSharedUserClient", "GPU accelerator shared client", 0.3),
    ("AppleMobileFileIntegrityUserClient", "AMFI user client (code signing)", 0.8),
    ("AppleCredentialManagerUserClient", "Credential manager client", 0.7),
    ("IODMACommand", "DMA command (direct memory access)", 0.6),
    ("AppleIntelMEUserClient", "Intel Management Engine client", 0.6),
    ("IOPCIDevice", "PCI device direct access", 0.5),
    ("AppleSEPKeyStoreUserClient", "SEP keystore client (Secure Enclave)", 0.7),
];

// ── System Call Hook Indicators ──────────────────────────────────────────────

const SYSCALL_HOOK_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("sysent_modified", "System call table (sysent) modification detected", "T1014", 0.95),
    ("mach_trap_modified", "Mach trap table hook detected", "T1014", 0.95),
    ("kauth_callback_unknown", "Unknown kauth callback registered", "T1556", 0.8),
    ("macf_policy_unknown", "Unknown MACF policy module loaded", "T1556", 0.85),
    ("dtrace_probe_hijack", "DTrace probe point hijacked", "T1014", 0.8),
    ("syscall_redirect", "System call redirected to non-kernel address", "T1014", 0.95),
    ("mach_msg_trap_hook", "Mach message trap hooked", "T1014", 0.9),
    ("exception_port_steal", "Task exception port redirected", "T1014", 0.85),
    ("host_priv_port_leak", "Host privileged port leaked to userspace", "T1134", 0.9),
    ("task_for_pid_0", "task_for_pid(0) — kernel task port access", "T1134", 0.95),
    ("processor_set_tasks", "processor_set_tasks() — enumerate all tasks", "T1014", 0.7),
    ("thread_create_running_kernel", "Thread created running in kernel space", "T1055.001", 0.9),
];

// ── Boot & Firmware Indicators ───────────────────────────────────────────────

const BOOT_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("boot-args.*-v", "Verbose boot (diagnostic, not necessarily malicious)", "T1542.003", 0.2),
    ("boot-args.*debug", "Kernel debug mode enabled via NVRAM", "T1542.003", 0.7),
    ("boot-args.*kext-dev-mode=1", "KEXT developer mode (SIP weakened)", "T1562.001", 0.85),
    ("boot-args.*amfi_get_out_of_my_way=1", "AMFI disabled via boot-args", "T1562.001", 0.95),
    ("boot-args.*cs_enforcement_disable=1", "Code signing enforcement disabled", "T1562.001", 0.95),
    ("boot-args.*rootless=0", "SIP disabled via boot-args (legacy)", "T1562.001", 0.9),
    ("boot-args.*-no_compat_check", "Hardware compatibility check disabled", "T1542.003", 0.6),
    ("csr-active-config.*0x67", "SIP fully disabled (CSR config 0x67)", "T1562.001", 0.95),
    ("csr-active-config.*0x77", "SIP fully disabled (CSR config 0x77)", "T1562.001", 0.95),
    ("csr-active-config.*0x6f", "SIP disabled with NVRAM protection off", "T1562.001", 0.95),
    ("EFI.*modified", "EFI System Partition modification detected", "T1542.003", 0.85),
    ("boot.efi.*tampered", "boot.efi integrity failure", "T1542.003", 0.95),
    ("SSV.*seal_broken", "Sealed System Volume seal broken", "T1601", 0.95),
    ("AuxKC.*unauthorized", "Auxiliary Kernel Collection contains unauthorized KEXT", "T1547.006", 0.9),
    ("immutablekernel.*modified", "Immutable kernel image modified", "T1601", 0.98),
    ("iBoot.*exploit", "iBoot exploitation artifact", "T1542.003", 0.98),
    ("nvram.*delete.*csr", "CSR config deleted from NVRAM", "T1562.001", 0.85),
];

// ── Kernel Integrity Indicators ──────────────────────────────────────────────

const KERNEL_INTEGRITY_INDICATORS: &[(&str, &str, &str, f64)] = &[
    ("text_segment_writable", "Kernel text segment made writable", "T1014", 0.98),
    ("kernel_patch_detected", "Kernel code patching detected", "T1014", 0.98),
    ("kpp_bypass", "Kernel Patch Protection bypass detected", "T1014", 0.95),
    ("ktrr_bypass", "KTRR (Kernel Text Readonly Region) bypass", "T1014", 0.95),
    ("ppl_violation", "PPL (Page Protection Layer) violation", "T1014", 0.95),
    ("pac_forge", "PAC (Pointer Authentication Code) forgery detected", "T1014", 0.95),
    ("zone_corruption", "Kernel zone (kalloc/zalloc) corruption", "T1014", 0.85),
    ("vtable_hook", "IOKit vtable entry modified", "T1014", 0.9),
    ("allproc_unlink", "Process unlinked from allproc list (hiding)", "T1014", 0.95),
    ("pid_spoof", "Process PID or PPID spoofed", "T1134", 0.85),
    ("cred_modify", "Kernel credential structure modified (privesc)", "T1134", 0.95),
    ("trustcache_inject", "Binary injected into TrustCache", "T1601", 0.95),
    ("sandbox_escape", "Sandbox profile bypassed at kernel level", "T1562.001", 0.9),
    ("codesign_bypass_kernel", "Code signing bypassed in kernel", "T1553.002", 0.95),
    ("task_port_steal", "Task port stolen for unauthorized process control", "T1134", 0.9),
    ("kernel_heap_spray", "Kernel heap spray pattern detected", "T1014", 0.85),
    ("iomfb_exploit", "IOMFB (IOKit Mobile Framebuffer) exploitation", "T1014", 0.9),
    ("iokit_ool_exploit", "IOKit OOL (out-of-line) data exploit", "T1014", 0.9),
];

// ── KEXT Loading Anomalies ───────────────────────────────────────────────────

const KEXT_ANOMALY_PATTERNS: &[(&str, &str, f64)] = &[
    ("/tmp/", "KEXT loaded from /tmp/ directory", 0.95),
    ("/var/tmp/", "KEXT loaded from /var/tmp/", 0.95),
    ("/Users/", "KEXT loaded from user home directory", 0.85),
    ("/private/var/", "KEXT loaded from private var", 0.7),
    ("/Volumes/", "KEXT loaded from mounted volume", 0.75),
    ("/dev/", "KEXT loaded from /dev/ (impossible path, suspicious)", 0.95),
    ("com.apple.", "KEXT spoofing Apple bundle ID (verify signature)", 0.4),
    (".hidden", "KEXT with hidden directory component", 0.85),
    ("...", "KEXT path with dot traversal", 0.9),
    ("adhoc", "KEXT with ad-hoc code signature", 0.8),
    ("unsigned", "Unsigned KEXT loaded", 0.9),
    ("expired_cert", "KEXT with expired signing certificate", 0.7),
    ("revoked_cert", "KEXT with revoked signing certificate", 0.95),
];

// ── Process Hiding Techniques ────────────────────────────────────────────────

const PROCESS_HIDING_INDICATORS: &[(&str, &str, f64)] = &[
    ("proc_list_mismatch", "Process visible in kernel but not in userspace ps", 0.9),
    ("pid_reuse_rapid", "Rapid PID reuse (fork-bomb or hiding)", 0.6),
    ("zombie_with_open_ports", "Zombie process with active network connections", 0.85),
    ("kernel_thread_anonymous", "Anonymous kernel thread (no associated process)", 0.5),
    ("mach_port_hidden", "Mach port registered but process not visible", 0.8),
    ("launchd_unknown_child", "Unknown child process of launchd", 0.5),
    ("reparented_to_launchd", "Process reparented to launchd (orphan detection evasion)", 0.4),
    ("proc_setinfo_abuse", "proc_setinfo() used to modify process attributes", 0.7),
    ("ptrace_deny_attach", "PT_DENY_ATTACH set (anti-debugging, common in rootkits)", 0.5),
    ("csops_status_spoof", "Code signing status spoofed via csops()", 0.8),
];

// ── Types ────────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum RootkitThreatType {
    // IOKit-specific
    MaliciousIOKitDriver,
    IOUserClientAbuse,
    IORegistryManipulation,
    IOKitMemoryMapAbuse,
    IOKitVtableHook,
    IOKitExploit,
    // KEXT-specific
    KnownRootkitKEXT,
    UnsignedKEXT,
    SpoofedBundleID,
    AnomalousKEXTPath,
    ExpiredKEXTSignature,
    RevokedKEXTSignature,
    // System call hooks
    SysCallTableHook,
    MachTrapHook,
    KauthCallbackHijack,
    MACFPolicyAbuse,
    ExceptionPortSteal,
    TaskPortSteal,
    // Boot/firmware
    SIPDisabled,
    AMFIDisabled,
    CodeSigningDisabled,
    EFIModification,
    SSVSealBroken,
    AuxKCTampering,
    IBootExploit,
    BootArgManipulation,
    // Kernel integrity
    KernelTextModified,
    KernelPatchDetected,
    KPPBypass,
    PPLViolation,
    PACForge,
    ZoneCorruption,
    TrustCacheInjection,
    SandboxEscape,
    KernelHeapSpray,
    // Process hiding
    ProcessListManipulation,
    PIDSpoofing,
    CredentialModification,
    ProcessHiding,
    AntiDebugging,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RootkitFinding {
    pub threat_type: RootkitThreatType,
    pub confidence: f64,
    pub description: String,
    pub kext_bundle_id: Option<String>,
    pub kext_path: Option<String>,
    pub kext_signature: Option<String>,
    pub malware_family: Option<String>,
    pub iokit_class: Option<String>,
    pub syscall_number: Option<u32>,
    pub kernel_address: Option<String>,
    pub boot_arg: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub mitre_id: String,
    pub cve_id: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KernelEvent {
    pub event_type: String,
    pub kext_bundle_id: Option<String>,
    pub kext_path: Option<String>,
    pub kext_signed: Option<bool>,
    pub kext_signer: Option<String>,
    pub kext_dependencies: Vec<String>,
    pub iokit_class: Option<String>,
    pub iokit_user_client: Option<String>,
    pub syscall_name: Option<String>,
    pub syscall_number: Option<u32>,
    pub kernel_address: Option<String>,
    pub boot_args: Option<String>,
    pub nvram_key: Option<String>,
    pub nvram_value: Option<String>,
    pub integrity_check: Option<String>,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub parent_pid: Option<u32>,
    pub file_path: Option<String>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RootkitAnalysisResult {
    pub is_rootkit: bool,
    pub events_analyzed: u32,
    pub findings: Vec<RootkitFinding>,
    pub threat_categories: Vec<String>,
    pub risk_score: f64,
    pub severity: Severity,
    pub mitre_ids: Vec<String>,
    pub analysis_time_ms: u64,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct RootkitScanStats {
    pub total_events: u64,
    pub rootkit_detections: u64,
    pub kext_anomalies: u64,
    pub syscall_hook_detections: u64,
    pub boot_integrity_failures: u64,
    pub kernel_integrity_failures: u64,
    pub process_hiding_detections: u64,
    pub iokit_abuse_detections: u64,
    pub avg_analysis_time_ms: f64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RootkitSigEntry {
    pub bundle_id: String,
    pub family: String,
    pub severity: f64,
}

// ── Main Struct ──────────────────────────────────────────────────────────────

pub struct IOKitRootkitDetector {
    running: Arc<AtomicBool>,
    scan_history: RwLock<HierarchicalState<RootkitScanStats>>,
    result_cache: TieredCache<String, RootkitAnalysisResult>,
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    kernel_feature_codec: RwLock<VqCodec>,
    rate_accumulator: RwLock<StreamAccumulator<f64, RootkitScanStats>>,
    metrics: MemoryMetrics,
    event_diffs: RwLock<DifferentialStore<String, String>>,
    recent_analyses: RwLock<PruningMap<String, RootkitAnalysisResult>>,
    sig_db: PagedMemory<RootkitSigEntry>,
    file_streamer: StreamingFileProcessor,
    content_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    threat_matrix: RwLock<SparseMatrix<String, String, u64>>,
    stats: RwLock<RootkitScanStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
    known_good_kexts: RwLock<HashSet<String>>,
    compressed_artifacts: RwLock<HashMap<String, Vec<u8>>>,
}

impl IOKitRootkitDetector {
    pub fn new() -> Self {
        let mut known_good = HashSet::new();
        // Apple standard KEXTs
        for prefix in &[
            "com.apple.iokit.", "com.apple.driver.", "com.apple.kpi.",
            "com.apple.kext.", "com.apple.filesystems.", "com.apple.security.",
            "com.apple.nke.", "com.apple.network.",
        ] {
            known_good.insert(prefix.to_string());
        }

        Self {
            running: Arc::new(AtomicBool::new(true)),
            scan_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            result_cache: TieredCache::new(CACHE_MAX),
            risk_computer: RwLock::new(ReversibleComputation::new(STATS_WINDOW, |v: &[f64]| {
                if v.is_empty() { 0.0 } else { v.iter().sum::<f64>() / v.len() as f64 }
            })),
            kernel_feature_codec: RwLock::new(VqCodec::new(VQ_CODEBOOK_SIZE, VQ_VECTOR_DIM)),
            rate_accumulator: RwLock::new(StreamAccumulator::new(
                STATS_WINDOW, RootkitScanStats::default(),
                |acc: &mut RootkitScanStats, vals: &[f64]| { acc.total_events += vals.len() as u64; },
            )),
            metrics: MemoryMetrics::new(64 * 1024 * 1024),
            event_diffs: RwLock::new(DifferentialStore::new()),
            recent_analyses: RwLock::new(PruningMap::new(CACHE_MAX)),
            sig_db: PagedMemory::new(PAGE_SIZE, MAX_RESIDENT_PAGES),
            file_streamer: StreamingFileProcessor::new(MMAP_CHUNK_SIZE),
            content_dedup: RwLock::new(DedupStore::new()),
            threat_matrix: RwLock::new(SparseMatrix::new(0u64)),
            stats: RwLock::new(RootkitScanStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(512)),
            total_events: AtomicU64::new(0),
            known_good_kexts: RwLock::new(known_good),
            compressed_artifacts: RwLock::new(HashMap::new()),
        }
    }

    pub fn analyze_event(&self, event: &KernelEvent) -> Option<RootkitAnalysisResult> {
        if !self.running.load(Ordering::SeqCst) { return None; }
        let start = std::time::Instant::now();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.scan_history.write().checkpoint(self.stats.read().clone());

        let cache_key = format!("rootkit:{}:{}:{}",
            event.event_type, event.process_pid.unwrap_or(0), event.timestamp);
        let mut findings = Vec::new();
        let mut mitre_ids = HashSet::new();
        let mut categories = HashSet::new();

        // ── 1. Known rootkit KEXT matching ──────────────────────────────
        if let Some(ref bundle_id) = event.kext_bundle_id {
            let bid_lower = bundle_id.to_lowercase();
            for &(pattern, desc, family, conf) in KNOWN_ROOTKIT_KEXTS {
                if bid_lower.contains(&pattern.to_lowercase()) {
                    findings.push(RootkitFinding {
                        threat_type: RootkitThreatType::KnownRootkitKEXT,
                        confidence: conf,
                        description: format!("{}: {}", desc, bundle_id),
                        kext_bundle_id: Some(bundle_id.clone()),
                        kext_path: event.kext_path.clone(),
                        kext_signature: event.kext_signer.clone(),
                        malware_family: Some(family.to_string()),
                        iokit_class: None, syscall_number: None, kernel_address: None,
                        boot_arg: None, process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: "T1547.006".into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1547.006".into());
                    categories.insert("KnownRootkitKEXT".to_string());
                }
            }

            // KEXT signing verification
            if let Some(false) = event.kext_signed {
                findings.push(RootkitFinding {
                    threat_type: RootkitThreatType::UnsignedKEXT,
                    confidence: 0.9,
                    description: format!("Unsigned KEXT loaded: {}", bundle_id),
                    kext_bundle_id: Some(bundle_id.clone()),
                    kext_path: event.kext_path.clone(),
                    kext_signature: None, malware_family: None, iokit_class: None,
                    syscall_number: None, kernel_address: None, boot_arg: None,
                    process_name: event.process_name.clone(),
                    process_pid: event.process_pid, mitre_id: "T1547.006".into(),
                    cve_id: None, timestamp: event.timestamp,
                });
                mitre_ids.insert("T1547.006".into());
                categories.insert("UnsignedKEXT".to_string());
            }

            // Apple bundle ID spoofing check
            if bid_lower.starts_with("com.apple.") {
                let known = self.known_good_kexts.read();
                let is_known = known.iter().any(|prefix| bid_lower.starts_with(&prefix.to_lowercase()));
                if !is_known {
                    // Not in our known-good list AND claims com.apple — suspicious
                    if let Some(ref signer) = event.kext_signer {
                        if !signer.contains("Apple") && !signer.contains("Software Signing") {
                            findings.push(RootkitFinding {
                                threat_type: RootkitThreatType::SpoofedBundleID,
                                confidence: 0.85,
                                description: format!("KEXT claims Apple bundle ID but signed by: {}", signer),
                                kext_bundle_id: Some(bundle_id.clone()),
                                kext_path: event.kext_path.clone(),
                                kext_signature: Some(signer.clone()),
                                malware_family: None, iokit_class: None,
                                syscall_number: None, kernel_address: None, boot_arg: None,
                                process_name: event.process_name.clone(),
                                process_pid: event.process_pid, mitre_id: "T1036.005".into(),
                                cve_id: None, timestamp: event.timestamp,
                            });
                            mitre_ids.insert("T1036.005".into());
                            categories.insert("SpoofedBundleID".to_string());
                        }
                    }
                }
            }
        }

        // ── 2. KEXT path anomaly detection ──────────────────────────────
        if let Some(ref path) = event.kext_path {
            for &(anomaly, desc, conf) in KEXT_ANOMALY_PATTERNS {
                if path.to_lowercase().contains(&anomaly.to_lowercase()) {
                    // Skip com.apple. pattern if already checked above
                    if anomaly == "com.apple." { continue; }

                    let tt = if anomaly == "unsigned" { RootkitThreatType::UnsignedKEXT }
                        else if anomaly == "adhoc" { RootkitThreatType::UnsignedKEXT }
                        else if anomaly == "expired_cert" { RootkitThreatType::ExpiredKEXTSignature }
                        else if anomaly == "revoked_cert" { RootkitThreatType::RevokedKEXTSignature }
                        else { RootkitThreatType::AnomalousKEXTPath };

                    findings.push(RootkitFinding {
                        threat_type: tt, confidence: conf,
                        description: format!("{}: {}", desc, path),
                        kext_bundle_id: event.kext_bundle_id.clone(),
                        kext_path: Some(path.clone()),
                        kext_signature: event.kext_signer.clone(),
                        malware_family: None, iokit_class: None,
                        syscall_number: None, kernel_address: None, boot_arg: None,
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: "T1547.006".into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1547.006".into());
                    categories.insert("KEXTAnomaly".to_string());
                }
            }
        }

        // ── 3. IOKit user client abuse ──────────────────────────────────
        if let Some(ref ioclass) = event.iokit_class {
            for &(class, desc, conf) in SUSPICIOUS_IOKIT_CLASSES {
                if ioclass.contains(class) {
                    findings.push(RootkitFinding {
                        threat_type: RootkitThreatType::IOUserClientAbuse,
                        confidence: conf,
                        description: format!("{}: {}", desc, ioclass),
                        kext_bundle_id: None, kext_path: None, kext_signature: None,
                        malware_family: None, iokit_class: Some(ioclass.clone()),
                        syscall_number: None, kernel_address: None, boot_arg: None,
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: "T1014".into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1014".into());
                    categories.insert("IOKitAbuse".to_string());
                }
            }
        }

        // ── 4. System call hook detection ───────────────────────────────
        if let Some(ref integrity) = event.integrity_check {
            let int_lower = integrity.to_lowercase();
            for &(pattern, desc, mitre, conf) in SYSCALL_HOOK_INDICATORS {
                if int_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("sysent") { RootkitThreatType::SysCallTableHook }
                        else if pattern.contains("mach_trap") { RootkitThreatType::MachTrapHook }
                        else if pattern.contains("kauth") { RootkitThreatType::KauthCallbackHijack }
                        else if pattern.contains("macf") { RootkitThreatType::MACFPolicyAbuse }
                        else if pattern.contains("exception_port") { RootkitThreatType::ExceptionPortSteal }
                        else if pattern.contains("task_for_pid") || pattern.contains("task_port") ||
                                pattern.contains("host_priv") { RootkitThreatType::TaskPortSteal }
                        else { RootkitThreatType::SysCallTableHook };
                    findings.push(RootkitFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        kext_bundle_id: None, kext_path: None, kext_signature: None,
                        malware_family: None, iokit_class: None,
                        syscall_number: event.syscall_number,
                        kernel_address: event.kernel_address.clone(),
                        boot_arg: None,
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: mitre.into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                    categories.insert("SyscallHook".to_string());
                }
            }

            // Kernel integrity indicators
            for &(pattern, desc, mitre, conf) in KERNEL_INTEGRITY_INDICATORS {
                if int_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("text_segment") { RootkitThreatType::KernelTextModified }
                        else if pattern.contains("kernel_patch") { RootkitThreatType::KernelPatchDetected }
                        else if pattern.contains("kpp") { RootkitThreatType::KPPBypass }
                        else if pattern.contains("ppl") { RootkitThreatType::PPLViolation }
                        else if pattern.contains("pac") { RootkitThreatType::PACForge }
                        else if pattern.contains("zone") { RootkitThreatType::ZoneCorruption }
                        else if pattern.contains("vtable") { RootkitThreatType::IOKitVtableHook }
                        else if pattern.contains("allproc") { RootkitThreatType::ProcessListManipulation }
                        else if pattern.contains("pid_spoof") { RootkitThreatType::PIDSpoofing }
                        else if pattern.contains("cred_modify") { RootkitThreatType::CredentialModification }
                        else if pattern.contains("trustcache") { RootkitThreatType::TrustCacheInjection }
                        else if pattern.contains("sandbox") { RootkitThreatType::SandboxEscape }
                        else if pattern.contains("heap_spray") { RootkitThreatType::KernelHeapSpray }
                        else if pattern.contains("task_port") { RootkitThreatType::TaskPortSteal }
                        else if pattern.contains("iomfb") || pattern.contains("iokit_ool") { RootkitThreatType::IOKitExploit }
                        else { RootkitThreatType::KernelPatchDetected };
                    findings.push(RootkitFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        kext_bundle_id: None, kext_path: None, kext_signature: None,
                        malware_family: None, iokit_class: None,
                        syscall_number: None, kernel_address: event.kernel_address.clone(),
                        boot_arg: None,
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: mitre.into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                    categories.insert("KernelIntegrity".to_string());
                }
            }

            // Process hiding indicators
            for &(pattern, desc, conf) in PROCESS_HIDING_INDICATORS {
                if int_lower.contains(&pattern.to_lowercase()) {
                    let tt = if pattern.contains("proc_list") || pattern.contains("allproc") {
                        RootkitThreatType::ProcessListManipulation
                    } else if pattern.contains("pid") {
                        RootkitThreatType::PIDSpoofing
                    } else if pattern.contains("ptrace") || pattern.contains("csops") {
                        RootkitThreatType::AntiDebugging
                    } else {
                        RootkitThreatType::ProcessHiding
                    };
                    findings.push(RootkitFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        kext_bundle_id: None, kext_path: None, kext_signature: None,
                        malware_family: None, iokit_class: None,
                        syscall_number: None, kernel_address: None, boot_arg: None,
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: "T1014".into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert("T1014".into());
                    categories.insert("ProcessHiding".to_string());
                }
            }
        }

        // ── 5. Boot & firmware analysis ─────────────────────────────────
        let boot_text = format!("{} {} {}",
            event.boot_args.as_deref().unwrap_or(""),
            event.nvram_key.as_deref().unwrap_or(""),
            event.nvram_value.as_deref().unwrap_or(""));
        if !boot_text.trim().is_empty() {
            let boot_lower = boot_text.to_lowercase();
            for &(pattern, desc, mitre, conf) in BOOT_INDICATORS {
                let check = pattern.to_lowercase().replace(".*", "");
                if boot_lower.contains(&check) {
                    let tt = if pattern.contains("amfi") { RootkitThreatType::AMFIDisabled }
                        else if pattern.contains("cs_enforcement") || pattern.contains("codesign") {
                            RootkitThreatType::CodeSigningDisabled
                        }
                        else if pattern.contains("csr") || pattern.contains("rootless") || pattern.contains("kext-dev") {
                            RootkitThreatType::SIPDisabled
                        }
                        else if pattern.contains("EFI") { RootkitThreatType::EFIModification }
                        else if pattern.contains("SSV") { RootkitThreatType::SSVSealBroken }
                        else if pattern.contains("AuxKC") { RootkitThreatType::AuxKCTampering }
                        else if pattern.contains("iBoot") { RootkitThreatType::IBootExploit }
                        else if pattern.contains("immutable") { RootkitThreatType::KernelPatchDetected }
                        else if pattern.contains("boot.efi") { RootkitThreatType::EFIModification }
                        else { RootkitThreatType::BootArgManipulation };
                    findings.push(RootkitFinding {
                        threat_type: tt, confidence: conf, description: desc.to_string(),
                        kext_bundle_id: None, kext_path: None, kext_signature: None,
                        malware_family: None, iokit_class: None,
                        syscall_number: None, kernel_address: None,
                        boot_arg: Some(boot_text.trim().to_string()),
                        process_name: event.process_name.clone(),
                        process_pid: event.process_pid, mitre_id: mitre.into(),
                        cve_id: None, timestamp: event.timestamp,
                    });
                    mitre_ids.insert(mitre.into());
                    categories.insert("BootFirmware".to_string());
                }
            }
        }

        // ── Store state & build result ──────────────────────────────────
        self.event_diffs.write().record_insert(cache_key.clone(),
            format!("type={},kext={:?},findings={}",
                event.event_type, event.kext_bundle_id, findings.len()));

        let risk_score = self.calculate_risk_score(&findings);
        self.risk_computer.write().push(risk_score);
        let severity = Self::risk_to_severity(risk_score);
        let is_rootkit = risk_score > 0.55;
        let mitre_vec: Vec<String> = mitre_ids.into_iter().collect();
        let cats_vec: Vec<String> = categories.into_iter().collect();
        let elapsed = start.elapsed().as_millis() as u64;

        let result = RootkitAnalysisResult {
            is_rootkit, events_analyzed: 1, findings,
            threat_categories: cats_vec,
            risk_score, severity: severity.clone(),
            mitre_ids: mitre_vec.clone(), analysis_time_ms: elapsed,
        };

        self.result_cache.insert(cache_key.clone(), result.clone());
        self.recent_analyses.write().insert_with_priority(cache_key.clone(), result.clone(), risk_score);
        {
            let mut m = self.threat_matrix.write();
            for f in &result.findings {
                let k = format!("{:?}", f.threat_type);
                let c = *m.get(&k, &cache_key);
                m.set(k, cache_key.clone(), c + 1);
            }
        }
        if let Ok(j) = serde_json::to_vec(&result.findings) {
            self.compressed_artifacts.write().insert(cache_key, compression::compress_lz4(&j));
        }
        self.rate_accumulator.write().push(risk_score);

        {
            let mut s = self.stats.write();
            s.total_events += 1;
            if is_rootkit {
                s.rootkit_detections += 1;
                for f in &result.findings {
                    match f.threat_type {
                        RootkitThreatType::KnownRootkitKEXT | RootkitThreatType::UnsignedKEXT |
                        RootkitThreatType::SpoofedBundleID | RootkitThreatType::AnomalousKEXTPath =>
                            s.kext_anomalies += 1,
                        RootkitThreatType::SysCallTableHook | RootkitThreatType::MachTrapHook |
                        RootkitThreatType::KauthCallbackHijack | RootkitThreatType::MACFPolicyAbuse =>
                            s.syscall_hook_detections += 1,
                        RootkitThreatType::SIPDisabled | RootkitThreatType::AMFIDisabled |
                        RootkitThreatType::EFIModification | RootkitThreatType::SSVSealBroken |
                        RootkitThreatType::IBootExploit | RootkitThreatType::BootArgManipulation =>
                            s.boot_integrity_failures += 1,
                        RootkitThreatType::KernelTextModified | RootkitThreatType::KernelPatchDetected |
                        RootkitThreatType::KPPBypass | RootkitThreatType::PPLViolation |
                        RootkitThreatType::PACForge | RootkitThreatType::ZoneCorruption =>
                            s.kernel_integrity_failures += 1,
                        RootkitThreatType::ProcessListManipulation | RootkitThreatType::PIDSpoofing |
                        RootkitThreatType::ProcessHiding =>
                            s.process_hiding_detections += 1,
                        RootkitThreatType::IOUserClientAbuse | RootkitThreatType::IOKitVtableHook |
                        RootkitThreatType::IOKitExploit | RootkitThreatType::IORegistryManipulation |
                        RootkitThreatType::IOKitMemoryMapAbuse =>
                            s.iokit_abuse_detections += 1,
                        _ => {}
                    }
                }
            }
            let n = s.total_events as f64;
            s.avg_analysis_time_ms = s.avg_analysis_time_ms * ((n - 1.0) / n) + elapsed as f64 / n;
        }

        if is_rootkit {
            self.alerts.write().push_back(MalwareAlert {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().timestamp(),
                severity,
                module: "iokit_rootkit_detector".into(),
                title: format!("ROOTKIT DETECTED: {} categories ({})",
                    result.threat_categories.len(),
                    result.threat_categories.join(", ")),
                details: format!(
                    "CRITICAL: Risk {:.1}%, {} findings. Categories: {}. KEXT: {:?}, Process: {:?} (pid {:?})",
                    risk_score * 100.0, result.findings.len(),
                    result.threat_categories.join(", "),
                    event.kext_bundle_id, event.process_name, event.process_pid),
                path: event.file_path.clone().or(event.kext_path.clone()),
                process_name: event.process_name.clone(),
                process_pid: event.process_pid,
                verdict: None,
                mitre_ids: mitre_vec,
                remediation: vec![
                    "IMMEDIATE: Isolate system from network".into(),
                    "Boot into Recovery Mode (Cmd+R) and verify SIP: csrutil status".into(),
                    "Run: kextstat | grep -v com.apple to list third-party KEXTs".into(),
                    "Check NVRAM: nvram -p | grep boot-args".into(),
                    "Check NVRAM: nvram -p | grep csr-active-config".into(),
                    "Verify system volume: diskutil apfs listVolumeGroups".into(),
                    "If rootkit confirmed: full system reinstall from known-good media".into(),
                    "Preserve forensic evidence before remediation".into(),
                    "Report to Apple Product Security if 0-day suspected".into(),
                ],
                confidence: risk_score,
            });
        }
        Some(result)
    }

    fn calculate_risk_score(&self, findings: &[RootkitFinding]) -> f64 {
        if findings.is_empty() { return 0.0; }
        let mut score = 0.0f64;
        for f in findings {
            let w = match f.threat_type {
                // Highest severity — confirmed rootkit behaviors
                RootkitThreatType::KnownRootkitKEXT => 2.0,
                RootkitThreatType::KernelTextModified => 1.9,
                RootkitThreatType::SysCallTableHook => 1.8,
                RootkitThreatType::MachTrapHook => 1.8,
                RootkitThreatType::KPPBypass | RootkitThreatType::PPLViolation => 1.8,
                RootkitThreatType::PACForge => 1.7,
                RootkitThreatType::ProcessListManipulation => 1.7,
                RootkitThreatType::TrustCacheInjection => 1.7,
                RootkitThreatType::SSVSealBroken => 1.7,
                RootkitThreatType::IBootExploit => 1.8,
                RootkitThreatType::EFIModification => 1.7,
                // High severity
                RootkitThreatType::KernelPatchDetected => 1.6,
                RootkitThreatType::IOKitVtableHook => 1.5,
                RootkitThreatType::CredentialModification => 1.5,
                RootkitThreatType::AMFIDisabled | RootkitThreatType::CodeSigningDisabled => 1.5,
                RootkitThreatType::SIPDisabled => 1.4,
                RootkitThreatType::UnsignedKEXT => 1.4,
                RootkitThreatType::SpoofedBundleID => 1.3,
                RootkitThreatType::AnomalousKEXTPath => 1.3,
                RootkitThreatType::TaskPortSteal | RootkitThreatType::ExceptionPortSteal => 1.4,
                RootkitThreatType::KauthCallbackHijack | RootkitThreatType::MACFPolicyAbuse => 1.4,
                RootkitThreatType::SandboxEscape => 1.4,
                RootkitThreatType::KernelHeapSpray | RootkitThreatType::ZoneCorruption => 1.3,
                RootkitThreatType::IOKitExploit => 1.3,
                // Medium severity
                RootkitThreatType::IOUserClientAbuse => 1.0,
                RootkitThreatType::PIDSpoofing => 1.1,
                RootkitThreatType::AntiDebugging => 0.8,
                RootkitThreatType::BootArgManipulation => 1.0,
                _ => 0.9,
            };
            score += f.confidence * w;
        }
        // Use higher divisor to prevent saturation with many low-confidence findings
        (score / (findings.len() as f64 * 1.8)).min(1.0)
    }

    fn risk_to_severity(s: f64) -> Severity {
        if s >= 0.85 { Severity::Critical }
        else if s >= 0.65 { Severity::High }
        else if s >= 0.45 { Severity::Medium }
        else if s >= 0.25 { Severity::Low }
        else { Severity::Info }
    }

    pub fn known_good_kext_count(&self) -> usize { self.known_good_kexts.read().len() }
    pub fn stats(&self) -> RootkitScanStats { self.stats.read().clone() }
    pub fn drain_alerts(&self) -> Vec<MalwareAlert> { self.alerts.write().drain(..).collect() }
    pub fn stop(&self) { self.running.store(false, Ordering::SeqCst); }
}
