//! Module 63: MDMProfileDetector — MDM Configuration Profile Persistence Detection
//!
//! Monitors macOS configuration profiles (MDM profiles) for unauthorized installation
//! that can enforce persistence, weaken security settings, install certificates,
//! redirect DNS, configure VPNs, or grant remote management access.
//!
//! ## Features
//!
//! - **Profile directory monitoring**: Watches /var/db/ConfigurationProfiles for changes
//! - **Profile payload analysis**: Inspects profile payloads for dangerous configurations
//! - **Certificate injection detection**: Detects custom CA certificates for MITM attacks
//! - **DNS override detection**: Catches profiles that redirect DNS to attacker-controlled servers
//! - **VPN configuration abuse**: Monitors for forced VPN profiles routing traffic to adversaries
//! - **Web content filter abuse**: Detects profiles installing proxy/filter configurations
//! - **Remote management backdoors**: Catches profiles enabling screen sharing, ARD, SSH
//! - **Restriction profile abuse**: Detects profiles that disable security features
//! - **Profile enrollment spoofing**: Identifies profiles masquerading as corporate MDM
//! - **Profiles CLI monitoring**: Watches `profiles` command invocations for install/remove
//! - **Trust store manipulation**: Detects added root CAs in system trust store
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) profile change history
//! - **#2  TieredCache** — Hot cache for recently analyzed profiles
//! - **#3  ReversibleComputation** — Recompute risk scores on profile changes
//! - **#5  StreamAccumulator** — Streaming profile event rate
//! - **#6  MemoryMetrics** — Bounded memory for profile analysis
//! - **#461 DifferentialStore** — Track profile payload diffs between scans
//! - **#569 PruningMap** — Auto-expire old profile events
//! - **#592 DedupStore** — Deduplicate identical profile payloads
//! - **#627 SparseMatrix** — Payload type × action frequency matrix
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1176 — Browser Extensions (profile-installed extensions)
//! - T1484 — Domain Policy Modification
//! - T1553.004 — Install Root Certificate
//! - T1021.001 — Remote Services: Remote Desktop Protocol (ARD profiles)
//! - T1071 — Application Layer Protocol (VPN/proxy profiles)
//! - T1562.001 — Impair Defenses: Disable or Modify Tools

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Constants ───────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const PROFILE_CACHE_MAX: usize = 5_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 16 * 1024 * 1024;

/// macOS configuration profile storage directories
const PROFILE_DIRS: &[&str] = &[
    "/var/db/ConfigurationProfiles",
    "/var/db/ConfigurationProfiles/Store",
    "/var/db/ConfigurationProfiles/Settings",
    "/Library/ConfigurationProfiles",
    "/Library/Managed Preferences",
];

/// User-level profile directories (per-user)
const USER_PROFILE_DIRS: &[&str] = &[
    "Library/ConfigurationProfiles",
    "Library/ManagedPreferences",
];

/// System certificate trust store paths
const TRUST_STORE_PATHS: &[&str] = &[
    "/Library/Keychains/System.keychain",
    "/System/Library/Keychains/SystemRootCertificates.keychain",
    "/var/db/TCC/TCC.db",
];

/// Dangerous profile payload types — these can fundamentally alter system behavior
const DANGEROUS_PAYLOAD_TYPES: &[&str] = &[
    "com.apple.security.root",               // Root certificate installation
    "com.apple.security.pkcs12",             // PKCS12 certificate
    "com.apple.security.pkcs1",              // PKCS1 certificate
    "com.apple.vpn.managed",                 // VPN configuration
    "com.apple.vpn.managed.applayer",        // App-layer VPN
    "com.apple.webcontent-filter",           // Web content filter/proxy
    "com.apple.proxy.http.global",           // Global HTTP proxy
    "com.apple.dnsProxy.managed",            // DNS proxy
    "com.apple.MCX",                         // Managed client settings
    "com.apple.screensharing",               // Screen sharing/ARD
    "com.apple.RemoteDesktop",               // Apple Remote Desktop
    "com.apple.SSH",                         // SSH access control
    "com.apple.loginwindow",                 // Login window modification
    "com.apple.security.firewall",           // Firewall modification
    "com.apple.ManagedClient.preferences",   // Managed preferences
    "com.apple.applicationaccess",           // Application restrictions
    "com.apple.SoftwareUpdate",              // Software update redirection
    "com.apple.MCXRedirector",               // MCX redirector
];

/// Payload types that weaken security when configured
const SECURITY_WEAKENING_PAYLOADS: &[&str] = &[
    "com.apple.security.firewall",           // Can disable firewall
    "com.apple.applicationaccess",           // Can allow unsigned apps
    "com.apple.systempolicy.control",        // Can disable Gatekeeper
    "com.apple.SoftwareUpdate",              // Can redirect updates
    "com.apple.TCC.configuration-profile-policy", // Can grant TCC without consent
];

/// Known MDM vendor organization names
const KNOWN_MDM_VENDORS: &[&str] = &[
    "Jamf", "JAMF Software", "Microsoft Intune",
    "VMware AirWatch", "Workspace ONE",
    "Kandji", "Mosyle", "Addigy",
    "Hexnode", "SimpleMDM", "Fleet",
    "Meraki", "MobileIron", "Ivanti",
    "Apple", "Apple Inc.",
];

/// Suspicious profile characteristics
const SUSPICIOUS_PROFILE_INDICATORS: &[&str] = &[
    "PayloadRemovalDisallowed",   // Cannot be removed by user
    "HasRemovalPasscode",         // Requires passcode to remove
    "IsEncrypted",                // Encrypted payload (hides content)
    "ConsentText",                // Custom consent (social engineering)
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ProfileType {
    /// MDM enrollment profile
    MDMEnrollment,
    /// Configuration profile with payloads
    Configuration,
    /// Certificate-only profile
    Certificate,
    /// VPN/network profile
    VPNNetwork,
    /// Restriction/policy profile
    Restriction,
    /// Remote management profile
    RemoteManagement,
    /// Unknown profile type
    Unknown,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ProfileAction {
    Installed,
    Removed,
    Modified,
    PayloadAdded,
    PayloadRemoved,
    Enrolled,
    Unenrolled,
    CertificateAdded,
    TrustStoreModified,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum ProfileRisk {
    Trusted,
    KnownMDM,
    Unknown,
    Suspicious,
    Dangerous,
    Malicious,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MDMProfileEvent {
    pub id: String,
    pub timestamp: i64,
    pub profile_type: ProfileType,
    pub action: ProfileAction,
    pub risk: ProfileRisk,
    pub severity: Severity,
    pub confidence: f64,
    pub profile_identifier: String,
    pub profile_display_name: String,
    pub profile_organization: String,
    pub profile_uuid: String,
    pub payload_types: Vec<String>,
    pub dangerous_payloads: Vec<String>,
    pub file_path: String,
    pub content_hash: String,
    pub installing_process: String,
    pub installing_pid: u32,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub blocked: bool,
    pub removal_disallowed: bool,
    pub is_encrypted: bool,
    pub is_signed: bool,
    pub is_known_mdm: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct MDMProfileStats {
    pub events_analyzed: u64,
    pub profiles_scanned: u64,
    pub threats_detected: u64,
    pub threats_blocked: u64,
    pub profiles_installed: u64,
    pub profiles_removed: u64,
    pub dangerous_payloads_found: u64,
    pub certificates_added: u64,
    pub vpn_profiles_detected: u64,
    pub security_weakening_detected: u64,
    pub removal_locked_profiles: u64,
    pub unknown_mdm_profiles: u64,
    pub payload_types: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// MDMProfileDetector — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct MDMProfileDetector {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical profile history ──
    monitor_history: RwLock<HierarchicalState<MDMProfileStats>>,
    // ── Breakthrough #2: Tiered profile event cache ──
    event_cache: TieredCache<String, MDMProfileEvent>,
    // ── Breakthrough #3: Reversible risk computation ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming profile event rate ──
    event_rate: RwLock<StreamAccumulator<f64, MDMProfileStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Profile payload diff tracking ──
    profile_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old profile events ──
    recent_events: RwLock<PruningMap<String, MDMProfileEvent>>,
    // ── Breakthrough #592: Deduplicate identical profiles ──
    profile_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Payload type × action frequency ──
    payload_action_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Known profile UUIDs — maps UUID → last known hash
    known_profiles: RwLock<HashMap<String, String>>,
    stats: RwLock<MDMProfileStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl MDMProfileDetector {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(PROFILE_CACHE_MAX)
            .with_metrics(metrics.clone(), "mdm_profile_events");
        let risk_computer = ReversibleComputation::new(512,
            |risks: &[f64]| if risks.is_empty() { 0.0 } else { risks.iter().sum::<f64>() / risks.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, MDMProfileStats::default(),
            |acc: &mut MDMProfileStats, rates: &[f64]| { for &r in rates { acc.events_analyzed += r as u64; } });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache, risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate), metrics,
            profile_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(PROFILE_CACHE_MAX)),
            profile_dedup: RwLock::new(DedupStore::new()),
            payload_action_matrix: RwLock::new(SparseMatrix::new(0u64)),
            known_profiles: RwLock::new(HashMap::new()),
            stats: RwLock::new(MDMProfileStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(500)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("mdm_profile", MEMORY_BUDGET / 2);
        info!("MDMProfileDetector started — watching {} profile dirs, {} trust stores",
            PROFILE_DIRS.len(), TRUST_STORE_PATHS.len());
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("MDMProfileDetector stopped");
    }

    pub fn is_running(&self) -> bool { self.running.load(Ordering::SeqCst) }

    // ── Classification ─────────────────────────────────────────────────────

    fn classify_profile(payload_types: &[String]) -> ProfileType {
        if payload_types.iter().any(|p| p.contains("mdm") || p.contains("MDM")) {
            return ProfileType::MDMEnrollment;
        }
        if payload_types.iter().any(|p| p.contains("vpn") || p.contains("VPN")) {
            return ProfileType::VPNNetwork;
        }
        if payload_types.iter().any(|p| p.contains("certificate") || p.contains("root") || p.contains("pkcs")) {
            return ProfileType::Certificate;
        }
        if payload_types.iter().any(|p| p.contains("screensharing") || p.contains("RemoteDesktop") || p.contains("SSH")) {
            return ProfileType::RemoteManagement;
        }
        if payload_types.iter().any(|p| p.contains("restriction") || p.contains("applicationaccess") || p.contains("firewall")) {
            return ProfileType::Restriction;
        }
        if payload_types.is_empty() {
            return ProfileType::Unknown;
        }
        ProfileType::Configuration
    }

    fn is_known_mdm(organization: &str) -> bool {
        KNOWN_MDM_VENDORS.iter().any(|v| {
            organization.to_lowercase().contains(&v.to_lowercase())
        })
    }

    fn find_dangerous_payloads(payload_types: &[String]) -> Vec<String> {
        payload_types.iter()
            .filter(|p| DANGEROUS_PAYLOAD_TYPES.iter().any(|d| p.contains(d)))
            .cloned()
            .collect()
    }

    fn find_security_weakening(payload_types: &[String]) -> Vec<String> {
        payload_types.iter()
            .filter(|p| SECURITY_WEAKENING_PAYLOADS.iter().any(|s| p.contains(s)))
            .cloned()
            .collect()
    }

    fn classify_risk(
        organization: &str,
        dangerous_payloads: &[String],
        security_weakening: &[String],
        removal_disallowed: bool,
        is_encrypted: bool,
        is_signed: bool,
    ) -> ProfileRisk {
        // Unsigned + dangerous payloads = malicious
        if !is_signed && !dangerous_payloads.is_empty() {
            return ProfileRisk::Malicious;
        }
        // Security weakening from unknown source = dangerous
        if !security_weakening.is_empty() && !Self::is_known_mdm(organization) {
            return ProfileRisk::Dangerous;
        }
        // Encrypted + removal locked from unknown = suspicious
        if is_encrypted && removal_disallowed && !Self::is_known_mdm(organization) {
            return ProfileRisk::Suspicious;
        }
        // Known MDM vendor
        if Self::is_known_mdm(organization) {
            return ProfileRisk::KnownMDM;
        }
        // Has dangerous payloads from unknown
        if !dangerous_payloads.is_empty() {
            return ProfileRisk::Suspicious;
        }
        ProfileRisk::Unknown
    }

    // ── Primary Analysis ───────────────────────────────────────────────────

    /// Analyze an MDM profile installation or modification.
    pub fn analyze_profile(
        &self,
        action: ProfileAction,
        profile_identifier: &str,
        display_name: &str,
        organization: &str,
        profile_uuid: &str,
        payload_types: &[String],
        file_path: &str,
        content_hash: &str,
        process_name: &str,
        pid: u32,
        removal_disallowed: bool,
        is_encrypted: bool,
        is_signed: bool,
    ) -> Option<MDMProfileEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let dangerous_payloads = Self::find_dangerous_payloads(payload_types);
        let security_weakening = Self::find_security_weakening(payload_types);
        let profile_type = Self::classify_profile(payload_types);
        let known_mdm = Self::is_known_mdm(organization);
        let risk = Self::classify_risk(
            organization, &dangerous_payloads, &security_weakening,
            removal_disallowed, is_encrypted, is_signed,
        );

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();

        // ── New profile installation ──
        if action == ProfileAction::Installed {
            self.stats.write().profiles_installed += 1;
            if !known_mdm {
                indicators.push(format!("Profile installed from unknown organization: '{}'", organization));
                self.stats.write().unknown_mdm_profiles += 1;
            }
        }

        // ── Profile removal ──
        if action == ProfileAction::Removed {
            self.stats.write().profiles_removed += 1;
        }

        // ── Dangerous payload detection ──
        if !dangerous_payloads.is_empty() {
            for dp in &dangerous_payloads {
                indicators.push(format!("Dangerous payload: {}", dp));
            }
            self.stats.write().dangerous_payloads_found += dangerous_payloads.len() as u64;
        }

        // ── Security weakening ──
        if !security_weakening.is_empty() {
            for sw in &security_weakening {
                indicators.push(format!("Security-weakening payload: {}", sw));
                mitre_techniques.push("T1562.001".to_string());
            }
            self.stats.write().security_weakening_detected += security_weakening.len() as u64;
        }

        // ── Certificate injection ──
        if payload_types.iter().any(|p| p.contains("root") || p.contains("pkcs")) {
            indicators.push("Root certificate installation detected".to_string());
            mitre_techniques.push("T1553.004".to_string());
            self.stats.write().certificates_added += 1;
        }

        // ── VPN/proxy configuration ──
        if payload_types.iter().any(|p| p.contains("vpn") || p.contains("proxy")) {
            indicators.push("VPN/proxy profile detected — traffic may be redirected".to_string());
            mitre_techniques.push("T1071".to_string());
            self.stats.write().vpn_profiles_detected += 1;
        }

        // ── Remote management ──
        if payload_types.iter().any(|p| p.contains("screensharing") || p.contains("RemoteDesktop") || p.contains("SSH")) {
            indicators.push("Remote management enabled via profile".to_string());
            mitre_techniques.push("T1021.001".to_string());
        }

        // ── Removal disallowed ──
        if removal_disallowed {
            indicators.push("Profile cannot be removed by user (PayloadRemovalDisallowed)".to_string());
            self.stats.write().removal_locked_profiles += 1;
        }

        // ── Encrypted payload (hiding content) ──
        if is_encrypted && !known_mdm {
            indicators.push("Profile payload is encrypted — content hidden from inspection".to_string());
        }

        // ── Unsigned profile ──
        if !is_signed {
            indicators.push("Profile is unsigned — no identity verification".to_string());
        }

        // ── Non-standard installer ──
        if !["mdmclient", "profiles", "mdmd", "launchd", "UserEventAgent",
             "ConfigurationProfiles", "SystemUIServer"].iter()
            .any(|p| process_name.contains(p))
        {
            indicators.push(format!("Profile installed by unexpected process: {}", process_name));
        }

        // ── Content change ──
        if action == ProfileAction::Modified {
            let previous = self.known_profiles.read().get(profile_uuid).cloned();
            if let Some(ref prev) = previous {
                if prev != content_hash {
                    indicators.push(format!("Profile content changed: {} → {}",
                        &prev[..8.min(prev.len())],
                        &content_hash[..8.min(content_hash.len())]));
                }
            }
        }

        if indicators.is_empty() { return None; }

        let severity = match risk {
            ProfileRisk::Malicious => Severity::Critical,
            ProfileRisk::Dangerous => Severity::Critical,
            ProfileRisk::Suspicious => Severity::High,
            ProfileRisk::Unknown => Severity::Medium,
            ProfileRisk::KnownMDM => Severity::Low,
            ProfileRisk::Trusted => Severity::Info,
        };

        let confidence = match risk {
            ProfileRisk::Malicious => 0.95,
            ProfileRisk::Dangerous => 0.90,
            ProfileRisk::Suspicious => 0.80,
            ProfileRisk::Unknown => 0.65,
            _ => (0.4 + indicators.len() as f64 * 0.1).min(0.90),
        };

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1484".to_string());
        }

        let event = MDMProfileEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            profile_type, action, risk, severity, confidence,
            profile_identifier: profile_identifier.to_string(),
            profile_display_name: display_name.to_string(),
            profile_organization: organization.to_string(),
            profile_uuid: profile_uuid.to_string(),
            payload_types: payload_types.to_vec(),
            dangerous_payloads,
            file_path: file_path.to_string(),
            content_hash: content_hash.to_string(),
            installing_process: process_name.to_string(),
            installing_pid: pid,
            indicators,
            mitre_techniques,
            blocked: matches!(risk, ProfileRisk::Malicious),
            removal_disallowed, is_encrypted, is_signed,
            is_known_mdm: known_mdm,
        };

        // Update stores
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(event.id.clone(), event.clone(), confidence);
        self.profile_diffs.write().record_insert(event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());
        self.profile_dedup.write().insert(
            format!("{}:{}", profile_uuid, content_hash), vec![]);
        self.known_profiles.write().insert(profile_uuid.to_string(), content_hash.to_string());

        // Update sparse matrix
        for pt in payload_types {
            let action_str = format!("{:?}", action);
            let current = *self.payload_action_matrix.read().get(pt, &action_str);
            self.payload_action_matrix.write().set(pt.clone(), action_str, current + 1);
        }

        // Update stats
        self.stats.write().threats_detected += 1;
        for pt in payload_types {
            *self.stats.write().payload_types.entry(pt.clone()).or_insert(0) += 1;
        }
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.profile_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.profile_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(confidence);

        warn!("MDM profile persistence: {:?} {:?} '{}' org='{}' by {} (pid {})",
            action, risk, display_name, organization, process_name, pid);

        Some(event)
    }

    /// Analyze a `profiles` CLI command invocation.
    pub fn analyze_profiles_command(&self, pid: u32, user: &str, cmdline: &str)
        -> Option<MDMProfileEvent>
    {
        let now = chrono::Utc::now().timestamp();

        if !cmdline.contains("profiles") { return None; }

        let mut indicators = Vec::new();
        let mut mitre_techniques = vec!["T1484".to_string()];

        if cmdline.contains("install") || cmdline.contains("-I") {
            indicators.push(format!("Profile install command by user '{}': {}", user, cmdline));
        }
        if cmdline.contains("remove") || cmdline.contains("-R") {
            indicators.push(format!("Profile removal command: {}", cmdline));
        }
        if cmdline.contains("renew") || cmdline.contains("-N") {
            indicators.push(format!("Profile renewal command: {}", cmdline));
        }
        if cmdline.contains("-forced") || cmdline.contains("--forced") {
            indicators.push("Force flag used — bypassing user consent".to_string());
            mitre_techniques.push("T1562.001".to_string());
        }

        if indicators.is_empty() { return None; }

        let event = MDMProfileEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            profile_type: ProfileType::Unknown,
            action: ProfileAction::Installed,
            risk: ProfileRisk::Unknown,
            severity: Severity::High,
            confidence: 0.70,
            profile_identifier: String::new(),
            profile_display_name: cmdline.to_string(),
            profile_organization: String::new(),
            profile_uuid: String::new(),
            payload_types: vec![],
            dangerous_payloads: vec![],
            file_path: String::new(),
            content_hash: String::new(),
            installing_process: "shell".to_string(),
            installing_pid: pid,
            indicators,
            mitre_techniques,
            blocked: false,
            removal_disallowed: false,
            is_encrypted: false, is_signed: false,
            is_known_mdm: false,
        };

        self.event_cache.insert(event.id.clone(), event.clone());
        self.stats.write().threats_detected += 1;
        self.event_rate.write().push(1.0);

        warn!("Profiles command detected: {} (user: {}, pid: {})", cmdline, user, pid);
        Some(event)
    }

    pub fn stats(&self) -> MDMProfileStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }
}
