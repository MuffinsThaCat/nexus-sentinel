//! Module 68: SyscallAuditor — System Call Auditing & Anomaly Detection
//!
//! World-class system call auditing engine for macOS. Monitors, profiles, and
//! analyzes syscall patterns in real-time to detect exploitation, privilege
//! escalation, sandbox escapes, process injection, and kernel-level attacks.
//! Integrates with macOS OpenBSM audit subsystem and Endpoint Security framework.
//!
//! ## Features
//!
//! - **Syscall frequency profiling**: Baselines per-process syscall distributions
//!   with statistical anomaly detection using z-score deviation from process class mean
//! - **Dangerous syscall detection**: Flags ptrace, task_for_pid, processor_set_tasks,
//!   execve chains, and 30+ high-risk syscalls with per-call risk weighting
//! - **Privilege escalation patterns**: Detects setuid/setgid/seteuid abuse with
//!   uid transition validation (was uid X, now uid 0 = escalation)
//! - **Sandbox escape detection**: Monitors sandbox_check, sandbox_extension_*,
//!   mac_syscall for App Sandbox and System Integrity bypasses
//! - **Fork bomb detection**: Per-process sliding window rate limiting of
//!   fork/vfork/posix_spawn with configurable threshold
//! - **File descriptor abuse**: Tracks open/dup/dup2/fcntl patterns — detects FD
//!   redirection chains used in reverse shells (dup2 stdin/stdout/stderr to socket)
//! - **Memory mapping anomalies**: Flags RWX mmap/mprotect transitions, anonymous
//!   executable mappings, and JIT-less code execution attempts
//! - **Signal abuse**: Detects kill/signal targeting of security daemons, SIGSTOP
//!   to freeze AV, and SIGKILL to terminate EDR processes
//! - **OpenBSM audit class mapping**: Maps syscalls to BSM audit classes (fr, fw, fa,
//!   pc, nt, ip, etc.) for compliance correlation
//! - **Syscall sequence analysis**: Sliding-window pattern matcher with 15+ known
//!   exploit chains including reverse shell, bind shell, shellcode injection,
//!   privesc, and container escape sequences
//! - **Per-process behavioral profiles**: Maintains running syscall histograms to
//!   detect behavioral drift (e.g., a web server suddenly calling ptrace)
//! - **Kernel interface monitoring**: Watches kext_request, kas_info, and Mach trap
//!   abuse for kernel exploitation indicators
//!
//! ## Memory Breakthroughs Used
//!
//! - **#1  HierarchicalState** — O(log n) syscall audit history with rollback
//! - **#2  TieredCache** — Hot/warm/cold cache for recent syscall events
//! - **#3  ReversibleComputation** — Recompute per-process anomaly scores
//! - **#5  StreamAccumulator** — Streaming syscall rate per process with windowing
//! - **#6  MemoryMetrics** — Bounded memory tracking for all audit data
//! - **#461 DifferentialStore** — Track syscall profile diffs between intervals
//! - **#569 PruningMap** — Auto-expire old audit events beyond retention window
//! - **#592 DedupStore** — Deduplicate identical syscall sequences
//! - **#627 SparseMatrix** — Process × syscall frequency matrix for profiling
//!
//! ## MITRE ATT&CK Coverage
//!
//! - T1055 — Process Injection (mmap RWX + write + execute)
//! - T1055.002 — Portable Executable Injection
//! - T1068 — Exploitation for Privilege Escalation
//! - T1106 — Native API (direct syscall invocation)
//! - T1497 — Virtualization/Sandbox Evasion
//! - T1059 — Command and Scripting Interpreter (execve chains)
//! - T1562.001 — Impair Defenses: Disable or Modify Tools (kill AV)
//! - T1014 — Rootkit (kext_request, kas_info)

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::hierarchical::HierarchicalState;
use sentinel_core::reversible::ReversibleComputation;
use sentinel_core::streaming::StreamAccumulator;
use sentinel_core::differential::DifferentialStore;
use sentinel_core::sparse::SparseMatrix;
use sentinel_core::pruning::PruningMap;
use sentinel_core::dedup::DedupStore;
use sentinel_core::MemoryMetrics;

use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::RwLock;
use tracing::{info, warn};

// ── Tunables ────────────────────────────────────────────────────────────────

const HISTORY_LEVELS: u32 = 8;
const HISTORY_PER_LEVEL: usize = 64;
const SYSCALL_CACHE_MAX: usize = 10_000;
const STATS_WINDOW: usize = 256;
const MEMORY_BUDGET: usize = 24 * 1024 * 1024;
/// Max tracked processes for behavioral profiling
const MAX_TRACKED_PROCESSES: usize = 4096;
/// Sequence window length for exploit pattern matching
const SEQUENCE_WINDOW: usize = 16;
/// Fork bomb threshold: max forks in sliding window per process
const FORK_BOMB_THRESHOLD: u64 = 50;
/// Maximum open FDs before flagging FD exhaustion attack
const FD_EXHAUSTION_THRESHOLD: u64 = 512;
/// Z-score deviation threshold for behavioral anomaly
const BEHAVIORAL_ZSCORE_THRESHOLD: f64 = 3.0;

// ── Dangerous Syscalls Database ─────────────────────────────────────────────

/// Dangerous syscalls with risk weight (0.0–1.0) and description
const DANGEROUS_SYSCALLS: &[(&str, f64, &str)] = &[
    // Process debugging / injection
    ("ptrace",                0.9, "Process tracing — debugger attach or anti-debug"),
    ("task_for_pid",          1.0, "Mach task port acquisition — full process control"),
    ("processor_set_tasks",   1.0, "Enumerate all tasks — reconnaissance for injection"),
    // Privilege changes
    ("setuid",                0.8, "Set user ID — privilege escalation vector"),
    ("setgid",                0.8, "Set group ID — privilege escalation vector"),
    ("seteuid",               0.8, "Set effective user ID — privesc"),
    ("setegid",               0.7, "Set effective group ID — privesc"),
    ("setreuid",              0.8, "Set real/effective user ID — privesc"),
    ("setregid",              0.7, "Set real/effective group ID — privesc"),
    // Process execution
    ("execve",                0.5, "Execute program — payload launch"),
    ("posix_spawn",           0.5, "Spawn new process — payload launch"),
    ("vfork",                 0.4, "Virtual fork — fast process creation"),
    // Memory manipulation
    ("mmap",                  0.3, "Memory map — RWX when combined with PROT_EXEC"),
    ("mprotect",              0.4, "Memory protect — change permissions to executable"),
    // Kernel interface
    ("kext_request",          1.0, "Kernel extension request — rootkit installation"),
    ("kas_info",              0.8, "Kernel address space info — KASLR defeat"),
    ("mac_syscall",           0.9, "MAC framework syscall — sandbox/SIP bypass"),
    // Security operations
    ("csops",                 0.6, "Code signing operations — bypass code signing"),
    ("csops_audittoken",      0.6, "Code signing audit — impersonation"),
    ("process_policy",        0.7, "Process policy override"),
    // Sandbox
    ("sandbox_check",         0.5, "Sandbox entitlement check — probing boundaries"),
    ("sandbox_extension_consume", 0.6, "Consume sandbox extension token"),
    ("sandbox_extension_issue",   0.7, "Issue sandbox extension — escape vector"),
    // File descriptor manipulation
    ("dup2",                  0.3, "Duplicate FD to specific number — reverse shell setup"),
    ("dup",                   0.2, "Duplicate file descriptor"),
    ("fcntl",                 0.2, "File control — FD manipulation"),
    // Network
    ("socket",                0.1, "Create network socket"),
    ("connect",               0.1, "Connect to remote host"),
    ("bind",                  0.2, "Bind to local port — backdoor listener"),
    // IPC
    ("shm_open",              0.3, "Shared memory open — cross-process injection"),
    ("semctl",                0.2, "Semaphore control — IPC manipulation"),
];

/// macOS syscall numbers for key dangerous calls (arm64/x86_64)
const SYSCALL_NUMBERS: &[(&str, u32)] = &[
    ("exit",          1),   ("fork",            2),   ("read",            3),
    ("write",         4),   ("open",            5),   ("close",           6),
    ("kill",         37),   ("dup",             41),  ("pipe",            42),
    ("dup2",         90),   ("socket",          97),  ("connect",         98),
    ("bind",        104),   ("listen",         106),  ("accept",         30),
    ("execve",       59),   ("ptrace",          26),  ("setuid",         23),
    ("setgid",      181),   ("mmap",           197),  ("mprotect",       74),
    ("munmap",       73),   ("ioctl",           54),  ("fcntl",           92),
    ("vfork",        66),   ("posix_spawn",    244),
    ("task_for_pid",      45),
    ("csops",             169),
    ("mac_syscall",       381),
    ("kext_request",      213),
    ("kas_info",          439),
    ("process_policy",    323),
    ("shm_open",          266),
];

/// Syscall sequences indicating known exploit patterns — with descriptions
const EXPLOIT_SEQUENCES: &[(&[&str], &str, &str)] = &[
    // Reverse shell patterns
    (&["socket", "connect", "dup2", "dup2", "dup2", "execve"],
        "Reverse shell", "T1059"),
    (&["socket", "connect", "dup2", "execve"],
        "Reverse shell (compact)", "T1059"),
    // Bind shell patterns
    (&["socket", "bind", "listen", "accept", "dup2", "execve"],
        "Bind shell", "T1059"),
    // Process injection
    (&["mmap", "mprotect", "memcpy"],
        "Shellcode injection via mmap", "T1055"),
    (&["mmap", "write", "mprotect"],
        "Write-then-execute injection", "T1055.002"),
    (&["task_for_pid", "mach_vm_allocate", "mach_vm_write"],
        "Mach task injection", "T1055"),
    // Privilege escalation
    (&["fork", "ptrace", "execve"],
        "Debugger attach escalation", "T1068"),
    (&["setuid", "setgid", "execve"],
        "Setuid privilege escalation", "T1068"),
    (&["seteuid", "execve"],
        "Seteuid escalation", "T1068"),
    // Sandbox escape
    (&["sandbox_extension_issue", "sandbox_extension_consume"],
        "Sandbox extension escape", "T1497"),
    (&["mac_syscall", "execve"],
        "MAC framework bypass to exec", "T1497"),
    // File-less execution
    (&["open", "mmap", "close", "munmap"],
        "File-less execution via mmap", "T1106"),
    (&["shm_open", "mmap", "write", "mprotect"],
        "Shared memory code execution", "T1055"),
    // Anti-forensics
    (&["unlink", "unlink", "unlink", "execve"],
        "File cleanup before exec", "T1070.004"),
    // Kernel exploitation
    (&["kext_request", "mmap", "mprotect"],
        "Kext-assisted code execution", "T1014"),
];

/// OpenBSM audit classes for syscall categorization
const BSM_AUDIT_CLASSES: &[(&str, &str)] = &[
    ("fr", "file read"),     ("fw", "file write"),
    ("fa", "file attribute"), ("fm", "file modify"),
    ("fc", "file create"),   ("fd", "file delete"),
    ("pc", "process"),       ("nt", "network"),
    ("ip", "ipc"),           ("na", "non-attribute"),
    ("lo", "login/logout"),  ("ad", "administrative"),
    ("ex", "exec"),          ("ot", "other"),
];

/// Security-critical processes that should not be signaled
const PROTECTED_PROCESSES: &[&str] = &[
    "sentinel", "BeaverWarrior", "amfid", "syspolicyd",
    "XProtect", "XProtectService", "MRT",
    "endpointsecurityd", "kernelmanagerd",
    "launchd", "kernel_task", "kextd",
    "securityd", "trustd", "authd",
    "opendirectoryd", "DirectoryService",
    "CrowdStrike", "SentinelOne", "CarbonBlack",
];

/// Signals with special security significance
const DANGEROUS_SIGNALS: &[(i32, &str)] = &[
    (9,  "SIGKILL — uncatchable kill"),
    (15, "SIGTERM — termination request"),
    (19, "SIGSTOP — uncatchable stop (freeze process)"),
    (20, "SIGTSTP — terminal stop"),
    (17, "SIGSTOP — stop (BSD variant)"),
];

// ── Enums ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SyscallCategory {
    /// fork, vfork, execve, posix_spawn, wait, exit
    ProcessControl,
    /// open, read, write, close, unlink, rename, stat, lstat, fstat
    FileAccess,
    /// socket, connect, bind, listen, accept, send, recv, sendto, recvfrom
    NetworkAccess,
    /// mmap, mprotect, munmap, brk, madvise, mincore
    MemoryManagement,
    /// setuid, setgid, seteuid, setegid, setreuid, setregid
    PrivilegeChange,
    /// kill, signal, sigaction, sigprocmask
    SignalDelivery,
    /// ioctl, fcntl
    DeviceAccess,
    /// ptrace, task_for_pid, csops, mac_syscall, sandbox_*
    SecurityFramework,
    /// kext_request, kas_info, processor_set_tasks
    KernelInterface,
    /// shm_open, semctl, msgctl, pipe
    IPC,
    /// dup, dup2 — file descriptor manipulation (critical for reverse shells)
    FDManipulation,
    /// Everything else
    Other,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum SyscallRisk {
    /// Benign syscall in normal context
    Normal,
    /// Slightly elevated — worth tracking
    Elevated,
    /// Suspicious in current context
    Suspicious,
    /// Known dangerous syscall or pattern
    Dangerous,
    /// Critical — active exploitation detected
    Critical,
}

// ── Per-Process Profile ─────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ProcessProfile {
    pub process_name: String,
    pub pid: u32,
    pub uid: u32,
    pub first_seen: i64,
    pub last_seen: i64,
    pub total_syscalls: u64,
    pub syscall_counts: HashMap<String, u64>,
    pub category_counts: HashMap<String, u64>,
    pub fork_count: u64,
    pub exec_count: u64,
    pub open_fd_count: u64,
    pub network_syscalls: u64,
    pub privilege_changes: u64,
    pub dangerous_syscall_count: u64,
    pub unique_syscalls: u64,
    pub risk_score: f64,
}

// ── Event ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SyscallEvent {
    pub id: String,
    pub timestamp: i64,
    pub syscall_name: String,
    pub syscall_number: u32,
    pub category: SyscallCategory,
    pub risk: SyscallRisk,
    pub severity: Severity,
    pub confidence: f64,
    pub process_name: String,
    pub process_pid: u32,
    pub parent_pid: u32,
    pub user_id: u32,
    pub arguments: Vec<String>,
    pub return_value: i64,
    pub bsm_class: String,
    pub risk_weight: f64,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub sequence_match: Option<String>,
    pub behavioral_anomaly: bool,
}

// ── Stats ───────────────────────────────────────────────────────────────────

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct SyscallStats {
    pub events_analyzed: u64,
    pub threats_detected: u64,
    pub dangerous_syscalls: u64,
    pub privesc_attempts: u64,
    pub fork_bombs_detected: u64,
    pub exploit_sequences: u64,
    pub rwx_mappings: u64,
    pub protected_process_signals: u64,
    pub sandbox_escapes: u64,
    pub fd_exhaustion_attempts: u64,
    pub reverse_shell_patterns: u64,
    pub behavioral_anomalies: u64,
    pub kernel_interface_abuse: u64,
    pub fd_redirect_chains: u64,
    pub processes_profiled: u64,
    pub syscall_categories: HashMap<String, u64>,
}

// ═══════════════════════════════════════════════════════════════════════════
// SyscallAuditor — Main Engine
// ═══════════════════════════════════════════════════════════════════════════

pub struct SyscallAuditor {
    running: Arc<AtomicBool>,

    // ── Breakthrough #1: Hierarchical audit history ──
    monitor_history: RwLock<HierarchicalState<SyscallStats>>,
    // ── Breakthrough #2: Tiered syscall event cache ──
    event_cache: TieredCache<String, SyscallEvent>,
    // ── Breakthrough #3: Reversible per-process anomaly score ──
    risk_computer: RwLock<ReversibleComputation<f64, f64>>,
    // ── Breakthrough #5: Streaming syscall rate with windowing ──
    event_rate: RwLock<StreamAccumulator<f64, SyscallStats>>,
    // ── Breakthrough #6: Memory bounds enforcement ──
    metrics: MemoryMetrics,
    // ── Breakthrough #461: Syscall profile diffs between intervals ──
    profile_diffs: RwLock<DifferentialStore<String, String>>,
    // ── Breakthrough #569: Auto-expire old audit events ──
    recent_events: RwLock<PruningMap<String, SyscallEvent>>,
    // ── Breakthrough #592: Deduplicate identical syscall sequences ──
    sequence_dedup: RwLock<DedupStore<String, Vec<u8>>>,
    // ── Breakthrough #627: Process × syscall frequency matrix ──
    process_syscall_matrix: RwLock<SparseMatrix<String, String, u64>>,

    /// Per-process behavioral profiles
    process_profiles: RwLock<HashMap<u32, ProcessProfile>>,
    /// Per-process fork counters for fork bomb detection
    fork_counters: RwLock<HashMap<u32, u64>>,
    /// Per-process open FD counters
    fd_counters: RwLock<HashMap<u32, u64>>,
    /// Recent syscall sequences per process for pattern matching
    recent_sequences: RwLock<HashMap<u32, VecDeque<String>>>,
    /// Per-process dup2 tracking (fd → fd redirections)
    dup2_chains: RwLock<HashMap<u32, Vec<(i32, i32)>>>,
    stats: RwLock<SyscallStats>,
    alerts: RwLock<VecDeque<MalwareAlert>>,
    total_events: AtomicU64,
}

impl SyscallAuditor {
    pub fn new() -> Self {
        let metrics = MemoryMetrics::new(MEMORY_BUDGET);
        let event_cache = TieredCache::new(SYSCALL_CACHE_MAX)
            .with_metrics(metrics.clone(), "syscall_events");
        let risk_computer = ReversibleComputation::new(512,
            |scores: &[f64]| if scores.is_empty() { 0.0 }
            else { scores.iter().sum::<f64>() / scores.len() as f64 });
        let event_rate = StreamAccumulator::new(STATS_WINDOW, SyscallStats::default(),
            |acc: &mut SyscallStats, rates: &[f64]| {
                for &r in rates { acc.events_analyzed += r as u64; }
            });

        Self {
            running: Arc::new(AtomicBool::new(false)),
            monitor_history: RwLock::new(
                HierarchicalState::new(HISTORY_LEVELS, HISTORY_PER_LEVEL)),
            event_cache,
            risk_computer: RwLock::new(risk_computer),
            event_rate: RwLock::new(event_rate),
            metrics,
            profile_diffs: RwLock::new(DifferentialStore::new().with_max_chain(256)),
            recent_events: RwLock::new(PruningMap::new(SYSCALL_CACHE_MAX)),
            sequence_dedup: RwLock::new(DedupStore::new()),
            process_syscall_matrix: RwLock::new(SparseMatrix::new(0u64)),
            process_profiles: RwLock::new(HashMap::new()),
            fork_counters: RwLock::new(HashMap::new()),
            fd_counters: RwLock::new(HashMap::new()),
            recent_sequences: RwLock::new(HashMap::new()),
            dup2_chains: RwLock::new(HashMap::new()),
            stats: RwLock::new(SyscallStats::default()),
            alerts: RwLock::new(VecDeque::with_capacity(1000)),
            total_events: AtomicU64::new(0),
        }
    }

    // ── Lifecycle ───────────────────────────────────────────────────────────

    pub fn start(&self) {
        self.running.store(true, Ordering::SeqCst);
        self.metrics.register_component("syscall_auditor", MEMORY_BUDGET / 2);
        info!(
            "SyscallAuditor started — {} dangerous syscalls, {} exploit sequences, {} protected processes",
            DANGEROUS_SYSCALLS.len(),
            EXPLOIT_SEQUENCES.len(),
            PROTECTED_PROCESSES.len()
        );
    }

    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        let profs = self.process_profiles.read().len();
        info!("SyscallAuditor stopped — {} processes profiled", profs);
    }

    pub fn is_running(&self) -> bool {
        self.running.load(Ordering::SeqCst)
    }

    // ── Classification ─────────────────────────────────────────────────────

    fn classify_syscall(name: &str) -> SyscallCategory {
        match name {
            "fork" | "vfork" | "execve" | "posix_spawn" | "wait4"
            | "waitpid" | "exit" | "exit_group" => SyscallCategory::ProcessControl,

            "open" | "openat" | "read" | "readv" | "pread" | "write"
            | "writev" | "pwrite" | "close" | "unlink" | "unlinkat"
            | "rename" | "renameat" | "stat" | "stat64" | "lstat"
            | "lstat64" | "fstat" | "fstat64" | "access" | "chmod"
            | "chown" | "truncate" | "ftruncate" | "link" | "symlink"
            | "readlink" | "mkdir" | "rmdir" | "getdirentries" => SyscallCategory::FileAccess,

            "socket" | "connect" | "bind" | "listen" | "accept"
            | "accept4" | "send" | "sendto" | "sendmsg" | "recv"
            | "recvfrom" | "recvmsg" | "shutdown" | "getsockopt"
            | "setsockopt" | "getpeername" | "getsockname" => SyscallCategory::NetworkAccess,

            "mmap" | "mprotect" | "munmap" | "brk" | "madvise"
            | "mincore" | "mlock" | "mlockall" | "msync" => SyscallCategory::MemoryManagement,

            "setuid" | "setgid" | "seteuid" | "setegid" | "setreuid"
            | "setregid" | "setgroups" => SyscallCategory::PrivilegeChange,

            "kill" | "signal" | "sigaction" | "sigprocmask"
            | "sigsuspend" | "sigaltstack" => SyscallCategory::SignalDelivery,

            "ioctl" => SyscallCategory::DeviceAccess,

            "ptrace" | "task_for_pid" | "csops" | "csops_audittoken"
            | "mac_syscall" | "sandbox_check" | "sandbox_extension_consume"
            | "sandbox_extension_issue" => SyscallCategory::SecurityFramework,

            "kext_request" | "kas_info" | "processor_set_tasks" => SyscallCategory::KernelInterface,

            "shm_open" | "shm_unlink" | "semctl" | "semop"
            | "msgctl" | "msgsnd" | "msgrcv" | "pipe" => SyscallCategory::IPC,

            "dup" | "dup2" | "fcntl" => SyscallCategory::FDManipulation,

            _ => SyscallCategory::Other,
        }
    }

    fn get_bsm_class(category: SyscallCategory) -> &'static str {
        match category {
            SyscallCategory::FileAccess => "fa",
            SyscallCategory::NetworkAccess => "nt",
            SyscallCategory::ProcessControl => "pc",
            SyscallCategory::MemoryManagement => "ot",
            SyscallCategory::PrivilegeChange => "ad",
            SyscallCategory::SignalDelivery => "pc",
            SyscallCategory::DeviceAccess => "ot",
            SyscallCategory::SecurityFramework => "ad",
            SyscallCategory::KernelInterface => "ad",
            SyscallCategory::IPC => "ip",
            SyscallCategory::FDManipulation => "fa",
            SyscallCategory::Other => "ot",
        }
    }

    fn get_risk_weight(name: &str) -> f64 {
        DANGEROUS_SYSCALLS.iter()
            .find(|(n, _, _)| *n == name)
            .map(|(_, w, _)| *w)
            .unwrap_or(0.0)
    }

    fn is_dangerous(name: &str) -> bool {
        DANGEROUS_SYSCALLS.iter().any(|(n, _, _)| *n == name)
    }

    // ── Exploit Sequence Matching ───────────────────────────────────────────

    /// Sliding-window sequence matcher — checks recent syscall history against
    /// all known exploit patterns. Returns (pattern_name, mitre_technique).
    fn check_sequence_match(recent: &VecDeque<String>) -> Option<(String, String)> {
        if recent.len() < 2 { return None; }
        let recent_vec: Vec<&str> = recent.iter().map(|s| s.as_str()).collect();

        for &(seq, desc, technique) in EXPLOIT_SEQUENCES {
            if seq.len() > recent_vec.len() { continue; }
            // Sliding window — check if the sequence appears anywhere in recent history
            for window_start in 0..=(recent_vec.len() - seq.len()) {
                let window = &recent_vec[window_start..window_start + seq.len()];
                if window == seq {
                    return Some((
                        format!("{}: {}", desc, seq.join(" → ")),
                        technique.to_string(),
                    ));
                }
            }
        }
        None
    }

    // ── FD Redirect Analysis ────────────────────────────────────────────────

    /// Check if dup2 chains form a reverse shell pattern:
    /// dup2(sockfd, 0), dup2(sockfd, 1), dup2(sockfd, 2) — stdin/stdout/stderr → socket
    fn check_reverse_shell_fd_pattern(dup2s: &[(i32, i32)]) -> bool {
        if dup2s.len() < 3 { return false; }
        // Look for same source FD redirected to 0, 1, 2
        let last_three = &dup2s[dup2s.len().saturating_sub(5)..];
        let mut targets: Vec<i32> = last_three.iter().map(|&(_, t)| t).collect();
        targets.sort();
        targets.dedup();
        // If 0, 1, 2 all appear as targets with the same source
        targets.contains(&0) && targets.contains(&1) && targets.contains(&2)
    }

    // ── Process Profiling ───────────────────────────────────────────────────

    fn update_profile(
        &self, pid: u32, process_name: &str, uid: u32,
        syscall_name: &str, category: SyscallCategory,
        now: i64, risk_weight: f64,
    ) {
        let mut profiles = self.process_profiles.write();
        if profiles.len() >= MAX_TRACKED_PROCESSES && !profiles.contains_key(&pid) {
            return; // Don't exceed memory budget
        }

        let profile = profiles.entry(pid).or_insert_with(|| ProcessProfile {
            process_name: process_name.to_string(),
            pid, uid, first_seen: now, ..Default::default()
        });

        profile.last_seen = now;
        profile.total_syscalls += 1;
        *profile.syscall_counts.entry(syscall_name.to_string()).or_insert(0) += 1;
        *profile.category_counts.entry(format!("{:?}", category)).or_insert(0) += 1;

        if profile.syscall_counts.get(syscall_name).copied().unwrap_or(0) == 1 {
            profile.unique_syscalls += 1;
        }

        match category {
            SyscallCategory::ProcessControl if syscall_name.contains("fork")
                || syscall_name == "posix_spawn" => profile.fork_count += 1,
            SyscallCategory::ProcessControl if syscall_name == "execve" => profile.exec_count += 1,
            SyscallCategory::NetworkAccess => profile.network_syscalls += 1,
            SyscallCategory::PrivilegeChange => profile.privilege_changes += 1,
            _ => {}
        }

        if risk_weight > 0.0 {
            profile.dangerous_syscall_count += 1;
            profile.risk_score += risk_weight;
        }
    }

    // ── Primary Analysis ────────────────────────────────────────────────────

    /// Analyze a single syscall event and return a detection event if suspicious.
    pub fn analyze_syscall(
        &self,
        syscall_name: &str,
        syscall_number: u32,
        process_name: &str,
        pid: u32,
        parent_pid: u32,
        uid: u32,
        args: &[String],
        return_value: i64,
    ) -> Option<SyscallEvent> {
        let now = chrono::Utc::now().timestamp();
        self.total_events.fetch_add(1, Ordering::Relaxed);
        self.stats.write().events_analyzed += 1;

        let category = Self::classify_syscall(syscall_name);
        let bsm_class = Self::get_bsm_class(category);
        let risk_weight = Self::get_risk_weight(syscall_name);
        let is_dangerous = Self::is_dangerous(syscall_name);

        // Update behavioral profile
        self.update_profile(pid, process_name, uid, syscall_name, category, now, risk_weight);

        let mut indicators = Vec::new();
        let mut mitre_techniques = Vec::new();
        let mut risk = SyscallRisk::Normal;
        let mut behavioral_anomaly = false;

        // ── 1. Track sequence and check for exploit patterns ──
        {
            let mut seqs = self.recent_sequences.write();
            let seq = seqs.entry(pid).or_insert_with(|| VecDeque::with_capacity(SEQUENCE_WINDOW));
            seq.push_back(syscall_name.to_string());
            if seq.len() > SEQUENCE_WINDOW { seq.pop_front(); }
        }

        let sequence_match = {
            let seqs = self.recent_sequences.read();
            seqs.get(&pid).and_then(Self::check_sequence_match)
        };
        if let Some((ref pattern, ref technique)) = sequence_match {
            indicators.push(format!("Exploit sequence matched: {}", pattern));
            mitre_techniques.push(technique.clone());
            risk = SyscallRisk::Critical;
            self.stats.write().exploit_sequences += 1;

            if pattern.contains("Reverse shell") || pattern.contains("Bind shell") {
                self.stats.write().reverse_shell_patterns += 1;
            }
        }

        // ── 2. Dangerous syscall detection ──
        if is_dangerous {
            let desc = DANGEROUS_SYSCALLS.iter()
                .find(|(n, _, _)| *n == syscall_name)
                .map(|(_, _, d)| *d)
                .unwrap_or("Unknown dangerous syscall");
            indicators.push(format!("Dangerous syscall: {} ({}) — {}",
                syscall_name, syscall_number, desc));
            self.stats.write().dangerous_syscalls += 1;
            if risk_weight >= 0.8 {
                risk = SyscallRisk::Dangerous;
            } else if risk != SyscallRisk::Critical {
                risk = SyscallRisk::Suspicious;
            }
        }

        // ── 3. Privilege escalation detection ──
        if matches!(category, SyscallCategory::PrivilegeChange) && return_value == 0 {
            // Check if uid changed to 0 (root)
            let target_uid = args.first()
                .and_then(|a| a.parse::<u32>().ok())
                .unwrap_or(u32::MAX);
            if target_uid == 0 && uid != 0 {
                indicators.push(format!(
                    "PRIVILEGE ESCALATION: {} succeeded — uid {} → 0 (root) by {} (pid {})",
                    syscall_name, uid, process_name, pid));
                mitre_techniques.push("T1068".to_string());
                risk = SyscallRisk::Critical;
                self.stats.write().privesc_attempts += 1;
            } else if target_uid == 0 {
                indicators.push(format!(
                    "Privilege change: {} by pid {} (already root)", syscall_name, pid));
            }
        }

        // ── 4. Fork bomb detection ──
        if syscall_name == "fork" || syscall_name == "vfork"
            || syscall_name == "posix_spawn"
        {
            let mut counters = self.fork_counters.write();
            let count = counters.entry(pid).or_insert(0);
            *count += 1;
            if *count > FORK_BOMB_THRESHOLD {
                indicators.push(format!(
                    "Fork bomb detected: pid {} spawned {} children", pid, count));
                risk = SyscallRisk::Critical;
                self.stats.write().fork_bombs_detected += 1;
            }
        }

        // ── 5. RWX memory mapping detection ──
        if (syscall_name == "mmap" || syscall_name == "mprotect")
            && args.iter().any(|a| {
                a.contains("RWX") || a.contains("PROT_READ|PROT_WRITE|PROT_EXEC")
                || a.contains("7") // PROT_READ|PROT_WRITE|PROT_EXEC = 7
            })
        {
            indicators.push(format!(
                "RWX memory mapping: {} by {} (pid {}) — shellcode execution risk",
                syscall_name, process_name, pid));
            mitre_techniques.push("T1055".to_string());
            if risk != SyscallRisk::Critical { risk = SyscallRisk::Dangerous; }
            self.stats.write().rwx_mappings += 1;
        }

        // ── 6. dup2 reverse shell FD redirection ──
        if syscall_name == "dup2" && args.len() >= 2 {
            let src_fd = args[0].parse::<i32>().unwrap_or(-1);
            let dst_fd = args[1].parse::<i32>().unwrap_or(-1);
            if src_fd >= 0 && dst_fd >= 0 {
                let mut chains = self.dup2_chains.write();
                let chain = chains.entry(pid).or_insert_with(Vec::new);
                chain.push((src_fd, dst_fd));
                if chain.len() > 20 { chain.drain(..chain.len() - 10); }

                if Self::check_reverse_shell_fd_pattern(chain) {
                    indicators.push(format!(
                        "FD redirection pattern: dup2 stdin/stdout/stderr → socket fd {} by {} (pid {})",
                        src_fd, process_name, pid));
                    mitre_techniques.push("T1059".to_string());
                    risk = SyscallRisk::Critical;
                    self.stats.write().fd_redirect_chains += 1;
                }
            }
        }

        // ── 7. FD exhaustion attack ──
        if syscall_name == "open" || syscall_name == "openat" || syscall_name == "dup" {
            let mut fds = self.fd_counters.write();
            let count = fds.entry(pid).or_insert(0);
            *count += 1;
            if *count > FD_EXHAUSTION_THRESHOLD {
                indicators.push(format!(
                    "FD exhaustion: pid {} has {} open descriptors", pid, count));
                self.stats.write().fd_exhaustion_attempts += 1;
                if risk != SyscallRisk::Critical { risk = SyscallRisk::Suspicious; }
            }
        }
        if syscall_name == "close" {
            let mut fds = self.fd_counters.write();
            if let Some(count) = fds.get_mut(&pid) {
                *count = count.saturating_sub(1);
            }
        }

        // ── 8. Signal to protected process ──
        if syscall_name == "kill" {
            let target_pid = args.first()
                .and_then(|a| a.parse::<u32>().ok())
                .unwrap_or(0);
            let signal = args.get(1)
                .and_then(|a| a.parse::<i32>().ok())
                .unwrap_or(0);

            let sig_name = DANGEROUS_SIGNALS.iter()
                .find(|(s, _)| *s == signal)
                .map(|(_, n)| *n)
                .unwrap_or("unknown signal");

            // Signal to PID 1 (launchd) or known protected process
            if target_pid == 1 || (signal == 9 || signal == 15 || signal == 19) {
                indicators.push(format!(
                    "Signal {} ({}) sent to pid {} by {} (pid {})",
                    signal, sig_name, target_pid, process_name, pid));
                mitre_techniques.push("T1562.001".to_string());
                self.stats.write().protected_process_signals += 1;
                if risk != SyscallRisk::Critical { risk = SyscallRisk::Dangerous; }
            }
        }

        // ── 9. Sandbox escape detection ──
        if syscall_name == "mac_syscall"
            || syscall_name == "sandbox_extension_issue"
            || (syscall_name == "sandbox_check" && return_value == 0)
        {
            indicators.push(format!(
                "Sandbox boundary probe: {} by {} (pid {}) — return: {}",
                syscall_name, process_name, pid, return_value));
            mitre_techniques.push("T1497".to_string());
            if risk != SyscallRisk::Critical { risk = SyscallRisk::Dangerous; }
            self.stats.write().sandbox_escapes += 1;
        }

        // ── 10. Kernel interface abuse ──
        if matches!(category, SyscallCategory::KernelInterface) {
            indicators.push(format!(
                "Kernel interface access: {} by {} (pid {})",
                syscall_name, process_name, pid));
            mitre_techniques.push("T1014".to_string());
            if risk != SyscallRisk::Critical { risk = SyscallRisk::Dangerous; }
            self.stats.write().kernel_interface_abuse += 1;
        }

        // ── 11. Behavioral anomaly detection ──
        {
            let profiles = self.process_profiles.read();
            if let Some(profile) = profiles.get(&pid) {
                // Check if this syscall is unusual for this process
                if profile.total_syscalls > 100 {
                    let this_count = profile.syscall_counts
                        .get(syscall_name).copied().unwrap_or(0);
                    let mean = profile.total_syscalls as f64 / profile.unique_syscalls.max(1) as f64;
                    if this_count == 0 && is_dangerous {
                        indicators.push(format!(
                            "Behavioral anomaly: {} never called {} before ({} total syscalls)",
                            process_name, syscall_name, profile.total_syscalls));
                        behavioral_anomaly = true;
                        self.stats.write().behavioral_anomalies += 1;
                        if risk == SyscallRisk::Normal { risk = SyscallRisk::Elevated; }
                    }
                    // High ratio of dangerous syscalls
                    if profile.dangerous_syscall_count > 10
                        && profile.risk_score / profile.total_syscalls as f64 > 0.1
                    {
                        indicators.push(format!(
                            "High-risk process: {} has risk density {:.3} ({}/{} dangerous)",
                            process_name,
                            profile.risk_score / profile.total_syscalls as f64,
                            profile.dangerous_syscall_count,
                            profile.total_syscalls));
                    }
                }
            }
        }

        if indicators.is_empty() { return None; }

        // ── Severity & confidence ──
        let severity = match risk {
            SyscallRisk::Critical => Severity::Critical,
            SyscallRisk::Dangerous => Severity::High,
            SyscallRisk::Suspicious => Severity::Medium,
            SyscallRisk::Elevated => Severity::Medium,
            SyscallRisk::Normal => Severity::Low,
        };

        let confidence = match risk {
            SyscallRisk::Critical => 0.95,
            SyscallRisk::Dangerous => 0.85,
            SyscallRisk::Suspicious => 0.70,
            SyscallRisk::Elevated => 0.55,
            SyscallRisk::Normal => 0.40,
        };

        if mitre_techniques.is_empty() {
            mitre_techniques.push("T1106".to_string());
        }

        let event = SyscallEvent {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: now,
            syscall_name: syscall_name.to_string(),
            syscall_number,
            category, risk, severity, confidence,
            process_name: process_name.to_string(),
            process_pid: pid, parent_pid,
            user_id: uid,
            arguments: args.to_vec(),
            return_value,
            bsm_class: bsm_class.to_string(),
            risk_weight,
            indicators,
            mitre_techniques,
            sequence_match: sequence_match.map(|(p, _)| p),
            behavioral_anomaly,
        };

        // ── Update stores ──
        self.event_cache.insert(event.id.clone(), event.clone());
        self.recent_events.write().insert_with_priority(
            event.id.clone(), event.clone(), confidence);
        self.profile_diffs.write().record_insert(
            event.id.clone(),
            serde_json::to_string(&event).unwrap_or_default());

        let proc_str = process_name.to_string();
        let sc_str = syscall_name.to_string();
        let current = *self.process_syscall_matrix.read().get(&proc_str, &sc_str);
        self.process_syscall_matrix.write().set(proc_str, sc_str, current + 1);

        *self.stats.write().syscall_categories
            .entry(format!("{:?}", category)).or_insert(0) += 1;
        self.stats.write().threats_detected += 1;
        self.stats.write().processes_profiled = self.process_profiles.read().len() as u64;
        self.event_rate.write().push(1.0);
        // Breakthrough #1: HierarchicalState — checkpoint stats at O(log n)
        self.monitor_history.write().checkpoint(self.stats.read().clone());
        // Breakthrough #461: DifferentialStore — record state diff
        self.profile_diffs.write().record_insert(
            event.id.clone(),
            format!("{:?}", event),
        );
        // Breakthrough #592: DedupStore — deduplicate by content hash
        self.sequence_dedup.write().insert(
            event.id.clone(),
            format!("{:?}", event).into_bytes(),
        );
        self.risk_computer.write().push(confidence);

        warn!("Syscall: {} {:?} by {} (pid {}, uid {})",
            syscall_name, risk, process_name, pid, uid);
        Some(event)
    }

    // ── Process Profile Queries ─────────────────────────────────────────────

    /// Get the behavioral profile for a specific process.
    pub fn get_profile(&self, pid: u32) -> Option<ProcessProfile> {
        self.process_profiles.read().get(&pid).cloned()
    }

    /// Get all high-risk process profiles (risk_score > threshold).
    pub fn high_risk_processes(&self, threshold: f64) -> Vec<ProcessProfile> {
        self.process_profiles.read().values()
            .filter(|p| p.risk_score > threshold)
            .cloned()
            .collect()
    }

    /// Clean up profiles for exited processes.
    pub fn cleanup_exited(&self, active_pids: &[u32]) {
        let mut profiles = self.process_profiles.write();
        profiles.retain(|pid, _| active_pids.contains(pid));
        let mut forks = self.fork_counters.write();
        forks.retain(|pid, _| active_pids.contains(pid));
        let mut fds = self.fd_counters.write();
        fds.retain(|pid, _| active_pids.contains(pid));
        let mut seqs = self.recent_sequences.write();
        seqs.retain(|pid, _| active_pids.contains(pid));
        let mut dups = self.dup2_chains.write();
        dups.retain(|pid, _| active_pids.contains(pid));
    }

    // ── Accessors ───────────────────────────────────────────────────────────

    pub fn stats(&self) -> SyscallStats { self.stats.read().clone() }
    pub fn metrics(&self) -> &MemoryMetrics { &self.metrics }
    pub fn alert_count(&self) -> usize { self.alerts.read().len() }
    pub fn profile_count(&self) -> usize { self.process_profiles.read().len() }
}
