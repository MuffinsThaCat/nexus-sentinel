//! Exploit Detector â€” detects active exploitation of known vulnerabilities.
//!
//! Memory optimizations (2 techniques):
//! - **#2 Tiered Cache**: Hot exploit signature lookups
//! - **#6 Theoretical Verifier**: Bound exploit store

use crate::types::*;
use sentinel_core::tiered_cache::TieredCache;
use sentinel_core::MemoryMetrics;
use parking_lot::RwLock;
use std::sync::atomic::{AtomicU64, Ordering};
use tracing::warn;

const MAX_ALERTS: usize = 5_000;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ExploitEvent {
    pub cve_id: String,
    pub source_ip: String,
    pub target_asset: String,
    pub detected_at: i64,
    pub payload_hash: Option<String>,
}

/// Exploit detector with 2 memory breakthroughs.
pub struct ExploitDetector {
    events: RwLock<Vec<ExploitEvent>>,
    /// #2 Tiered cache: hot exploit signature lookups
    exploit_cache: TieredCache<String, u64>,
    alerts: RwLock<Vec<VulnAlert>>,
    total_detected: AtomicU64,
    /// #6 Theoretical verifier
    metrics: Option<MemoryMetrics>,
    enabled: bool,
}

impl ExploitDetector {
    pub fn new() -> Self {
        Self {
            events: RwLock::new(Vec::new()),
            exploit_cache: TieredCache::new(50_000),
            alerts: RwLock::new(Vec::new()),
            total_detected: AtomicU64::new(0),
            metrics: None,
            enabled: true,
        }
    }

    /// #6 Theoretical verifier: bound exploit store at 4MB.
    pub fn with_metrics(mut self, metrics: MemoryMetrics) -> Self {
        metrics.register_component("exploit_detector", 4 * 1024 * 1024);
        self.exploit_cache = self.exploit_cache.with_metrics(metrics.clone(), "exploit_detector");
        self.metrics = Some(metrics);
        self
    }

    /// Known critical CVEs that indicate nation-state or APT activity.
    const APT_CVES: &'static [&'static str] = &[
        "CVE-2021-44228", "CVE-2021-26855", "CVE-2023-23397",
        "CVE-2023-36884", "CVE-2024-3400", "CVE-2024-21887",
    ];

    pub fn detect(&self, event: ExploitEvent) {
        if !self.enabled { return; }
        let now = chrono::Utc::now().timestamp();
        self.total_detected.fetch_add(1, Ordering::Relaxed);

        // Check for APT-associated CVEs
        let is_apt = Self::APT_CVES.iter().any(|c| event.cve_id.starts_with(c));
        if is_apt {
            warn!(cve = %event.cve_id, src = %event.source_ip, target = %event.target_asset, "APT-associated exploit");
            self.add_alert(now, Severity::Critical, "APT exploit detected", &format!("CVE {} (APT-associated) on {} from {}", event.cve_id, event.target_asset, event.source_ip));
        } else {
            warn!(cve = %event.cve_id, src = %event.source_ip, target = %event.target_asset, "Active exploitation detected");
            self.add_alert(now, Severity::Critical, "Exploit detected", &format!("CVE {} exploited on {} from {}", event.cve_id, event.target_asset, event.source_ip));
        }

        // Detect repeat attacker (same source IP)
        let repeat_count = self.events.read().iter().filter(|e| e.source_ip == event.source_ip).count();
        if repeat_count > 0 {
            self.add_alert(now, Severity::Critical, "Repeat attacker", &format!("{} has {} previous exploit attempts", event.source_ip, repeat_count));
        }

        // Detect multi-CVE targeting (same asset, different CVEs)
        let asset_cves: Vec<String> = self.events.read().iter()
            .filter(|e| e.target_asset == event.target_asset && e.cve_id != event.cve_id)
            .map(|e| e.cve_id.clone()).collect();
        if !asset_cves.is_empty() {
            self.add_alert(now, Severity::Critical, "Multi-CVE attack", &format!("{} targeted with {} different CVEs", event.target_asset, asset_cves.len() + 1));
        }

        let mut events = self.events.write();
        if events.len() >= MAX_ALERTS { events.remove(0); }
        events.push(event);
    }

    /// Get top attacked assets.
    pub fn top_targets(&self, limit: usize) -> Vec<(String, usize)> {
        let events = self.events.read();
        let mut counts: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
        for e in events.iter() { *counts.entry(e.target_asset.clone()).or_insert(0) += 1; }
        let mut result: Vec<_> = counts.into_iter().collect();
        result.sort_by(|a, b| b.1.cmp(&a.1));
        result.truncate(limit);
        result
    }

    fn add_alert(&self, ts: i64, severity: Severity, title: &str, details: &str) {
        let mut alerts = self.alerts.write();
        if alerts.len() >= MAX_ALERTS { alerts.remove(0); }
        alerts.push(VulnAlert { timestamp: ts, severity, component: "exploit_detector".into(), title: title.into(), details: details.into() });
    }

    pub fn total_detected(&self) -> u64 { self.total_detected.load(Ordering::Relaxed) }
    pub fn alerts(&self) -> Vec<VulnAlert> { self.alerts.read().clone() }
    pub fn set_enabled(&mut self, e: bool) { self.enabled = e; }
}
